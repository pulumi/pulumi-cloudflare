# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccessApplicationCorsHeaderArgs',
    'AccessApplicationCorsHeaderArgsDict',
    'AccessApplicationDestinationArgs',
    'AccessApplicationDestinationArgsDict',
    'AccessApplicationFooterLinkArgs',
    'AccessApplicationFooterLinkArgsDict',
    'AccessApplicationLandingPageDesignArgs',
    'AccessApplicationLandingPageDesignArgsDict',
    'AccessApplicationSaasAppArgs',
    'AccessApplicationSaasAppArgsDict',
    'AccessApplicationSaasAppCustomAttributeArgs',
    'AccessApplicationSaasAppCustomAttributeArgsDict',
    'AccessApplicationSaasAppCustomAttributeSourceArgs',
    'AccessApplicationSaasAppCustomAttributeSourceArgsDict',
    'AccessApplicationSaasAppCustomClaimArgs',
    'AccessApplicationSaasAppCustomClaimArgsDict',
    'AccessApplicationSaasAppCustomClaimSourceArgs',
    'AccessApplicationSaasAppCustomClaimSourceArgsDict',
    'AccessApplicationSaasAppHybridAndImplicitOptionsArgs',
    'AccessApplicationSaasAppHybridAndImplicitOptionsArgsDict',
    'AccessApplicationSaasAppRefreshTokenOptionArgs',
    'AccessApplicationSaasAppRefreshTokenOptionArgsDict',
    'AccessApplicationScimConfigArgs',
    'AccessApplicationScimConfigArgsDict',
    'AccessApplicationScimConfigAuthenticationArgs',
    'AccessApplicationScimConfigAuthenticationArgsDict',
    'AccessApplicationScimConfigMappingArgs',
    'AccessApplicationScimConfigMappingArgsDict',
    'AccessApplicationScimConfigMappingOperationsArgs',
    'AccessApplicationScimConfigMappingOperationsArgsDict',
    'AccessApplicationTargetCriteriaArgs',
    'AccessApplicationTargetCriteriaArgsDict',
    'AccessApplicationTargetCriteriaTargetAttributeArgs',
    'AccessApplicationTargetCriteriaTargetAttributeArgsDict',
    'AccessGroupExcludeArgs',
    'AccessGroupExcludeArgsDict',
    'AccessGroupExcludeAuthContextArgs',
    'AccessGroupExcludeAuthContextArgsDict',
    'AccessGroupExcludeAzureArgs',
    'AccessGroupExcludeAzureArgsDict',
    'AccessGroupExcludeExternalEvaluationArgs',
    'AccessGroupExcludeExternalEvaluationArgsDict',
    'AccessGroupExcludeGithubArgs',
    'AccessGroupExcludeGithubArgsDict',
    'AccessGroupExcludeGsuiteArgs',
    'AccessGroupExcludeGsuiteArgsDict',
    'AccessGroupExcludeOktaArgs',
    'AccessGroupExcludeOktaArgsDict',
    'AccessGroupExcludeSamlArgs',
    'AccessGroupExcludeSamlArgsDict',
    'AccessGroupIncludeArgs',
    'AccessGroupIncludeArgsDict',
    'AccessGroupIncludeAuthContextArgs',
    'AccessGroupIncludeAuthContextArgsDict',
    'AccessGroupIncludeAzureArgs',
    'AccessGroupIncludeAzureArgsDict',
    'AccessGroupIncludeExternalEvaluationArgs',
    'AccessGroupIncludeExternalEvaluationArgsDict',
    'AccessGroupIncludeGithubArgs',
    'AccessGroupIncludeGithubArgsDict',
    'AccessGroupIncludeGsuiteArgs',
    'AccessGroupIncludeGsuiteArgsDict',
    'AccessGroupIncludeOktaArgs',
    'AccessGroupIncludeOktaArgsDict',
    'AccessGroupIncludeSamlArgs',
    'AccessGroupIncludeSamlArgsDict',
    'AccessGroupRequireArgs',
    'AccessGroupRequireArgsDict',
    'AccessGroupRequireAuthContextArgs',
    'AccessGroupRequireAuthContextArgsDict',
    'AccessGroupRequireAzureArgs',
    'AccessGroupRequireAzureArgsDict',
    'AccessGroupRequireExternalEvaluationArgs',
    'AccessGroupRequireExternalEvaluationArgsDict',
    'AccessGroupRequireGithubArgs',
    'AccessGroupRequireGithubArgsDict',
    'AccessGroupRequireGsuiteArgs',
    'AccessGroupRequireGsuiteArgsDict',
    'AccessGroupRequireOktaArgs',
    'AccessGroupRequireOktaArgsDict',
    'AccessGroupRequireSamlArgs',
    'AccessGroupRequireSamlArgsDict',
    'AccessIdentityProviderConfigArgs',
    'AccessIdentityProviderConfigArgsDict',
    'AccessIdentityProviderScimConfigArgs',
    'AccessIdentityProviderScimConfigArgsDict',
    'AccessMutualTlsHostnameSettingsSettingArgs',
    'AccessMutualTlsHostnameSettingsSettingArgsDict',
    'AccessOrganizationCustomPageArgs',
    'AccessOrganizationCustomPageArgsDict',
    'AccessOrganizationLoginDesignArgs',
    'AccessOrganizationLoginDesignArgsDict',
    'AccessPolicyApprovalGroupArgs',
    'AccessPolicyApprovalGroupArgsDict',
    'AccessPolicyConnectionRulesArgs',
    'AccessPolicyConnectionRulesArgsDict',
    'AccessPolicyConnectionRulesSshArgs',
    'AccessPolicyConnectionRulesSshArgsDict',
    'AccessPolicyExcludeArgs',
    'AccessPolicyExcludeArgsDict',
    'AccessPolicyExcludeAuthContextArgs',
    'AccessPolicyExcludeAuthContextArgsDict',
    'AccessPolicyExcludeAzureArgs',
    'AccessPolicyExcludeAzureArgsDict',
    'AccessPolicyExcludeExternalEvaluationArgs',
    'AccessPolicyExcludeExternalEvaluationArgsDict',
    'AccessPolicyExcludeGithubArgs',
    'AccessPolicyExcludeGithubArgsDict',
    'AccessPolicyExcludeGsuiteArgs',
    'AccessPolicyExcludeGsuiteArgsDict',
    'AccessPolicyExcludeOktaArgs',
    'AccessPolicyExcludeOktaArgsDict',
    'AccessPolicyExcludeSamlArgs',
    'AccessPolicyExcludeSamlArgsDict',
    'AccessPolicyIncludeArgs',
    'AccessPolicyIncludeArgsDict',
    'AccessPolicyIncludeAuthContextArgs',
    'AccessPolicyIncludeAuthContextArgsDict',
    'AccessPolicyIncludeAzureArgs',
    'AccessPolicyIncludeAzureArgsDict',
    'AccessPolicyIncludeExternalEvaluationArgs',
    'AccessPolicyIncludeExternalEvaluationArgsDict',
    'AccessPolicyIncludeGithubArgs',
    'AccessPolicyIncludeGithubArgsDict',
    'AccessPolicyIncludeGsuiteArgs',
    'AccessPolicyIncludeGsuiteArgsDict',
    'AccessPolicyIncludeOktaArgs',
    'AccessPolicyIncludeOktaArgsDict',
    'AccessPolicyIncludeSamlArgs',
    'AccessPolicyIncludeSamlArgsDict',
    'AccessPolicyRequireArgs',
    'AccessPolicyRequireArgsDict',
    'AccessPolicyRequireAuthContextArgs',
    'AccessPolicyRequireAuthContextArgsDict',
    'AccessPolicyRequireAzureArgs',
    'AccessPolicyRequireAzureArgsDict',
    'AccessPolicyRequireExternalEvaluationArgs',
    'AccessPolicyRequireExternalEvaluationArgsDict',
    'AccessPolicyRequireGithubArgs',
    'AccessPolicyRequireGithubArgsDict',
    'AccessPolicyRequireGsuiteArgs',
    'AccessPolicyRequireGsuiteArgsDict',
    'AccessPolicyRequireOktaArgs',
    'AccessPolicyRequireOktaArgsDict',
    'AccessPolicyRequireSamlArgs',
    'AccessPolicyRequireSamlArgsDict',
    'AccessRuleConfigurationArgs',
    'AccessRuleConfigurationArgsDict',
    'AddressMapIpArgs',
    'AddressMapIpArgsDict',
    'AddressMapMembershipArgs',
    'AddressMapMembershipArgsDict',
    'ApiShieldAuthIdCharacteristicArgs',
    'ApiShieldAuthIdCharacteristicArgsDict',
    'ApiTokenConditionArgs',
    'ApiTokenConditionArgsDict',
    'ApiTokenConditionRequestIpArgs',
    'ApiTokenConditionRequestIpArgsDict',
    'ApiTokenPolicyArgs',
    'ApiTokenPolicyArgsDict',
    'CertificatePackValidationErrorArgs',
    'CertificatePackValidationErrorArgsDict',
    'CertificatePackValidationRecordArgs',
    'CertificatePackValidationRecordArgsDict',
    'CloudConnectorRulesRuleArgs',
    'CloudConnectorRulesRuleArgsDict',
    'CloudConnectorRulesRuleParametersArgs',
    'CloudConnectorRulesRuleParametersArgsDict',
    'CustomHostnameSslArgs',
    'CustomHostnameSslArgsDict',
    'CustomHostnameSslSettingArgs',
    'CustomHostnameSslSettingArgsDict',
    'CustomHostnameSslValidationErrorArgs',
    'CustomHostnameSslValidationErrorArgsDict',
    'CustomHostnameSslValidationRecordArgs',
    'CustomHostnameSslValidationRecordArgsDict',
    'CustomSslCustomSslOptionsArgs',
    'CustomSslCustomSslOptionsArgsDict',
    'CustomSslCustomSslPriorityArgs',
    'CustomSslCustomSslPriorityArgsDict',
    'DeviceDexTestDataArgs',
    'DeviceDexTestDataArgsDict',
    'DeviceManagedNetworksConfigArgs',
    'DeviceManagedNetworksConfigArgsDict',
    'DevicePostureIntegrationConfigArgs',
    'DevicePostureIntegrationConfigArgsDict',
    'DevicePostureRuleInputArgs',
    'DevicePostureRuleInputArgsDict',
    'DevicePostureRuleInputLocationArgs',
    'DevicePostureRuleInputLocationArgsDict',
    'DevicePostureRuleMatchArgs',
    'DevicePostureRuleMatchArgsDict',
    'DlpProfileContextAwarenessArgs',
    'DlpProfileContextAwarenessArgsDict',
    'DlpProfileContextAwarenessSkipArgs',
    'DlpProfileContextAwarenessSkipArgsDict',
    'DlpProfileEntryArgs',
    'DlpProfileEntryArgsDict',
    'DlpProfileEntryPatternArgs',
    'DlpProfileEntryPatternArgsDict',
    'EmailRoutingCatchAllActionArgs',
    'EmailRoutingCatchAllActionArgsDict',
    'EmailRoutingCatchAllMatcherArgs',
    'EmailRoutingCatchAllMatcherArgsDict',
    'EmailRoutingRuleActionArgs',
    'EmailRoutingRuleActionArgsDict',
    'EmailRoutingRuleMatcherArgs',
    'EmailRoutingRuleMatcherArgsDict',
    'FallbackDomainDomainArgs',
    'FallbackDomainDomainArgsDict',
    'HealthcheckHeaderArgs',
    'HealthcheckHeaderArgsDict',
    'HyperdriveConfigCachingArgs',
    'HyperdriveConfigCachingArgsDict',
    'HyperdriveConfigOriginArgs',
    'HyperdriveConfigOriginArgsDict',
    'InfrastructureAccessTargetIpArgs',
    'InfrastructureAccessTargetIpArgsDict',
    'InfrastructureAccessTargetIpIpv4Args',
    'InfrastructureAccessTargetIpIpv4ArgsDict',
    'InfrastructureAccessTargetIpIpv6Args',
    'InfrastructureAccessTargetIpIpv6ArgsDict',
    'ListItemArgs',
    'ListItemArgsDict',
    'ListItemHostnameArgs',
    'ListItemHostnameArgsDict',
    'ListItemRedirectArgs',
    'ListItemRedirectArgsDict',
    'ListItemValueArgs',
    'ListItemValueArgsDict',
    'ListItemValueHostnameArgs',
    'ListItemValueHostnameArgsDict',
    'ListItemValueRedirectArgs',
    'ListItemValueRedirectArgsDict',
    'LoadBalancerAdaptiveRoutingArgs',
    'LoadBalancerAdaptiveRoutingArgsDict',
    'LoadBalancerCountryPoolArgs',
    'LoadBalancerCountryPoolArgsDict',
    'LoadBalancerLocationStrategyArgs',
    'LoadBalancerLocationStrategyArgsDict',
    'LoadBalancerMonitorHeaderArgs',
    'LoadBalancerMonitorHeaderArgsDict',
    'LoadBalancerPoolLoadSheddingArgs',
    'LoadBalancerPoolLoadSheddingArgsDict',
    'LoadBalancerPoolOriginArgs',
    'LoadBalancerPoolOriginArgsDict',
    'LoadBalancerPoolOriginHeaderArgs',
    'LoadBalancerPoolOriginHeaderArgsDict',
    'LoadBalancerPoolOriginSteeringArgs',
    'LoadBalancerPoolOriginSteeringArgsDict',
    'LoadBalancerPopPoolArgs',
    'LoadBalancerPopPoolArgsDict',
    'LoadBalancerRandomSteeringArgs',
    'LoadBalancerRandomSteeringArgsDict',
    'LoadBalancerRegionPoolArgs',
    'LoadBalancerRegionPoolArgsDict',
    'LoadBalancerRuleArgs',
    'LoadBalancerRuleArgsDict',
    'LoadBalancerRuleFixedResponseArgs',
    'LoadBalancerRuleFixedResponseArgsDict',
    'LoadBalancerRuleOverrideArgs',
    'LoadBalancerRuleOverrideArgsDict',
    'LoadBalancerRuleOverrideAdaptiveRoutingArgs',
    'LoadBalancerRuleOverrideAdaptiveRoutingArgsDict',
    'LoadBalancerRuleOverrideCountryPoolArgs',
    'LoadBalancerRuleOverrideCountryPoolArgsDict',
    'LoadBalancerRuleOverrideLocationStrategyArgs',
    'LoadBalancerRuleOverrideLocationStrategyArgsDict',
    'LoadBalancerRuleOverridePopPoolArgs',
    'LoadBalancerRuleOverridePopPoolArgsDict',
    'LoadBalancerRuleOverrideRandomSteeringArgs',
    'LoadBalancerRuleOverrideRandomSteeringArgsDict',
    'LoadBalancerRuleOverrideRegionPoolArgs',
    'LoadBalancerRuleOverrideRegionPoolArgsDict',
    'LoadBalancerRuleOverrideSessionAffinityAttributeArgs',
    'LoadBalancerRuleOverrideSessionAffinityAttributeArgsDict',
    'LoadBalancerSessionAffinityAttributeArgs',
    'LoadBalancerSessionAffinityAttributeArgsDict',
    'LogpushJobOutputOptionsArgs',
    'LogpushJobOutputOptionsArgsDict',
    'ManagedHeadersManagedRequestHeaderArgs',
    'ManagedHeadersManagedRequestHeaderArgsDict',
    'ManagedHeadersManagedResponseHeaderArgs',
    'ManagedHeadersManagedResponseHeaderArgsDict',
    'NotificationPolicyEmailIntegrationArgs',
    'NotificationPolicyEmailIntegrationArgsDict',
    'NotificationPolicyFiltersArgs',
    'NotificationPolicyFiltersArgsDict',
    'NotificationPolicyPagerdutyIntegrationArgs',
    'NotificationPolicyPagerdutyIntegrationArgsDict',
    'NotificationPolicyWebhooksIntegrationArgs',
    'NotificationPolicyWebhooksIntegrationArgsDict',
    'PageRuleActionsArgs',
    'PageRuleActionsArgsDict',
    'PageRuleActionsCacheKeyFieldsArgs',
    'PageRuleActionsCacheKeyFieldsArgsDict',
    'PageRuleActionsCacheKeyFieldsCookieArgs',
    'PageRuleActionsCacheKeyFieldsCookieArgsDict',
    'PageRuleActionsCacheKeyFieldsHeaderArgs',
    'PageRuleActionsCacheKeyFieldsHeaderArgsDict',
    'PageRuleActionsCacheKeyFieldsHostArgs',
    'PageRuleActionsCacheKeyFieldsHostArgsDict',
    'PageRuleActionsCacheKeyFieldsQueryStringArgs',
    'PageRuleActionsCacheKeyFieldsQueryStringArgsDict',
    'PageRuleActionsCacheKeyFieldsUserArgs',
    'PageRuleActionsCacheKeyFieldsUserArgsDict',
    'PageRuleActionsCacheTtlByStatusArgs',
    'PageRuleActionsCacheTtlByStatusArgsDict',
    'PageRuleActionsForwardingUrlArgs',
    'PageRuleActionsForwardingUrlArgsDict',
    'PageRuleActionsMinifyArgs',
    'PageRuleActionsMinifyArgsDict',
    'PagesProjectBuildConfigArgs',
    'PagesProjectBuildConfigArgsDict',
    'PagesProjectDeploymentConfigsArgs',
    'PagesProjectDeploymentConfigsArgsDict',
    'PagesProjectDeploymentConfigsPreviewArgs',
    'PagesProjectDeploymentConfigsPreviewArgsDict',
    'PagesProjectDeploymentConfigsPreviewPlacementArgs',
    'PagesProjectDeploymentConfigsPreviewPlacementArgsDict',
    'PagesProjectDeploymentConfigsPreviewServiceBindingArgs',
    'PagesProjectDeploymentConfigsPreviewServiceBindingArgsDict',
    'PagesProjectDeploymentConfigsProductionArgs',
    'PagesProjectDeploymentConfigsProductionArgsDict',
    'PagesProjectDeploymentConfigsProductionPlacementArgs',
    'PagesProjectDeploymentConfigsProductionPlacementArgsDict',
    'PagesProjectDeploymentConfigsProductionServiceBindingArgs',
    'PagesProjectDeploymentConfigsProductionServiceBindingArgsDict',
    'PagesProjectSourceArgs',
    'PagesProjectSourceArgsDict',
    'PagesProjectSourceConfigArgs',
    'PagesProjectSourceConfigArgsDict',
    'RateLimitActionArgs',
    'RateLimitActionArgsDict',
    'RateLimitActionResponseArgs',
    'RateLimitActionResponseArgsDict',
    'RateLimitCorrelateArgs',
    'RateLimitCorrelateArgsDict',
    'RateLimitMatchArgs',
    'RateLimitMatchArgsDict',
    'RateLimitMatchRequestArgs',
    'RateLimitMatchRequestArgsDict',
    'RateLimitMatchResponseArgs',
    'RateLimitMatchResponseArgsDict',
    'RecordDataArgs',
    'RecordDataArgsDict',
    'RiskBehaviorBehaviorArgs',
    'RiskBehaviorBehaviorArgsDict',
    'RulesetRuleArgs',
    'RulesetRuleArgsDict',
    'RulesetRuleActionParametersArgs',
    'RulesetRuleActionParametersArgsDict',
    'RulesetRuleActionParametersAlgorithmArgs',
    'RulesetRuleActionParametersAlgorithmArgsDict',
    'RulesetRuleActionParametersAutominifyArgs',
    'RulesetRuleActionParametersAutominifyArgsDict',
    'RulesetRuleActionParametersBrowserTtlArgs',
    'RulesetRuleActionParametersBrowserTtlArgsDict',
    'RulesetRuleActionParametersCacheKeyArgs',
    'RulesetRuleActionParametersCacheKeyArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyHostArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyUserArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict',
    'RulesetRuleActionParametersCacheReserveArgs',
    'RulesetRuleActionParametersCacheReserveArgsDict',
    'RulesetRuleActionParametersEdgeTtlArgs',
    'RulesetRuleActionParametersEdgeTtlArgsDict',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict',
    'RulesetRuleActionParametersFromListArgs',
    'RulesetRuleActionParametersFromListArgsDict',
    'RulesetRuleActionParametersFromValueArgs',
    'RulesetRuleActionParametersFromValueArgsDict',
    'RulesetRuleActionParametersFromValueTargetUrlArgs',
    'RulesetRuleActionParametersFromValueTargetUrlArgsDict',
    'RulesetRuleActionParametersHeaderArgs',
    'RulesetRuleActionParametersHeaderArgsDict',
    'RulesetRuleActionParametersMatchedDataArgs',
    'RulesetRuleActionParametersMatchedDataArgsDict',
    'RulesetRuleActionParametersOriginArgs',
    'RulesetRuleActionParametersOriginArgsDict',
    'RulesetRuleActionParametersOverridesArgs',
    'RulesetRuleActionParametersOverridesArgsDict',
    'RulesetRuleActionParametersOverridesCategoryArgs',
    'RulesetRuleActionParametersOverridesCategoryArgsDict',
    'RulesetRuleActionParametersOverridesRuleArgs',
    'RulesetRuleActionParametersOverridesRuleArgsDict',
    'RulesetRuleActionParametersResponseArgs',
    'RulesetRuleActionParametersResponseArgsDict',
    'RulesetRuleActionParametersServeStaleArgs',
    'RulesetRuleActionParametersServeStaleArgsDict',
    'RulesetRuleActionParametersSniArgs',
    'RulesetRuleActionParametersSniArgsDict',
    'RulesetRuleActionParametersUriArgs',
    'RulesetRuleActionParametersUriArgsDict',
    'RulesetRuleActionParametersUriPathArgs',
    'RulesetRuleActionParametersUriPathArgsDict',
    'RulesetRuleActionParametersUriQueryArgs',
    'RulesetRuleActionParametersUriQueryArgsDict',
    'RulesetRuleExposedCredentialCheckArgs',
    'RulesetRuleExposedCredentialCheckArgsDict',
    'RulesetRuleLoggingArgs',
    'RulesetRuleLoggingArgsDict',
    'RulesetRuleRatelimitArgs',
    'RulesetRuleRatelimitArgsDict',
    'SnippetFileArgs',
    'SnippetFileArgsDict',
    'SnippetRulesRuleArgs',
    'SnippetRulesRuleArgsDict',
    'SpectrumApplicationDnsArgs',
    'SpectrumApplicationDnsArgsDict',
    'SpectrumApplicationEdgeIpsArgs',
    'SpectrumApplicationEdgeIpsArgsDict',
    'SpectrumApplicationOriginDnsArgs',
    'SpectrumApplicationOriginDnsArgsDict',
    'SpectrumApplicationOriginPortRangeArgs',
    'SpectrumApplicationOriginPortRangeArgsDict',
    'SplitTunnelTunnelArgs',
    'SplitTunnelTunnelArgsDict',
    'TeamsAccountAntivirusArgs',
    'TeamsAccountAntivirusArgsDict',
    'TeamsAccountAntivirusNotificationSettingsArgs',
    'TeamsAccountAntivirusNotificationSettingsArgsDict',
    'TeamsAccountBlockPageArgs',
    'TeamsAccountBlockPageArgsDict',
    'TeamsAccountBodyScanningArgs',
    'TeamsAccountBodyScanningArgsDict',
    'TeamsAccountCertificateArgs',
    'TeamsAccountCertificateArgsDict',
    'TeamsAccountCustomCertificateArgs',
    'TeamsAccountCustomCertificateArgsDict',
    'TeamsAccountExtendedEmailMatchingArgs',
    'TeamsAccountExtendedEmailMatchingArgsDict',
    'TeamsAccountFipsArgs',
    'TeamsAccountFipsArgsDict',
    'TeamsAccountLoggingArgs',
    'TeamsAccountLoggingArgsDict',
    'TeamsAccountLoggingSettingsByRuleTypeArgs',
    'TeamsAccountLoggingSettingsByRuleTypeArgsDict',
    'TeamsAccountLoggingSettingsByRuleTypeDnsArgs',
    'TeamsAccountLoggingSettingsByRuleTypeDnsArgsDict',
    'TeamsAccountLoggingSettingsByRuleTypeHttpArgs',
    'TeamsAccountLoggingSettingsByRuleTypeHttpArgsDict',
    'TeamsAccountLoggingSettingsByRuleTypeL4Args',
    'TeamsAccountLoggingSettingsByRuleTypeL4ArgsDict',
    'TeamsAccountPayloadLogArgs',
    'TeamsAccountPayloadLogArgsDict',
    'TeamsAccountProxyArgs',
    'TeamsAccountProxyArgsDict',
    'TeamsAccountSshSessionLogArgs',
    'TeamsAccountSshSessionLogArgsDict',
    'TeamsListItemsWithDescriptionArgs',
    'TeamsListItemsWithDescriptionArgsDict',
    'TeamsLocationNetworkArgs',
    'TeamsLocationNetworkArgsDict',
    'TeamsRuleRuleSettingsArgs',
    'TeamsRuleRuleSettingsArgsDict',
    'TeamsRuleRuleSettingsAuditSshArgs',
    'TeamsRuleRuleSettingsAuditSshArgsDict',
    'TeamsRuleRuleSettingsBisoAdminControlsArgs',
    'TeamsRuleRuleSettingsBisoAdminControlsArgsDict',
    'TeamsRuleRuleSettingsCheckSessionArgs',
    'TeamsRuleRuleSettingsCheckSessionArgsDict',
    'TeamsRuleRuleSettingsDnsResolversArgs',
    'TeamsRuleRuleSettingsDnsResolversArgsDict',
    'TeamsRuleRuleSettingsDnsResolversIpv4Args',
    'TeamsRuleRuleSettingsDnsResolversIpv4ArgsDict',
    'TeamsRuleRuleSettingsDnsResolversIpv6Args',
    'TeamsRuleRuleSettingsDnsResolversIpv6ArgsDict',
    'TeamsRuleRuleSettingsEgressArgs',
    'TeamsRuleRuleSettingsEgressArgsDict',
    'TeamsRuleRuleSettingsL4overrideArgs',
    'TeamsRuleRuleSettingsL4overrideArgsDict',
    'TeamsRuleRuleSettingsNotificationSettingsArgs',
    'TeamsRuleRuleSettingsNotificationSettingsArgsDict',
    'TeamsRuleRuleSettingsPayloadLogArgs',
    'TeamsRuleRuleSettingsPayloadLogArgsDict',
    'TeamsRuleRuleSettingsUntrustedCertArgs',
    'TeamsRuleRuleSettingsUntrustedCertArgsDict',
    'TunnelConfigConfigArgs',
    'TunnelConfigConfigArgsDict',
    'TunnelConfigConfigIngressRuleArgs',
    'TunnelConfigConfigIngressRuleArgsDict',
    'TunnelConfigConfigIngressRuleOriginRequestArgs',
    'TunnelConfigConfigIngressRuleOriginRequestArgsDict',
    'TunnelConfigConfigIngressRuleOriginRequestAccessArgs',
    'TunnelConfigConfigIngressRuleOriginRequestAccessArgsDict',
    'TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs',
    'TunnelConfigConfigIngressRuleOriginRequestIpRuleArgsDict',
    'TunnelConfigConfigOriginRequestArgs',
    'TunnelConfigConfigOriginRequestArgsDict',
    'TunnelConfigConfigOriginRequestAccessArgs',
    'TunnelConfigConfigOriginRequestAccessArgsDict',
    'TunnelConfigConfigOriginRequestIpRuleArgs',
    'TunnelConfigConfigOriginRequestIpRuleArgsDict',
    'TunnelConfigConfigWarpRoutingArgs',
    'TunnelConfigConfigWarpRoutingArgsDict',
    'UserAgentBlockingRuleConfigurationArgs',
    'UserAgentBlockingRuleConfigurationArgsDict',
    'WaitingRoomAdditionalRouteArgs',
    'WaitingRoomAdditionalRouteArgsDict',
    'WaitingRoomRulesRuleArgs',
    'WaitingRoomRulesRuleArgsDict',
    'WorkerScriptAnalyticsEngineBindingArgs',
    'WorkerScriptAnalyticsEngineBindingArgsDict',
    'WorkerScriptD1DatabaseBindingArgs',
    'WorkerScriptD1DatabaseBindingArgsDict',
    'WorkerScriptHyperdriveConfigBindingArgs',
    'WorkerScriptHyperdriveConfigBindingArgsDict',
    'WorkerScriptKvNamespaceBindingArgs',
    'WorkerScriptKvNamespaceBindingArgsDict',
    'WorkerScriptPlacementArgs',
    'WorkerScriptPlacementArgsDict',
    'WorkerScriptPlainTextBindingArgs',
    'WorkerScriptPlainTextBindingArgsDict',
    'WorkerScriptQueueBindingArgs',
    'WorkerScriptQueueBindingArgsDict',
    'WorkerScriptR2BucketBindingArgs',
    'WorkerScriptR2BucketBindingArgsDict',
    'WorkerScriptSecretTextBindingArgs',
    'WorkerScriptSecretTextBindingArgsDict',
    'WorkerScriptServiceBindingArgs',
    'WorkerScriptServiceBindingArgsDict',
    'WorkerScriptWebassemblyBindingArgs',
    'WorkerScriptWebassemblyBindingArgsDict',
    'WorkersScriptAnalyticsEngineBindingArgs',
    'WorkersScriptAnalyticsEngineBindingArgsDict',
    'WorkersScriptD1DatabaseBindingArgs',
    'WorkersScriptD1DatabaseBindingArgsDict',
    'WorkersScriptHyperdriveConfigBindingArgs',
    'WorkersScriptHyperdriveConfigBindingArgsDict',
    'WorkersScriptKvNamespaceBindingArgs',
    'WorkersScriptKvNamespaceBindingArgsDict',
    'WorkersScriptPlacementArgs',
    'WorkersScriptPlacementArgsDict',
    'WorkersScriptPlainTextBindingArgs',
    'WorkersScriptPlainTextBindingArgsDict',
    'WorkersScriptQueueBindingArgs',
    'WorkersScriptQueueBindingArgsDict',
    'WorkersScriptR2BucketBindingArgs',
    'WorkersScriptR2BucketBindingArgsDict',
    'WorkersScriptSecretTextBindingArgs',
    'WorkersScriptSecretTextBindingArgsDict',
    'WorkersScriptServiceBindingArgs',
    'WorkersScriptServiceBindingArgsDict',
    'WorkersScriptWebassemblyBindingArgs',
    'WorkersScriptWebassemblyBindingArgsDict',
    'ZeroTrustAccessApplicationCorsHeaderArgs',
    'ZeroTrustAccessApplicationCorsHeaderArgsDict',
    'ZeroTrustAccessApplicationDestinationArgs',
    'ZeroTrustAccessApplicationDestinationArgsDict',
    'ZeroTrustAccessApplicationFooterLinkArgs',
    'ZeroTrustAccessApplicationFooterLinkArgsDict',
    'ZeroTrustAccessApplicationLandingPageDesignArgs',
    'ZeroTrustAccessApplicationLandingPageDesignArgsDict',
    'ZeroTrustAccessApplicationSaasAppArgs',
    'ZeroTrustAccessApplicationSaasAppArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeArgs',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomClaimArgs',
    'ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs',
    'ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict',
    'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs',
    'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict',
    'ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgs',
    'ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgsDict',
    'ZeroTrustAccessApplicationScimConfigArgs',
    'ZeroTrustAccessApplicationScimConfigArgsDict',
    'ZeroTrustAccessApplicationScimConfigAuthenticationArgs',
    'ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict',
    'ZeroTrustAccessApplicationScimConfigMappingArgs',
    'ZeroTrustAccessApplicationScimConfigMappingArgsDict',
    'ZeroTrustAccessApplicationScimConfigMappingOperationsArgs',
    'ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict',
    'ZeroTrustAccessApplicationTargetCriteriaArgs',
    'ZeroTrustAccessApplicationTargetCriteriaArgsDict',
    'ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgs',
    'ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgsDict',
    'ZeroTrustAccessGroupExcludeArgs',
    'ZeroTrustAccessGroupExcludeArgsDict',
    'ZeroTrustAccessGroupExcludeAuthContextArgs',
    'ZeroTrustAccessGroupExcludeAuthContextArgsDict',
    'ZeroTrustAccessGroupExcludeAzureArgs',
    'ZeroTrustAccessGroupExcludeAzureArgsDict',
    'ZeroTrustAccessGroupExcludeExternalEvaluationArgs',
    'ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupExcludeGithubArgs',
    'ZeroTrustAccessGroupExcludeGithubArgsDict',
    'ZeroTrustAccessGroupExcludeGsuiteArgs',
    'ZeroTrustAccessGroupExcludeGsuiteArgsDict',
    'ZeroTrustAccessGroupExcludeOktaArgs',
    'ZeroTrustAccessGroupExcludeOktaArgsDict',
    'ZeroTrustAccessGroupExcludeSamlArgs',
    'ZeroTrustAccessGroupExcludeSamlArgsDict',
    'ZeroTrustAccessGroupIncludeArgs',
    'ZeroTrustAccessGroupIncludeArgsDict',
    'ZeroTrustAccessGroupIncludeAuthContextArgs',
    'ZeroTrustAccessGroupIncludeAuthContextArgsDict',
    'ZeroTrustAccessGroupIncludeAzureArgs',
    'ZeroTrustAccessGroupIncludeAzureArgsDict',
    'ZeroTrustAccessGroupIncludeExternalEvaluationArgs',
    'ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupIncludeGithubArgs',
    'ZeroTrustAccessGroupIncludeGithubArgsDict',
    'ZeroTrustAccessGroupIncludeGsuiteArgs',
    'ZeroTrustAccessGroupIncludeGsuiteArgsDict',
    'ZeroTrustAccessGroupIncludeOktaArgs',
    'ZeroTrustAccessGroupIncludeOktaArgsDict',
    'ZeroTrustAccessGroupIncludeSamlArgs',
    'ZeroTrustAccessGroupIncludeSamlArgsDict',
    'ZeroTrustAccessGroupRequireArgs',
    'ZeroTrustAccessGroupRequireArgsDict',
    'ZeroTrustAccessGroupRequireAuthContextArgs',
    'ZeroTrustAccessGroupRequireAuthContextArgsDict',
    'ZeroTrustAccessGroupRequireAzureArgs',
    'ZeroTrustAccessGroupRequireAzureArgsDict',
    'ZeroTrustAccessGroupRequireExternalEvaluationArgs',
    'ZeroTrustAccessGroupRequireExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupRequireGithubArgs',
    'ZeroTrustAccessGroupRequireGithubArgsDict',
    'ZeroTrustAccessGroupRequireGsuiteArgs',
    'ZeroTrustAccessGroupRequireGsuiteArgsDict',
    'ZeroTrustAccessGroupRequireOktaArgs',
    'ZeroTrustAccessGroupRequireOktaArgsDict',
    'ZeroTrustAccessGroupRequireSamlArgs',
    'ZeroTrustAccessGroupRequireSamlArgsDict',
    'ZeroTrustAccessIdentityProviderConfigArgs',
    'ZeroTrustAccessIdentityProviderConfigArgsDict',
    'ZeroTrustAccessIdentityProviderScimConfigArgs',
    'ZeroTrustAccessIdentityProviderScimConfigArgsDict',
    'ZeroTrustAccessMtlsHostnameSettingsSettingArgs',
    'ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict',
    'ZeroTrustAccessOrganizationCustomPageArgs',
    'ZeroTrustAccessOrganizationCustomPageArgsDict',
    'ZeroTrustAccessOrganizationLoginDesignArgs',
    'ZeroTrustAccessOrganizationLoginDesignArgsDict',
    'ZeroTrustAccessPolicyApprovalGroupArgs',
    'ZeroTrustAccessPolicyApprovalGroupArgsDict',
    'ZeroTrustAccessPolicyConnectionRulesArgs',
    'ZeroTrustAccessPolicyConnectionRulesArgsDict',
    'ZeroTrustAccessPolicyConnectionRulesSshArgs',
    'ZeroTrustAccessPolicyConnectionRulesSshArgsDict',
    'ZeroTrustAccessPolicyExcludeArgs',
    'ZeroTrustAccessPolicyExcludeArgsDict',
    'ZeroTrustAccessPolicyExcludeAuthContextArgs',
    'ZeroTrustAccessPolicyExcludeAuthContextArgsDict',
    'ZeroTrustAccessPolicyExcludeAzureArgs',
    'ZeroTrustAccessPolicyExcludeAzureArgsDict',
    'ZeroTrustAccessPolicyExcludeExternalEvaluationArgs',
    'ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyExcludeGithubArgs',
    'ZeroTrustAccessPolicyExcludeGithubArgsDict',
    'ZeroTrustAccessPolicyExcludeGsuiteArgs',
    'ZeroTrustAccessPolicyExcludeGsuiteArgsDict',
    'ZeroTrustAccessPolicyExcludeOktaArgs',
    'ZeroTrustAccessPolicyExcludeOktaArgsDict',
    'ZeroTrustAccessPolicyExcludeSamlArgs',
    'ZeroTrustAccessPolicyExcludeSamlArgsDict',
    'ZeroTrustAccessPolicyIncludeArgs',
    'ZeroTrustAccessPolicyIncludeArgsDict',
    'ZeroTrustAccessPolicyIncludeAuthContextArgs',
    'ZeroTrustAccessPolicyIncludeAuthContextArgsDict',
    'ZeroTrustAccessPolicyIncludeAzureArgs',
    'ZeroTrustAccessPolicyIncludeAzureArgsDict',
    'ZeroTrustAccessPolicyIncludeExternalEvaluationArgs',
    'ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyIncludeGithubArgs',
    'ZeroTrustAccessPolicyIncludeGithubArgsDict',
    'ZeroTrustAccessPolicyIncludeGsuiteArgs',
    'ZeroTrustAccessPolicyIncludeGsuiteArgsDict',
    'ZeroTrustAccessPolicyIncludeOktaArgs',
    'ZeroTrustAccessPolicyIncludeOktaArgsDict',
    'ZeroTrustAccessPolicyIncludeSamlArgs',
    'ZeroTrustAccessPolicyIncludeSamlArgsDict',
    'ZeroTrustAccessPolicyRequireArgs',
    'ZeroTrustAccessPolicyRequireArgsDict',
    'ZeroTrustAccessPolicyRequireAuthContextArgs',
    'ZeroTrustAccessPolicyRequireAuthContextArgsDict',
    'ZeroTrustAccessPolicyRequireAzureArgs',
    'ZeroTrustAccessPolicyRequireAzureArgsDict',
    'ZeroTrustAccessPolicyRequireExternalEvaluationArgs',
    'ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyRequireGithubArgs',
    'ZeroTrustAccessPolicyRequireGithubArgsDict',
    'ZeroTrustAccessPolicyRequireGsuiteArgs',
    'ZeroTrustAccessPolicyRequireGsuiteArgsDict',
    'ZeroTrustAccessPolicyRequireOktaArgs',
    'ZeroTrustAccessPolicyRequireOktaArgsDict',
    'ZeroTrustAccessPolicyRequireSamlArgs',
    'ZeroTrustAccessPolicyRequireSamlArgsDict',
    'ZeroTrustDeviceManagedNetworksConfigArgs',
    'ZeroTrustDeviceManagedNetworksConfigArgsDict',
    'ZeroTrustDevicePostureIntegrationConfigArgs',
    'ZeroTrustDevicePostureIntegrationConfigArgsDict',
    'ZeroTrustDevicePostureRuleInputArgs',
    'ZeroTrustDevicePostureRuleInputArgsDict',
    'ZeroTrustDevicePostureRuleInputLocationArgs',
    'ZeroTrustDevicePostureRuleInputLocationArgsDict',
    'ZeroTrustDevicePostureRuleMatchArgs',
    'ZeroTrustDevicePostureRuleMatchArgsDict',
    'ZeroTrustDexTestDataArgs',
    'ZeroTrustDexTestDataArgsDict',
    'ZeroTrustDlpProfileContextAwarenessArgs',
    'ZeroTrustDlpProfileContextAwarenessArgsDict',
    'ZeroTrustDlpProfileContextAwarenessSkipArgs',
    'ZeroTrustDlpProfileContextAwarenessSkipArgsDict',
    'ZeroTrustDlpProfileEntryArgs',
    'ZeroTrustDlpProfileEntryArgsDict',
    'ZeroTrustDlpProfileEntryPatternArgs',
    'ZeroTrustDlpProfileEntryPatternArgsDict',
    'ZeroTrustDnsLocationNetworkArgs',
    'ZeroTrustDnsLocationNetworkArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs',
    'ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs',
    'ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsEgressArgs',
    'ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs',
    'ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs',
    'ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs',
    'ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict',
    'ZeroTrustGatewaySettingsAntivirusArgs',
    'ZeroTrustGatewaySettingsAntivirusArgsDict',
    'ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs',
    'ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgsDict',
    'ZeroTrustGatewaySettingsBlockPageArgs',
    'ZeroTrustGatewaySettingsBlockPageArgsDict',
    'ZeroTrustGatewaySettingsBodyScanningArgs',
    'ZeroTrustGatewaySettingsBodyScanningArgsDict',
    'ZeroTrustGatewaySettingsCertificateArgs',
    'ZeroTrustGatewaySettingsCertificateArgsDict',
    'ZeroTrustGatewaySettingsCustomCertificateArgs',
    'ZeroTrustGatewaySettingsCustomCertificateArgsDict',
    'ZeroTrustGatewaySettingsExtendedEmailMatchingArgs',
    'ZeroTrustGatewaySettingsExtendedEmailMatchingArgsDict',
    'ZeroTrustGatewaySettingsFipsArgs',
    'ZeroTrustGatewaySettingsFipsArgsDict',
    'ZeroTrustGatewaySettingsLoggingArgs',
    'ZeroTrustGatewaySettingsLoggingArgsDict',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgsDict',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgsDict',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgsDict',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4ArgsDict',
    'ZeroTrustGatewaySettingsPayloadLogArgs',
    'ZeroTrustGatewaySettingsPayloadLogArgsDict',
    'ZeroTrustGatewaySettingsProxyArgs',
    'ZeroTrustGatewaySettingsProxyArgsDict',
    'ZeroTrustGatewaySettingsSshSessionLogArgs',
    'ZeroTrustGatewaySettingsSshSessionLogArgsDict',
    'ZeroTrustInfrastructureAccessTargetIpArgs',
    'ZeroTrustInfrastructureAccessTargetIpArgsDict',
    'ZeroTrustInfrastructureAccessTargetIpIpv4Args',
    'ZeroTrustInfrastructureAccessTargetIpIpv4ArgsDict',
    'ZeroTrustInfrastructureAccessTargetIpIpv6Args',
    'ZeroTrustInfrastructureAccessTargetIpIpv6ArgsDict',
    'ZeroTrustListItemsWithDescriptionArgs',
    'ZeroTrustListItemsWithDescriptionArgsDict',
    'ZeroTrustLocalFallbackDomainDomainArgs',
    'ZeroTrustLocalFallbackDomainDomainArgsDict',
    'ZeroTrustRiskBehaviorBehaviorArgs',
    'ZeroTrustRiskBehaviorBehaviorArgsDict',
    'ZeroTrustSplitTunnelTunnelArgs',
    'ZeroTrustSplitTunnelTunnelArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict',
    'ZoneLockdownConfigurationArgs',
    'ZoneLockdownConfigurationArgsDict',
    'ZoneSettingsOverrideInitialSettingArgs',
    'ZoneSettingsOverrideInitialSettingArgsDict',
    'ZoneSettingsOverrideInitialSettingMinifyArgs',
    'ZoneSettingsOverrideInitialSettingMinifyArgsDict',
    'ZoneSettingsOverrideInitialSettingMobileRedirectArgs',
    'ZoneSettingsOverrideInitialSettingMobileRedirectArgsDict',
    'ZoneSettingsOverrideInitialSettingNelArgs',
    'ZoneSettingsOverrideInitialSettingNelArgsDict',
    'ZoneSettingsOverrideInitialSettingSecurityHeaderArgs',
    'ZoneSettingsOverrideInitialSettingSecurityHeaderArgsDict',
    'ZoneSettingsOverrideSettingsArgs',
    'ZoneSettingsOverrideSettingsArgsDict',
    'ZoneSettingsOverrideSettingsMinifyArgs',
    'ZoneSettingsOverrideSettingsMinifyArgsDict',
    'ZoneSettingsOverrideSettingsMobileRedirectArgs',
    'ZoneSettingsOverrideSettingsMobileRedirectArgsDict',
    'ZoneSettingsOverrideSettingsNelArgs',
    'ZoneSettingsOverrideSettingsNelArgsDict',
    'ZoneSettingsOverrideSettingsSecurityHeaderArgs',
    'ZoneSettingsOverrideSettingsSecurityHeaderArgsDict',
    'GetLoadBalancerPoolsFilterArgs',
    'GetLoadBalancerPoolsFilterArgsDict',
    'GetLoadBalancerPoolsPoolArgs',
    'GetLoadBalancerPoolsPoolArgsDict',
    'GetLoadBalancerPoolsPoolLoadSheddingArgs',
    'GetLoadBalancerPoolsPoolLoadSheddingArgsDict',
    'GetLoadBalancerPoolsPoolOriginArgs',
    'GetLoadBalancerPoolsPoolOriginArgsDict',
    'GetLoadBalancerPoolsPoolOriginHeaderArgs',
    'GetLoadBalancerPoolsPoolOriginHeaderArgsDict',
    'GetRulesetsFilterArgs',
    'GetRulesetsFilterArgsDict',
    'GetZonesFilterArgs',
    'GetZonesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AccessApplicationCorsHeaderArgsDict(TypedDict):
        allow_all_headers: NotRequired[pulumi.Input[bool]]
        """
        Value to determine whether all HTTP headers are exposed.
        """
        allow_all_methods: NotRequired[pulumi.Input[bool]]
        """
        Value to determine whether all methods are exposed.
        """
        allow_all_origins: NotRequired[pulumi.Input[bool]]
        """
        Value to determine whether all origins are permitted to make CORS requests.
        """
        allow_credentials: NotRequired[pulumi.Input[bool]]
        """
        Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of HTTP headers to expose via CORS.
        """
        allowed_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of methods to expose via CORS.
        """
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of origins permitted to make CORS requests.
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        The maximum time a preflight request will be cached.
        """
elif False:
    AccessApplicationCorsHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationCorsHeaderArgs:
    def __init__(__self__, *,
                 allow_all_headers: Optional[pulumi.Input[bool]] = None,
                 allow_all_methods: Optional[pulumi.Input[bool]] = None,
                 allow_all_origins: Optional[pulumi.Input[bool]] = None,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_all_headers: Value to determine whether all HTTP headers are exposed.
        :param pulumi.Input[bool] allow_all_methods: Value to determine whether all methods are exposed.
        :param pulumi.Input[bool] allow_all_origins: Value to determine whether all origins are permitted to make CORS requests.
        :param pulumi.Input[bool] allow_credentials: Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: List of HTTP headers to expose via CORS.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: List of methods to expose via CORS.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: List of origins permitted to make CORS requests.
        :param pulumi.Input[int] max_age: The maximum time a preflight request will be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all HTTP headers are exposed.
        """
        return pulumi.get(self, "allow_all_headers")

    @allow_all_headers.setter
    def allow_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_headers", value)

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all methods are exposed.
        """
        return pulumi.get(self, "allow_all_methods")

    @allow_all_methods.setter
    def allow_all_methods(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_methods", value)

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all origins are permitted to make CORS requests.
        """
        return pulumi.get(self, "allow_all_origins")

    @allow_all_origins.setter
    def allow_all_origins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_origins", value)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of HTTP headers to expose via CORS.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of methods to expose via CORS.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of origins permitted to make CORS requests.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum time a preflight request will be cached.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AccessApplicationDestinationArgsDict(TypedDict):
        uri: pulumi.Input[str]
        """
        The URI of the destination. Public destinations can include a domain and path with wildcards. Private destinations are an early access feature and gated behind a feature flag. Private destinations support private IPv4, IPv6, and Server Name Indications (SNI) with optional port ranges.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The destination type. Available values: `public`, `private`. Defaults to `public`.
        """
elif False:
    AccessApplicationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationDestinationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: The URI of the destination. Public destinations can include a domain and path with wildcards. Private destinations are an early access feature and gated behind a feature flag. Private destinations support private IPv4, IPv6, and Server Name Indications (SNI) with optional port ranges.
        :param pulumi.Input[str] type: The destination type. Available values: `public`, `private`. Defaults to `public`.
        """
        pulumi.set(__self__, "uri", uri)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI of the destination. Public destinations can include a domain and path with wildcards. Private destinations are an early access feature and gated behind a feature flag. Private destinations support private IPv4, IPv6, and Server Name Indications (SNI) with optional port ranges.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The destination type. Available values: `public`, `private`. Defaults to `public`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AccessApplicationFooterLinkArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the footer link.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL of the footer link.
        """
elif False:
    AccessApplicationFooterLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationFooterLinkArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the footer link.
        :param pulumi.Input[str] url: The URL of the footer link.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the footer link.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the footer link.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AccessApplicationLandingPageDesignArgsDict(TypedDict):
        button_color: NotRequired[pulumi.Input[str]]
        """
        The button color of the landing page.
        """
        button_text_color: NotRequired[pulumi.Input[str]]
        """
        The button text color of the landing page.
        """
        image_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the image to be displayed in the landing page.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The message of the landing page.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The title of the landing page.
        """
elif False:
    AccessApplicationLandingPageDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationLandingPageDesignArgs:
    def __init__(__self__, *,
                 button_color: Optional[pulumi.Input[str]] = None,
                 button_text_color: Optional[pulumi.Input[str]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] button_color: The button color of the landing page.
        :param pulumi.Input[str] button_text_color: The button text color of the landing page.
        :param pulumi.Input[str] image_url: The URL of the image to be displayed in the landing page.
        :param pulumi.Input[str] message: The message of the landing page.
        :param pulumi.Input[str] title: The title of the landing page.
        """
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[pulumi.Input[str]]:
        """
        The button color of the landing page.
        """
        return pulumi.get(self, "button_color")

    @button_color.setter
    def button_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_color", value)

    @property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[pulumi.Input[str]]:
        """
        The button text color of the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @button_text_color.setter
    def button_text_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text_color", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the image to be displayed in the landing page.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The message of the landing page.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the landing page.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class AccessApplicationSaasAppArgsDict(TypedDict):
        access_token_lifetime: NotRequired[pulumi.Input[str]]
        """
        The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        allow_pkce_without_client_secret: NotRequired[pulumi.Input[bool]]
        """
        Allow PKCE flow without a client secret.
        """
        app_launcher_url: NotRequired[pulumi.Input[str]]
        """
        The URL where this applications tile redirects users.
        """
        auth_type: NotRequired[pulumi.Input[str]]
        """
        **Modifying this attribute will force creation of a new resource.**
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The application client id.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The application client secret, only returned on initial apply.
        """
        consumer_service_url: NotRequired[pulumi.Input[str]]
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgsDict']]]]
        """
        Custom attribute mapped from IDPs.
        """
        custom_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgsDict']]]]
        """
        Custom claim mapped from IDPs.
        """
        default_relay_state: NotRequired[pulumi.Input[str]]
        """
        The relay state used if not provided by the identity provider.
        """
        grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OIDC flows supported by this application.
        """
        group_filter_regex: NotRequired[pulumi.Input[str]]
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        """
        hybrid_and_implicit_options: NotRequired[pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgsDict']]
        """
        Hybrid and Implicit Flow options.
        """
        idp_entity_id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier for the SaaS application.
        """
        name_id_format: NotRequired[pulumi.Input[str]]
        """
        The format of the name identifier sent to the SaaS application.
        """
        name_id_transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        public_key: NotRequired[pulumi.Input[str]]
        """
        The public certificate that will be used to verify identities.
        """
        redirect_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        """
        refresh_token_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionArgsDict']]]]
        """
        Refresh token grant options.
        """
        saml_attribute_transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Define the user information shared with access.
        """
        sp_entity_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique name for an identity or service provider.
        """
        sso_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint where the SaaS application will send login requests.
        """
elif False:
    AccessApplicationSaasAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppArgs:
    def __init__(__self__, *,
                 access_token_lifetime: Optional[pulumi.Input[str]] = None,
                 allow_pkce_without_client_secret: Optional[pulumi.Input[bool]] = None,
                 app_launcher_url: Optional[pulumi.Input[str]] = None,
                 auth_type: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 consumer_service_url: Optional[pulumi.Input[str]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]] = None,
                 custom_claims: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgs']]]] = None,
                 default_relay_state: Optional[pulumi.Input[str]] = None,
                 grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_filter_regex: Optional[pulumi.Input[str]] = None,
                 hybrid_and_implicit_options: Optional[pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgs']] = None,
                 idp_entity_id: Optional[pulumi.Input[str]] = None,
                 name_id_format: Optional[pulumi.Input[str]] = None,
                 name_id_transform_jsonata: Optional[pulumi.Input[str]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 refresh_token_options: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionArgs']]]] = None,
                 saml_attribute_transform_jsonata: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sp_entity_id: Optional[pulumi.Input[str]] = None,
                 sso_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token_lifetime: The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        :param pulumi.Input[bool] allow_pkce_without_client_secret: Allow PKCE flow without a client secret.
        :param pulumi.Input[str] app_launcher_url: The URL where this applications tile redirects users.
        :param pulumi.Input[str] auth_type: **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] client_id: The application client id.
        :param pulumi.Input[str] client_secret: The application client secret, only returned on initial apply.
        :param pulumi.Input[str] consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]] custom_attributes: Custom attribute mapped from IDPs.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgs']]] custom_claims: Custom claim mapped from IDPs.
        :param pulumi.Input[str] default_relay_state: The relay state used if not provided by the identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] grant_types: The OIDC flows supported by this application.
        :param pulumi.Input[str] group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        :param pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgs'] hybrid_and_implicit_options: Hybrid and Implicit Flow options.
        :param pulumi.Input[str] idp_entity_id: The unique identifier for the SaaS application.
        :param pulumi.Input[str] name_id_format: The format of the name identifier sent to the SaaS application.
        :param pulumi.Input[str] name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param pulumi.Input[str] public_key: The public certificate that will be used to verify identities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionArgs']]] refresh_token_options: Refresh token grant options.
        :param pulumi.Input[str] saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: Define the user information shared with access.
        :param pulumi.Input[str] sp_entity_id: A globally unique name for an identity or service provider.
        :param pulumi.Input[str] sso_endpoint: The endpoint where the SaaS application will send login requests.
        """
        if access_token_lifetime is not None:
            pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        if allow_pkce_without_client_secret is not None:
            pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        if app_launcher_url is not None:
            pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if consumer_service_url is not None:
            pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if custom_claims is not None:
            pulumi.set(__self__, "custom_claims", custom_claims)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if group_filter_regex is not None:
            pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        if hybrid_and_implicit_options is not None:
            pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if name_id_transform_jsonata is not None:
            pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if refresh_token_options is not None:
            pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        if saml_attribute_transform_jsonata is not None:
            pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sso_endpoint is not None:
            pulumi.set(__self__, "sso_endpoint", sso_endpoint)

    @property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> Optional[pulumi.Input[str]]:
        """
        The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @access_token_lifetime.setter
    def access_token_lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_lifetime", value)

    @property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow PKCE flow without a client secret.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @allow_pkce_without_client_secret.setter
    def allow_pkce_without_client_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_pkce_without_client_secret", value)

    @property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL where this applications tile redirects users.
        """
        return pulumi.get(self, "app_launcher_url")

    @app_launcher_url.setter
    def app_launcher_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_launcher_url", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[str]]:
        """
        **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The application client id.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The application client secret, only returned on initial apply.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> Optional[pulumi.Input[str]]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @consumer_service_url.setter
    def consumer_service_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_service_url", value)

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]]:
        """
        Custom attribute mapped from IDPs.
        """
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]]):
        pulumi.set(self, "custom_attributes", value)

    @property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgs']]]]:
        """
        Custom claim mapped from IDPs.
        """
        return pulumi.get(self, "custom_claims")

    @custom_claims.setter
    def custom_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgs']]]]):
        pulumi.set(self, "custom_claims", value)

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[pulumi.Input[str]]:
        """
        The relay state used if not provided by the identity provider.
        """
        return pulumi.get(self, "default_relay_state")

    @default_relay_state.setter
    def default_relay_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_relay_state", value)

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OIDC flows supported by this application.
        """
        return pulumi.get(self, "grant_types")

    @grant_types.setter
    def grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "grant_types", value)

    @property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> Optional[pulumi.Input[str]]:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        """
        return pulumi.get(self, "group_filter_regex")

    @group_filter_regex.setter
    def group_filter_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_filter_regex", value)

    @property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> Optional[pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgs']]:
        """
        Hybrid and Implicit Flow options.
        """
        return pulumi.get(self, "hybrid_and_implicit_options")

    @hybrid_and_implicit_options.setter
    def hybrid_and_implicit_options(self, value: Optional[pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgs']]):
        pulumi.set(self, "hybrid_and_implicit_options", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier for the SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the name identifier sent to the SaaS application.
        """
        return pulumi.get(self, "name_id_format")

    @name_id_format.setter
    def name_id_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_format", value)

    @property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @name_id_transform_jsonata.setter
    def name_id_transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_transform_jsonata", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        The public certificate that will be used to verify identities.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        """
        return pulumi.get(self, "redirect_uris")

    @redirect_uris.setter
    def redirect_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "redirect_uris", value)

    @property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionArgs']]]]:
        """
        Refresh token grant options.
        """
        return pulumi.get(self, "refresh_token_options")

    @refresh_token_options.setter
    def refresh_token_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionArgs']]]]):
        pulumi.set(self, "refresh_token_options", value)

    @property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @saml_attribute_transform_jsonata.setter
    def saml_attribute_transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_attribute_transform_jsonata", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Define the user information shared with access.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sp_entity_id", value)

    @property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint where the SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")

    @sso_endpoint.setter
    def sso_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_endpoint", value)


if not MYPY:
    class AccessApplicationSaasAppCustomAttributeArgsDict(TypedDict):
        source: pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgsDict']
        friendly_name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the attribute as provided to the SaaS app.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the attribute as provided to the SaaS app.
        """
        name_format: NotRequired[pulumi.Input[str]]
        """
        A globally unique name for an identity or service provider.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        True if the attribute must be always present.
        """
elif False:
    AccessApplicationSaasAppCustomAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomAttributeArgs:
    def __init__(__self__, *,
                 source: pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs'],
                 friendly_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 name_format: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] friendly_name: A friendly name for the attribute as provided to the SaaS app.
        :param pulumi.Input[str] name: The name of the attribute as provided to the SaaS app.
        :param pulumi.Input[str] name_format: A globally unique name for an identity or service provider.
        :param pulumi.Input[bool] required: True if the attribute must be always present.
        """
        pulumi.set(__self__, "source", source)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_format is not None:
            pulumi.set(__self__, "name_format", name_format)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs']:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs']):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @name_format.setter
    def name_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_format", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AccessApplicationSaasAppCustomAttributeSourceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the attribute as provided by the IDP.
        """
        name_by_idp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping from IdP ID to claim name.
        """
elif False:
    AccessApplicationSaasAppCustomAttributeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomAttributeSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 name_by_idp: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute as provided by the IDP.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the attribute as provided by the IDP.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")

    @name_by_idp.setter
    def name_by_idp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "name_by_idp", value)


if not MYPY:
    class AccessApplicationSaasAppCustomClaimArgsDict(TypedDict):
        source: pulumi.Input['AccessApplicationSaasAppCustomClaimSourceArgsDict']
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the attribute as provided to the SaaS app.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        True if the attribute must be always present.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The scope of the claim.
        """
elif False:
    AccessApplicationSaasAppCustomClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomClaimArgs:
    def __init__(__self__, *,
                 source: pulumi.Input['AccessApplicationSaasAppCustomClaimSourceArgs'],
                 name: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute as provided to the SaaS app.
        :param pulumi.Input[bool] required: True if the attribute must be always present.
        :param pulumi.Input[str] scope: The scope of the claim.
        """
        pulumi.set(__self__, "source", source)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input['AccessApplicationSaasAppCustomClaimSourceArgs']:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['AccessApplicationSaasAppCustomClaimSourceArgs']):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The scope of the claim.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class AccessApplicationSaasAppCustomClaimSourceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the attribute as provided by the IDP.
        """
        name_by_idp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping from IdP ID to claim name.
        """
elif False:
    AccessApplicationSaasAppCustomClaimSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomClaimSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 name_by_idp: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute as provided by the IDP.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the attribute as provided by the IDP.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")

    @name_by_idp.setter
    def name_by_idp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "name_by_idp", value)


if not MYPY:
    class AccessApplicationSaasAppHybridAndImplicitOptionsArgsDict(TypedDict):
        return_access_token_from_authorization_endpoint: NotRequired[pulumi.Input[bool]]
        """
        If true, the authorization endpoint will return an access token.
        """
        return_id_token_from_authorization_endpoint: NotRequired[pulumi.Input[bool]]
        """
        If true, the authorization endpoint will return an id token.
        """
elif False:
    AccessApplicationSaasAppHybridAndImplicitOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppHybridAndImplicitOptionsArgs:
    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: Optional[pulumi.Input[bool]] = None,
                 return_id_token_from_authorization_endpoint: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] return_access_token_from_authorization_endpoint: If true, the authorization endpoint will return an access token.
        :param pulumi.Input[bool] return_id_token_from_authorization_endpoint: If true, the authorization endpoint will return an id token.
        """
        if return_access_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        if return_id_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the authorization endpoint will return an access token.
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @return_access_token_from_authorization_endpoint.setter
    def return_access_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_access_token_from_authorization_endpoint", value)

    @property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the authorization endpoint will return an id token.
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")

    @return_id_token_from_authorization_endpoint.setter
    def return_id_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_id_token_from_authorization_endpoint", value)


if not MYPY:
    class AccessApplicationSaasAppRefreshTokenOptionArgsDict(TypedDict):
        lifetime: NotRequired[pulumi.Input[str]]
        """
        How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
elif False:
    AccessApplicationSaasAppRefreshTokenOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppRefreshTokenOptionArgs:
    def __init__(__self__, *,
                 lifetime: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lifetime: How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
        if lifetime is not None:
            pulumi.set(__self__, "lifetime", lifetime)

    @property
    @pulumi.getter
    def lifetime(self) -> Optional[pulumi.Input[str]]:
        """
        How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")

    @lifetime.setter
    def lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifetime", value)


if not MYPY:
    class AccessApplicationScimConfigArgsDict(TypedDict):
        idp_uid: pulumi.Input[str]
        """
        The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        """
        remote_uri: pulumi.Input[str]
        """
        The base URI for the application's SCIM-compatible API.
        """
        authentication: NotRequired[pulumi.Input['AccessApplicationScimConfigAuthenticationArgsDict']]
        """
        Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        """
        deactivate_on_delete: NotRequired[pulumi.Input[bool]]
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether SCIM provisioning is turned on for this application.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgsDict']]]]
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
elif False:
    AccessApplicationScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationScimConfigArgs:
    def __init__(__self__, *,
                 idp_uid: pulumi.Input[str],
                 remote_uri: pulumi.Input[str],
                 authentication: Optional[pulumi.Input['AccessApplicationScimConfigAuthenticationArgs']] = None,
                 deactivate_on_delete: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgs']]]] = None):
        """
        :param pulumi.Input[str] idp_uid: The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        :param pulumi.Input[str] remote_uri: The base URI for the application's SCIM-compatible API.
        :param pulumi.Input['AccessApplicationScimConfigAuthenticationArgs'] authentication: Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        :param pulumi.Input[bool] deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param pulumi.Input[bool] enabled: Whether SCIM provisioning is turned on for this application.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgs']]] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "remote_uri", remote_uri)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if deactivate_on_delete is not None:
            pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> pulumi.Input[str]:
        """
        The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @idp_uid.setter
    def idp_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_uid", value)

    @property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> pulumi.Input[str]:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")

    @remote_uri.setter
    def remote_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_uri", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['AccessApplicationScimConfigAuthenticationArgs']]:
        """
        Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['AccessApplicationScimConfigAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @deactivate_on_delete.setter
    def deactivate_on_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deactivate_on_delete", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgs']]]]:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgs']]]]):
        pulumi.set(self, "mappings", value)


if not MYPY:
    class AccessApplicationScimConfigAuthenticationArgsDict(TypedDict):
        scheme: pulumi.Input[str]
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        authorization_url: NotRequired[pulumi.Input[str]]
        """
        URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        token_url: NotRequired[pulumi.Input[str]]
        """
        URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
elif False:
    AccessApplicationScimConfigAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationScimConfigAuthenticationArgs:
    def __init__(__self__, *,
                 scheme: pulumi.Input[str],
                 authorization_url: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 token_url: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scheme: The authentication scheme to use when making SCIM requests to this application.
        :param pulumi.Input[str] authorization_url: URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] password: Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] token: Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        :param pulumi.Input[str] token_url: URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] user: User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        pulumi.set(__self__, "scheme", scheme)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[str]:
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "authorization_url")

    @authorization_url.setter
    def authorization_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AccessApplicationScimConfigMappingArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Which SCIM resource type this mapping applies to.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping is enabled.
        """
        filter: NotRequired[pulumi.Input[str]]
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        operations: NotRequired[pulumi.Input['AccessApplicationScimConfigMappingOperationsArgsDict']]
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        strictness: NotRequired[pulumi.Input[str]]
        """
        How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        """
        transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
elif False:
    AccessApplicationScimConfigMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationScimConfigMappingArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 filter: Optional[pulumi.Input[str]] = None,
                 operations: Optional[pulumi.Input['AccessApplicationScimConfigMappingOperationsArgs']] = None,
                 strictness: Optional[pulumi.Input[str]] = None,
                 transform_jsonata: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] schema: Which SCIM resource type this mapping applies to.
        :param pulumi.Input[bool] enabled: Whether or not this mapping is enabled.
        :param pulumi.Input[str] filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param pulumi.Input['AccessApplicationScimConfigMappingOperationsArgs'] operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param pulumi.Input[str] strictness: How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        :param pulumi.Input[str] transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "schema", schema)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if strictness is not None:
            pulumi.set(__self__, "strictness", strictness)
        if transform_jsonata is not None:
            pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input['AccessApplicationScimConfigMappingOperationsArgs']]:
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input['AccessApplicationScimConfigMappingOperationsArgs']]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def strictness(self) -> Optional[pulumi.Input[str]]:
        """
        How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        """
        return pulumi.get(self, "strictness")

    @strictness.setter
    def strictness(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strictness", value)

    @property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")

    @transform_jsonata.setter
    def transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_jsonata", value)


if not MYPY:
    class AccessApplicationScimConfigMappingOperationsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        delete: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to DELETE operations.
        """
        update: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
elif False:
    AccessApplicationScimConfigMappingOperationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationScimConfigMappingOperationsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[bool]] = None,
                 delete: Optional[pulumi.Input[bool]] = None,
                 update: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] create: Whether or not this mapping applies to create (POST) operations.
        :param pulumi.Input[bool] delete: Whether or not this mapping applies to DELETE operations.
        :param pulumi.Input[bool] update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AccessApplicationTargetCriteriaArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        protocol: pulumi.Input[str]
        """
        The communication protocol your application secures.
        """
        target_attributes: pulumi.Input[Sequence[pulumi.Input['AccessApplicationTargetCriteriaTargetAttributeArgsDict']]]
        """
        Contains a map of target attribute keys to target attribute values.
        """
elif False:
    AccessApplicationTargetCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationTargetCriteriaArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 target_attributes: pulumi.Input[Sequence[pulumi.Input['AccessApplicationTargetCriteriaTargetAttributeArgs']]]):
        """
        :param pulumi.Input[int] port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param pulumi.Input[str] protocol: The communication protocol your application secures.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationTargetCriteriaTargetAttributeArgs']]] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The communication protocol your application secures.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> pulumi.Input[Sequence[pulumi.Input['AccessApplicationTargetCriteriaTargetAttributeArgs']]]:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")

    @target_attributes.setter
    def target_attributes(self, value: pulumi.Input[Sequence[pulumi.Input['AccessApplicationTargetCriteriaTargetAttributeArgs']]]):
        pulumi.set(self, "target_attributes", value)


if not MYPY:
    class AccessApplicationTargetCriteriaTargetAttributeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The key of the attribute.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The values of the attribute.
        """
elif False:
    AccessApplicationTargetCriteriaTargetAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationTargetCriteriaTargetAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The key of the attribute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The values of the attribute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The key of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The values of the attribute.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AccessGroupExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessGroupExcludeExternalEvaluationArgsDict']]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    AccessGroupExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input['AccessGroupExcludeExternalEvaluationArgs'] external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class AccessGroupExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    AccessGroupExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupExcludeAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    AccessGroupExcludeAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AccessGroupExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessGroupExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessGroupExcludeGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    AccessGroupExcludeGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class AccessGroupExcludeGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessGroupExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupExcludeOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    AccessGroupExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class AccessGroupExcludeSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessGroupExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessGroupIncludeExternalEvaluationArgsDict']]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    AccessGroupIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input['AccessGroupIncludeExternalEvaluationArgs'] external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class AccessGroupIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    AccessGroupIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupIncludeAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    AccessGroupIncludeAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AccessGroupIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessGroupIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessGroupIncludeGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    AccessGroupIncludeGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class AccessGroupIncludeGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessGroupIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupIncludeOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    AccessGroupIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class AccessGroupIncludeSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessGroupIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessGroupRequireExternalEvaluationArgsDict']]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    AccessGroupRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input['AccessGroupRequireExternalEvaluationArgs'] external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class AccessGroupRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    AccessGroupRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupRequireAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    AccessGroupRequireAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AccessGroupRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessGroupRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessGroupRequireGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    AccessGroupRequireGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class AccessGroupRequireGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessGroupRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupRequireOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    AccessGroupRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class AccessGroupRequireSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessGroupRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessIdentityProviderConfigArgsDict(TypedDict):
        api_token: NotRequired[pulumi.Input[str]]
        apps_domain: NotRequired[pulumi.Input[str]]
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        auth_url: NotRequired[pulumi.Input[str]]
        authorization_server_id: NotRequired[pulumi.Input[str]]
        centrify_account: NotRequired[pulumi.Input[str]]
        centrify_app_id: NotRequired[pulumi.Input[str]]
        certs_url: NotRequired[pulumi.Input[str]]
        claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        client_id: NotRequired[pulumi.Input[str]]
        client_secret: NotRequired[pulumi.Input[str]]
        conditional_access_enabled: NotRequired[pulumi.Input[bool]]
        directory_id: NotRequired[pulumi.Input[str]]
        email_attribute_name: NotRequired[pulumi.Input[str]]
        email_claim_name: NotRequired[pulumi.Input[str]]
        idp_public_cert: NotRequired[pulumi.Input[str]]
        issuer_url: NotRequired[pulumi.Input[str]]
        okta_account: NotRequired[pulumi.Input[str]]
        onelogin_account: NotRequired[pulumi.Input[str]]
        ping_env_id: NotRequired[pulumi.Input[str]]
        pkce_enabled: NotRequired[pulumi.Input[bool]]
        redirect_url: NotRequired[pulumi.Input[str]]
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        sign_request: NotRequired[pulumi.Input[bool]]
        sso_target_url: NotRequired[pulumi.Input[str]]
        support_groups: NotRequired[pulumi.Input[bool]]
        token_url: NotRequired[pulumi.Input[str]]
elif False:
    AccessIdentityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessIdentityProviderConfigArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input[str]] = None,
                 apps_domain: Optional[pulumi.Input[str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 authorization_server_id: Optional[pulumi.Input[str]] = None,
                 centrify_account: Optional[pulumi.Input[str]] = None,
                 centrify_app_id: Optional[pulumi.Input[str]] = None,
                 certs_url: Optional[pulumi.Input[str]] = None,
                 claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 conditional_access_enabled: Optional[pulumi.Input[bool]] = None,
                 directory_id: Optional[pulumi.Input[str]] = None,
                 email_attribute_name: Optional[pulumi.Input[str]] = None,
                 email_claim_name: Optional[pulumi.Input[str]] = None,
                 idp_public_cert: Optional[pulumi.Input[str]] = None,
                 issuer_url: Optional[pulumi.Input[str]] = None,
                 okta_account: Optional[pulumi.Input[str]] = None,
                 onelogin_account: Optional[pulumi.Input[str]] = None,
                 ping_env_id: Optional[pulumi.Input[str]] = None,
                 pkce_enabled: Optional[pulumi.Input[bool]] = None,
                 redirect_url: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sign_request: Optional[pulumi.Input[bool]] = None,
                 sso_target_url: Optional[pulumi.Input[str]] = None,
                 support_groups: Optional[pulumi.Input[bool]] = None,
                 token_url: Optional[pulumi.Input[str]] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if conditional_access_enabled is not None:
            pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            pulumi.set(__self__, "email_claim_name", email_claim_name)
        if idp_public_cert is not None:
            pulumi.set(__self__, "idp_public_cert", idp_public_cert)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if ping_env_id is not None:
            pulumi.set(__self__, "ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "apps_domain")

    @apps_domain.setter
    def apps_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apps_domain", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "authorization_server_id")

    @authorization_server_id.setter
    def authorization_server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_server_id", value)

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "centrify_account")

    @centrify_account.setter
    def centrify_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "centrify_account", value)

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "centrify_app_id")

    @centrify_app_id.setter
    def centrify_app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "centrify_app_id", value)

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certs_url")

    @certs_url.setter
    def certs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certs_url", value)

    @property
    @pulumi.getter
    def claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "claims")

    @claims.setter
    def claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "claims", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "conditional_access_enabled")

    @conditional_access_enabled.setter
    def conditional_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditional_access_enabled", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory_id", value)

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_attribute_name")

    @email_attribute_name.setter
    def email_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_attribute_name", value)

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_claim_name")

    @email_claim_name.setter
    def email_claim_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_claim_name", value)

    @property
    @pulumi.getter(name="idpPublicCert")
    def idp_public_cert(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idp_public_cert")

    @idp_public_cert.setter
    def idp_public_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_public_cert", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "okta_account")

    @okta_account.setter
    def okta_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "okta_account", value)

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "onelogin_account")

    @onelogin_account.setter
    def onelogin_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "onelogin_account", value)

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ping_env_id")

    @ping_env_id.setter
    def ping_env_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ping_env_id", value)

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pkce_enabled")

    @pkce_enabled.setter
    def pkce_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pkce_enabled", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_request", value)

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sso_target_url")

    @sso_target_url.setter
    def sso_target_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_target_url", value)

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "support_groups")

    @support_groups.setter
    def support_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_groups", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)


if not MYPY:
    class AccessIdentityProviderScimConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        group_member_deprovision: NotRequired[pulumi.Input[bool]]
        """
        Deprecated. Use `identity_update_behavior`.
        """
        identity_update_behavior: NotRequired[pulumi.Input[str]]
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        seat_deprovision: NotRequired[pulumi.Input[bool]]
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        user_deprovision: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
elif False:
    AccessIdentityProviderScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessIdentityProviderScimConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 group_member_deprovision: Optional[pulumi.Input[bool]] = None,
                 identity_update_behavior: Optional[pulumi.Input[str]] = None,
                 seat_deprovision: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 user_deprovision: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: A flag to enable or disable SCIM for the identity provider.
        :param pulumi.Input[bool] group_member_deprovision: Deprecated. Use `identity_update_behavior`.
        :param pulumi.Input[str] identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        :param pulumi.Input[bool] seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param pulumi.Input[str] secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        :param pulumi.Input[bool] user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group_member_deprovision is not None:
            pulumi.set(__self__, "group_member_deprovision", group_member_deprovision)
        if identity_update_behavior is not None:
            pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="groupMemberDeprovision")
    def group_member_deprovision(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Use `identity_update_behavior`.
        """
        return pulumi.get(self, "group_member_deprovision")

    @group_member_deprovision.setter
    def group_member_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "group_member_deprovision", value)

    @property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        return pulumi.get(self, "identity_update_behavior")

    @identity_update_behavior.setter
    def identity_update_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_update_behavior", value)

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @seat_deprovision.setter
    def seat_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "seat_deprovision", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")

    @user_deprovision.setter
    def user_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_deprovision", value)


if not MYPY:
    class AccessMutualTlsHostnameSettingsSettingArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        The hostname that these settings apply to.
        """
        china_network: NotRequired[pulumi.Input[bool]]
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        client_certificate_forwarding: NotRequired[pulumi.Input[bool]]
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
elif False:
    AccessMutualTlsHostnameSettingsSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessMutualTlsHostnameSettingsSettingArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 china_network: Optional[pulumi.Input[bool]] = None,
                 client_certificate_forwarding: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] hostname: The hostname that these settings apply to.
        :param pulumi.Input[bool] china_network: Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        :param pulumi.Input[bool] client_certificate_forwarding: Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        pulumi.set(__self__, "hostname", hostname)
        if china_network is not None:
            pulumi.set(__self__, "china_network", china_network)
        if client_certificate_forwarding is not None:
            pulumi.set(__self__, "client_certificate_forwarding", client_certificate_forwarding)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        The hostname that these settings apply to.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="chinaNetwork")
    def china_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        return pulumi.get(self, "china_network")

    @china_network.setter
    def china_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "china_network", value)

    @property
    @pulumi.getter(name="clientCertificateForwarding")
    def client_certificate_forwarding(self) -> Optional[pulumi.Input[bool]]:
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        return pulumi.get(self, "client_certificate_forwarding")

    @client_certificate_forwarding.setter
    def client_certificate_forwarding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_certificate_forwarding", value)


if not MYPY:
    class AccessOrganizationCustomPageArgsDict(TypedDict):
        forbidden: NotRequired[pulumi.Input[str]]
        """
        The id of the forbidden page.
        """
        identity_denied: NotRequired[pulumi.Input[str]]
        """
        The id of the identity denied page.
        """
elif False:
    AccessOrganizationCustomPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessOrganizationCustomPageArgs:
    def __init__(__self__, *,
                 forbidden: Optional[pulumi.Input[str]] = None,
                 identity_denied: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] forbidden: The id of the forbidden page.
        :param pulumi.Input[str] identity_denied: The id of the identity denied page.
        """
        if forbidden is not None:
            pulumi.set(__self__, "forbidden", forbidden)
        if identity_denied is not None:
            pulumi.set(__self__, "identity_denied", identity_denied)

    @property
    @pulumi.getter
    def forbidden(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the forbidden page.
        """
        return pulumi.get(self, "forbidden")

    @forbidden.setter
    def forbidden(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forbidden", value)

    @property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the identity denied page.
        """
        return pulumi.get(self, "identity_denied")

    @identity_denied.setter
    def identity_denied(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_denied", value)


if not MYPY:
    class AccessOrganizationLoginDesignArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[str]]
        """
        The background color on the login page.
        """
        footer_text: NotRequired[pulumi.Input[str]]
        """
        The text at the bottom of the login page.
        """
        header_text: NotRequired[pulumi.Input[str]]
        """
        The text at the top of the login page.
        """
        logo_path: NotRequired[pulumi.Input[str]]
        """
        The URL of the logo on the login page.
        """
        text_color: NotRequired[pulumi.Input[str]]
        """
        The text color on the login page.
        """
elif False:
    AccessOrganizationLoginDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessOrganizationLoginDesignArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None,
                 logo_path: Optional[pulumi.Input[str]] = None,
                 text_color: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_color: The background color on the login page.
        :param pulumi.Input[str] footer_text: The text at the bottom of the login page.
        :param pulumi.Input[str] header_text: The text at the top of the login page.
        :param pulumi.Input[str] logo_path: The URL of the logo on the login page.
        :param pulumi.Input[str] text_color: The text color on the login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color on the login page.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text at the bottom of the login page.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text at the top of the login page.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the logo on the login page.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_path", value)

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[pulumi.Input[str]]:
        """
        The text color on the login page.
        """
        return pulumi.get(self, "text_color")

    @text_color.setter
    def text_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_color", value)


if not MYPY:
    class AccessPolicyApprovalGroupArgsDict(TypedDict):
        approvals_needed: pulumi.Input[int]
        """
        Number of approvals needed.
        """
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of emails to request approval from.
        """
        email_list_uuid: NotRequired[pulumi.Input[str]]
elif False:
    AccessPolicyApprovalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyApprovalGroupArgs:
    def __init__(__self__, *,
                 approvals_needed: pulumi.Input[int],
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_list_uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] approvals_needed: Number of approvals needed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_addresses: List of emails to request approval from.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> pulumi.Input[int]:
        """
        Number of approvals needed.
        """
        return pulumi.get(self, "approvals_needed")

    @approvals_needed.setter
    def approvals_needed(self, value: pulumi.Input[int]):
        pulumi.set(self, "approvals_needed", value)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of emails to request approval from.
        """
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_list_uuid")

    @email_list_uuid.setter
    def email_list_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_list_uuid", value)


if not MYPY:
    class AccessPolicyConnectionRulesArgsDict(TypedDict):
        ssh: pulumi.Input['AccessPolicyConnectionRulesSshArgsDict']
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
elif False:
    AccessPolicyConnectionRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyConnectionRulesArgs:
    def __init__(__self__, *,
                 ssh: pulumi.Input['AccessPolicyConnectionRulesSshArgs']):
        """
        :param pulumi.Input['AccessPolicyConnectionRulesSshArgs'] ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def ssh(self) -> pulumi.Input['AccessPolicyConnectionRulesSshArgs']:
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: pulumi.Input['AccessPolicyConnectionRulesSshArgs']):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class AccessPolicyConnectionRulesSshArgsDict(TypedDict):
        usernames: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        allow_email_alias: NotRequired[pulumi.Input[bool]]
        """
        Allows connecting to Unix username that matches the authenticating email prefix.
        """
elif False:
    AccessPolicyConnectionRulesSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyConnectionRulesSshArgs:
    def __init__(__self__, *,
                 usernames: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allow_email_alias: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        :param pulumi.Input[bool] allow_email_alias: Allows connecting to Unix username that matches the authenticating email prefix.
        """
        pulumi.set(__self__, "usernames", usernames)
        if allow_email_alias is not None:
            pulumi.set(__self__, "allow_email_alias", allow_email_alias)

    @property
    @pulumi.getter
    def usernames(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "usernames", value)

    @property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows connecting to Unix username that matches the authenticating email prefix.
        """
        return pulumi.get(self, "allow_email_alias")

    @allow_email_alias.setter
    def allow_email_alias(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_email_alias", value)


if not MYPY:
    class AccessPolicyExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgsDict']]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    AccessPolicyExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs'] external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class AccessPolicyExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    AccessPolicyExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyExcludeAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    AccessPolicyExcludeAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AccessPolicyExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessPolicyExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessPolicyExcludeGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    AccessPolicyExcludeGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class AccessPolicyExcludeGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessPolicyExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyExcludeOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    AccessPolicyExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class AccessPolicyExcludeSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessPolicyExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgsDict']]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    AccessPolicyIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs'] external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class AccessPolicyIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    AccessPolicyIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyIncludeAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    AccessPolicyIncludeAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AccessPolicyIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessPolicyIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessPolicyIncludeGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    AccessPolicyIncludeGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class AccessPolicyIncludeGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessPolicyIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyIncludeOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    AccessPolicyIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class AccessPolicyIncludeSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessPolicyIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessPolicyRequireExternalEvaluationArgsDict']]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    AccessPolicyRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input['AccessPolicyRequireExternalEvaluationArgs'] external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class AccessPolicyRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    AccessPolicyRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyRequireAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    AccessPolicyRequireAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AccessPolicyRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessPolicyRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessPolicyRequireGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    AccessPolicyRequireGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class AccessPolicyRequireGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessPolicyRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyRequireOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    AccessPolicyRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class AccessPolicyRequireSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessPolicyRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessRuleConfigurationArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        """
        value: pulumi.Input[str]
        """
        The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
elif False:
    AccessRuleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessRuleConfigurationArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target: The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] value: The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AddressMapIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 address.
        """
elif False:
    AddressMapIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressMapIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 address.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AddressMapMembershipArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        Identifier of the account or zone.
        """
        kind: pulumi.Input[str]
        """
        The type of the membership.
        """
        can_delete: NotRequired[pulumi.Input[bool]]
        """
        Controls whether the membership can be deleted via the API or not.
        """
elif False:
    AddressMapMembershipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressMapMembershipArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str],
                 kind: pulumi.Input[str],
                 can_delete: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] identifier: Identifier of the account or zone.
        :param pulumi.Input[str] kind: The type of the membership.
        :param pulumi.Input[bool] can_delete: Controls whether the membership can be deleted via the API or not.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "kind", kind)
        if can_delete is not None:
            pulumi.set(__self__, "can_delete", can_delete)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        Identifier of the account or zone.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        The type of the membership.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether the membership can be deleted via the API or not.
        """
        return pulumi.get(self, "can_delete")

    @can_delete.setter
    def can_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_delete", value)


if not MYPY:
    class ApiShieldAuthIdCharacteristicArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the characteristic.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of characteristic. Available values: `header`, `cookie`.
        """
elif False:
    ApiShieldAuthIdCharacteristicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldAuthIdCharacteristicArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the characteristic.
        :param pulumi.Input[str] type: The type of characteristic. Available values: `header`, `cookie`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the characteristic.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of characteristic. Available values: `header`, `cookie`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApiTokenConditionArgsDict(TypedDict):
        request_ip: NotRequired[pulumi.Input['ApiTokenConditionRequestIpArgsDict']]
        """
        Request IP related conditions.
        """
elif False:
    ApiTokenConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenConditionArgs:
    def __init__(__self__, *,
                 request_ip: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']] = None):
        """
        :param pulumi.Input['ApiTokenConditionRequestIpArgs'] request_ip: Request IP related conditions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']]:
        """
        Request IP related conditions.
        """
        return pulumi.get(self, "request_ip")

    @request_ip.setter
    def request_ip(self, value: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']]):
        pulumi.set(self, "request_ip", value)


if not MYPY:
    class ApiTokenConditionRequestIpArgsDict(TypedDict):
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
        """
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP addresses or CIDR notation where the token should not be used from.
        """
elif False:
    ApiTokenConditionRequestIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenConditionRequestIpArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ins: List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] not_ins: List of IP addresses or CIDR notation where the token should not be used from.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
        """
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP addresses or CIDR notation where the token should not be used from.
        """
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class ApiTokenPolicyArgsDict(TypedDict):
        permission_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        """
        resources: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        Describes what operations against which resources are allowed or denied.
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
elif False:
    ApiTokenPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenPolicyArgs:
    def __init__(__self__, *,
                 permission_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 resources: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 effect: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permission_groups: List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] resources: Describes what operations against which resources are allowed or denied.
        :param pulumi.Input[str] effect: Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        """
        return pulumi.get(self, "permission_groups")

    @permission_groups.setter
    def permission_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permission_groups", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Describes what operations against which resources are allowed or denied.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)


if not MYPY:
    class CertificatePackValidationErrorArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[str]]
elif False:
    CertificatePackValidationErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificatePackValidationErrorArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class CertificatePackValidationRecordArgsDict(TypedDict):
        cname_name: NotRequired[pulumi.Input[str]]
        cname_target: NotRequired[pulumi.Input[str]]
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        http_body: NotRequired[pulumi.Input[str]]
        http_url: NotRequired[pulumi.Input[str]]
        txt_name: NotRequired[pulumi.Input[str]]
        txt_value: NotRequired[pulumi.Input[str]]
elif False:
    CertificatePackValidationRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificatePackValidationRecordArgs:
    def __init__(__self__, *,
                 cname_name: Optional[pulumi.Input[str]] = None,
                 cname_target: Optional[pulumi.Input[str]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http_body: Optional[pulumi.Input[str]] = None,
                 http_url: Optional[pulumi.Input[str]] = None,
                 txt_name: Optional[pulumi.Input[str]] = None,
                 txt_value: Optional[pulumi.Input[str]] = None):
        if cname_name is not None:
            pulumi.set(__self__, "cname_name", cname_name)
        if cname_target is not None:
            pulumi.set(__self__, "cname_target", cname_target)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_name")

    @cname_name.setter
    def cname_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_name", value)

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_target")

    @cname_target.setter
    def cname_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_target", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_body")

    @http_body.setter
    def http_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_body", value)

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_url", value)

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_name")

    @txt_name.setter
    def txt_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_name", value)

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_value")

    @txt_value.setter
    def txt_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_value", value)


if not MYPY:
    class CloudConnectorRulesRuleArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        Criteria for an HTTP request to trigger the cloud connector rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        """
        provider: pulumi.Input[str]
        """
        Type of provider. Available values: `aws_s3`, `cloudflare_r2`, `azure_storage`, `gcp_storage`
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Brief summary of the cloud connector rule and its intended use.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the headers rule is active.
        """
        parameters: NotRequired[pulumi.Input['CloudConnectorRulesRuleParametersArgsDict']]
        """
        Cloud Connector Rule Parameters
        """
elif False:
    CloudConnectorRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudConnectorRulesRuleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 provider: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 parameters: Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']] = None):
        """
        :param pulumi.Input[str] expression: Criteria for an HTTP request to trigger the cloud connector rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        :param pulumi.Input[str] provider: Type of provider. Available values: `aws_s3`, `cloudflare_r2`, `azure_storage`, `gcp_storage`
        :param pulumi.Input[str] description: Brief summary of the cloud connector rule and its intended use.
        :param pulumi.Input[bool] enabled: Whether the headers rule is active.
        :param pulumi.Input['CloudConnectorRulesRuleParametersArgs'] parameters: Cloud Connector Rule Parameters
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "provider", provider)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Criteria for an HTTP request to trigger the cloud connector rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[str]:
        """
        Type of provider. Available values: `aws_s3`, `cloudflare_r2`, `azure_storage`, `gcp_storage`
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Brief summary of the cloud connector rule and its intended use.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']]:
        """
        Cloud Connector Rule Parameters
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class CloudConnectorRulesRuleParametersArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        Host parameter for cloud connector rule
        """
elif False:
    CloudConnectorRulesRuleParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudConnectorRulesRuleParametersArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str]):
        """
        :param pulumi.Input[str] host: Host parameter for cloud connector rule
        """
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Host parameter for cloud connector rule
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)


if not MYPY:
    class CustomHostnameSslArgsDict(TypedDict):
        bundle_method: NotRequired[pulumi.Input[str]]
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        certificate_authority: NotRequired[pulumi.Input[str]]
        custom_certificate: NotRequired[pulumi.Input[str]]
        """
        If a custom uploaded certificate is used.
        """
        custom_key: NotRequired[pulumi.Input[str]]
        """
        The key for a custom uploaded certificate.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        """
        settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgsDict']]]]
        """
        SSL/TLS settings for the certificate.
        """
        status: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        """
        validation_errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationErrorArgsDict']]]]
        validation_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationRecordArgsDict']]]]
        wildcard: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the certificate covers a wildcard.
        """
elif False:
    CustomHostnameSslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslArgs:
    def __init__(__self__, *,
                 bundle_method: Optional[pulumi.Input[str]] = None,
                 certificate_authority: Optional[pulumi.Input[str]] = None,
                 custom_certificate: Optional[pulumi.Input[str]] = None,
                 custom_key: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 validation_errors: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationErrorArgs']]]] = None,
                 validation_records: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationRecordArgs']]]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        :param pulumi.Input[str] custom_certificate: If a custom uploaded certificate is used.
        :param pulumi.Input[str] custom_key: The key for a custom uploaded certificate.
        :param pulumi.Input[str] method: Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        :param pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]] settings: SSL/TLS settings for the certificate.
        :param pulumi.Input[str] type: Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        :param pulumi.Input[bool] wildcard: Indicates whether the certificate covers a wildcard.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)
        if validation_records is not None:
            pulumi.set(__self__, "validation_records", validation_records)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[pulumi.Input[str]]:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @bundle_method.setter
    def bundle_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bundle_method", value)

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_authority", value)

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_certificate", value)

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_key", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]]]:
        """
        SSL/TLS settings for the certificate.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationErrorArgs']]]]:
        return pulumi.get(self, "validation_errors")

    @validation_errors.setter
    def validation_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationErrorArgs']]]]):
        pulumi.set(self, "validation_errors", value)

    @property
    @pulumi.getter(name="validationRecords")
    def validation_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationRecordArgs']]]]:
        return pulumi.get(self, "validation_records")

    @validation_records.setter
    def validation_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationRecordArgs']]]]):
        pulumi.set(self, "validation_records", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class CustomHostnameSslSettingArgsDict(TypedDict):
        ciphers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of SSL/TLS ciphers to associate with this certificate.
        """
        early_hints: NotRequired[pulumi.Input[str]]
        """
        Whether early hints should be supported. Available values: `on`, `off`.
        """
        http2: NotRequired[pulumi.Input[str]]
        """
        Whether HTTP2 should be supported. Available values: `on`, `off`.
        """
        min_tls_version: NotRequired[pulumi.Input[str]]
        """
        Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
        """
        tls13: NotRequired[pulumi.Input[str]]
        """
        Whether TLSv1.3 should be supported. Available values: `on`, `off`.
        """
elif False:
    CustomHostnameSslSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslSettingArgs:
    def __init__(__self__, *,
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 early_hints: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[str]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 tls13: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ciphers: List of SSL/TLS ciphers to associate with this certificate.
        :param pulumi.Input[str] early_hints: Whether early hints should be supported. Available values: `on`, `off`.
        :param pulumi.Input[str] http2: Whether HTTP2 should be supported. Available values: `on`, `off`.
        :param pulumi.Input[str] min_tls_version: Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
        :param pulumi.Input[str] tls13: Whether TLSv1.3 should be supported. Available values: `on`, `off`.
        """
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of SSL/TLS ciphers to associate with this certificate.
        """
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ciphers", value)

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[pulumi.Input[str]]:
        """
        Whether early hints should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "early_hints")

    @early_hints.setter
    def early_hints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "early_hints", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[str]]:
        """
        Whether HTTP2 should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter
    def tls13(self) -> Optional[pulumi.Input[str]]:
        """
        Whether TLSv1.3 should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "tls13")

    @tls13.setter
    def tls13(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls13", value)


if not MYPY:
    class CustomHostnameSslValidationErrorArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[str]]
elif False:
    CustomHostnameSslValidationErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslValidationErrorArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class CustomHostnameSslValidationRecordArgsDict(TypedDict):
        cname_name: NotRequired[pulumi.Input[str]]
        cname_target: NotRequired[pulumi.Input[str]]
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        http_body: NotRequired[pulumi.Input[str]]
        http_url: NotRequired[pulumi.Input[str]]
        txt_name: NotRequired[pulumi.Input[str]]
        txt_value: NotRequired[pulumi.Input[str]]
elif False:
    CustomHostnameSslValidationRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslValidationRecordArgs:
    def __init__(__self__, *,
                 cname_name: Optional[pulumi.Input[str]] = None,
                 cname_target: Optional[pulumi.Input[str]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http_body: Optional[pulumi.Input[str]] = None,
                 http_url: Optional[pulumi.Input[str]] = None,
                 txt_name: Optional[pulumi.Input[str]] = None,
                 txt_value: Optional[pulumi.Input[str]] = None):
        if cname_name is not None:
            pulumi.set(__self__, "cname_name", cname_name)
        if cname_target is not None:
            pulumi.set(__self__, "cname_target", cname_target)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_name")

    @cname_name.setter
    def cname_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_name", value)

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_target")

    @cname_target.setter
    def cname_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_target", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_body")

    @http_body.setter
    def http_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_body", value)

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_url", value)

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_name")

    @txt_name.setter
    def txt_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_name", value)

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_value")

    @txt_value.setter
    def txt_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_value", value)


if not MYPY:
    class CustomSslCustomSslOptionsArgsDict(TypedDict):
        bundle_method: NotRequired[pulumi.Input[str]]
        """
        Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        Certificate certificate and the intermediate(s).
        """
        geo_restrictions: NotRequired[pulumi.Input[str]]
        """
        Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        Certificate's private key.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
elif False:
    CustomSslCustomSslOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomSslCustomSslOptionsArgs:
    def __init__(__self__, *,
                 bundle_method: Optional[pulumi.Input[str]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 geo_restrictions: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bundle_method: Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        :param pulumi.Input[str] certificate: Certificate certificate and the intermediate(s).
        :param pulumi.Input[str] geo_restrictions: Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        :param pulumi.Input[str] private_key: Certificate's private key.
        :param pulumi.Input[str] type: Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if geo_restrictions is not None:
            pulumi.set(__self__, "geo_restrictions", geo_restrictions)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[pulumi.Input[str]]:
        """
        Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @bundle_method.setter
    def bundle_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bundle_method", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate certificate and the intermediate(s).
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="geoRestrictions")
    def geo_restrictions(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        """
        return pulumi.get(self, "geo_restrictions")

    @geo_restrictions.setter
    def geo_restrictions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "geo_restrictions", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate's private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CustomSslCustomSslPriorityArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of this resource.
        """
        priority: NotRequired[pulumi.Input[int]]
elif False:
    CustomSslCustomSslPriorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomSslCustomSslPriorityArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class DeviceDexTestDataArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        """
        kind: pulumi.Input[str]
        """
        The type of Device Dex Test. Available values: `http`, `traceroute`.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The http request method. Available values: `GET`.
        """
elif False:
    DeviceDexTestDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceDexTestDataArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 kind: pulumi.Input[str],
                 method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        :param pulumi.Input[str] kind: The type of Device Dex Test. Available values: `http`, `traceroute`.
        :param pulumi.Input[str] method: The http request method. Available values: `GET`.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        The type of Device Dex Test. Available values: `http`, `traceroute`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The http request method. Available values: `GET`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)


if not MYPY:
    class DeviceManagedNetworksConfigArgsDict(TypedDict):
        sha256: pulumi.Input[str]
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        tls_sockaddr: pulumi.Input[str]
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
elif False:
    DeviceManagedNetworksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceManagedNetworksConfigArgs:
    def __init__(__self__, *,
                 sha256: pulumi.Input[str],
                 tls_sockaddr: pulumi.Input[str]):
        """
        :param pulumi.Input[str] sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        :param pulumi.Input[str] tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)

    @property
    @pulumi.getter
    def sha256(self) -> pulumi.Input[str]:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: pulumi.Input[str]):
        pulumi.set(self, "sha256", value)

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> pulumi.Input[str]:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")

    @tls_sockaddr.setter
    def tls_sockaddr(self, value: pulumi.Input[str]):
        pulumi.set(self, "tls_sockaddr", value)


if not MYPY:
    class DevicePostureIntegrationConfigArgsDict(TypedDict):
        access_client_id: NotRequired[pulumi.Input[str]]
        """
        The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        """
        access_client_secret: NotRequired[pulumi.Input[str]]
        """
        The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        """
        api_url: NotRequired[pulumi.Input[str]]
        """
        The third-party API's URL.
        """
        auth_url: NotRequired[pulumi.Input[str]]
        """
        The third-party authorization API URL.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The client identifier for authenticating API calls.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        The client key for authenticating API calls.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret for authenticating API calls.
        """
        customer_id: NotRequired[pulumi.Input[str]]
        """
        The customer identifier for authenticating API calls.
        """
elif False:
    DevicePostureIntegrationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePostureIntegrationConfigArgs:
    def __init__(__self__, *,
                 access_client_id: Optional[pulumi.Input[str]] = None,
                 access_client_secret: Optional[pulumi.Input[str]] = None,
                 api_url: Optional[pulumi.Input[str]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 customer_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_client_id: The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        :param pulumi.Input[str] access_client_secret: The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        :param pulumi.Input[str] api_url: The third-party API's URL.
        :param pulumi.Input[str] auth_url: The third-party authorization API URL.
        :param pulumi.Input[str] client_id: The client identifier for authenticating API calls.
        :param pulumi.Input[str] client_key: The client key for authenticating API calls.
        :param pulumi.Input[str] client_secret: The client secret for authenticating API calls.
        :param pulumi.Input[str] customer_id: The customer identifier for authenticating API calls.
        """
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        """
        return pulumi.get(self, "access_client_id")

    @access_client_id.setter
    def access_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_id", value)

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        """
        return pulumi.get(self, "access_client_secret")

    @access_client_secret.setter
    def access_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_secret", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The third-party API's URL.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        """
        The third-party authorization API URL.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client identifier for authenticating API calls.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The client key for authenticating API calls.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret for authenticating API calls.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The customer identifier for authenticating API calls.
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_id", value)


if not MYPY:
    class DevicePostureRuleInputArgsDict(TypedDict):
        active_threats: NotRequired[pulumi.Input[int]]
        """
        The number of active threats from SentinelOne.
        """
        certificate_id: NotRequired[pulumi.Input[str]]
        """
        The UUID of a Cloudflare managed certificate.
        """
        check_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific volume(s) to check for encryption.
        """
        check_private_key: NotRequired[pulumi.Input[bool]]
        """
        Confirm the certificate was not imported from another device.
        """
        cn: NotRequired[pulumi.Input[str]]
        """
        The common name for a certificate.
        """
        compliance_status: NotRequired[pulumi.Input[str]]
        """
        The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        """
        connection_id: NotRequired[pulumi.Input[str]]
        """
        The workspace one or intune connection id.
        """
        count_operator: NotRequired[pulumi.Input[str]]
        """
        The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        The domain that the client must join.
        """
        eid_last_seen: NotRequired[pulumi.Input[str]]
        """
        The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if the firewall must be enabled.
        """
        exists: NotRequired[pulumi.Input[bool]]
        """
        Checks if the file should exist.
        """
        extended_key_usages: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        """
        infected: NotRequired[pulumi.Input[bool]]
        """
        True if SentinelOne device is infected.
        """
        is_active: NotRequired[pulumi.Input[bool]]
        """
        True if SentinelOne device is active.
        """
        issue_count: NotRequired[pulumi.Input[str]]
        """
        The number of issues for kolide.
        """
        last_seen: NotRequired[pulumi.Input[str]]
        """
        The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DevicePostureRuleInputLocationArgsDict']]]]
        """
        List of operating system locations to check for a client certificate..
        """
        network_status: NotRequired[pulumi.Input[str]]
        """
        The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        """
        operational_state: NotRequired[pulumi.Input[str]]
        """
        The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        os: NotRequired[pulumi.Input[str]]
        """
        OS signal score from Crowdstrike. Value must be between 1 and 100.
        """
        os_distro_name: NotRequired[pulumi.Input[str]]
        """
        The operating system excluding version information.
        """
        os_distro_revision: NotRequired[pulumi.Input[str]]
        """
        The operating system version excluding OS name information or release name.
        """
        os_version_extra: NotRequired[pulumi.Input[str]]
        """
        Extra version value following the operating system semantic version.
        """
        overall: NotRequired[pulumi.Input[str]]
        """
        Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path to the file.
        """
        require_all: NotRequired[pulumi.Input[bool]]
        """
        True if all drives must be encrypted.
        """
        risk_level: NotRequired[pulumi.Input[str]]
        """
        The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        """
        running: NotRequired[pulumi.Input[bool]]
        """
        Checks if the application should be running.
        """
        score: NotRequired[pulumi.Input[int]]
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        """
        sensor_config: NotRequired[pulumi.Input[str]]
        """
        Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        """
        sha256: NotRequired[pulumi.Input[str]]
        """
        The sha256 hash of the file.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        """
        thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the file certificate.
        """
        total_score: NotRequired[pulumi.Input[int]]
        """
        The total score from Tanium.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The operating system semantic version.
        """
        version_operator: NotRequired[pulumi.Input[str]]
        """
        The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
elif False:
    DevicePostureRuleInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePostureRuleInputArgs:
    def __init__(__self__, *,
                 active_threats: Optional[pulumi.Input[int]] = None,
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 check_disks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 check_private_key: Optional[pulumi.Input[bool]] = None,
                 cn: Optional[pulumi.Input[str]] = None,
                 compliance_status: Optional[pulumi.Input[str]] = None,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 count_operator: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 eid_last_seen: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exists: Optional[pulumi.Input[bool]] = None,
                 extended_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infected: Optional[pulumi.Input[bool]] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 issue_count: Optional[pulumi.Input[str]] = None,
                 last_seen: Optional[pulumi.Input[str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['DevicePostureRuleInputLocationArgs']]]] = None,
                 network_status: Optional[pulumi.Input[str]] = None,
                 operational_state: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 os: Optional[pulumi.Input[str]] = None,
                 os_distro_name: Optional[pulumi.Input[str]] = None,
                 os_distro_revision: Optional[pulumi.Input[str]] = None,
                 os_version_extra: Optional[pulumi.Input[str]] = None,
                 overall: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 require_all: Optional[pulumi.Input[bool]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None,
                 running: Optional[pulumi.Input[bool]] = None,
                 score: Optional[pulumi.Input[int]] = None,
                 sensor_config: Optional[pulumi.Input[str]] = None,
                 sha256: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 thumbprint: Optional[pulumi.Input[str]] = None,
                 total_score: Optional[pulumi.Input[int]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 version_operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] active_threats: The number of active threats from SentinelOne.
        :param pulumi.Input[str] certificate_id: The UUID of a Cloudflare managed certificate.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_disks: Specific volume(s) to check for encryption.
        :param pulumi.Input[bool] check_private_key: Confirm the certificate was not imported from another device.
        :param pulumi.Input[str] cn: The common name for a certificate.
        :param pulumi.Input[str] compliance_status: The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        :param pulumi.Input[str] connection_id: The workspace one or intune connection id.
        :param pulumi.Input[str] count_operator: The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param pulumi.Input[str] domain: The domain that the client must join.
        :param pulumi.Input[str] eid_last_seen: The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        :param pulumi.Input[bool] enabled: True if the firewall must be enabled.
        :param pulumi.Input[bool] exists: Checks if the file should exist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extended_key_usages: List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        :param pulumi.Input[str] id: The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        :param pulumi.Input[bool] infected: True if SentinelOne device is infected.
        :param pulumi.Input[bool] is_active: True if SentinelOne device is active.
        :param pulumi.Input[str] issue_count: The number of issues for kolide.
        :param pulumi.Input[str] last_seen: The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        :param pulumi.Input[Sequence[pulumi.Input['DevicePostureRuleInputLocationArgs']]] locations: List of operating system locations to check for a client certificate..
        :param pulumi.Input[str] network_status: The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        :param pulumi.Input[str] operational_state: The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        :param pulumi.Input[str] operator: The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param pulumi.Input[str] os: OS signal score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] os_distro_name: The operating system excluding version information.
        :param pulumi.Input[str] os_distro_revision: The operating system version excluding OS name information or release name.
        :param pulumi.Input[str] os_version_extra: Extra version value following the operating system semantic version.
        :param pulumi.Input[str] overall: Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] path: The path to the file.
        :param pulumi.Input[bool] require_all: True if all drives must be encrypted.
        :param pulumi.Input[str] risk_level: The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        :param pulumi.Input[bool] running: Checks if the application should be running.
        :param pulumi.Input[int] score: A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        :param pulumi.Input[str] sensor_config: Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] sha256: The sha256 hash of the file.
        :param pulumi.Input[str] state: The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        :param pulumi.Input[str] thumbprint: The thumbprint of the file certificate.
        :param pulumi.Input[int] total_score: The total score from Tanium.
        :param pulumi.Input[str] version: The operating system semantic version.
        :param pulumi.Input[str] version_operator: The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if check_private_key is not None:
            pulumi.set(__self__, "check_private_key", check_private_key)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if eid_last_seen is not None:
            pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)
        if running is not None:
            pulumi.set(__self__, "running", running)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if total_score is not None:
            pulumi.set(__self__, "total_score", total_score)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[pulumi.Input[int]]:
        """
        The number of active threats from SentinelOne.
        """
        return pulumi.get(self, "active_threats")

    @active_threats.setter
    def active_threats(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_threats", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of a Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific volume(s) to check for encryption.
        """
        return pulumi.get(self, "check_disks")

    @check_disks.setter
    def check_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_disks", value)

    @property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Confirm the certificate was not imported from another device.
        """
        return pulumi.get(self, "check_private_key")

    @check_private_key.setter
    def check_private_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_private_key", value)

    @property
    @pulumi.getter
    def cn(self) -> Optional[pulumi.Input[str]]:
        """
        The common name for a certificate.
        """
        return pulumi.get(self, "cn")

    @cn.setter
    def cn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cn", value)

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[pulumi.Input[str]]:
        """
        The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        """
        return pulumi.get(self, "compliance_status")

    @compliance_status.setter
    def compliance_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compliance_status", value)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The workspace one or intune connection id.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "count_operator")

    @count_operator.setter
    def count_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count_operator", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The domain that the client must join.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[pulumi.Input[str]]:
        """
        The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        return pulumi.get(self, "eid_last_seen")

    @eid_last_seen.setter
    def eid_last_seen(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eid_last_seen", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the firewall must be enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def exists(self) -> Optional[pulumi.Input[bool]]:
        """
        Checks if the file should exist.
        """
        return pulumi.get(self, "exists")

    @exists.setter
    def exists(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exists", value)

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        """
        return pulumi.get(self, "extended_key_usages")

    @extended_key_usages.setter
    def extended_key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extended_key_usages", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infected(self) -> Optional[pulumi.Input[bool]]:
        """
        True if SentinelOne device is infected.
        """
        return pulumi.get(self, "infected")

    @infected.setter
    def infected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infected", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        True if SentinelOne device is active.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[pulumi.Input[str]]:
        """
        The number of issues for kolide.
        """
        return pulumi.get(self, "issue_count")

    @issue_count.setter
    def issue_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issue_count", value)

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[pulumi.Input[str]]:
        """
        The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        return pulumi.get(self, "last_seen")

    @last_seen.setter
    def last_seen(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_seen", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevicePostureRuleInputLocationArgs']]]]:
        """
        List of operating system locations to check for a client certificate..
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevicePostureRuleInputLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[pulumi.Input[str]]:
        """
        The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        """
        return pulumi.get(self, "network_status")

    @network_status.setter
    def network_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_status", value)

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[pulumi.Input[str]]:
        """
        The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        """
        return pulumi.get(self, "operational_state")

    @operational_state.setter
    def operational_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operational_state", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[str]]:
        """
        OS signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system excluding version information.
        """
        return pulumi.get(self, "os_distro_name")

    @os_distro_name.setter
    def os_distro_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_distro_name", value)

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system version excluding OS name information or release name.
        """
        return pulumi.get(self, "os_distro_revision")

    @os_distro_revision.setter
    def os_distro_revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_distro_revision", value)

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[pulumi.Input[str]]:
        """
        Extra version value following the operating system semantic version.
        """
        return pulumi.get(self, "os_version_extra")

    @os_version_extra.setter
    def os_version_extra(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_version_extra", value)

    @property
    @pulumi.getter
    def overall(self) -> Optional[pulumi.Input[str]]:
        """
        Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "overall")

    @overall.setter
    def overall(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overall", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[pulumi.Input[bool]]:
        """
        True if all drives must be encrypted.
        """
        return pulumi.get(self, "require_all")

    @require_all.setter
    def require_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)

    @property
    @pulumi.getter
    def running(self) -> Optional[pulumi.Input[bool]]:
        """
        Checks if the application should be running.
        """
        return pulumi.get(self, "running")

    @running.setter
    def running(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "running", value)

    @property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[int]]:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "score", value)

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[pulumi.Input[str]]:
        """
        Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "sensor_config")

    @sensor_config.setter
    def sensor_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensor_config", value)

    @property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[str]]:
        """
        The sha256 hash of the file.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the file certificate.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[pulumi.Input[int]]:
        """
        The total score from Tanium.
        """
        return pulumi.get(self, "total_score")

    @total_score.setter
    def total_score(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system semantic version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "version_operator")

    @version_operator.setter
    def version_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_operator", value)


if not MYPY:
    class DevicePostureRuleInputLocationArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of paths to check for client certificate rule.
        """
        trust_stores: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
elif False:
    DevicePostureRuleInputLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePostureRuleInputLocationArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 trust_stores: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: List of paths to check for client certificate rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] trust_stores: List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if trust_stores is not None:
            pulumi.set(__self__, "trust_stores", trust_stores)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of paths to check for client certificate rule.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
        return pulumi.get(self, "trust_stores")

    @trust_stores.setter
    def trust_stores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "trust_stores", value)


if not MYPY:
    class DevicePostureRuleMatchArgsDict(TypedDict):
        platform: NotRequired[pulumi.Input[str]]
        """
        The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
elif False:
    DevicePostureRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePostureRuleMatchArgs:
    def __init__(__self__, *,
                 platform: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] platform: The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        """
        The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)


if not MYPY:
    class DlpProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['DlpProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    DlpProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 skip: pulumi.Input['DlpProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[bool] enabled: Scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['DlpProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def skip(self) -> pulumi.Input['DlpProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['DlpProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class DlpProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[bool]
        """
        Return all matches, regardless of context analysis result, if the data is a file.
        """
elif False:
    DlpProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] files: Return all matches, regardless of context analysis result, if the data is a file.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> pulumi.Input[bool]:
        """
        Return all matches, regardless of context analysis result, if the data is a file.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class DlpProfileEntryArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the entry to deploy.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the entry is active. Defaults to `false`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique entry identifier.
        """
        pattern: NotRequired[pulumi.Input['DlpProfileEntryPatternArgsDict']]
elif False:
    DlpProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpProfileEntryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 pattern: Optional[pulumi.Input['DlpProfileEntryPatternArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the entry to deploy.
        :param pulumi.Input[bool] enabled: Whether the entry is active. Defaults to `false`.
        :param pulumi.Input[str] id: Unique entry identifier.
        """
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the entry to deploy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the entry is active. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique entry identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input['DlpProfileEntryPatternArgs']]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input['DlpProfileEntryPatternArgs']]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class DlpProfileEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[str]
        """
        The regex that defines the pattern.
        """
        validation: NotRequired[pulumi.Input[str]]
        """
        The validation algorithm to apply with this pattern.
        """
elif False:
    DlpProfileEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpProfileEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[str],
                 validation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: The regex that defines the pattern.
        :param pulumi.Input[str] validation: The validation algorithm to apply with this pattern.
        """
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        """
        The regex that defines the pattern.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input[str]]:
        """
        The validation algorithm to apply with this pattern.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class EmailRoutingCatchAllActionArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of supported action. Available values: `drop`, `forward`, `worker`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list with items in the following form.
        """
elif False:
    EmailRoutingCatchAllActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingCatchAllActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] type: Type of supported action. Available values: `drop`, `forward`, `worker`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list with items in the following form.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of supported action. Available values: `drop`, `forward`, `worker`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list with items in the following form.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EmailRoutingCatchAllMatcherArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of matcher. Available values: `all`.
        """
elif False:
    EmailRoutingCatchAllMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingCatchAllMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Type of matcher. Available values: `all`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of matcher. Available values: `all`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingRuleActionArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of action. Available values: `forward`, `worker`, `drop`
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Value to match on. Required for `type` of `literal`.
        """
elif False:
    EmailRoutingRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingRuleActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: Type of action. Available values: `forward`, `worker`, `drop`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Value to match on. Required for `type` of `literal`.
        """
        pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of action. Available values: `forward`, `worker`, `drop`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Value to match on. Required for `type` of `literal`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EmailRoutingRuleMatcherArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of matcher. Available values: `literal`, `all`
        """
        field: NotRequired[pulumi.Input[str]]
        """
        Field to match on. Required for `type` of `literal`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value to match on. Required for `type` of `literal`.
        """
elif False:
    EmailRoutingRuleMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingRuleMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 field: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of matcher. Available values: `literal`, `all`
        :param pulumi.Input[str] field: Field to match on. Required for `type` of `literal`.
        :param pulumi.Input[str] value: Value to match on. Required for `type` of `literal`.
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of matcher. Available values: `literal`, `all`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        Field to match on. Required for `type` of `literal`.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value to match on. Required for `type` of `literal`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FallbackDomainDomainArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        The domain suffix to match when resolving locally.
        """
elif False:
    FallbackDomainDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FallbackDomainDomainArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP addresses to handle domain resolution.
        :param pulumi.Input[str] suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class HealthcheckHeaderArgsDict(TypedDict):
        header: pulumi.Input[str]
        """
        The header name.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of string values for the header.
        """
elif False:
    HealthcheckHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HealthcheckHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] header: The header name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of string values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of string values for the header.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class HyperdriveConfigCachingArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Disable caching for this Hyperdrive configuration.
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        Configure the `max_age` value of this Hyperdrive configuration.
        """
        stale_while_revalidate: NotRequired[pulumi.Input[int]]
        """
        Disable caching for this Hyperdrive configuration.
        """
elif False:
    HyperdriveConfigCachingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HyperdriveConfigCachingArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 stale_while_revalidate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disabled: Disable caching for this Hyperdrive configuration.
        :param pulumi.Input[int] max_age: Configure the `max_age` value of this Hyperdrive configuration.
        :param pulumi.Input[int] stale_while_revalidate: Disable caching for this Hyperdrive configuration.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if stale_while_revalidate is not None:
            pulumi.set(__self__, "stale_while_revalidate", stale_while_revalidate)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable caching for this Hyperdrive configuration.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        Configure the `max_age` value of this Hyperdrive configuration.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter(name="staleWhileRevalidate")
    def stale_while_revalidate(self) -> Optional[pulumi.Input[int]]:
        """
        Disable caching for this Hyperdrive configuration.
        """
        return pulumi.get(self, "stale_while_revalidate")

    @stale_while_revalidate.setter
    def stale_while_revalidate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stale_while_revalidate", value)


if not MYPY:
    class HyperdriveConfigOriginArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        The name of your origin database.
        """
        host: pulumi.Input[str]
        """
        The host (hostname or IP) of your origin database.
        """
        password: pulumi.Input[str]
        """
        The password of the Hyperdrive configuration.
        """
        scheme: pulumi.Input[str]
        """
        Specifies the URL scheme used to connect to your origin database.
        """
        user: pulumi.Input[str]
        """
        The user of your origin database.
        """
        access_client_id: NotRequired[pulumi.Input[str]]
        """
        Client ID associated with the Cloudflare Access Service Token used to connect via Access.
        """
        access_client_secret: NotRequired[pulumi.Input[str]]
        """
        Client Secret associated with the Cloudflare Access Service Token used to connect via Access.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port (default: 5432 for Postgres) of your origin database.
        """
elif False:
    HyperdriveConfigOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HyperdriveConfigOriginArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 password: pulumi.Input[str],
                 scheme: pulumi.Input[str],
                 user: pulumi.Input[str],
                 access_client_id: Optional[pulumi.Input[str]] = None,
                 access_client_secret: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] database: The name of your origin database.
        :param pulumi.Input[str] host: The host (hostname or IP) of your origin database.
        :param pulumi.Input[str] password: The password of the Hyperdrive configuration.
        :param pulumi.Input[str] scheme: Specifies the URL scheme used to connect to your origin database.
        :param pulumi.Input[str] user: The user of your origin database.
        :param pulumi.Input[str] access_client_id: Client ID associated with the Cloudflare Access Service Token used to connect via Access.
        :param pulumi.Input[str] access_client_secret: Client Secret associated with the Cloudflare Access Service Token used to connect via Access.
        :param pulumi.Input[int] port: The port (default: 5432 for Postgres) of your origin database.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "user", user)
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of your origin database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host (hostname or IP) of your origin database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the Hyperdrive configuration.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[str]:
        """
        Specifies the URL scheme used to connect to your origin database.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        """
        The user of your origin database.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID associated with the Cloudflare Access Service Token used to connect via Access.
        """
        return pulumi.get(self, "access_client_id")

    @access_client_id.setter
    def access_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_id", value)

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Client Secret associated with the Cloudflare Access Service Token used to connect via Access.
        """
        return pulumi.get(self, "access_client_secret")

    @access_client_secret.setter
    def access_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_secret", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port (default: 5432 for Postgres) of your origin database.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class InfrastructureAccessTargetIpArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['InfrastructureAccessTargetIpIpv4ArgsDict']]
        """
        The target's IPv4 address.
        """
        ipv6: NotRequired[pulumi.Input['InfrastructureAccessTargetIpIpv6ArgsDict']]
        """
        The target's IPv6 address.
        """
elif False:
    InfrastructureAccessTargetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureAccessTargetIpArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['InfrastructureAccessTargetIpIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['InfrastructureAccessTargetIpIpv6Args']] = None):
        """
        :param pulumi.Input['InfrastructureAccessTargetIpIpv4Args'] ipv4: The target's IPv4 address.
        :param pulumi.Input['InfrastructureAccessTargetIpIpv6Args'] ipv6: The target's IPv6 address.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['InfrastructureAccessTargetIpIpv4Args']]:
        """
        The target's IPv4 address.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['InfrastructureAccessTargetIpIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['InfrastructureAccessTargetIpIpv6Args']]:
        """
        The target's IPv6 address.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['InfrastructureAccessTargetIpIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class InfrastructureAccessTargetIpIpv4ArgsDict(TypedDict):
        ip_addr: pulumi.Input[str]
        """
        The IP address of the target.
        """
        virtual_network_id: pulumi.Input[str]
        """
        The private virtual network identifier for the target.
        """
elif False:
    InfrastructureAccessTargetIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureAccessTargetIpIpv4Args:
    def __init__(__self__, *,
                 ip_addr: pulumi.Input[str],
                 virtual_network_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip_addr: The IP address of the target.
        :param pulumi.Input[str] virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> pulumi.Input[str]:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @ip_addr.setter
    def ip_addr(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_addr", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> pulumi.Input[str]:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class InfrastructureAccessTargetIpIpv6ArgsDict(TypedDict):
        ip_addr: pulumi.Input[str]
        """
        The IP address of the target.
        """
        virtual_network_id: pulumi.Input[str]
        """
        The private virtual network identifier for the target.
        """
elif False:
    InfrastructureAccessTargetIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureAccessTargetIpIpv6Args:
    def __init__(__self__, *,
                 ip_addr: pulumi.Input[str],
                 virtual_network_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip_addr: The IP address of the target.
        :param pulumi.Input[str] virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> pulumi.Input[str]:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @ip_addr.setter
    def ip_addr(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_addr", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> pulumi.Input[str]:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class ListItemArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[str]]
        """
        An optional comment for the item.
        """
        value: NotRequired[pulumi.Input['ListItemValueArgsDict']]
elif False:
    ListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input['ListItemValueArgs']] = None):
        """
        :param pulumi.Input[str] comment: An optional comment for the item.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        An optional comment for the item.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['ListItemValueArgs']]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['ListItemValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ListItemHostnameArgsDict(TypedDict):
        url_hostname: pulumi.Input[str]
        """
        The FQDN to match on.
        """
elif False:
    ListItemHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemHostnameArgs:
    def __init__(__self__, *,
                 url_hostname: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url_hostname: The FQDN to match on.
        """
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> pulumi.Input[str]:
        """
        The FQDN to match on.
        """
        return pulumi.get(self, "url_hostname")

    @url_hostname.setter
    def url_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "url_hostname", value)


if not MYPY:
    class ListItemRedirectArgsDict(TypedDict):
        source_url: pulumi.Input[str]
        """
        The source url of the redirect.
        """
        target_url: pulumi.Input[str]
        """
        The target url of the redirect.
        """
        include_subdomains: NotRequired[pulumi.Input[bool]]
        """
        Whether the redirect also matches subdomains of the source url.
        """
        preserve_path_suffix: NotRequired[pulumi.Input[bool]]
        """
        Whether the redirect target url should keep the query string of the request's url.
        """
        preserve_query_string: NotRequired[pulumi.Input[bool]]
        """
        Whether the redirect target url should keep the query string of the request's url.
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        The status code to be used when redirecting a request.
        """
        subpath_matching: NotRequired[pulumi.Input[bool]]
        """
        Whether the redirect also matches subpaths of the source url.
        """
elif False:
    ListItemRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemRedirectArgs:
    def __init__(__self__, *,
                 source_url: pulumi.Input[str],
                 target_url: pulumi.Input[str],
                 include_subdomains: Optional[pulumi.Input[bool]] = None,
                 preserve_path_suffix: Optional[pulumi.Input[bool]] = None,
                 preserve_query_string: Optional[pulumi.Input[bool]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 subpath_matching: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] source_url: The source url of the redirect.
        :param pulumi.Input[str] target_url: The target url of the redirect.
        :param pulumi.Input[bool] include_subdomains: Whether the redirect also matches subdomains of the source url.
        :param pulumi.Input[bool] preserve_path_suffix: Whether the redirect target url should keep the query string of the request's url.
        :param pulumi.Input[bool] preserve_query_string: Whether the redirect target url should keep the query string of the request's url.
        :param pulumi.Input[int] status_code: The status code to be used when redirecting a request.
        :param pulumi.Input[bool] subpath_matching: Whether the redirect also matches subpaths of the source url.
        """
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        """
        The source url of the redirect.
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_url", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target url of the redirect.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the redirect also matches subdomains of the source url.
        """
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the redirect target url should keep the query string of the request's url.
        """
        return pulumi.get(self, "preserve_path_suffix")

    @preserve_path_suffix.setter
    def preserve_path_suffix(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_path_suffix", value)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the redirect target url should keep the query string of the request's url.
        """
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_query_string", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The status code to be used when redirecting a request.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the redirect also matches subpaths of the source url.
        """
        return pulumi.get(self, "subpath_matching")

    @subpath_matching.setter
    def subpath_matching(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "subpath_matching", value)


if not MYPY:
    class ListItemValueArgsDict(TypedDict):
        asn: NotRequired[pulumi.Input[int]]
        hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input['ListItemValueHostnameArgsDict']]]]
        ip: NotRequired[pulumi.Input[str]]
        redirects: NotRequired[pulumi.Input[Sequence[pulumi.Input['ListItemValueRedirectArgsDict']]]]
elif False:
    ListItemValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemValueArgs:
    def __init__(__self__, *,
                 asn: Optional[pulumi.Input[int]] = None,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueHostnameArgs']]]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 redirects: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueRedirectArgs']]]] = None):
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def asn(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "asn", value)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueHostnameArgs']]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueHostnameArgs']]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueRedirectArgs']]]]:
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueRedirectArgs']]]]):
        pulumi.set(self, "redirects", value)


if not MYPY:
    class ListItemValueHostnameArgsDict(TypedDict):
        url_hostname: pulumi.Input[str]
        """
        The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
        """
elif False:
    ListItemValueHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemValueHostnameArgs:
    def __init__(__self__, *,
                 url_hostname: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url_hostname: The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
        """
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> pulumi.Input[str]:
        """
        The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
        """
        return pulumi.get(self, "url_hostname")

    @url_hostname.setter
    def url_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "url_hostname", value)


if not MYPY:
    class ListItemValueRedirectArgsDict(TypedDict):
        source_url: pulumi.Input[str]
        """
        The source url of the redirect.
        """
        target_url: pulumi.Input[str]
        """
        The target url of the redirect.
        """
        include_subdomains: NotRequired[pulumi.Input[str]]
        """
        Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        """
        preserve_path_suffix: NotRequired[pulumi.Input[str]]
        """
        Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        """
        preserve_query_string: NotRequired[pulumi.Input[str]]
        """
        Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        The status code to be used when redirecting a request.
        """
        subpath_matching: NotRequired[pulumi.Input[str]]
        """
        Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
elif False:
    ListItemValueRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemValueRedirectArgs:
    def __init__(__self__, *,
                 source_url: pulumi.Input[str],
                 target_url: pulumi.Input[str],
                 include_subdomains: Optional[pulumi.Input[str]] = None,
                 preserve_path_suffix: Optional[pulumi.Input[str]] = None,
                 preserve_query_string: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 subpath_matching: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_url: The source url of the redirect.
        :param pulumi.Input[str] target_url: The target url of the redirect.
        :param pulumi.Input[str] include_subdomains: Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        :param pulumi.Input[str] preserve_path_suffix: Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        :param pulumi.Input[str] preserve_query_string: Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        :param pulumi.Input[int] status_code: The status code to be used when redirecting a request.
        :param pulumi.Input[str] subpath_matching: Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        """
        The source url of the redirect.
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_url", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target url of the redirect.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_path_suffix")

    @preserve_path_suffix.setter
    def preserve_path_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preserve_path_suffix", value)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preserve_query_string", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The status code to be used when redirecting a request.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "subpath_matching")

    @subpath_matching.setter
    def subpath_matching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subpath_matching", value)


if not MYPY:
    class LoadBalancerAdaptiveRoutingArgsDict(TypedDict):
        failover_across_pools: NotRequired[pulumi.Input[bool]]
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
elif False:
    LoadBalancerAdaptiveRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[bool]]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failover_across_pools", value)


if not MYPY:
    class LoadBalancerCountryPoolArgsDict(TypedDict):
        country: pulumi.Input[str]
        """
        A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        """
        pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of pool IDs in failover priority to use in the given country.
        """
elif False:
    LoadBalancerCountryPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerCountryPoolArgs:
    def __init__(__self__, *,
                 country: pulumi.Input[str],
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] country: A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use in the given country.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "pool_ids", pool_ids)

    @property
    @pulumi.getter
    def country(self) -> pulumi.Input[str]:
        """
        A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[str]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use in the given country.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)


if not MYPY:
    class LoadBalancerLocationStrategyArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        """
        prefer_ecs: NotRequired[pulumi.Input[str]]
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
elif False:
    LoadBalancerLocationStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerLocationStrategyArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 prefer_ecs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        :param pulumi.Input[str] prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
        return pulumi.get(self, "prefer_ecs")

    @prefer_ecs.setter
    def prefer_ecs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_ecs", value)


if not MYPY:
    class LoadBalancerMonitorHeaderArgsDict(TypedDict):
        header: pulumi.Input[str]
        """
        The header name.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values for the header.
        """
elif False:
    LoadBalancerMonitorHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerMonitorHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] header: The header name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values for the header.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class LoadBalancerPoolLoadSheddingArgsDict(TypedDict):
        default_percent: NotRequired[pulumi.Input[float]]
        """
        Percent of traffic to shed 0 - 100. Defaults to `0`.
        """
        default_policy: NotRequired[pulumi.Input[str]]
        """
        Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        """
        session_percent: NotRequired[pulumi.Input[float]]
        """
        Percent of session traffic to shed 0 - 100. Defaults to `0`.
        """
        session_policy: NotRequired[pulumi.Input[str]]
        """
        Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
elif False:
    LoadBalancerPoolLoadSheddingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolLoadSheddingArgs:
    def __init__(__self__, *,
                 default_percent: Optional[pulumi.Input[float]] = None,
                 default_policy: Optional[pulumi.Input[str]] = None,
                 session_percent: Optional[pulumi.Input[float]] = None,
                 session_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] default_percent: Percent of traffic to shed 0 - 100. Defaults to `0`.
        :param pulumi.Input[str] default_policy: Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        :param pulumi.Input[float] session_percent: Percent of session traffic to shed 0 - 100. Defaults to `0`.
        :param pulumi.Input[str] session_policy: Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[pulumi.Input[float]]:
        """
        Percent of traffic to shed 0 - 100. Defaults to `0`.
        """
        return pulumi.get(self, "default_percent")

    @default_percent.setter
    def default_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_percent", value)

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        """
        return pulumi.get(self, "default_policy")

    @default_policy.setter
    def default_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_policy", value)

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[pulumi.Input[float]]:
        """
        Percent of session traffic to shed 0 - 100. Defaults to `0`.
        """
        return pulumi.get(self, "session_percent")

    @session_percent.setter
    def session_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "session_percent", value)

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
        return pulumi.get(self, "session_policy")

    @session_policy.setter
    def session_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_policy", value)


if not MYPY:
    class LoadBalancerPoolOriginArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        """
        name: pulumi.Input[str]
        """
        A human-identifiable name for the origin.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgsDict']]]]
        """
        HTTP request headers.
        """
        virtual_network_id: NotRequired[pulumi.Input[str]]
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        weight: NotRequired[pulumi.Input[float]]
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections. Defaults to `1`.
        """
elif False:
    LoadBalancerPoolOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]]] = None,
                 virtual_network_id: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] address: The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        :param pulumi.Input[str] name: A human-identifiable name for the origin.
        :param pulumi.Input[bool] enabled: Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]] headers: HTTP request headers.
        :param pulumi.Input[str] virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param pulumi.Input[float] weight: The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections. Defaults to `1`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]]]:
        """
        HTTP request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[pulumi.Input[str]]:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_id", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[float]]:
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections. Defaults to `1`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class LoadBalancerPoolOriginHeaderArgsDict(TypedDict):
        header: pulumi.Input[str]
        """
        HTTP Header name.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values for the HTTP headers.
        """
elif False:
    LoadBalancerPoolOriginHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] header: HTTP Header name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Values for the HTTP headers.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        HTTP Header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values for the HTTP headers.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class LoadBalancerPoolOriginSteeringArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[str]]
        """
        Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `""`, `hash`, `random`, `least_outstanding_requests`, `least_connections`. Defaults to `random`.
        """
elif False:
    LoadBalancerPoolOriginSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginSteeringArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy: Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `""`, `hash`, `random`, `least_outstanding_requests`, `least_connections`. Defaults to `random`.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `""`, `hash`, `random`, `least_outstanding_requests`, `least_connections`. Defaults to `random`.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class LoadBalancerPopPoolArgsDict(TypedDict):
        pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        pop: pulumi.Input[str]
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
elif False:
    LoadBalancerPopPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPopPoolArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pop: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param pulumi.Input[str] pop: A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def pop(self) -> pulumi.Input[str]:
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        return pulumi.get(self, "pop")

    @pop.setter
    def pop(self, value: pulumi.Input[str]):
        pulumi.set(self, "pop", value)


if not MYPY:
    class LoadBalancerRandomSteeringArgsDict(TypedDict):
        default_weight: NotRequired[pulumi.Input[float]]
        """
        The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        """
        pool_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[float]]]]
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
elif False:
    LoadBalancerRandomSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[float]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[float] default_weight: The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[float]]:
        """
        The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_weight", value)

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "pool_weights", value)


if not MYPY:
    class LoadBalancerRegionPoolArgsDict(TypedDict):
        pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of pool IDs in failover priority to use in the given region.
        """
        region: pulumi.Input[str]
        """
        A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
elif False:
    LoadBalancerRegionPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRegionPoolArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use in the given region.
        :param pulumi.Input[str] region: A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use in the given region.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class LoadBalancerRuleArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Human readable name for this rule.
        """
        condition: NotRequired[pulumi.Input[str]]
        """
        The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        A disabled rule will not be executed.
        """
        fixed_response: NotRequired[pulumi.Input['LoadBalancerRuleFixedResponseArgsDict']]
        """
        Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.
        """
        overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgsDict']]]]
        """
        The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
        """
        terminates: NotRequired[pulumi.Input[bool]]
        """
        Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.
        """
elif False:
    LoadBalancerRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 fixed_response: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 terminates: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: Human readable name for this rule.
        :param pulumi.Input[str] condition: The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        :param pulumi.Input[bool] disabled: A disabled rule will not be executed.
        :param pulumi.Input['LoadBalancerRuleFixedResponseArgs'] fixed_response: Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]] overrides: The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.
        :param pulumi.Input[int] priority: Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
        :param pulumi.Input[bool] terminates: Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.
        """
        pulumi.set(__self__, "name", name)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if terminates is not None:
            pulumi.set(__self__, "terminates", terminates)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Human readable name for this rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A disabled rule will not be executed.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]:
        """
        Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.
        """
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]]]:
        """
        The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]]]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def terminates(self) -> Optional[pulumi.Input[bool]]:
        """
        Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.
        """
        return pulumi.get(self, "terminates")

    @terminates.setter
    def terminates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "terminates", value)


if not MYPY:
    class LoadBalancerRuleFixedResponseArgsDict(TypedDict):
        content_type: NotRequired[pulumi.Input[str]]
        """
        The value of the HTTP context-type header for this fixed response.
        """
        location: NotRequired[pulumi.Input[str]]
        """
        The value of the HTTP location header for this fixed response.
        """
        message_body: NotRequired[pulumi.Input[str]]
        """
        The text used as the html body for this fixed response.
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        The HTTP status code used for this fixed response.
        """
elif False:
    LoadBalancerRuleFixedResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleFixedResponseArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 message_body: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] content_type: The value of the HTTP context-type header for this fixed response.
        :param pulumi.Input[str] location: The value of the HTTP location header for this fixed response.
        :param pulumi.Input[str] message_body: The text used as the html body for this fixed response.
        :param pulumi.Input[int] status_code: The HTTP status code used for this fixed response.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the HTTP context-type header for this fixed response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the HTTP location header for this fixed response.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[pulumi.Input[str]]:
        """
        The text used as the html body for this fixed response.
        """
        return pulumi.get(self, "message_body")

    @message_body.setter
    def message_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_body", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTP status code used for this fixed response.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class LoadBalancerRuleOverrideArgsDict(TypedDict):
        adaptive_routings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgsDict']]]]
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        """
        country_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgsDict']]]]
        """
        A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        """
        default_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        """
        fallback_pool: NotRequired[pulumi.Input[str]]
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        location_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgsDict']]]]
        """
        Controls location-based steering for non-proxied requests.
        """
        pop_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgsDict']]]]
        """
        A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        """
        random_steerings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgsDict']]]]
        """
        Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        """
        region_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgsDict']]]]
        """
        A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        """
        session_affinity: NotRequired[pulumi.Input[str]]
        """
        Configure attributes for session affinity.
        """
        session_affinity_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgsDict']]]]
        """
        Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        """
        session_affinity_ttl: NotRequired[pulumi.Input[int]]
        """
        Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        """
        steering_policy: NotRequired[pulumi.Input[str]]
        """
        The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        """
elif False:
    LoadBalancerRuleOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverrideArgs:
    def __init__(__self__, *,
                 adaptive_routings: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]]] = None,
                 country_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]]] = None,
                 default_pools: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fallback_pool: Optional[pulumi.Input[str]] = None,
                 location_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]]] = None,
                 pop_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]]] = None,
                 random_steerings: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]]] = None,
                 region_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]]] = None,
                 session_affinity: Optional[pulumi.Input[str]] = None,
                 session_affinity_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]]] = None,
                 session_affinity_ttl: Optional[pulumi.Input[int]] = None,
                 steering_policy: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]] adaptive_routings: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]] country_pools: A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_pools: A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        :param pulumi.Input[str] fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]] location_strategies: Controls location-based steering for non-proxied requests.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]] pop_pools: A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]] random_steerings: Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]] region_pools: A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        :param pulumi.Input[str] session_affinity: Configure attributes for session affinity.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]] session_affinity_attributes: Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        :param pulumi.Input[int] session_affinity_ttl: Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        :param pulumi.Input[str] steering_policy: The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        :param pulumi.Input[int] ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        """
        if adaptive_routings is not None:
            pulumi.set(__self__, "adaptive_routings", adaptive_routings)
        if country_pools is not None:
            pulumi.set(__self__, "country_pools", country_pools)
        if default_pools is not None:
            pulumi.set(__self__, "default_pools", default_pools)
        if fallback_pool is not None:
            pulumi.set(__self__, "fallback_pool", fallback_pool)
        if location_strategies is not None:
            pulumi.set(__self__, "location_strategies", location_strategies)
        if pop_pools is not None:
            pulumi.set(__self__, "pop_pools", pop_pools)
        if random_steerings is not None:
            pulumi.set(__self__, "random_steerings", random_steerings)
        if region_pools is not None:
            pulumi.set(__self__, "region_pools", region_pools)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_affinity_attributes is not None:
            pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        if session_affinity_ttl is not None:
            pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        if steering_policy is not None:
            pulumi.set(__self__, "steering_policy", steering_policy)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRoutings")
    def adaptive_routings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]]]:
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        """
        return pulumi.get(self, "adaptive_routings")

    @adaptive_routings.setter
    def adaptive_routings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]]]):
        pulumi.set(self, "adaptive_routings", value)

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]]]:
        """
        A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        """
        return pulumi.get(self, "country_pools")

    @country_pools.setter
    def country_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]]]):
        pulumi.set(self, "country_pools", value)

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        """
        return pulumi.get(self, "default_pools")

    @default_pools.setter
    def default_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_pools", value)

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> Optional[pulumi.Input[str]]:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @fallback_pool.setter
    def fallback_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_pool", value)

    @property
    @pulumi.getter(name="locationStrategies")
    def location_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]]]:
        """
        Controls location-based steering for non-proxied requests.
        """
        return pulumi.get(self, "location_strategies")

    @location_strategies.setter
    def location_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]]]):
        pulumi.set(self, "location_strategies", value)

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]]]:
        """
        A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        """
        return pulumi.get(self, "pop_pools")

    @pop_pools.setter
    def pop_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]]]):
        pulumi.set(self, "pop_pools", value)

    @property
    @pulumi.getter(name="randomSteerings")
    def random_steerings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]]]:
        """
        Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        """
        return pulumi.get(self, "random_steerings")

    @random_steerings.setter
    def random_steerings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]]]):
        pulumi.set(self, "random_steerings", value)

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]]]:
        """
        A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        """
        return pulumi.get(self, "region_pools")

    @region_pools.setter
    def region_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]]]):
        pulumi.set(self, "region_pools", value)

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        Configure attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_affinity", value)

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]]]:
        """
        Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @session_affinity_attributes.setter
    def session_affinity_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]]]):
        pulumi.set(self, "session_affinity_attributes", value)

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        """
        return pulumi.get(self, "session_affinity_ttl")

    @session_affinity_ttl.setter
    def session_affinity_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_affinity_ttl", value)

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        """
        return pulumi.get(self, "steering_policy")

    @steering_policy.setter
    def steering_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "steering_policy", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class LoadBalancerRuleOverrideAdaptiveRoutingArgsDict(TypedDict):
        failover_across_pools: NotRequired[pulumi.Input[bool]]
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool.
        """
elif False:
    LoadBalancerRuleOverrideAdaptiveRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverrideAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[bool]]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failover_across_pools", value)


if not MYPY:
    class LoadBalancerRuleOverrideCountryPoolArgsDict(TypedDict):
        country: pulumi.Input[str]
        """
        A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        """
        pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of pool IDs in failover priority to use in the given country.
        """
elif False:
    LoadBalancerRuleOverrideCountryPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverrideCountryPoolArgs:
    def __init__(__self__, *,
                 country: pulumi.Input[str],
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] country: A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use in the given country.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "pool_ids", pool_ids)

    @property
    @pulumi.getter
    def country(self) -> pulumi.Input[str]:
        """
        A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[str]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use in the given country.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)


if not MYPY:
    class LoadBalancerRuleOverrideLocationStrategyArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`.
        """
        prefer_ecs: NotRequired[pulumi.Input[str]]
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`.
        """
elif False:
    LoadBalancerRuleOverrideLocationStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverrideLocationStrategyArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 prefer_ecs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`.
        :param pulumi.Input[str] prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`.
        """
        return pulumi.get(self, "prefer_ecs")

    @prefer_ecs.setter
    def prefer_ecs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_ecs", value)


if not MYPY:
    class LoadBalancerRuleOverridePopPoolArgsDict(TypedDict):
        pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        pop: pulumi.Input[str]
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
elif False:
    LoadBalancerRuleOverridePopPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridePopPoolArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pop: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param pulumi.Input[str] pop: A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def pop(self) -> pulumi.Input[str]:
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        return pulumi.get(self, "pop")

    @pop.setter
    def pop(self, value: pulumi.Input[str]):
        pulumi.set(self, "pop", value)


if not MYPY:
    class LoadBalancerRuleOverrideRandomSteeringArgsDict(TypedDict):
        default_weight: NotRequired[pulumi.Input[float]]
        """
        The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        """
        pool_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[float]]]]
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
elif False:
    LoadBalancerRuleOverrideRandomSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverrideRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[float]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[float] default_weight: The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[float]]:
        """
        The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_weight", value)

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "pool_weights", value)


if not MYPY:
    class LoadBalancerRuleOverrideRegionPoolArgsDict(TypedDict):
        pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of pool IDs in failover priority to use in the given region.
        """
        region: pulumi.Input[str]
        """
        A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
elif False:
    LoadBalancerRuleOverrideRegionPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverrideRegionPoolArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use in the given region.
        :param pulumi.Input[str] region: A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use in the given region.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class LoadBalancerRuleOverrideSessionAffinityAttributeArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Configures the HTTP header names to use when header session affinity is enabled.
        """
        require_all_headers: NotRequired[pulumi.Input[bool]]
        """
        Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        """
        samesite: NotRequired[pulumi.Input[str]]
        """
        Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`.
        """
        secure: NotRequired[pulumi.Input[str]]
        """
        Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`.
        """
        zero_downtime_failover: NotRequired[pulumi.Input[str]]
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`.
        """
elif False:
    LoadBalancerRuleOverrideSessionAffinityAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverrideSessionAffinityAttributeArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 require_all_headers: Optional[pulumi.Input[bool]] = None,
                 samesite: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[str]] = None,
                 zero_downtime_failover: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: Configures the HTTP header names to use when header session affinity is enabled.
        :param pulumi.Input[bool] require_all_headers: Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        :param pulumi.Input[str] samesite: Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`.
        :param pulumi.Input[str] secure: Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`.
        :param pulumi.Input[str] zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Configures the HTTP header names to use when header session affinity is enabled.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        """
        return pulumi.get(self, "require_all_headers")

    @require_all_headers.setter
    def require_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all_headers", value)

    @property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`.
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samesite", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`.
        """
        return pulumi.get(self, "zero_downtime_failover")

    @zero_downtime_failover.setter
    def zero_downtime_failover(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_downtime_failover", value)


if not MYPY:
    class LoadBalancerSessionAffinityAttributeArgsDict(TypedDict):
        drain_duration: NotRequired[pulumi.Input[int]]
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Configures the HTTP header names to use when header session affinity is enabled.
        """
        require_all_headers: NotRequired[pulumi.Input[bool]]
        """
        Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        """
        samesite: NotRequired[pulumi.Input[str]]
        """
        Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        """
        secure: NotRequired[pulumi.Input[str]]
        """
        Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        """
        zero_downtime_failover: NotRequired[pulumi.Input[str]]
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
elif False:
    LoadBalancerSessionAffinityAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerSessionAffinityAttributeArgs:
    def __init__(__self__, *,
                 drain_duration: Optional[pulumi.Input[int]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 require_all_headers: Optional[pulumi.Input[bool]] = None,
                 samesite: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[str]] = None,
                 zero_downtime_failover: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: Configures the HTTP header names to use when header session affinity is enabled.
        :param pulumi.Input[bool] require_all_headers: Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        :param pulumi.Input[str] samesite: Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        :param pulumi.Input[str] secure: Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        :param pulumi.Input[str] zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[pulumi.Input[int]]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
        """
        return pulumi.get(self, "drain_duration")

    @drain_duration.setter
    def drain_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "drain_duration", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Configures the HTTP header names to use when header session affinity is enabled.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        """
        return pulumi.get(self, "require_all_headers")

    @require_all_headers.setter
    def require_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all_headers", value)

    @property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samesite", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
        return pulumi.get(self, "zero_downtime_failover")

    @zero_downtime_failover.setter
    def zero_downtime_failover(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_downtime_failover", value)


if not MYPY:
    class LogpushJobOutputOptionsArgsDict(TypedDict):
        batch_prefix: NotRequired[pulumi.Input[str]]
        """
        String to be prepended before each batch.
        """
        batch_suffix: NotRequired[pulumi.Input[str]]
        """
        String to be appended after each batch.
        """
        cve20214428: NotRequired[pulumi.Input[bool]]
        """
        Mitigation for CVE-2021-44228. If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{. Defaults to `false`.
        """
        field_delimiter: NotRequired[pulumi.Input[str]]
        """
        String to join fields. This field be ignored when record_template is set. Defaults to `,`.
        """
        field_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of field names to be included in the Logpush output.
        """
        output_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the output type. Available values: `ndjson`, `csv`. Defaults to `ndjson`.
        """
        record_delimiter: NotRequired[pulumi.Input[str]]
        """
        String to be inserted in-between the records as separator.
        """
        record_prefix: NotRequired[pulumi.Input[str]]
        """
        String to be prepended before each record. Defaults to `{`.
        """
        record_suffix: NotRequired[pulumi.Input[str]]
        """
        String to be appended after each record. Defaults to `}
        `.
        """
        record_template: NotRequired[pulumi.Input[str]]
        """
        String to use as template for each record instead of the default comma-separated list.
        """
        sample_rate: NotRequired[pulumi.Input[float]]
        """
        Specifies the sampling rate. Defaults to `1`.
        """
        timestamp_format: NotRequired[pulumi.Input[str]]
        """
        Specifies the format for timestamps. Available values: `unixnano`, `unix`, `rfc3339`. Defaults to `unixnano`.
        """
elif False:
    LogpushJobOutputOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogpushJobOutputOptionsArgs:
    def __init__(__self__, *,
                 batch_prefix: Optional[pulumi.Input[str]] = None,
                 batch_suffix: Optional[pulumi.Input[str]] = None,
                 cve20214428: Optional[pulumi.Input[bool]] = None,
                 field_delimiter: Optional[pulumi.Input[str]] = None,
                 field_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 output_type: Optional[pulumi.Input[str]] = None,
                 record_delimiter: Optional[pulumi.Input[str]] = None,
                 record_prefix: Optional[pulumi.Input[str]] = None,
                 record_suffix: Optional[pulumi.Input[str]] = None,
                 record_template: Optional[pulumi.Input[str]] = None,
                 sample_rate: Optional[pulumi.Input[float]] = None,
                 timestamp_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] batch_prefix: String to be prepended before each batch.
        :param pulumi.Input[str] batch_suffix: String to be appended after each batch.
        :param pulumi.Input[bool] cve20214428: Mitigation for CVE-2021-44228. If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{. Defaults to `false`.
        :param pulumi.Input[str] field_delimiter: String to join fields. This field be ignored when record_template is set. Defaults to `,`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] field_names: List of field names to be included in the Logpush output.
        :param pulumi.Input[str] output_type: Specifies the output type. Available values: `ndjson`, `csv`. Defaults to `ndjson`.
        :param pulumi.Input[str] record_delimiter: String to be inserted in-between the records as separator.
        :param pulumi.Input[str] record_prefix: String to be prepended before each record. Defaults to `{`.
        :param pulumi.Input[str] record_suffix: String to be appended after each record. Defaults to `}
               `.
        :param pulumi.Input[str] record_template: String to use as template for each record instead of the default comma-separated list.
        :param pulumi.Input[float] sample_rate: Specifies the sampling rate. Defaults to `1`.
        :param pulumi.Input[str] timestamp_format: Specifies the format for timestamps. Available values: `unixnano`, `unix`, `rfc3339`. Defaults to `unixnano`.
        """
        if batch_prefix is not None:
            pulumi.set(__self__, "batch_prefix", batch_prefix)
        if batch_suffix is not None:
            pulumi.set(__self__, "batch_suffix", batch_suffix)
        if cve20214428 is not None:
            pulumi.set(__self__, "cve20214428", cve20214428)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)
        if output_type is not None:
            pulumi.set(__self__, "output_type", output_type)
        if record_delimiter is not None:
            pulumi.set(__self__, "record_delimiter", record_delimiter)
        if record_prefix is not None:
            pulumi.set(__self__, "record_prefix", record_prefix)
        if record_suffix is not None:
            pulumi.set(__self__, "record_suffix", record_suffix)
        if record_template is not None:
            pulumi.set(__self__, "record_template", record_template)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter(name="batchPrefix")
    def batch_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        String to be prepended before each batch.
        """
        return pulumi.get(self, "batch_prefix")

    @batch_prefix.setter
    def batch_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_prefix", value)

    @property
    @pulumi.getter(name="batchSuffix")
    def batch_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        String to be appended after each batch.
        """
        return pulumi.get(self, "batch_suffix")

    @batch_suffix.setter
    def batch_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_suffix", value)

    @property
    @pulumi.getter
    def cve20214428(self) -> Optional[pulumi.Input[bool]]:
        """
        Mitigation for CVE-2021-44228. If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{. Defaults to `false`.
        """
        return pulumi.get(self, "cve20214428")

    @cve20214428.setter
    def cve20214428(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cve20214428", value)

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        String to join fields. This field be ignored when record_template is set. Defaults to `,`.
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_delimiter", value)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of field names to be included in the Logpush output.
        """
        return pulumi.get(self, "field_names")

    @field_names.setter
    def field_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "field_names", value)

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the output type. Available values: `ndjson`, `csv`. Defaults to `ndjson`.
        """
        return pulumi.get(self, "output_type")

    @output_type.setter
    def output_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_type", value)

    @property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        String to be inserted in-between the records as separator.
        """
        return pulumi.get(self, "record_delimiter")

    @record_delimiter.setter
    def record_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_delimiter", value)

    @property
    @pulumi.getter(name="recordPrefix")
    def record_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        String to be prepended before each record. Defaults to `{`.
        """
        return pulumi.get(self, "record_prefix")

    @record_prefix.setter
    def record_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_prefix", value)

    @property
    @pulumi.getter(name="recordSuffix")
    def record_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        String to be appended after each record. Defaults to `}
        `.
        """
        return pulumi.get(self, "record_suffix")

    @record_suffix.setter
    def record_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_suffix", value)

    @property
    @pulumi.getter(name="recordTemplate")
    def record_template(self) -> Optional[pulumi.Input[str]]:
        """
        String to use as template for each record instead of the default comma-separated list.
        """
        return pulumi.get(self, "record_template")

    @record_template.setter
    def record_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_template", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the sampling rate. Defaults to `1`.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the format for timestamps. Available values: `unixnano`, `unix`, `rfc3339`. Defaults to `unixnano`.
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ManagedHeadersManagedRequestHeaderArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether the headers rule is active.
        """
        id: pulumi.Input[str]
        """
        Unique headers rule identifier.
        """
elif False:
    ManagedHeadersManagedRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedHeadersManagedRequestHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Whether the headers rule is active.
        :param pulumi.Input[str] id: Unique headers rule identifier.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique headers rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ManagedHeadersManagedResponseHeaderArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether the headers rule is active.
        """
        id: pulumi.Input[str]
        """
        Unique headers rule identifier.
        """
elif False:
    ManagedHeadersManagedResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedHeadersManagedResponseHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Whether the headers rule is active.
        :param pulumi.Input[str] id: Unique headers rule identifier.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique headers rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NotificationPolicyEmailIntegrationArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of this resource.
        """
        name: NotRequired[pulumi.Input[str]]
elif False:
    NotificationPolicyEmailIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyEmailIntegrationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NotificationPolicyFiltersArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Targeted actions for alert.
        """
        affected_components: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `D1`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.
        """
        airport_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Filter on Points of Presence.
        """
        alert_trigger_preferences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Alert trigger preferences. Example: `slo`.
        """
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        State of the pool to alert on.
        """
        environments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
        """
        event_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Source configuration to alert on for pool or origin.
        """
        event_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Stream event type to alert on.
        """
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Alert grouping.
        """
        health_check_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Identifier health check. Required when using `filters.0.status`.
        """
        incident_impacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.
        """
        input_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Stream input id to alert on.
        """
        limits: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A numerical limit. Example: `100`.
        """
        megabits_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Megabits per second threshold for dos alert.
        """
        new_healths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Health status to alert on for pool or origin.
        """
        new_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Tunnel health status to alert on.
        """
        packets_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Packets per second threshold for dos alert.
        """
        pool_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Load balancer pool identifier.
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        """
        project_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Identifier of pages project.
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Protocol to alert on for dos.
        """
        requests_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Requests per second threshold for dos alert.
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Selectors for alert. Valid options depend on the alert type.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        slos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A numerical limit. Example: `99.9`.
        """
        statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Status to alert on.
        """
        target_hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Target host to alert on for dos.
        """
        target_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Target ip to alert on for dos in CIDR notation.
        """
        target_zone_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Target domain to alert on.
        """
        tunnel_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Tunnel IDs to alert on.
        """
        tunnel_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Tunnel Names to alert on.
        """
        wheres: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Filter for alert.
        """
        zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of zone identifiers.
        """
elif False:
    NotificationPolicyFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyFiltersArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 affected_components: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 airport_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 alert_trigger_preferences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 event_sources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 event_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 health_check_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 incident_impacts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limits: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 megabits_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_healths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 packets_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 requests_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 slos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_zone_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wheres: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Targeted actions for alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] affected_components: Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `D1`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] airport_codes: Filter on Points of Presence.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alert_trigger_preferences: Alert trigger preferences. Example: `slo`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] enableds: State of the pool to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] environments: Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] event_sources: Source configuration to alert on for pool or origin.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] event_types: Stream event type to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Alert grouping.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] health_check_ids: Identifier health check. Required when using `filters.0.status`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] incident_impacts: The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_ids: Stream input id to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limits: A numerical limit. Example: `100`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] megabits_per_seconds: Megabits per second threshold for dos alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_healths: Health status to alert on for pool or origin.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_statuses: Tunnel health status to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] packets_per_seconds: Packets per second threshold for dos alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: Load balancer pool identifier.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] products: Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] project_ids: Identifier of pages project.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: Protocol to alert on for dos.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] requests_per_seconds: Requests per second threshold for dos alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selectors: Selectors for alert. Valid options depend on the alert type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] slos: A numerical limit. Example: `99.9`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] statuses: Status to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_hostnames: Target host to alert on for dos.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_ips: Target ip to alert on for dos in CIDR notation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_zone_names: Target domain to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tunnel_ids: Tunnel IDs to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tunnel_names: Tunnel Names to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wheres: Filter for alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: A list of zone identifiers.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if affected_components is not None:
            pulumi.set(__self__, "affected_components", affected_components)
        if airport_codes is not None:
            pulumi.set(__self__, "airport_codes", airport_codes)
        if alert_trigger_preferences is not None:
            pulumi.set(__self__, "alert_trigger_preferences", alert_trigger_preferences)
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if event_sources is not None:
            pulumi.set(__self__, "event_sources", event_sources)
        if event_types is not None:
            pulumi.set(__self__, "event_types", event_types)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if health_check_ids is not None:
            pulumi.set(__self__, "health_check_ids", health_check_ids)
        if incident_impacts is not None:
            pulumi.set(__self__, "incident_impacts", incident_impacts)
        if input_ids is not None:
            pulumi.set(__self__, "input_ids", input_ids)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if megabits_per_seconds is not None:
            pulumi.set(__self__, "megabits_per_seconds", megabits_per_seconds)
        if new_healths is not None:
            pulumi.set(__self__, "new_healths", new_healths)
        if new_statuses is not None:
            pulumi.set(__self__, "new_statuses", new_statuses)
        if packets_per_seconds is not None:
            pulumi.set(__self__, "packets_per_seconds", packets_per_seconds)
        if pool_ids is not None:
            pulumi.set(__self__, "pool_ids", pool_ids)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if requests_per_seconds is not None:
            pulumi.set(__self__, "requests_per_seconds", requests_per_seconds)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if slos is not None:
            pulumi.set(__self__, "slos", slos)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if target_hostnames is not None:
            pulumi.set(__self__, "target_hostnames", target_hostnames)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if target_zone_names is not None:
            pulumi.set(__self__, "target_zone_names", target_zone_names)
        if tunnel_ids is not None:
            pulumi.set(__self__, "tunnel_ids", tunnel_ids)
        if tunnel_names is not None:
            pulumi.set(__self__, "tunnel_names", tunnel_names)
        if wheres is not None:
            pulumi.set(__self__, "wheres", wheres)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Targeted actions for alert.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="affectedComponents")
    def affected_components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `D1`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.
        """
        return pulumi.get(self, "affected_components")

    @affected_components.setter
    def affected_components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "affected_components", value)

    @property
    @pulumi.getter(name="airportCodes")
    def airport_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Filter on Points of Presence.
        """
        return pulumi.get(self, "airport_codes")

    @airport_codes.setter
    def airport_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "airport_codes", value)

    @property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Alert trigger preferences. Example: `slo`.
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @alert_trigger_preferences.setter
    def alert_trigger_preferences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alert_trigger_preferences", value)

    @property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        State of the pool to alert on.
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "enableds", value)

    @property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Source configuration to alert on for pool or origin.
        """
        return pulumi.get(self, "event_sources")

    @event_sources.setter
    def event_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "event_sources", value)

    @property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Stream event type to alert on.
        """
        return pulumi.get(self, "event_types")

    @event_types.setter
    def event_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "event_types", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Alert grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Identifier health check. Required when using `filters.0.status`.
        """
        return pulumi.get(self, "health_check_ids")

    @health_check_ids.setter
    def health_check_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "health_check_ids", value)

    @property
    @pulumi.getter(name="incidentImpacts")
    def incident_impacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.
        """
        return pulumi.get(self, "incident_impacts")

    @incident_impacts.setter
    def incident_impacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "incident_impacts", value)

    @property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Stream input id to alert on.
        """
        return pulumi.get(self, "input_ids")

    @input_ids.setter
    def input_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_ids", value)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A numerical limit. Example: `100`.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Megabits per second threshold for dos alert.
        """
        return pulumi.get(self, "megabits_per_seconds")

    @megabits_per_seconds.setter
    def megabits_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "megabits_per_seconds", value)

    @property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Health status to alert on for pool or origin.
        """
        return pulumi.get(self, "new_healths")

    @new_healths.setter
    def new_healths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_healths", value)

    @property
    @pulumi.getter(name="newStatuses")
    def new_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Tunnel health status to alert on.
        """
        return pulumi.get(self, "new_statuses")

    @new_statuses.setter
    def new_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_statuses", value)

    @property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Packets per second threshold for dos alert.
        """
        return pulumi.get(self, "packets_per_seconds")

    @packets_per_seconds.setter
    def packets_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "packets_per_seconds", value)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Load balancer pool identifier.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Identifier of pages project.
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "project_ids", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Protocol to alert on for dos.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Requests per second threshold for dos alert.
        """
        return pulumi.get(self, "requests_per_seconds")

    @requests_per_seconds.setter
    def requests_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "requests_per_seconds", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Selectors for alert. Valid options depend on the alert type.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "selectors", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def slos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A numerical limit. Example: `99.9`.
        """
        return pulumi.get(self, "slos")

    @slos.setter
    def slos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "slos", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Status to alert on.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statuses", value)

    @property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Target host to alert on for dos.
        """
        return pulumi.get(self, "target_hostnames")

    @target_hostnames.setter
    def target_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_hostnames", value)

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Target ip to alert on for dos in CIDR notation.
        """
        return pulumi.get(self, "target_ips")

    @target_ips.setter
    def target_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_ips", value)

    @property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Target domain to alert on.
        """
        return pulumi.get(self, "target_zone_names")

    @target_zone_names.setter
    def target_zone_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_zone_names", value)

    @property
    @pulumi.getter(name="tunnelIds")
    def tunnel_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Tunnel IDs to alert on.
        """
        return pulumi.get(self, "tunnel_ids")

    @tunnel_ids.setter
    def tunnel_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tunnel_ids", value)

    @property
    @pulumi.getter(name="tunnelNames")
    def tunnel_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Tunnel Names to alert on.
        """
        return pulumi.get(self, "tunnel_names")

    @tunnel_names.setter
    def tunnel_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tunnel_names", value)

    @property
    @pulumi.getter
    def wheres(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Filter for alert.
        """
        return pulumi.get(self, "wheres")

    @wheres.setter
    def wheres(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wheres", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of zone identifiers.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


if not MYPY:
    class NotificationPolicyPagerdutyIntegrationArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of this resource.
        """
        name: NotRequired[pulumi.Input[str]]
elif False:
    NotificationPolicyPagerdutyIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyPagerdutyIntegrationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NotificationPolicyWebhooksIntegrationArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of this resource.
        """
        name: NotRequired[pulumi.Input[str]]
elif False:
    NotificationPolicyWebhooksIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyWebhooksIntegrationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PageRuleActionsArgsDict(TypedDict):
        always_use_https: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        automatic_https_rewrites: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        browser_cache_ttl: NotRequired[pulumi.Input[str]]
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        browser_check: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        bypass_cache_on_cookie: NotRequired[pulumi.Input[str]]
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        cache_by_device_type: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        cache_deception_armor: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        cache_key_fields: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsArgsDict']]
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        cache_level: NotRequired[pulumi.Input[str]]
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        cache_on_cookie: NotRequired[pulumi.Input[str]]
        """
        String value of cookie name to conditionally cache the page.
        """
        cache_ttl_by_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgsDict']]]]
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        disable_apps: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        disable_performance: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        disable_railgun: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        disable_security: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        disable_zaraz: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        edge_cache_ttl: NotRequired[pulumi.Input[int]]
        """
        The Time To Live for the edge cache.
        """
        email_obfuscation: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        explicit_cache_control: NotRequired[pulumi.Input[str]]
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        forwarding_url: NotRequired[pulumi.Input['PageRuleActionsForwardingUrlArgsDict']]
        """
        The URL to forward to, and with what status. See below.
        """
        host_header_override: NotRequired[pulumi.Input[str]]
        """
        Value of the Host header to send.
        """
        ip_geolocation: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        minifies: NotRequired[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgsDict']]]]
        """
        The configuration for HTML, CSS and JS minification. See below for full list of options.
        """
        mirage: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        opportunistic_encryption: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        origin_error_page_pass_thru: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        polish: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        resolve_override: NotRequired[pulumi.Input[str]]
        """
        Overridden origin server name.
        """
        respect_strong_etag: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        response_buffering: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        rocket_loader: NotRequired[pulumi.Input[str]]
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        security_level: NotRequired[pulumi.Input[str]]
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        server_side_exclude: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        sort_query_string_for_cache: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        ssl: NotRequired[pulumi.Input[str]]
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        true_client_ip_header: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        waf: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
elif False:
    PageRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsArgs:
    def __init__(__self__, *,
                 always_use_https: Optional[pulumi.Input[bool]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
                 browser_cache_ttl: Optional[pulumi.Input[str]] = None,
                 browser_check: Optional[pulumi.Input[str]] = None,
                 bypass_cache_on_cookie: Optional[pulumi.Input[str]] = None,
                 cache_by_device_type: Optional[pulumi.Input[str]] = None,
                 cache_deception_armor: Optional[pulumi.Input[str]] = None,
                 cache_key_fields: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']] = None,
                 cache_level: Optional[pulumi.Input[str]] = None,
                 cache_on_cookie: Optional[pulumi.Input[str]] = None,
                 cache_ttl_by_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]]] = None,
                 disable_apps: Optional[pulumi.Input[bool]] = None,
                 disable_performance: Optional[pulumi.Input[bool]] = None,
                 disable_railgun: Optional[pulumi.Input[bool]] = None,
                 disable_security: Optional[pulumi.Input[bool]] = None,
                 disable_zaraz: Optional[pulumi.Input[bool]] = None,
                 edge_cache_ttl: Optional[pulumi.Input[int]] = None,
                 email_obfuscation: Optional[pulumi.Input[str]] = None,
                 explicit_cache_control: Optional[pulumi.Input[str]] = None,
                 forwarding_url: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']] = None,
                 host_header_override: Optional[pulumi.Input[str]] = None,
                 ip_geolocation: Optional[pulumi.Input[str]] = None,
                 minifies: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]]] = None,
                 mirage: Optional[pulumi.Input[str]] = None,
                 opportunistic_encryption: Optional[pulumi.Input[str]] = None,
                 origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 resolve_override: Optional[pulumi.Input[str]] = None,
                 respect_strong_etag: Optional[pulumi.Input[str]] = None,
                 response_buffering: Optional[pulumi.Input[str]] = None,
                 rocket_loader: Optional[pulumi.Input[str]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 server_side_exclude: Optional[pulumi.Input[str]] = None,
                 sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 true_client_ip_header: Optional[pulumi.Input[str]] = None,
                 waf: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] always_use_https: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[str] automatic_https_rewrites: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] browser_cache_ttl: The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        :param pulumi.Input[str] browser_check: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] bypass_cache_on_cookie: String value of cookie name to conditionally bypass cache the page.
        :param pulumi.Input[str] cache_by_device_type: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] cache_deception_armor: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsArgs'] cache_key_fields: Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        :param pulumi.Input[str] cache_level: Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        :param pulumi.Input[str] cache_on_cookie: String value of cookie name to conditionally cache the page.
        :param pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]] cache_ttl_by_statuses: Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        :param pulumi.Input[bool] disable_apps: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_performance: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_railgun: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_security: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_zaraz: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[int] edge_cache_ttl: The Time To Live for the edge cache.
        :param pulumi.Input[str] email_obfuscation: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] explicit_cache_control: Whether origin Cache-Control action is `"on"` or `"off"`.
        :param pulumi.Input['PageRuleActionsForwardingUrlArgs'] forwarding_url: The URL to forward to, and with what status. See below.
        :param pulumi.Input[str] host_header_override: Value of the Host header to send.
        :param pulumi.Input[str] ip_geolocation: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]] minifies: The configuration for HTML, CSS and JS minification. See below for full list of options.
        :param pulumi.Input[str] mirage: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] opportunistic_encryption: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] origin_error_page_pass_thru: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] polish: Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        :param pulumi.Input[str] resolve_override: Overridden origin server name.
        :param pulumi.Input[str] respect_strong_etag: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] response_buffering: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] rocket_loader: Whether to set the rocket loader to `"on"`, `"off"`.
        :param pulumi.Input[str] security_level: Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        :param pulumi.Input[str] server_side_exclude: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] sort_query_string_for_cache: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] ssl: Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        :param pulumi.Input[str] true_client_ip_header: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] waf: Whether this action is `"on"` or `"off"`.
        """
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if bypass_cache_on_cookie is not None:
            pulumi.set(__self__, "bypass_cache_on_cookie", bypass_cache_on_cookie)
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if cache_key_fields is not None:
            pulumi.set(__self__, "cache_key_fields", cache_key_fields)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if cache_on_cookie is not None:
            pulumi.set(__self__, "cache_on_cookie", cache_on_cookie)
        if cache_ttl_by_statuses is not None:
            pulumi.set(__self__, "cache_ttl_by_statuses", cache_ttl_by_statuses)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_performance is not None:
            pulumi.set(__self__, "disable_performance", disable_performance)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_security is not None:
            pulumi.set(__self__, "disable_security", disable_security)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_cache_ttl is not None:
            pulumi.set(__self__, "edge_cache_ttl", edge_cache_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if explicit_cache_control is not None:
            pulumi.set(__self__, "explicit_cache_control", explicit_cache_control)
        if forwarding_url is not None:
            pulumi.set(__self__, "forwarding_url", forwarding_url)
        if host_header_override is not None:
            pulumi.set(__self__, "host_header_override", host_header_override)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if minifies is not None:
            pulumi.set(__self__, "minifies", minifies)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if resolve_override is not None:
            pulumi.set(__self__, "resolve_override", resolve_override)
        if respect_strong_etag is not None:
            pulumi.set(__self__, "respect_strong_etag", respect_strong_etag)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "always_use_https")

    @always_use_https.setter
    def always_use_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_use_https", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[pulumi.Input[str]]:
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        return pulumi.get(self, "browser_cache_ttl")

    @browser_cache_ttl.setter
    def browser_cache_ttl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_cache_ttl", value)

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "browser_check")

    @browser_check.setter
    def browser_check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_check", value)

    @property
    @pulumi.getter(name="bypassCacheOnCookie")
    def bypass_cache_on_cookie(self) -> Optional[pulumi.Input[str]]:
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        return pulumi.get(self, "bypass_cache_on_cookie")

    @bypass_cache_on_cookie.setter
    def bypass_cache_on_cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bypass_cache_on_cookie", value)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_by_device_type")

    @cache_by_device_type.setter
    def cache_by_device_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_by_device_type", value)

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_deception_armor")

    @cache_deception_armor.setter
    def cache_deception_armor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_deception_armor", value)

    @property
    @pulumi.getter(name="cacheKeyFields")
    def cache_key_fields(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']]:
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        return pulumi.get(self, "cache_key_fields")

    @cache_key_fields.setter
    def cache_key_fields(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']]):
        pulumi.set(self, "cache_key_fields", value)

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        return pulumi.get(self, "cache_level")

    @cache_level.setter
    def cache_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_level", value)

    @property
    @pulumi.getter(name="cacheOnCookie")
    def cache_on_cookie(self) -> Optional[pulumi.Input[str]]:
        """
        String value of cookie name to conditionally cache the page.
        """
        return pulumi.get(self, "cache_on_cookie")

    @cache_on_cookie.setter
    def cache_on_cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_on_cookie", value)

    @property
    @pulumi.getter(name="cacheTtlByStatuses")
    def cache_ttl_by_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]]]:
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        return pulumi.get(self, "cache_ttl_by_statuses")

    @cache_ttl_by_statuses.setter
    def cache_ttl_by_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]]]):
        pulumi.set(self, "cache_ttl_by_statuses", value)

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_apps")

    @disable_apps.setter
    def disable_apps(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_apps", value)

    @property
    @pulumi.getter(name="disablePerformance")
    def disable_performance(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_performance")

    @disable_performance.setter
    def disable_performance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_performance", value)

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_railgun")

    @disable_railgun.setter
    def disable_railgun(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_railgun", value)

    @property
    @pulumi.getter(name="disableSecurity")
    def disable_security(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_security")

    @disable_security.setter
    def disable_security(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_security", value)

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_zaraz")

    @disable_zaraz.setter
    def disable_zaraz(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_zaraz", value)

    @property
    @pulumi.getter(name="edgeCacheTtl")
    def edge_cache_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The Time To Live for the edge cache.
        """
        return pulumi.get(self, "edge_cache_ttl")

    @edge_cache_ttl.setter
    def edge_cache_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "edge_cache_ttl", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter(name="explicitCacheControl")
    def explicit_cache_control(self) -> Optional[pulumi.Input[str]]:
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "explicit_cache_control")

    @explicit_cache_control.setter
    def explicit_cache_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "explicit_cache_control", value)

    @property
    @pulumi.getter(name="forwardingUrl")
    def forwarding_url(self) -> Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']]:
        """
        The URL to forward to, and with what status. See below.
        """
        return pulumi.get(self, "forwarding_url")

    @forwarding_url.setter
    def forwarding_url(self, value: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']]):
        pulumi.set(self, "forwarding_url", value)

    @property
    @pulumi.getter(name="hostHeaderOverride")
    def host_header_override(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the Host header to send.
        """
        return pulumi.get(self, "host_header_override")

    @host_header_override.setter
    def host_header_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header_override", value)

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "ip_geolocation")

    @ip_geolocation.setter
    def ip_geolocation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_geolocation", value)

    @property
    @pulumi.getter
    def minifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]]]:
        """
        The configuration for HTML, CSS and JS minification. See below for full list of options.
        """
        return pulumi.get(self, "minifies")

    @minifies.setter
    def minifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]]]):
        pulumi.set(self, "minifies", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "origin_error_page_pass_thru")

    @origin_error_page_pass_thru.setter
    def origin_error_page_pass_thru(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_error_page_pass_thru", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter(name="resolveOverride")
    def resolve_override(self) -> Optional[pulumi.Input[str]]:
        """
        Overridden origin server name.
        """
        return pulumi.get(self, "resolve_override")

    @resolve_override.setter
    def resolve_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolve_override", value)

    @property
    @pulumi.getter(name="respectStrongEtag")
    def respect_strong_etag(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "respect_strong_etag")

    @respect_strong_etag.setter
    def respect_strong_etag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "respect_strong_etag", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "server_side_exclude")

    @server_side_exclude.setter
    def server_side_exclude(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_side_exclude", value)

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "sort_query_string_for_cache")

    @sort_query_string_for_cache.setter
    def sort_query_string_for_cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_query_string_for_cache", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "true_client_ip_header")

    @true_client_ip_header.setter
    def true_client_ip_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "true_client_ip_header", value)

    @property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsArgsDict(TypedDict):
        host: pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgsDict']
        """
        Controls which Host header goes into Cache Key:
        """
        query_string: pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgsDict']
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        user: pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgsDict']
        """
        Controls which end user-related features go into the Cache Key.
        """
        cookie: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgsDict']]
        """
        Controls what cookies go into Cache Key:
        """
        header: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgsDict']]
        """
        Controls what HTTP headers go into Cache Key:
        """
elif False:
    PageRuleActionsCacheKeyFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsArgs:
    def __init__(__self__, *,
                 host: pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs'],
                 query_string: pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs'],
                 user: pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs'],
                 cookie: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']] = None,
                 header: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']] = None):
        """
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs'] host: Controls which Host header goes into Cache Key:
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs'] query_string: Controls which URL query string parameters go into the Cache Key.
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs'] user: Controls which end user-related features go into the Cache Key.
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs'] cookie: Controls what cookies go into Cache Key:
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs'] header: Controls what HTTP headers go into Cache Key:
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "user", user)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']:
        """
        Controls which Host header goes into Cache Key:
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']:
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']:
        """
        Controls which end user-related features go into the Cache Key.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']]:
        """
        Controls what cookies go into Cache Key:
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']]:
        """
        Controls what HTTP headers go into Cache Key:
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']]):
        pulumi.set(self, "header", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsCookieArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Check for presence of specified cookies, without including their actual values.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Use values of specified cookies in Cache Key.
        """
elif False:
    PageRuleActionsCacheKeyFieldsCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsCookieArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: Check for presence of specified cookies, without including their actual values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Use values of specified cookies in Cache Key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Check for presence of specified cookies, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Use values of specified cookies in Cache Key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsHeaderArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
elif False:
    PageRuleActionsCacheKeyFieldsHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsHeaderArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: Check for presence of specified HTTP headers, without including their actual values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsHostArgsDict(TypedDict):
        resolved: NotRequired[pulumi.Input[bool]]
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
elif False:
    PageRuleActionsCacheKeyFieldsHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsHostArgs:
    def __init__(__self__, *,
                 resolved: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] resolved: `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input[bool]]:
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolved", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsQueryStringArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Exclude these query string parameters from Cache Key.
        """
        ignore: NotRequired[pulumi.Input[bool]]
        """
        `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only use values of specified query string parameters in Cache Key.
        """
elif False:
    PageRuleActionsCacheKeyFieldsQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsQueryStringArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ignore: Optional[pulumi.Input[bool]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Exclude these query string parameters from Cache Key.
        :param pulumi.Input[bool] ignore: `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Only use values of specified query string parameters in Cache Key.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if ignore is not None:
            pulumi.set(__self__, "ignore", ignore)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Exclude these query string parameters from Cache Key.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def ignore(self) -> Optional[pulumi.Input[bool]]:
        """
        `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        """
        return pulumi.get(self, "ignore")

    @ignore.setter
    def ignore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsUserArgsDict(TypedDict):
        device_type: NotRequired[pulumi.Input[bool]]
        """
        `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
        """
        geo: NotRequired[pulumi.Input[bool]]
        """
        `true` - includes the clients country, derived from the IP address; defaults to `false`.
        """
        lang: NotRequired[pulumi.Input[bool]]
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.

        Example:

        ```python
        import pulumi
        import pulumi_cloudflare as cloudflare

        # Unrealistic example with all features used
        foobar = cloudflare.PageRule("foobar",
            zone_id=cloudflare_zone_id,
            target=f"{cloudflare_zone}/app/*",
            priority=1,
            actions={
                "cache_key_fields": {
                    "cookie": {
                        "check_presences": ["wordpress_test_cookie"],
                    },
                    "header": {
                        "check_presences": ["header_present"],
                        "excludes": ["origin"],
                        "includes": [
                            "api-key",
                            "dnt",
                        ],
                    },
                    "host": {
                        "resolved": True,
                    },
                    "query_string": {
                        "ignore": True,
                    },
                    "user": {
                        "device_type": False,
                        "geo": True,
                        "lang": True,
                    },
                },
            })
        ```
        """
elif False:
    PageRuleActionsCacheKeyFieldsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsUserArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[bool]] = None,
                 geo: Optional[pulumi.Input[bool]] = None,
                 lang: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] device_type: `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
        :param pulumi.Input[bool] geo: `true` - includes the clients country, derived from the IP address; defaults to `false`.
        :param pulumi.Input[bool] lang: `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
               
               Example:
               
               ```python
               import pulumi
               import pulumi_cloudflare as cloudflare
               
               # Unrealistic example with all features used
               foobar = cloudflare.PageRule("foobar",
                   zone_id=cloudflare_zone_id,
                   target=f"{cloudflare_zone}/app/*",
                   priority=1,
                   actions={
                       "cache_key_fields": {
                           "cookie": {
                               "check_presences": ["wordpress_test_cookie"],
                           },
                           "header": {
                               "check_presences": ["header_present"],
                               "excludes": ["origin"],
                               "includes": [
                                   "api-key",
                                   "dnt",
                               ],
                           },
                           "host": {
                               "resolved": True,
                           },
                           "query_string": {
                               "ignore": True,
                           },
                           "user": {
                               "device_type": False,
                               "geo": True,
                               "lang": True,
                           },
                       },
                   })
               ```
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - includes the clients country, derived from the IP address; defaults to `false`.
        """
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.

        Example:

        ```python
        import pulumi
        import pulumi_cloudflare as cloudflare

        # Unrealistic example with all features used
        foobar = cloudflare.PageRule("foobar",
            zone_id=cloudflare_zone_id,
            target=f"{cloudflare_zone}/app/*",
            priority=1,
            actions={
                "cache_key_fields": {
                    "cookie": {
                        "check_presences": ["wordpress_test_cookie"],
                    },
                    "header": {
                        "check_presences": ["header_present"],
                        "excludes": ["origin"],
                        "includes": [
                            "api-key",
                            "dnt",
                        ],
                    },
                    "host": {
                        "resolved": True,
                    },
                    "query_string": {
                        "ignore": True,
                    },
                    "user": {
                        "device_type": False,
                        "geo": True,
                        "lang": True,
                    },
                },
            })
        ```
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lang", value)


if not MYPY:
    class PageRuleActionsCacheTtlByStatusArgsDict(TypedDict):
        codes: pulumi.Input[str]
        """
        A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        """
        ttl: pulumi.Input[int]
        """
        Duration a resource lives in the Cloudflare cache.
        - positive number - cache for specified duration in seconds
        """
elif False:
    PageRuleActionsCacheTtlByStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheTtlByStatusArgs:
    def __init__(__self__, *,
                 codes: pulumi.Input[str],
                 ttl: pulumi.Input[int]):
        """
        :param pulumi.Input[str] codes: A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        :param pulumi.Input[int] ttl: Duration a resource lives in the Cloudflare cache.
               - positive number - cache for specified duration in seconds
        """
        pulumi.set(__self__, "codes", codes)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def codes(self) -> pulumi.Input[str]:
        """
        A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        """
        return pulumi.get(self, "codes")

    @codes.setter
    def codes(self, value: pulumi.Input[str]):
        pulumi.set(self, "codes", value)

    @property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[int]:
        """
        Duration a resource lives in the Cloudflare cache.
        - positive number - cache for specified duration in seconds
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[int]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class PageRuleActionsForwardingUrlArgsDict(TypedDict):
        status_code: pulumi.Input[int]
        """
        The status code to use for the redirection.
        """
        url: pulumi.Input[str]
        """
        The URL to which the page rule should forward.
        """
elif False:
    PageRuleActionsForwardingUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsForwardingUrlArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[int],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[int] status_code: The status code to use for the redirection.
        :param pulumi.Input[str] url: The URL to which the page rule should forward.
        """
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[int]:
        """
        The status code to use for the redirection.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to which the page rule should forward.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PageRuleActionsMinifyArgsDict(TypedDict):
        css: pulumi.Input[str]
        """
        Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        """
        html: pulumi.Input[str]
        """
        Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        """
        js: pulumi.Input[str]
        """
        Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
elif False:
    PageRuleActionsMinifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsMinifyArgs:
    def __init__(__self__, *,
                 css: pulumi.Input[str],
                 html: pulumi.Input[str],
                 js: pulumi.Input[str]):
        """
        :param pulumi.Input[str] css: Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        :param pulumi.Input[str] html: Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        :param pulumi.Input[str] js: Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> pulumi.Input[str]:
        """
        Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: pulumi.Input[str]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        """
        Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> pulumi.Input[str]:
        """
        Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: pulumi.Input[str]):
        pulumi.set(self, "js", value)


if not MYPY:
    class PagesProjectBuildConfigArgsDict(TypedDict):
        build_caching: NotRequired[pulumi.Input[bool]]
        """
        Enable build caching for the project.
        """
        build_command: NotRequired[pulumi.Input[str]]
        """
        Command used to build project.
        """
        destination_dir: NotRequired[pulumi.Input[str]]
        """
        Output directory of the build.
        """
        root_dir: NotRequired[pulumi.Input[str]]
        """
        Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        """
        web_analytics_tag: NotRequired[pulumi.Input[str]]
        """
        The classifying tag for analytics.
        """
        web_analytics_token: NotRequired[pulumi.Input[str]]
        """
        The auth token for analytics.
        """
elif False:
    PagesProjectBuildConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectBuildConfigArgs:
    def __init__(__self__, *,
                 build_caching: Optional[pulumi.Input[bool]] = None,
                 build_command: Optional[pulumi.Input[str]] = None,
                 destination_dir: Optional[pulumi.Input[str]] = None,
                 root_dir: Optional[pulumi.Input[str]] = None,
                 web_analytics_tag: Optional[pulumi.Input[str]] = None,
                 web_analytics_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] build_caching: Enable build caching for the project.
        :param pulumi.Input[str] build_command: Command used to build project.
        :param pulumi.Input[str] destination_dir: Output directory of the build.
        :param pulumi.Input[str] root_dir: Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        :param pulumi.Input[str] web_analytics_tag: The classifying tag for analytics.
        :param pulumi.Input[str] web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @build_caching.setter
    def build_caching(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "build_caching", value)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @destination_dir.setter
    def destination_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_dir", value)

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        """
        return pulumi.get(self, "root_dir")

    @root_dir.setter
    def root_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_dir", value)

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @web_analytics_tag.setter
    def web_analytics_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_tag", value)

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[pulumi.Input[str]]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")

    @web_analytics_token.setter
    def web_analytics_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_token", value)


if not MYPY:
    class PagesProjectDeploymentConfigsArgsDict(TypedDict):
        preview: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgsDict']]
        """
        Configuration for preview deploys.
        """
        production: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsProductionArgsDict']]
        """
        Configuration for production deploys.
        """
elif False:
    PagesProjectDeploymentConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsArgs:
    def __init__(__self__, *,
                 preview: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']] = None,
                 production: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']] = None):
        """
        :param pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs'] preview: Configuration for preview deploys.
        :param pulumi.Input['PagesProjectDeploymentConfigsProductionArgs'] production: Configuration for production deploys.
        """
        if preview is not None:
            pulumi.set(__self__, "preview", preview)
        if production is not None:
            pulumi.set(__self__, "production", production)

    @property
    @pulumi.getter
    def preview(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']]:
        """
        Configuration for preview deploys.
        """
        return pulumi.get(self, "preview")

    @preview.setter
    def preview(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']]):
        pulumi.set(self, "preview", value)

    @property
    @pulumi.getter
    def production(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']]:
        """
        Configuration for production deploys.
        """
        return pulumi.get(self, "production")

    @production.setter
    def production(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']]):
        pulumi.set(self, "production", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewArgsDict(TypedDict):
        always_use_latest_compatibility_date: NotRequired[pulumi.Input[bool]]
        """
        Use latest compatibility date for Pages Functions. Defaults to `false`.
        """
        compatibility_date: NotRequired[pulumi.Input[str]]
        """
        Compatibility date used for Pages Functions.
        """
        compatibility_flags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Compatibility flags used for Pages Functions.
        """
        d1_databases: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        D1 Databases used for Pages Functions. Defaults to `map[]`.
        """
        durable_object_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Environment variables for Pages Functions. Defaults to `map[]`.
        """
        fail_open: NotRequired[pulumi.Input[bool]]
        """
        Fail open used for Pages Functions. Defaults to `false`.
        """
        kv_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        KV namespaces used for Pages Functions. Defaults to `map[]`.
        """
        placement: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgsDict']]
        """
        Configuration for placement in the Cloudflare Pages project.
        """
        r2_buckets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        R2 Buckets used for Pages Functions. Defaults to `map[]`.
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        """
        service_bindings: NotRequired[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgsDict']]]]
        """
        Services used for Pages Functions.
        """
        usage_model: NotRequired[pulumi.Input[str]]
        """
        Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewArgs:
    def __init__(__self__, *,
                 always_use_latest_compatibility_date: Optional[pulumi.Input[bool]] = None,
                 compatibility_date: Optional[pulumi.Input[str]] = None,
                 compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 d1_databases: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 durable_object_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 fail_open: Optional[pulumi.Input[bool]] = None,
                 kv_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']] = None,
                 r2_buckets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 service_bindings: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]]] = None,
                 usage_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] always_use_latest_compatibility_date: Use latest compatibility date for Pages Functions. Defaults to `false`.
        :param pulumi.Input[str] compatibility_date: Compatibility date used for Pages Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compatibility_flags: Compatibility flags used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] d1_databases: D1 Databases used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] durable_object_namespaces: Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment_variables: Environment variables for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[bool] fail_open: Fail open used for Pages Functions. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] kv_namespaces: KV namespaces used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs'] placement: Configuration for placement in the Cloudflare Pages project.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] r2_buckets: R2 Buckets used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]] service_bindings: Services used for Pages Functions.
        :param pulumi.Input[str] usage_model: Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
        if always_use_latest_compatibility_date is not None:
            pulumi.set(__self__, "always_use_latest_compatibility_date", always_use_latest_compatibility_date)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_bindings is not None:
            pulumi.set(__self__, "service_bindings", service_bindings)
        if usage_model is not None:
            pulumi.set(__self__, "usage_model", usage_model)

    @property
    @pulumi.getter(name="alwaysUseLatestCompatibilityDate")
    def always_use_latest_compatibility_date(self) -> Optional[pulumi.Input[bool]]:
        """
        Use latest compatibility date for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "always_use_latest_compatibility_date")

    @always_use_latest_compatibility_date.setter
    def always_use_latest_compatibility_date(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_use_latest_compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[pulumi.Input[str]]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @compatibility_date.setter
    def compatibility_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @compatibility_flags.setter
    def compatibility_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compatibility_flags", value)

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        D1 Databases used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "d1_databases")

    @d1_databases.setter
    def d1_databases(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "d1_databases", value)

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @durable_object_namespaces.setter
    def durable_object_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "durable_object_namespaces", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[bool]]:
        """
        Fail open used for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_open", value)

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        KV namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "kv_namespaces")

    @kv_namespaces.setter
    def kv_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "kv_namespaces", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']]:
        """
        Configuration for placement in the Cloudflare Pages project.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        R2 Buckets used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "r2_buckets")

    @r2_buckets.setter
    def r2_buckets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "r2_buckets", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="serviceBindings")
    def service_bindings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]]]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "service_bindings")

    @service_bindings.setter
    def service_bindings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]]]):
        pulumi.set(self, "service_bindings", value)

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[pulumi.Input[str]]:
        """
        Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
        return pulumi.get(self, "usage_model")

    @usage_model.setter
    def usage_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage_model", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewPlacementArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Placement Mode for the Pages Function.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Placement Mode for the Pages Function.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Placement Mode for the Pages Function.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewServiceBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        service: pulumi.Input[str]
        """
        The name of the Worker to bind to.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        The name of the Worker environment to bind to.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewServiceBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewServiceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] service: The name of the Worker to bind to.
        :param pulumi.Input[str] environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionArgsDict(TypedDict):
        always_use_latest_compatibility_date: NotRequired[pulumi.Input[bool]]
        """
        Use latest compatibility date for Pages Functions. Defaults to `false`.
        """
        compatibility_date: NotRequired[pulumi.Input[str]]
        """
        Compatibility date used for Pages Functions.
        """
        compatibility_flags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Compatibility flags used for Pages Functions.
        """
        d1_databases: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        D1 Databases used for Pages Functions. Defaults to `map[]`.
        """
        durable_object_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Environment variables for Pages Functions. Defaults to `map[]`.
        """
        fail_open: NotRequired[pulumi.Input[bool]]
        """
        Fail open used for Pages Functions. Defaults to `false`.
        """
        kv_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        KV namespaces used for Pages Functions. Defaults to `map[]`.
        """
        placement: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgsDict']]
        """
        Configuration for placement in the Cloudflare Pages project.
        """
        r2_buckets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        R2 Buckets used for Pages Functions. Defaults to `map[]`.
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        """
        service_bindings: NotRequired[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgsDict']]]]
        """
        Services used for Pages Functions.
        """
        usage_model: NotRequired[pulumi.Input[str]]
        """
        Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
elif False:
    PagesProjectDeploymentConfigsProductionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionArgs:
    def __init__(__self__, *,
                 always_use_latest_compatibility_date: Optional[pulumi.Input[bool]] = None,
                 compatibility_date: Optional[pulumi.Input[str]] = None,
                 compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 d1_databases: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 durable_object_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 fail_open: Optional[pulumi.Input[bool]] = None,
                 kv_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']] = None,
                 r2_buckets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 service_bindings: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]]] = None,
                 usage_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] always_use_latest_compatibility_date: Use latest compatibility date for Pages Functions. Defaults to `false`.
        :param pulumi.Input[str] compatibility_date: Compatibility date used for Pages Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compatibility_flags: Compatibility flags used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] d1_databases: D1 Databases used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] durable_object_namespaces: Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment_variables: Environment variables for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[bool] fail_open: Fail open used for Pages Functions. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] kv_namespaces: KV namespaces used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs'] placement: Configuration for placement in the Cloudflare Pages project.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] r2_buckets: R2 Buckets used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]] service_bindings: Services used for Pages Functions.
        :param pulumi.Input[str] usage_model: Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
        if always_use_latest_compatibility_date is not None:
            pulumi.set(__self__, "always_use_latest_compatibility_date", always_use_latest_compatibility_date)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_bindings is not None:
            pulumi.set(__self__, "service_bindings", service_bindings)
        if usage_model is not None:
            pulumi.set(__self__, "usage_model", usage_model)

    @property
    @pulumi.getter(name="alwaysUseLatestCompatibilityDate")
    def always_use_latest_compatibility_date(self) -> Optional[pulumi.Input[bool]]:
        """
        Use latest compatibility date for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "always_use_latest_compatibility_date")

    @always_use_latest_compatibility_date.setter
    def always_use_latest_compatibility_date(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_use_latest_compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[pulumi.Input[str]]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @compatibility_date.setter
    def compatibility_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @compatibility_flags.setter
    def compatibility_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compatibility_flags", value)

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        D1 Databases used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "d1_databases")

    @d1_databases.setter
    def d1_databases(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "d1_databases", value)

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @durable_object_namespaces.setter
    def durable_object_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "durable_object_namespaces", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[bool]]:
        """
        Fail open used for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_open", value)

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        KV namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "kv_namespaces")

    @kv_namespaces.setter
    def kv_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "kv_namespaces", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']]:
        """
        Configuration for placement in the Cloudflare Pages project.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        R2 Buckets used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "r2_buckets")

    @r2_buckets.setter
    def r2_buckets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "r2_buckets", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="serviceBindings")
    def service_bindings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]]]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "service_bindings")

    @service_bindings.setter
    def service_bindings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]]]):
        pulumi.set(self, "service_bindings", value)

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[pulumi.Input[str]]:
        """
        Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
        return pulumi.get(self, "usage_model")

    @usage_model.setter
    def usage_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage_model", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionPlacementArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Placement Mode for the Pages Function.
        """
elif False:
    PagesProjectDeploymentConfigsProductionPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Placement Mode for the Pages Function.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Placement Mode for the Pages Function.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionServiceBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        service: pulumi.Input[str]
        """
        The name of the Worker to bind to.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        The name of the Worker environment to bind to.
        """
elif False:
    PagesProjectDeploymentConfigsProductionServiceBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionServiceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] service: The name of the Worker to bind to.
        :param pulumi.Input[str] environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)


if not MYPY:
    class PagesProjectSourceArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['PagesProjectSourceConfigArgsDict']]
        """
        Configuration for the source of the Cloudflare Pages project.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Project host type.
        """
elif False:
    PagesProjectSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectSourceArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['PagesProjectSourceConfigArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PagesProjectSourceConfigArgs'] config: Configuration for the source of the Cloudflare Pages project.
        :param pulumi.Input[str] type: Project host type.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['PagesProjectSourceConfigArgs']]:
        """
        Configuration for the source of the Cloudflare Pages project.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['PagesProjectSourceConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Project host type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectSourceConfigArgsDict(TypedDict):
        production_branch: pulumi.Input[str]
        """
        Project production branch name.
        """
        deployments_enabled: NotRequired[pulumi.Input[bool]]
        """
        Toggle deployments on this repo. Defaults to `true`.
        """
        owner: NotRequired[pulumi.Input[str]]
        """
        Project owner username. **Modifying this attribute will force creation of a new resource.**
        """
        pr_comments_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable Pages to comment on Pull Requests. Defaults to `true`.
        """
        preview_branch_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Branches will be excluded from automatic deployment.
        """
        preview_branch_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Branches will be included for automatic deployment.
        """
        preview_deployment_setting: NotRequired[pulumi.Input[str]]
        """
        Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.
        """
        production_deployment_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable production deployments. Defaults to `true`.
        """
        repo_name: NotRequired[pulumi.Input[str]]
        """
        Project repository name. **Modifying this attribute will force creation of a new resource.**
        """
elif False:
    PagesProjectSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectSourceConfigArgs:
    def __init__(__self__, *,
                 production_branch: pulumi.Input[str],
                 deployments_enabled: Optional[pulumi.Input[bool]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 pr_comments_enabled: Optional[pulumi.Input[bool]] = None,
                 preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_deployment_setting: Optional[pulumi.Input[str]] = None,
                 production_deployment_enabled: Optional[pulumi.Input[bool]] = None,
                 repo_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] production_branch: Project production branch name.
        :param pulumi.Input[bool] deployments_enabled: Toggle deployments on this repo. Defaults to `true`.
        :param pulumi.Input[str] owner: Project owner username. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[bool] pr_comments_enabled: Enable Pages to comment on Pull Requests. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] preview_branch_excludes: Branches will be excluded from automatic deployment.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] preview_branch_includes: Branches will be included for automatic deployment.
        :param pulumi.Input[str] preview_deployment_setting: Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.
        :param pulumi.Input[bool] production_deployment_enabled: Enable production deployments. Defaults to `true`.
        :param pulumi.Input[str] repo_name: Project repository name. **Modifying this attribute will force creation of a new resource.**
        """
        pulumi.set(__self__, "production_branch", production_branch)
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_deployment_enabled is not None:
            pulumi.set(__self__, "production_deployment_enabled", production_deployment_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> pulumi.Input[str]:
        """
        Project production branch name.
        """
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: pulumi.Input[str]):
        pulumi.set(self, "production_branch", value)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Toggle deployments on this repo. Defaults to `true`.
        """
        return pulumi.get(self, "deployments_enabled")

    @deployments_enabled.setter
    def deployments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deployments_enabled", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Project owner username. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Pages to comment on Pull Requests. Defaults to `true`.
        """
        return pulumi.get(self, "pr_comments_enabled")

    @pr_comments_enabled.setter
    def pr_comments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pr_comments_enabled", value)

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Branches will be excluded from automatic deployment.
        """
        return pulumi.get(self, "preview_branch_excludes")

    @preview_branch_excludes.setter
    def preview_branch_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_excludes", value)

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Branches will be included for automatic deployment.
        """
        return pulumi.get(self, "preview_branch_includes")

    @preview_branch_includes.setter
    def preview_branch_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_includes", value)

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[pulumi.Input[str]]:
        """
        Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.
        """
        return pulumi.get(self, "preview_deployment_setting")

    @preview_deployment_setting.setter
    def preview_deployment_setting(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preview_deployment_setting", value)

    @property
    @pulumi.getter(name="productionDeploymentEnabled")
    def production_deployment_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable production deployments. Defaults to `true`.
        """
        return pulumi.get(self, "production_deployment_enabled")

    @production_deployment_enabled.setter
    def production_deployment_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "production_deployment_enabled", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[str]]:
        """
        Project repository name. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class RateLimitActionArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        """
        response: NotRequired[pulumi.Input['RateLimitActionResponseArgsDict']]
        """
        Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
elif False:
    RateLimitActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitActionArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 response: Optional[pulumi.Input['RateLimitActionResponseArgs']] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        :param pulumi.Input['RateLimitActionResponseArgs'] response: Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        :param pulumi.Input[int] timeout: The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
        pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RateLimitActionResponseArgs']]:
        """
        Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RateLimitActionResponseArgs']]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RateLimitActionResponseArgsDict(TypedDict):
        body: pulumi.Input[str]
        """
        The body to return, the content here should conform to the `content_type`.
        """
        content_type: pulumi.Input[str]
        """
        The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
        """
elif False:
    RateLimitActionResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitActionResponseArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[str],
                 content_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] body: The body to return, the content here should conform to the `content_type`.
        :param pulumi.Input[str] content_type: The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> pulumi.Input[str]:
        """
        The body to return, the content here should conform to the `content_type`.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[str]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class RateLimitCorrelateArgsDict(TypedDict):
        by: NotRequired[pulumi.Input[str]]
        """
        If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
elif False:
    RateLimitCorrelateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitCorrelateArgs:
    def __init__(__self__, *,
                 by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] by: If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
        if by is not None:
            pulumi.set(__self__, "by", by)

    @property
    @pulumi.getter
    def by(self) -> Optional[pulumi.Input[str]]:
        """
        If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
        return pulumi.get(self, "by")

    @by.setter
    def by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "by", value)


if not MYPY:
    class RateLimitMatchArgsDict(TypedDict):
        request: NotRequired[pulumi.Input['RateLimitMatchRequestArgsDict']]
        """
        Matches HTTP requests (from the client to Cloudflare).
        """
        response: NotRequired[pulumi.Input['RateLimitMatchResponseArgsDict']]
        """
        Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
elif False:
    RateLimitMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchArgs:
    def __init__(__self__, *,
                 request: Optional[pulumi.Input['RateLimitMatchRequestArgs']] = None,
                 response: Optional[pulumi.Input['RateLimitMatchResponseArgs']] = None):
        """
        :param pulumi.Input['RateLimitMatchRequestArgs'] request: Matches HTTP requests (from the client to Cloudflare).
        :param pulumi.Input['RateLimitMatchResponseArgs'] response: Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['RateLimitMatchRequestArgs']]:
        """
        Matches HTTP requests (from the client to Cloudflare).
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['RateLimitMatchRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RateLimitMatchResponseArgs']]:
        """
        Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RateLimitMatchResponseArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class RateLimitMatchRequestArgsDict(TypedDict):
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
        """
        schemes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
        """
        url_pattern: NotRequired[pulumi.Input[str]]
        """
        The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
        """
elif False:
    RateLimitMatchRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchRequestArgs:
    def __init__(__self__, *,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 schemes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 url_pattern: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schemes: HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
        :param pulumi.Input[str] url_pattern: The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
        """
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if schemes is not None:
            pulumi.set(__self__, "schemes", schemes)
        if url_pattern is not None:
            pulumi.set(__self__, "url_pattern", url_pattern)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def schemes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
        """
        return pulumi.get(self, "schemes")

    @schemes.setter
    def schemes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schemes", value)

    @property
    @pulumi.getter(name="urlPattern")
    def url_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
        """
        return pulumi.get(self, "url_pattern")

    @url_pattern.setter
    def url_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_pattern", value)


if not MYPY:
    class RateLimitMatchResponseArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]
        """
        List of HTTP headers maps to match the origin response on.
        """
        origin_traffic: NotRequired[pulumi.Input[bool]]
        """
        Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
        """
        statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        HTTP Status codes, can be one, many or indicate all by not providing this value.
        """
elif False:
    RateLimitMatchResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchResponseArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]] = None,
                 origin_traffic: Optional[pulumi.Input[bool]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]] headers: List of HTTP headers maps to match the origin response on.
        :param pulumi.Input[bool] origin_traffic: Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] statuses: HTTP Status codes, can be one, many or indicate all by not providing this value.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if origin_traffic is not None:
            pulumi.set(__self__, "origin_traffic", origin_traffic)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]:
        """
        List of HTTP headers maps to match the origin response on.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> Optional[pulumi.Input[bool]]:
        """
        Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
        """
        return pulumi.get(self, "origin_traffic")

    @origin_traffic.setter
    def origin_traffic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_traffic", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        HTTP Status codes, can be one, many or indicate all by not providing this value.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "statuses", value)


if not MYPY:
    class RecordDataArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[int]]
        altitude: NotRequired[pulumi.Input[float]]
        certificate: NotRequired[pulumi.Input[str]]
        content: NotRequired[pulumi.Input[str]]
        digest: NotRequired[pulumi.Input[str]]
        digest_type: NotRequired[pulumi.Input[int]]
        fingerprint: NotRequired[pulumi.Input[str]]
        flags: NotRequired[pulumi.Input[str]]
        key_tag: NotRequired[pulumi.Input[int]]
        lat_degrees: NotRequired[pulumi.Input[int]]
        lat_direction: NotRequired[pulumi.Input[str]]
        lat_minutes: NotRequired[pulumi.Input[int]]
        lat_seconds: NotRequired[pulumi.Input[float]]
        long_degrees: NotRequired[pulumi.Input[int]]
        long_direction: NotRequired[pulumi.Input[str]]
        long_minutes: NotRequired[pulumi.Input[int]]
        long_seconds: NotRequired[pulumi.Input[float]]
        matching_type: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        order: NotRequired[pulumi.Input[int]]
        port: NotRequired[pulumi.Input[int]]
        precision_horz: NotRequired[pulumi.Input[float]]
        precision_vert: NotRequired[pulumi.Input[float]]
        preference: NotRequired[pulumi.Input[int]]
        priority: NotRequired[pulumi.Input[int]]
        proto: NotRequired[pulumi.Input[str]]
        protocol: NotRequired[pulumi.Input[int]]
        public_key: NotRequired[pulumi.Input[str]]
        regex: NotRequired[pulumi.Input[str]]
        replacement: NotRequired[pulumi.Input[str]]
        selector: NotRequired[pulumi.Input[int]]
        service: NotRequired[pulumi.Input[str]]
        size: NotRequired[pulumi.Input[float]]
        tag: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[int]]
        usage: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
        weight: NotRequired[pulumi.Input[int]]
elif False:
    RecordDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordDataArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[int]] = None,
                 altitude: Optional[pulumi.Input[float]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 digest: Optional[pulumi.Input[str]] = None,
                 digest_type: Optional[pulumi.Input[int]] = None,
                 fingerprint: Optional[pulumi.Input[str]] = None,
                 flags: Optional[pulumi.Input[str]] = None,
                 key_tag: Optional[pulumi.Input[int]] = None,
                 lat_degrees: Optional[pulumi.Input[int]] = None,
                 lat_direction: Optional[pulumi.Input[str]] = None,
                 lat_minutes: Optional[pulumi.Input[int]] = None,
                 lat_seconds: Optional[pulumi.Input[float]] = None,
                 long_degrees: Optional[pulumi.Input[int]] = None,
                 long_direction: Optional[pulumi.Input[str]] = None,
                 long_minutes: Optional[pulumi.Input[int]] = None,
                 long_seconds: Optional[pulumi.Input[float]] = None,
                 matching_type: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 precision_horz: Optional[pulumi.Input[float]] = None,
                 precision_vert: Optional[pulumi.Input[float]] = None,
                 preference: Optional[pulumi.Input[int]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 proto: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[int]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 replacement: Optional[pulumi.Input[str]] = None,
                 selector: Optional[pulumi.Input[int]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[float]] = None,
                 tag: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[int]] = None,
                 usage: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if proto is not None:
            pulumi.set(__self__, "proto", proto)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def altitude(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "altitude")

    @altitude.setter
    def altitude(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "altitude", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "digest", value)

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "digest_type")

    @digest_type.setter
    def digest_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "digest_type", value)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "key_tag")

    @key_tag.setter
    def key_tag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "key_tag", value)

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lat_degrees")

    @lat_degrees.setter
    def lat_degrees(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lat_degrees", value)

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lat_direction")

    @lat_direction.setter
    def lat_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lat_direction", value)

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lat_minutes")

    @lat_minutes.setter
    def lat_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lat_minutes", value)

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "lat_seconds")

    @lat_seconds.setter
    def lat_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lat_seconds", value)

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "long_degrees")

    @long_degrees.setter
    def long_degrees(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "long_degrees", value)

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "long_direction")

    @long_direction.setter
    def long_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_direction", value)

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "long_minutes")

    @long_minutes.setter
    def long_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "long_minutes", value)

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "long_seconds")

    @long_seconds.setter
    def long_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_seconds", value)

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "matching_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "precision_horz")

    @precision_horz.setter
    def precision_horz(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision_horz", value)

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "precision_vert")

    @precision_vert.setter
    def precision_vert(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision_vert", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def proto(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proto")

    @proto.setter
    def proto(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proto", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RiskBehaviorBehaviorArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether this risk behavior type is enabled.
        """
        name: pulumi.Input[str]
        """
        Name of this risk behavior type
        """
        risk_level: pulumi.Input[str]
        """
        Risk level. Available values: `low`, `medium`, `high`
        """
elif False:
    RiskBehaviorBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskBehaviorBehaviorArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 risk_level: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Whether this risk behavior type is enabled.
        :param pulumi.Input[str] name: Name of this risk behavior type
        :param pulumi.Input[str] risk_level: Risk level. Available values: `low`, `medium`, `high`
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether this risk behavior type is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of this risk behavior type
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> pulumi.Input[str]:
        """
        Risk level. Available values: `low`, `medium`, `high`
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "risk_level", value)


if not MYPY:
    class RulesetRuleArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        action: NotRequired[pulumi.Input[str]]
        """
        Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        action_parameters: NotRequired[pulumi.Input['RulesetRuleActionParametersArgsDict']]
        """
        List of parameters that configure the behavior of the ruleset rule action.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Brief summary of the ruleset rule and its intended use.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the rule is active.
        """
        exposed_credential_check: NotRequired[pulumi.Input['RulesetRuleExposedCredentialCheckArgsDict']]
        """
        List of parameters that configure exposed credential checks.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique rule identifier.
        """
        logging: NotRequired[pulumi.Input['RulesetRuleLoggingArgsDict']]
        """
        List parameters to configure how the rule generates logs. Only valid for skip action.
        """
        ratelimit: NotRequired[pulumi.Input['RulesetRuleRatelimitArgsDict']]
        """
        List of parameters that configure HTTP rate limiting behaviour.
        """
        ref: NotRequired[pulumi.Input[str]]
        """
        Rule reference.
        """
elif False:
    RulesetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None,
                 action_parameters: Optional[pulumi.Input['RulesetRuleActionParametersArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exposed_credential_check: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 logging: Optional[pulumi.Input['RulesetRuleLoggingArgs']] = None,
                 ratelimit: Optional[pulumi.Input['RulesetRuleRatelimitArgs']] = None,
                 ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] action: Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param pulumi.Input['RulesetRuleActionParametersArgs'] action_parameters: List of parameters that configure the behavior of the ruleset rule action.
        :param pulumi.Input[str] description: Brief summary of the ruleset rule and its intended use.
        :param pulumi.Input[bool] enabled: Whether the rule is active.
        :param pulumi.Input['RulesetRuleExposedCredentialCheckArgs'] exposed_credential_check: List of parameters that configure exposed credential checks.
        :param pulumi.Input[str] id: Unique rule identifier.
        :param pulumi.Input['RulesetRuleLoggingArgs'] logging: List parameters to configure how the rule generates logs. Only valid for skip action.
        :param pulumi.Input['RulesetRuleRatelimitArgs'] ratelimit: List of parameters that configure HTTP rate limiting behaviour.
        :param pulumi.Input[str] ref: Rule reference.
        """
        pulumi.set(__self__, "expression", expression)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional[pulumi.Input['RulesetRuleActionParametersArgs']]:
        """
        List of parameters that configure the behavior of the ruleset rule action.
        """
        return pulumi.get(self, "action_parameters")

    @action_parameters.setter
    def action_parameters(self, value: Optional[pulumi.Input['RulesetRuleActionParametersArgs']]):
        pulumi.set(self, "action_parameters", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Brief summary of the ruleset rule and its intended use.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']]:
        """
        List of parameters that configure exposed credential checks.
        """
        return pulumi.get(self, "exposed_credential_check")

    @exposed_credential_check.setter
    def exposed_credential_check(self, value: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']]):
        pulumi.set(self, "exposed_credential_check", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['RulesetRuleLoggingArgs']]:
        """
        List parameters to configure how the rule generates logs. Only valid for skip action.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['RulesetRuleLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional[pulumi.Input['RulesetRuleRatelimitArgs']]:
        """
        List of parameters that configure HTTP rate limiting behaviour.
        """
        return pulumi.get(self, "ratelimit")

    @ratelimit.setter
    def ratelimit(self, value: Optional[pulumi.Input['RulesetRuleRatelimitArgs']]):
        pulumi.set(self, "ratelimit", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[str]]:
        """
        Rule reference.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class RulesetRuleActionParametersArgsDict(TypedDict):
        additional_cacheable_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Specifies uncommon ports to allow cacheable assets to be served from.
        """
        algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgsDict']]]]
        """
        Compression algorithms to use in order of preference.
        """
        automatic_https_rewrites: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Cloudflare Automatic HTTPS rewrites.
        """
        autominifies: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgsDict']]]]
        """
        Indicate which file extensions to minify automatically.
        """
        bic: NotRequired[pulumi.Input[bool]]
        """
        Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        """
        browser_ttl: NotRequired[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgsDict']]
        """
        List of browser TTL parameters to apply to the request.
        """
        cache: NotRequired[pulumi.Input[bool]]
        """
        Whether to cache if expression matches.
        """
        cache_key: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyArgsDict']]
        """
        List of cache key parameters to apply to the request.
        """
        cache_reserve: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheReserveArgsDict']]
        """
        List of cache reserve parameters to apply to the request.
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Content of the custom error response.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        Content-Type of the custom error response.
        """
        cookie_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of cookie values to include as part of custom fields logging.
        """
        disable_apps: NotRequired[pulumi.Input[bool]]
        """
        Turn off all active Cloudflare Apps.
        """
        disable_railgun: NotRequired[pulumi.Input[bool]]
        """
        Turn off railgun feature of the Cloudflare Speed app.
        """
        disable_rum: NotRequired[pulumi.Input[bool]]
        """
        Turn off RUM feature.
        """
        disable_zaraz: NotRequired[pulumi.Input[bool]]
        """
        Turn off zaraz feature.
        """
        edge_ttl: NotRequired[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgsDict']]
        """
        List of edge TTL parameters to apply to the request.
        """
        email_obfuscation: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        """
        fonts: NotRequired[pulumi.Input[bool]]
        """
        Toggle fonts.
        """
        from_list: NotRequired[pulumi.Input['RulesetRuleActionParametersFromListArgsDict']]
        """
        Use a list to lookup information for the action.
        """
        from_value: NotRequired[pulumi.Input['RulesetRuleActionParametersFromValueArgsDict']]
        """
        Use a value to lookup information for the action.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgsDict']]]]
        """
        List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
        """
        host_header: NotRequired[pulumi.Input[str]]
        """
        Host Header that request origin receives.
        """
        hotlink_protection: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off the hotlink protection feature.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the action parameter to modify.
        """
        increment: NotRequired[pulumi.Input[int]]
        matched_data: NotRequired[pulumi.Input['RulesetRuleActionParametersMatchedDataArgsDict']]
        """
        List of properties to configure WAF payload logging.
        """
        mirage: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        """
        opportunistic_encryption: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        origin: NotRequired[pulumi.Input['RulesetRuleActionParametersOriginArgsDict']]
        """
        List of properties to change request origin.
        """
        origin_cache_control: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
        """
        origin_error_page_passthru: NotRequired[pulumi.Input[bool]]
        """
        Pass-through error page for origin.
        """
        overrides: NotRequired[pulumi.Input['RulesetRuleActionParametersOverridesArgsDict']]
        """
        List of override configurations to apply to the ruleset.
        """
        phases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        """
        polish: NotRequired[pulumi.Input[str]]
        """
        Apply options from the Polish feature of the Cloudflare Speed app.
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
        """
        read_timeout: NotRequired[pulumi.Input[int]]
        """
        Specifies a maximum timeout for reading content from an origin server.
        """
        request_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of request headers to include as part of custom fields logging, in lowercase.
        """
        respect_strong_etags: NotRequired[pulumi.Input[bool]]
        """
        Respect strong ETags.
        """
        response_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of response headers to include as part of custom fields logging, in lowercase.
        """
        responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgsDict']]]]
        """
        List of parameters that configure the response given to end users.
        """
        rocket_loader: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        """
        rules: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`.
        """
        ruleset: NotRequired[pulumi.Input[str]]
        """
        Which ruleset ID to target.
        """
        rulesets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
        """
        security_level: NotRequired[pulumi.Input[str]]
        """
        Control options for the Security Level feature from the Security app.
        """
        serve_stale: NotRequired[pulumi.Input['RulesetRuleActionParametersServeStaleArgsDict']]
        """
        List of serve stale parameters to apply to the request.
        """
        server_side_excludes: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        """
        sni: NotRequired[pulumi.Input['RulesetRuleActionParametersSniArgsDict']]
        """
        List of properties to manange Server Name Indication.
        """
        ssl: NotRequired[pulumi.Input[str]]
        """
        Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        HTTP status code of the custom error response.
        """
        sxg: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off the SXG feature.
        """
        uri: NotRequired[pulumi.Input['RulesetRuleActionParametersUriArgsDict']]
        """
        List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        """
elif False:
    RulesetRuleActionParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersArgs:
    def __init__(__self__, *,
                 additional_cacheable_ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[bool]] = None,
                 autominifies: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]]] = None,
                 bic: Optional[pulumi.Input[bool]] = None,
                 browser_ttl: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']] = None,
                 cache: Optional[pulumi.Input[bool]] = None,
                 cache_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']] = None,
                 cache_reserve: Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 cookie_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disable_apps: Optional[pulumi.Input[bool]] = None,
                 disable_railgun: Optional[pulumi.Input[bool]] = None,
                 disable_rum: Optional[pulumi.Input[bool]] = None,
                 disable_zaraz: Optional[pulumi.Input[bool]] = None,
                 edge_ttl: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']] = None,
                 email_obfuscation: Optional[pulumi.Input[bool]] = None,
                 fonts: Optional[pulumi.Input[bool]] = None,
                 from_list: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']] = None,
                 from_value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 hotlink_protection: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 increment: Optional[pulumi.Input[int]] = None,
                 matched_data: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']] = None,
                 mirage: Optional[pulumi.Input[bool]] = None,
                 opportunistic_encryption: Optional[pulumi.Input[bool]] = None,
                 origin: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']] = None,
                 origin_cache_control: Optional[pulumi.Input[bool]] = None,
                 origin_error_page_passthru: Optional[pulumi.Input[bool]] = None,
                 overrides: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']] = None,
                 phases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 read_timeout: Optional[pulumi.Input[int]] = None,
                 request_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 respect_strong_etags: Optional[pulumi.Input[bool]] = None,
                 response_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 responses: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]]] = None,
                 rocket_loader: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ruleset: Optional[pulumi.Input[str]] = None,
                 rulesets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 serve_stale: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']] = None,
                 server_side_excludes: Optional[pulumi.Input[bool]] = None,
                 sni: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 sxg: Optional[pulumi.Input[bool]] = None,
                 uri: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] additional_cacheable_ports: Specifies uncommon ports to allow cacheable assets to be served from.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]] algorithms: Compression algorithms to use in order of preference.
        :param pulumi.Input[bool] automatic_https_rewrites: Turn on or off Cloudflare Automatic HTTPS rewrites.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]] autominifies: Indicate which file extensions to minify automatically.
        :param pulumi.Input[bool] bic: Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        :param pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs'] browser_ttl: List of browser TTL parameters to apply to the request.
        :param pulumi.Input[bool] cache: Whether to cache if expression matches.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyArgs'] cache_key: List of cache key parameters to apply to the request.
        :param pulumi.Input['RulesetRuleActionParametersCacheReserveArgs'] cache_reserve: List of cache reserve parameters to apply to the request.
        :param pulumi.Input[str] content: Content of the custom error response.
        :param pulumi.Input[str] content_type: Content-Type of the custom error response.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cookie_fields: List of cookie values to include as part of custom fields logging.
        :param pulumi.Input[bool] disable_apps: Turn off all active Cloudflare Apps.
        :param pulumi.Input[bool] disable_railgun: Turn off railgun feature of the Cloudflare Speed app.
        :param pulumi.Input[bool] disable_rum: Turn off RUM feature.
        :param pulumi.Input[bool] disable_zaraz: Turn off zaraz feature.
        :param pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs'] edge_ttl: List of edge TTL parameters to apply to the request.
        :param pulumi.Input[bool] email_obfuscation: Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        :param pulumi.Input[bool] fonts: Toggle fonts.
        :param pulumi.Input['RulesetRuleActionParametersFromListArgs'] from_list: Use a list to lookup information for the action.
        :param pulumi.Input['RulesetRuleActionParametersFromValueArgs'] from_value: Use a value to lookup information for the action.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]] headers: List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
        :param pulumi.Input[str] host_header: Host Header that request origin receives.
        :param pulumi.Input[bool] hotlink_protection: Turn on or off the hotlink protection feature.
        :param pulumi.Input[str] id: Identifier of the action parameter to modify.
        :param pulumi.Input['RulesetRuleActionParametersMatchedDataArgs'] matched_data: List of properties to configure WAF payload logging.
        :param pulumi.Input[bool] mirage: Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        :param pulumi.Input[bool] opportunistic_encryption: Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        :param pulumi.Input['RulesetRuleActionParametersOriginArgs'] origin: List of properties to change request origin.
        :param pulumi.Input[bool] origin_cache_control: Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
        :param pulumi.Input[bool] origin_error_page_passthru: Pass-through error page for origin.
        :param pulumi.Input['RulesetRuleActionParametersOverridesArgs'] overrides: List of override configurations to apply to the ruleset.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] phases: Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        :param pulumi.Input[str] polish: Apply options from the Polish feature of the Cloudflare Speed app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] products: Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
        :param pulumi.Input[int] read_timeout: Specifies a maximum timeout for reading content from an origin server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] request_fields: List of request headers to include as part of custom fields logging, in lowercase.
        :param pulumi.Input[bool] respect_strong_etags: Respect strong ETags.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] response_fields: List of response headers to include as part of custom fields logging, in lowercase.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]] responses: List of parameters that configure the response given to end users.
        :param pulumi.Input[bool] rocket_loader: Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] rules: Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`.
        :param pulumi.Input[str] ruleset: Which ruleset ID to target.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] rulesets: List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
        :param pulumi.Input[str] security_level: Control options for the Security Level feature from the Security app.
        :param pulumi.Input['RulesetRuleActionParametersServeStaleArgs'] serve_stale: List of serve stale parameters to apply to the request.
        :param pulumi.Input[bool] server_side_excludes: Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        :param pulumi.Input['RulesetRuleActionParametersSniArgs'] sni: List of properties to manange Server Name Indication.
        :param pulumi.Input[str] ssl: Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        :param pulumi.Input[int] status_code: HTTP status code of the custom error response.
        :param pulumi.Input[bool] sxg: Turn on or off the SXG feature.
        :param pulumi.Input['RulesetRuleActionParametersUriArgs'] uri: List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        """
        if additional_cacheable_ports is not None:
            pulumi.set(__self__, "additional_cacheable_ports", additional_cacheable_ports)
        if algorithms is not None:
            pulumi.set(__self__, "algorithms", algorithms)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if autominifies is not None:
            pulumi.set(__self__, "autominifies", autominifies)
        if bic is not None:
            pulumi.set(__self__, "bic", bic)
        if browser_ttl is not None:
            pulumi.set(__self__, "browser_ttl", browser_ttl)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if cache_key is not None:
            pulumi.set(__self__, "cache_key", cache_key)
        if cache_reserve is not None:
            pulumi.set(__self__, "cache_reserve", cache_reserve)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if cookie_fields is not None:
            pulumi.set(__self__, "cookie_fields", cookie_fields)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_rum is not None:
            pulumi.set(__self__, "disable_rum", disable_rum)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            pulumi.set(__self__, "edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if from_list is not None:
            pulumi.set(__self__, "from_list", from_list)
        if from_value is not None:
            pulumi.set(__self__, "from_value", from_value)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_cache_control is not None:
            pulumi.set(__self__, "origin_cache_control", origin_cache_control)
        if origin_error_page_passthru is not None:
            pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if request_fields is not None:
            pulumi.set(__self__, "request_fields", request_fields)
        if respect_strong_etags is not None:
            pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        if response_fields is not None:
            pulumi.set(__self__, "response_fields", response_fields)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if serve_stale is not None:
            pulumi.set(__self__, "serve_stale", serve_stale)
        if server_side_excludes is not None:
            pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if sxg is not None:
            pulumi.set(__self__, "sxg", sxg)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="additionalCacheablePorts")
    def additional_cacheable_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Specifies uncommon ports to allow cacheable assets to be served from.
        """
        return pulumi.get(self, "additional_cacheable_ports")

    @additional_cacheable_ports.setter
    def additional_cacheable_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "additional_cacheable_ports", value)

    @property
    @pulumi.getter
    def algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]]:
        """
        Compression algorithms to use in order of preference.
        """
        return pulumi.get(self, "algorithms")

    @algorithms.setter
    def algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]]):
        pulumi.set(self, "algorithms", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Cloudflare Automatic HTTPS rewrites.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter
    def autominifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]]]:
        """
        Indicate which file extensions to minify automatically.
        """
        return pulumi.get(self, "autominifies")

    @autominifies.setter
    def autominifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]]]):
        pulumi.set(self, "autominifies", value)

    @property
    @pulumi.getter
    def bic(self) -> Optional[pulumi.Input[bool]]:
        """
        Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        """
        return pulumi.get(self, "bic")

    @bic.setter
    def bic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bic", value)

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']]:
        """
        List of browser TTL parameters to apply to the request.
        """
        return pulumi.get(self, "browser_ttl")

    @browser_ttl.setter
    def browser_ttl(self, value: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']]):
        pulumi.set(self, "browser_ttl", value)

    @property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to cache if expression matches.
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache", value)

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']]:
        """
        List of cache key parameters to apply to the request.
        """
        return pulumi.get(self, "cache_key")

    @cache_key.setter
    def cache_key(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']]):
        pulumi.set(self, "cache_key", value)

    @property
    @pulumi.getter(name="cacheReserve")
    def cache_reserve(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']]:
        """
        List of cache reserve parameters to apply to the request.
        """
        return pulumi.get(self, "cache_reserve")

    @cache_reserve.setter
    def cache_reserve(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']]):
        pulumi.set(self, "cache_reserve", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Content of the custom error response.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        Content-Type of the custom error response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookie values to include as part of custom fields logging.
        """
        return pulumi.get(self, "cookie_fields")

    @cookie_fields.setter
    def cookie_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cookie_fields", value)

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off all active Cloudflare Apps.
        """
        return pulumi.get(self, "disable_apps")

    @disable_apps.setter
    def disable_apps(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_apps", value)

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off railgun feature of the Cloudflare Speed app.
        """
        return pulumi.get(self, "disable_railgun")

    @disable_railgun.setter
    def disable_railgun(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_railgun", value)

    @property
    @pulumi.getter(name="disableRum")
    def disable_rum(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off RUM feature.
        """
        return pulumi.get(self, "disable_rum")

    @disable_rum.setter
    def disable_rum(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_rum", value)

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off zaraz feature.
        """
        return pulumi.get(self, "disable_zaraz")

    @disable_zaraz.setter
    def disable_zaraz(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_zaraz", value)

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']]:
        """
        List of edge TTL parameters to apply to the request.
        """
        return pulumi.get(self, "edge_ttl")

    @edge_ttl.setter
    def edge_ttl(self, value: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']]):
        pulumi.set(self, "edge_ttl", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        """
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter
    def fonts(self) -> Optional[pulumi.Input[bool]]:
        """
        Toggle fonts.
        """
        return pulumi.get(self, "fonts")

    @fonts.setter
    def fonts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fonts", value)

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']]:
        """
        Use a list to lookup information for the action.
        """
        return pulumi.get(self, "from_list")

    @from_list.setter
    def from_list(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']]):
        pulumi.set(self, "from_list", value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']]:
        """
        Use a value to lookup information for the action.
        """
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']]):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]]]:
        """
        List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Host Header that request origin receives.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the hotlink protection feature.
        """
        return pulumi.get(self, "hotlink_protection")

    @hotlink_protection.setter
    def hotlink_protection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hotlink_protection", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the action parameter to modify.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def increment(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']]:
        """
        List of properties to configure WAF payload logging.
        """
        return pulumi.get(self, "matched_data")

    @matched_data.setter
    def matched_data(self, value: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']]):
        pulumi.set(self, "matched_data", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        """
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']]:
        """
        List of properties to change request origin.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter(name="originCacheControl")
    def origin_cache_control(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
        """
        return pulumi.get(self, "origin_cache_control")

    @origin_cache_control.setter
    def origin_cache_control(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_cache_control", value)

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[pulumi.Input[bool]]:
        """
        Pass-through error page for origin.
        """
        return pulumi.get(self, "origin_error_page_passthru")

    @origin_error_page_passthru.setter
    def origin_error_page_passthru(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_error_page_passthru", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']]:
        """
        List of override configurations to apply to the ruleset.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        """
        return pulumi.get(self, "phases")

    @phases.setter
    def phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "phases", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        """
        Apply options from the Polish feature of the Cloudflare Speed app.
        """
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a maximum timeout for reading content from an origin server.
        """
        return pulumi.get(self, "read_timeout")

    @read_timeout.setter
    def read_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_timeout", value)

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of request headers to include as part of custom fields logging, in lowercase.
        """
        return pulumi.get(self, "request_fields")

    @request_fields.setter
    def request_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "request_fields", value)

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[pulumi.Input[bool]]:
        """
        Respect strong ETags.
        """
        return pulumi.get(self, "respect_strong_etags")

    @respect_strong_etags.setter
    def respect_strong_etags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_strong_etags", value)

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of response headers to include as part of custom fields logging, in lowercase.
        """
        return pulumi.get(self, "response_fields")

    @response_fields.setter
    def response_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "response_fields", value)

    @property
    @pulumi.getter
    def responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]]]:
        """
        List of parameters that configure the response given to end users.
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]]]):
        pulumi.set(self, "responses", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        """
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[pulumi.Input[str]]:
        """
        Which ruleset ID to target.
        """
        return pulumi.get(self, "ruleset")

    @ruleset.setter
    def ruleset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ruleset", value)

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
        """
        return pulumi.get(self, "rulesets")

    @rulesets.setter
    def rulesets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "rulesets", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Control options for the Security Level feature from the Security app.
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']]:
        """
        List of serve stale parameters to apply to the request.
        """
        return pulumi.get(self, "serve_stale")

    @serve_stale.setter
    def serve_stale(self, value: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']]):
        pulumi.set(self, "serve_stale", value)

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        """
        return pulumi.get(self, "server_side_excludes")

    @server_side_excludes.setter
    def server_side_excludes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_side_excludes", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']]:
        """
        List of properties to manange Server Name Indication.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        HTTP status code of the custom error response.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def sxg(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the SXG feature.
        """
        return pulumi.get(self, "sxg")

    @sxg.setter
    def sxg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sxg", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']]:
        """
        List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class RulesetRuleActionParametersAlgorithmArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the compression algorithm to use. Available values: `zstd`, `gzip`, `brotli`, `auto`, `default`, `none`
        """
elif False:
    RulesetRuleActionParametersAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersAlgorithmArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the compression algorithm to use. Available values: `zstd`, `gzip`, `brotli`, `auto`, `default`, `none`
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the compression algorithm to use. Available values: `zstd`, `gzip`, `brotli`, `auto`, `default`, `none`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersAutominifyArgsDict(TypedDict):
        css: NotRequired[pulumi.Input[bool]]
        """
        CSS minification.
        """
        html: NotRequired[pulumi.Input[bool]]
        """
        HTML minification.
        """
        js: NotRequired[pulumi.Input[bool]]
        """
        JS minification.
        """
elif False:
    RulesetRuleActionParametersAutominifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersAutominifyArgs:
    def __init__(__self__, *,
                 css: Optional[pulumi.Input[bool]] = None,
                 html: Optional[pulumi.Input[bool]] = None,
                 js: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] css: CSS minification.
        :param pulumi.Input[bool] html: HTML minification.
        :param pulumi.Input[bool] js: JS minification.
        """
        if css is not None:
            pulumi.set(__self__, "css", css)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if js is not None:
            pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> Optional[pulumi.Input[bool]]:
        """
        CSS minification.
        """
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> Optional[pulumi.Input[bool]]:
        """
        HTML minification.
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> Optional[pulumi.Input[bool]]:
        """
        JS minification.
        """
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "js", value)


if not MYPY:
    class RulesetRuleActionParametersBrowserTtlArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        """
        default: NotRequired[pulumi.Input[int]]
        """
        Default browser TTL. This value is required when override_origin is set
        """
elif False:
    RulesetRuleActionParametersBrowserTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersBrowserTtlArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 default: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        :param pulumi.Input[int] default: Default browser TTL. This value is required when override_origin is set
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        Default browser TTL. This value is required when override_origin is set
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyArgsDict(TypedDict):
        cache_by_device_type: NotRequired[pulumi.Input[bool]]
        """
        Cache by device type.
        """
        cache_deception_armor: NotRequired[pulumi.Input[bool]]
        """
        Cache deception armor.
        """
        custom_key: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgsDict']]
        """
        Custom key parameters for the request.
        """
        ignore_query_strings_order: NotRequired[pulumi.Input[bool]]
        """
        Ignore query strings order.
        """
elif False:
    RulesetRuleActionParametersCacheKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyArgs:
    def __init__(__self__, *,
                 cache_by_device_type: Optional[pulumi.Input[bool]] = None,
                 cache_deception_armor: Optional[pulumi.Input[bool]] = None,
                 custom_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']] = None,
                 ignore_query_strings_order: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] cache_by_device_type: Cache by device type.
        :param pulumi.Input[bool] cache_deception_armor: Cache deception armor.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs'] custom_key: Custom key parameters for the request.
        :param pulumi.Input[bool] ignore_query_strings_order: Ignore query strings order.
        """
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if ignore_query_strings_order is not None:
            pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Cache by device type.
        """
        return pulumi.get(self, "cache_by_device_type")

    @cache_by_device_type.setter
    def cache_by_device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_by_device_type", value)

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[pulumi.Input[bool]]:
        """
        Cache deception armor.
        """
        return pulumi.get(self, "cache_deception_armor")

    @cache_deception_armor.setter
    def cache_deception_armor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_deception_armor", value)

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']]:
        """
        Custom key parameters for the request.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']]):
        pulumi.set(self, "custom_key", value)

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[pulumi.Input[bool]]:
        """
        Ignore query strings order.
        """
        return pulumi.get(self, "ignore_query_strings_order")

    @ignore_query_strings_order.setter
    def ignore_query_strings_order(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_query_strings_order", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyArgsDict(TypedDict):
        cookie: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict']]
        """
        Cookie parameters for the custom key.
        """
        header: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict']]
        """
        Header parameters for the custom key.
        """
        host: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict']]
        """
        Host parameters for the custom key.
        """
        query_string: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict']]
        """
        Query string parameters for the custom key.
        """
        user: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict']]
        """
        User parameters for the custom key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']] = None,
                 header: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']] = None,
                 host: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']] = None,
                 query_string: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']] = None,
                 user: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs'] cookie: Cookie parameters for the custom key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs'] header: Header parameters for the custom key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs'] host: Host parameters for the custom key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs'] query_string: Query string parameters for the custom key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs'] user: User parameters for the custom key.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']]:
        """
        Cookie parameters for the custom key.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']]:
        """
        Header parameters for the custom key.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']]:
        """
        Host parameters for the custom key.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']]:
        """
        Query string parameters for the custom key.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']]:
        """
        User parameters for the custom key.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']]):
        pulumi.set(self, "user", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of cookies to check for presence in the custom key.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of cookies to include in the custom key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: List of cookies to check for presence in the custom key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of cookies to include in the custom key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookies to check for presence in the custom key.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookies to include in the custom key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of headers to check for presence in the custom key.
        """
        contains: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        Dictionary of headers mapping to lists of values to check for presence in the custom key.
        """
        exclude_origin: NotRequired[pulumi.Input[bool]]
        """
        Exclude the origin header from the custom key.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of headers to include in the custom key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 contains: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 exclude_origin: Optional[pulumi.Input[bool]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: List of headers to check for presence in the custom key.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] contains: Dictionary of headers mapping to lists of values to check for presence in the custom key.
        :param pulumi.Input[bool] exclude_origin: Exclude the origin header from the custom key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of headers to include in the custom key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exclude_origin is not None:
            pulumi.set(__self__, "exclude_origin", exclude_origin)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of headers to check for presence in the custom key.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        Dictionary of headers mapping to lists of values to check for presence in the custom key.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Exclude the origin header from the custom key.
        """
        return pulumi.get(self, "exclude_origin")

    @exclude_origin.setter
    def exclude_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_origin", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of headers to include in the custom key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict(TypedDict):
        resolved: NotRequired[pulumi.Input[bool]]
        """
        Resolve hostname to IP address.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyHostArgs:
    def __init__(__self__, *,
                 resolved: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] resolved: Resolve hostname to IP address.
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input[bool]]:
        """
        Resolve hostname to IP address.
        """
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolved", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of query string parameters to exclude from the custom key.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of query string parameters to include in the custom key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of query string parameters to exclude from the custom key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of query string parameters to include in the custom key.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of query string parameters to exclude from the custom key.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of query string parameters to include in the custom key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict(TypedDict):
        device_type: NotRequired[pulumi.Input[bool]]
        """
        Add device type to the custom key.
        """
        geo: NotRequired[pulumi.Input[bool]]
        """
        Add geo data to the custom key.
        """
        lang: NotRequired[pulumi.Input[bool]]
        """
        Add language data to the custom key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyUserArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[bool]] = None,
                 geo: Optional[pulumi.Input[bool]] = None,
                 lang: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] device_type: Add device type to the custom key.
        :param pulumi.Input[bool] geo: Add geo data to the custom key.
        :param pulumi.Input[bool] lang: Add language data to the custom key.
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Add device type to the custom key.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input[bool]]:
        """
        Add geo data to the custom key.
        """
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[bool]]:
        """
        Add language data to the custom key.
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lang", value)


if not MYPY:
    class RulesetRuleActionParametersCacheReserveArgsDict(TypedDict):
        eligible: pulumi.Input[bool]
        """
        Determines whether Cloudflare will write the eligible resource to cache reserve.
        """
        minimum_file_size: NotRequired[pulumi.Input[int]]
        """
        The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and "eligible" is true, Cloudflare will use 0 bytes by default.
        """
elif False:
    RulesetRuleActionParametersCacheReserveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheReserveArgs:
    def __init__(__self__, *,
                 eligible: pulumi.Input[bool],
                 minimum_file_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] eligible: Determines whether Cloudflare will write the eligible resource to cache reserve.
        :param pulumi.Input[int] minimum_file_size: The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and "eligible" is true, Cloudflare will use 0 bytes by default.
        """
        pulumi.set(__self__, "eligible", eligible)
        if minimum_file_size is not None:
            pulumi.set(__self__, "minimum_file_size", minimum_file_size)

    @property
    @pulumi.getter
    def eligible(self) -> pulumi.Input[bool]:
        """
        Determines whether Cloudflare will write the eligible resource to cache reserve.
        """
        return pulumi.get(self, "eligible")

    @eligible.setter
    def eligible(self, value: pulumi.Input[bool]):
        pulumi.set(self, "eligible", value)

    @property
    @pulumi.getter(name="minimumFileSize")
    def minimum_file_size(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and "eligible" is true, Cloudflare will use 0 bytes by default.
        """
        return pulumi.get(self, "minimum_file_size")

    @minimum_file_size.setter
    def minimum_file_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_file_size", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        Mode of the edge TTL. Available values: `override_origin`, `respect_origin`, `bypass_by_default`
        """
        default: NotRequired[pulumi.Input[int]]
        """
        Default edge TTL.
        """
        status_code_ttls: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict']]]]
        """
        Edge TTL for the status codes.
        """
elif False:
    RulesetRuleActionParametersEdgeTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 default: Optional[pulumi.Input[int]] = None,
                 status_code_ttls: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]] = None):
        """
        :param pulumi.Input[str] mode: Mode of the edge TTL. Available values: `override_origin`, `respect_origin`, `bypass_by_default`
        :param pulumi.Input[int] default: Default edge TTL.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]] status_code_ttls: Edge TTL for the status codes.
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if status_code_ttls is not None:
            pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Mode of the edge TTL. Available values: `override_origin`, `respect_origin`, `bypass_by_default`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        Default edge TTL.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]]:
        """
        Edge TTL for the status codes.
        """
        return pulumi.get(self, "status_code_ttls")

    @status_code_ttls.setter
    def status_code_ttls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]]):
        pulumi.set(self, "status_code_ttls", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict(TypedDict):
        status_code: NotRequired[pulumi.Input[int]]
        """
        Status code for which the edge TTL is applied.
        """
        status_code_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict']]]]
        """
        Status code range for which the edge TTL is applied.
        """
        value: NotRequired[pulumi.Input[int]]
        """
        Status code edge TTL value.
        """
elif False:
    RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs:
    def __init__(__self__, *,
                 status_code: Optional[pulumi.Input[int]] = None,
                 status_code_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] status_code: Status code for which the edge TTL is applied.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]] status_code_ranges: Status code range for which the edge TTL is applied.
        :param pulumi.Input[int] value: Status code edge TTL value.
        """
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if status_code_ranges is not None:
            pulumi.set(__self__, "status_code_ranges", status_code_ranges)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        Status code for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]]]:
        """
        Status code range for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code_ranges")

    @status_code_ranges.setter
    def status_code_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]]]):
        pulumi.set(self, "status_code_ranges", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[int]]
        """
        From status code.
        """
        to: NotRequired[pulumi.Input[int]]
        """
        To status code.
        """
elif False:
    RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[int]] = None,
                 to: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_: From status code.
        :param pulumi.Input[int] to: To status code.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[int]]:
        """
        From status code.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[int]]:
        """
        To status code.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class RulesetRuleActionParametersFromListArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Expression to use for the list lookup.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the list.
        """
elif False:
    RulesetRuleActionParametersFromListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromListArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Expression to use for the list lookup.
        :param pulumi.Input[str] name: Name of the list.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Expression to use for the list lookup.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the list.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersFromValueArgsDict(TypedDict):
        preserve_query_string: NotRequired[pulumi.Input[bool]]
        """
        Preserve query string for redirect URL.
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        Status code for redirect.
        """
        target_url: NotRequired[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgsDict']]
        """
        Target URL for redirect.
        """
elif False:
    RulesetRuleActionParametersFromValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromValueArgs:
    def __init__(__self__, *,
                 preserve_query_string: Optional[pulumi.Input[bool]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 target_url: Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']] = None):
        """
        :param pulumi.Input[bool] preserve_query_string: Preserve query string for redirect URL.
        :param pulumi.Input[int] status_code: Status code for redirect.
        :param pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs'] target_url: Target URL for redirect.
        """
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Preserve query string for redirect URL.
        """
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_query_string", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        Status code for redirect.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']]:
        """
        Target URL for redirect.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']]):
        pulumi.set(self, "target_url", value)


if not MYPY:
    class RulesetRuleActionParametersFromValueTargetUrlArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[str]]
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Static value to provide as the HTTP request header value.
        """
elif False:
    RulesetRuleActionParametersFromValueTargetUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromValueTargetUrlArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] value: Static value to provide as the HTTP request header value.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Static value to provide as the HTTP request header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersHeaderArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[str]]
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the HTTP request header to target.
        """
        operation: NotRequired[pulumi.Input[str]]
        """
        Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Static value to provide as the HTTP request header value.
        """
elif False:
    RulesetRuleActionParametersHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersHeaderArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 operation: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] name: Name of the HTTP request header to target.
        :param pulumi.Input[str] operation: Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
        :param pulumi.Input[str] value: Static value to provide as the HTTP request header value.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the HTTP request header to target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Static value to provide as the HTTP request header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersMatchedDataArgsDict(TypedDict):
        public_key: NotRequired[pulumi.Input[str]]
        """
        Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
elif False:
    RulesetRuleActionParametersMatchedDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersMatchedDataArgs:
    def __init__(__self__, *,
                 public_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] public_key: Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class RulesetRuleActionParametersOriginArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        """
        Origin Hostname where request is sent.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Origin Port where request is sent.
        """
elif False:
    RulesetRuleActionParametersOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOriginArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: Origin Hostname where request is sent.
        :param pulumi.Input[int] port: Origin Port where request is sent.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Origin Hostname where request is sent.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Origin Port where request is sent.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgsDict']]]]
        """
        List of tag-based overrides.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Defines if the current ruleset-level override enables or disables the ruleset.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgsDict']]]]
        """
        List of rule-based overrides.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`.
        """
elif False:
    RulesetRuleActionParametersOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]] categories: List of tag-based overrides.
        :param pulumi.Input[bool] enabled: Defines if the current ruleset-level override enables or disables the ruleset.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]] rules: List of rule-based overrides.
        :param pulumi.Input[str] sensitivity_level: Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]]:
        """
        List of tag-based overrides.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the current ruleset-level override enables or disables the ruleset.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]]:
        """
        List of rule-based overrides.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesCategoryArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        category: NotRequired[pulumi.Input[str]]
        """
        Tag name to apply the ruleset rule override to.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
elif False:
    RulesetRuleActionParametersOverridesCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesCategoryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 category: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] action: Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param pulumi.Input[str] category: Tag name to apply the ruleset rule override to.
        :param pulumi.Input[bool] enabled: Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        Tag name to apply the ruleset rule override to.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Defines if the current rule-level override enables or disables the rule.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Rule ID to apply the override to.
        """
        score_threshold: NotRequired[pulumi.Input[int]]
        """
        Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        Sensitivity level for a ruleset rule override.
        """
elif False:
    RulesetRuleActionParametersOverridesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 score_threshold: Optional[pulumi.Input[int]] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param pulumi.Input[bool] enabled: Defines if the current rule-level override enables or disables the rule.
        :param pulumi.Input[str] id: Rule ID to apply the override to.
        :param pulumi.Input[int] score_threshold: Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        :param pulumi.Input[str] sensitivity_level: Sensitivity level for a ruleset rule override.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the current rule-level override enables or disables the rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Rule ID to apply the override to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        """
        return pulumi.get(self, "score_threshold")

    @score_threshold.setter
    def score_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "score_threshold", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity level for a ruleset rule override.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RulesetRuleActionParametersResponseArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[str]]
        """
        Body content to include in the response.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        HTTP content type to send in the response.
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        HTTP status code to send in the response.
        """
elif False:
    RulesetRuleActionParametersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersResponseArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] content: Body content to include in the response.
        :param pulumi.Input[str] content_type: HTTP content type to send in the response.
        :param pulumi.Input[int] status_code: HTTP status code to send in the response.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Body content to include in the response.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP content type to send in the response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        HTTP status code to send in the response.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class RulesetRuleActionParametersServeStaleArgsDict(TypedDict):
        disable_stale_while_updating: NotRequired[pulumi.Input[bool]]
        """
        Disable stale while updating.
        """
elif False:
    RulesetRuleActionParametersServeStaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersServeStaleArgs:
    def __init__(__self__, *,
                 disable_stale_while_updating: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable_stale_while_updating: Disable stale while updating.
        """
        if disable_stale_while_updating is not None:
            pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable stale while updating.
        """
        return pulumi.get(self, "disable_stale_while_updating")

    @disable_stale_while_updating.setter
    def disable_stale_while_updating(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_stale_while_updating", value)


if not MYPY:
    class RulesetRuleActionParametersSniArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        Value to define for SNI.
        """
elif False:
    RulesetRuleActionParametersSniArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersSniArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Value to define for SNI.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value to define for SNI.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersUriArgsDict(TypedDict):
        origin: NotRequired[pulumi.Input[bool]]
        path: NotRequired[pulumi.Input['RulesetRuleActionParametersUriPathArgsDict']]
        """
        URI path configuration when performing a URL rewrite.
        """
        query: NotRequired[pulumi.Input['RulesetRuleActionParametersUriQueryArgsDict']]
        """
        Query string configuration when performing a URL rewrite.
        """
elif False:
    RulesetRuleActionParametersUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriArgs:
    def __init__(__self__, *,
                 origin: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']] = None,
                 query: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersUriPathArgs'] path: URI path configuration when performing a URL rewrite.
        :param pulumi.Input['RulesetRuleActionParametersUriQueryArgs'] query: Query string configuration when performing a URL rewrite.
        """
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']]:
        """
        URI path configuration when performing a URL rewrite.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']]:
        """
        Query string configuration when performing a URL rewrite.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']]):
        pulumi.set(self, "query", value)


if not MYPY:
    class RulesetRuleActionParametersUriPathArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[str]]
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Static string value of the updated URI path or query string component.
        """
elif False:
    RulesetRuleActionParametersUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriPathArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] value: Static string value of the updated URI path or query string component.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Static string value of the updated URI path or query string component.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersUriQueryArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[str]]
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Static string value of the updated URI path or query string component.
        """
elif False:
    RulesetRuleActionParametersUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriQueryArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] value: Static string value of the updated URI path or query string component.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Static string value of the updated URI path or query string component.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleExposedCredentialCheckArgsDict(TypedDict):
        password_expression: NotRequired[pulumi.Input[str]]
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        username_expression: NotRequired[pulumi.Input[str]]
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
elif False:
    RulesetRuleExposedCredentialCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleExposedCredentialCheckArgs:
    def __init__(__self__, *,
                 password_expression: Optional[pulumi.Input[str]] = None,
                 username_expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        :param pulumi.Input[str] username_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        if password_expression is not None:
            pulumi.set(__self__, "password_expression", password_expression)
        if username_expression is not None:
            pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "password_expression")

    @password_expression.setter
    def password_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_expression", value)

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "username_expression")

    @username_expression.setter
    def username_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_expression", value)


if not MYPY:
    class RulesetRuleLoggingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Override the default logging behavior when a rule is matched.
        """
elif False:
    RulesetRuleLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleLoggingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Override the default logging behavior when a rule is matched.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Override the default logging behavior when a rule is matched.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class RulesetRuleRatelimitArgsDict(TypedDict):
        characteristics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of parameters that define how Cloudflare tracks the request rate for this rule.
        """
        counting_expression: NotRequired[pulumi.Input[str]]
        """
        Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        mitigation_timeout: NotRequired[pulumi.Input[int]]
        """
        Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        """
        period: NotRequired[pulumi.Input[int]]
        """
        The period of time to consider (in seconds) when evaluating the request rate.
        """
        requests_per_period: NotRequired[pulumi.Input[int]]
        """
        The number of requests over the period of time that will trigger the Rate Limiting rule.
        """
        requests_to_origin: NotRequired[pulumi.Input[bool]]
        """
        Whether to include requests to origin within the Rate Limiting count.
        """
        score_per_period: NotRequired[pulumi.Input[int]]
        """
        The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        """
        score_response_header_name: NotRequired[pulumi.Input[str]]
        """
        Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
elif False:
    RulesetRuleRatelimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleRatelimitArgs:
    def __init__(__self__, *,
                 characteristics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 counting_expression: Optional[pulumi.Input[str]] = None,
                 mitigation_timeout: Optional[pulumi.Input[int]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 requests_per_period: Optional[pulumi.Input[int]] = None,
                 requests_to_origin: Optional[pulumi.Input[bool]] = None,
                 score_per_period: Optional[pulumi.Input[int]] = None,
                 score_response_header_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] characteristics: List of parameters that define how Cloudflare tracks the request rate for this rule.
        :param pulumi.Input[str] counting_expression: Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[int] mitigation_timeout: Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        :param pulumi.Input[int] period: The period of time to consider (in seconds) when evaluating the request rate.
        :param pulumi.Input[int] requests_per_period: The number of requests over the period of time that will trigger the Rate Limiting rule.
        :param pulumi.Input[bool] requests_to_origin: Whether to include requests to origin within the Rate Limiting count.
        :param pulumi.Input[int] score_per_period: The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        :param pulumi.Input[str] score_response_header_name: Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if counting_expression is not None:
            pulumi.set(__self__, "counting_expression", counting_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)
        if requests_to_origin is not None:
            pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        if score_per_period is not None:
            pulumi.set(__self__, "score_per_period", score_per_period)
        if score_response_header_name is not None:
            pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter
    def characteristics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of parameters that define how Cloudflare tracks the request rate for this rule.
        """
        return pulumi.get(self, "characteristics")

    @characteristics.setter
    def characteristics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "characteristics", value)

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "counting_expression")

    @counting_expression.setter
    def counting_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "counting_expression", value)

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        """
        return pulumi.get(self, "mitigation_timeout")

    @mitigation_timeout.setter
    def mitigation_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mitigation_timeout", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        The period of time to consider (in seconds) when evaluating the request rate.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[pulumi.Input[int]]:
        """
        The number of requests over the period of time that will trigger the Rate Limiting rule.
        """
        return pulumi.get(self, "requests_per_period")

    @requests_per_period.setter
    def requests_per_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "requests_per_period", value)

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to include requests to origin within the Rate Limiting count.
        """
        return pulumi.get(self, "requests_to_origin")

    @requests_to_origin.setter
    def requests_to_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "requests_to_origin", value)

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        """
        return pulumi.get(self, "score_per_period")

    @score_per_period.setter
    def score_per_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "score_per_period", value)

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
        return pulumi.get(self, "score_response_header_name")

    @score_response_header_name.setter
    def score_response_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "score_response_header_name", value)


if not MYPY:
    class SnippetFileArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the snippet file.
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Content of the snippet file.
        """
elif False:
    SnippetFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnippetFileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the snippet file.
        :param pulumi.Input[str] content: Content of the snippet file.
        """
        pulumi.set(__self__, "name", name)
        if content is not None:
            pulumi.set(__self__, "content", content)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the snippet file.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Content of the snippet file.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)


if not MYPY:
    class SnippetRulesRuleArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        Criteria for an HTTP request to trigger the snippet rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        """
        snippet_name: pulumi.Input[str]
        """
        Name of the snippet invoked by this rule.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Brief summary of the snippet rule and its intended use.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the headers rule is active.
        """
elif False:
    SnippetRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnippetRulesRuleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 snippet_name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] expression: Criteria for an HTTP request to trigger the snippet rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        :param pulumi.Input[str] snippet_name: Name of the snippet invoked by this rule.
        :param pulumi.Input[str] description: Brief summary of the snippet rule and its intended use.
        :param pulumi.Input[bool] enabled: Whether the headers rule is active.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "snippet_name", snippet_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Criteria for an HTTP request to trigger the snippet rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="snippetName")
    def snippet_name(self) -> pulumi.Input[str]:
        """
        Name of the snippet invoked by this rule.
        """
        return pulumi.get(self, "snippet_name")

    @snippet_name.setter
    def snippet_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "snippet_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Brief summary of the snippet rule and its intended use.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SpectrumApplicationDnsArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the DNS record associated with the application.
        """
        type: pulumi.Input[str]
        """
        The type of DNS record associated with the application.
        """
elif False:
    SpectrumApplicationDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationDnsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the DNS record associated with the application.
        :param pulumi.Input[str] type: The type of DNS record associated with the application.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the DNS record associated with the application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of DNS record associated with the application.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SpectrumApplicationEdgeIpsArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        """
        connectivity: NotRequired[pulumi.Input[str]]
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
elif False:
    SpectrumApplicationEdgeIpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationEdgeIpsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 connectivity: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        :param pulumi.Input[str] connectivity: The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
        pulumi.set(__self__, "type", type)
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def connectivity(self) -> Optional[pulumi.Input[str]]:
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        """
        return pulumi.get(self, "connectivity")

    @connectivity.setter
    def connectivity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connectivity", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)


if not MYPY:
    class SpectrumApplicationOriginDnsArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Fully qualified domain name of the origin.
        """
elif False:
    SpectrumApplicationOriginDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationOriginDnsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Fully qualified domain name of the origin.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Fully qualified domain name of the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SpectrumApplicationOriginPortRangeArgsDict(TypedDict):
        end: pulumi.Input[int]
        """
        Upper bound of the origin port range.
        """
        start: pulumi.Input[int]
        """
        Lower bound of the origin port range.
        """
elif False:
    SpectrumApplicationOriginPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationOriginPortRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[int],
                 start: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end: Upper bound of the origin port range.
        :param pulumi.Input[int] start: Lower bound of the origin port range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[int]:
        """
        Upper bound of the origin port range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[int]:
        """
        Lower bound of the origin port range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class SplitTunnelTunnelArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        The address for the tunnel.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description for the tunnel.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        The domain name for the tunnel.
        """
elif False:
    SplitTunnelTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SplitTunnelTunnelArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address for the tunnel.
        :param pulumi.Input[str] description: A description for the tunnel.
        :param pulumi.Input[str] host: The domain name for the tunnel.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address for the tunnel.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description for the tunnel.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name for the tunnel.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class TeamsAccountAntivirusArgsDict(TypedDict):
        enabled_download_phase: pulumi.Input[bool]
        """
        Scan on file download.
        """
        enabled_upload_phase: pulumi.Input[bool]
        """
        Scan on file upload.
        """
        fail_closed: pulumi.Input[bool]
        """
        Block requests for files that cannot be scanned.
        """
        notification_settings: NotRequired[pulumi.Input['TeamsAccountAntivirusNotificationSettingsArgsDict']]
        """
        Set notifications for antivirus.
        """
elif False:
    TeamsAccountAntivirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountAntivirusArgs:
    def __init__(__self__, *,
                 enabled_download_phase: pulumi.Input[bool],
                 enabled_upload_phase: pulumi.Input[bool],
                 fail_closed: pulumi.Input[bool],
                 notification_settings: Optional[pulumi.Input['TeamsAccountAntivirusNotificationSettingsArgs']] = None):
        """
        :param pulumi.Input[bool] enabled_download_phase: Scan on file download.
        :param pulumi.Input[bool] enabled_upload_phase: Scan on file upload.
        :param pulumi.Input[bool] fail_closed: Block requests for files that cannot be scanned.
        :param pulumi.Input['TeamsAccountAntivirusNotificationSettingsArgs'] notification_settings: Set notifications for antivirus.
        """
        pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        pulumi.set(__self__, "fail_closed", fail_closed)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> pulumi.Input[bool]:
        """
        Scan on file download.
        """
        return pulumi.get(self, "enabled_download_phase")

    @enabled_download_phase.setter
    def enabled_download_phase(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_download_phase", value)

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> pulumi.Input[bool]:
        """
        Scan on file upload.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @enabled_upload_phase.setter
    def enabled_upload_phase(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_upload_phase", value)

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> pulumi.Input[bool]:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @fail_closed.setter
    def fail_closed(self, value: pulumi.Input[bool]):
        pulumi.set(self, "fail_closed", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['TeamsAccountAntivirusNotificationSettingsArgs']]:
        """
        Set notifications for antivirus.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['TeamsAccountAntivirusNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)


if not MYPY:
    class TeamsAccountAntivirusNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification settings.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Notification content.
        """
        support_url: NotRequired[pulumi.Input[str]]
        """
        Support URL to show in the notification.
        """
elif False:
    TeamsAccountAntivirusNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountAntivirusNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 support_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification settings.
        :param pulumi.Input[str] message: Notification content.
        :param pulumi.Input[str] support_url: Support URL to show in the notification.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Notification content.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[str]]:
        """
        Support URL to show in the notification.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class TeamsAccountBlockPageArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[str]]
        """
        Hex code of block page background color.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicator of enablement.
        """
        footer_text: NotRequired[pulumi.Input[str]]
        """
        Block page footer text.
        """
        header_text: NotRequired[pulumi.Input[str]]
        """
        Block page header text.
        """
        logo_path: NotRequired[pulumi.Input[str]]
        """
        URL of block page logo.
        """
        mailto_address: NotRequired[pulumi.Input[str]]
        """
        Admin email for users to contact.
        """
        mailto_subject: NotRequired[pulumi.Input[str]]
        """
        Subject line for emails created from block page.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of block page configuration.
        """
elif False:
    TeamsAccountBlockPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountBlockPageArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None,
                 logo_path: Optional[pulumi.Input[str]] = None,
                 mailto_address: Optional[pulumi.Input[str]] = None,
                 mailto_subject: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_color: Hex code of block page background color.
        :param pulumi.Input[bool] enabled: Indicator of enablement.
        :param pulumi.Input[str] footer_text: Block page footer text.
        :param pulumi.Input[str] header_text: Block page header text.
        :param pulumi.Input[str] logo_path: URL of block page logo.
        :param pulumi.Input[str] mailto_address: Admin email for users to contact.
        :param pulumi.Input[str] mailto_subject: Subject line for emails created from block page.
        :param pulumi.Input[str] name: Name of block page configuration.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Hex code of block page background color.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicator of enablement.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[str]]:
        """
        URL of block page logo.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_path", value)

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[pulumi.Input[str]]:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @mailto_address.setter
    def mailto_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mailto_address", value)

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @mailto_subject.setter
    def mailto_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mailto_subject", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of block page configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TeamsAccountBodyScanningArgsDict(TypedDict):
        inspection_mode: pulumi.Input[str]
        """
        Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
elif False:
    TeamsAccountBodyScanningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountBodyScanningArgs:
    def __init__(__self__, *,
                 inspection_mode: pulumi.Input[str]):
        """
        :param pulumi.Input[str] inspection_mode: Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
        pulumi.set(__self__, "inspection_mode", inspection_mode)

    @property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> pulumi.Input[str]:
        """
        Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
        return pulumi.get(self, "inspection_mode")

    @inspection_mode.setter
    def inspection_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "inspection_mode", value)


if not MYPY:
    class TeamsAccountCertificateArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of certificate for TLS interception.
        """
elif False:
    TeamsAccountCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountCertificateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of certificate for TLS interception.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of certificate for TLS interception.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TeamsAccountCustomCertificateArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether TLS encryption should use a custom certificate.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of custom certificate.
        """
        updated_at: NotRequired[pulumi.Input[str]]
elif False:
    TeamsAccountCustomCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountCustomCertificateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether TLS encryption should use a custom certificate.
        :param pulumi.Input[str] id: ID of custom certificate.
        """
        pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether TLS encryption should use a custom certificate.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of custom certificate.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class TeamsAccountExtendedEmailMatchingArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
elif False:
    TeamsAccountExtendedEmailMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountExtendedEmailMatchingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamsAccountFipsArgsDict(TypedDict):
        tls: NotRequired[pulumi.Input[bool]]
        """
        Only allow FIPS-compliant TLS configuration.
        """
elif False:
    TeamsAccountFipsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountFipsArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] tls: Only allow FIPS-compliant TLS configuration.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Only allow FIPS-compliant TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class TeamsAccountLoggingArgsDict(TypedDict):
        redact_pii: pulumi.Input[bool]
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        """
        settings_by_rule_type: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgsDict']
        """
        Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
elif False:
    TeamsAccountLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountLoggingArgs:
    def __init__(__self__, *,
                 redact_pii: pulumi.Input[bool],
                 settings_by_rule_type: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs']):
        """
        :param pulumi.Input[bool] redact_pii: Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        :param pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs'] settings_by_rule_type: Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        pulumi.set(__self__, "redact_pii", redact_pii)
        pulumi.set(__self__, "settings_by_rule_type", settings_by_rule_type)

    @property
    @pulumi.getter(name="redactPii")
    def redact_pii(self) -> pulumi.Input[bool]:
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        """
        return pulumi.get(self, "redact_pii")

    @redact_pii.setter
    def redact_pii(self, value: pulumi.Input[bool]):
        pulumi.set(self, "redact_pii", value)

    @property
    @pulumi.getter(name="settingsByRuleType")
    def settings_by_rule_type(self) -> pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs']:
        """
        Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        return pulumi.get(self, "settings_by_rule_type")

    @settings_by_rule_type.setter
    def settings_by_rule_type(self, value: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs']):
        pulumi.set(self, "settings_by_rule_type", value)


if not MYPY:
    class TeamsAccountLoggingSettingsByRuleTypeArgsDict(TypedDict):
        dns: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgsDict']
        """
        Logging configuration for DNS requests.
        """
        http: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgsDict']
        """
        Logging configuration for HTTP requests.
        """
        l4: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4ArgsDict']
        """
        Logging configuration for layer 4 requests.
        """
elif False:
    TeamsAccountLoggingSettingsByRuleTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountLoggingSettingsByRuleTypeArgs:
    def __init__(__self__, *,
                 dns: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs'],
                 http: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs'],
                 l4: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args']):
        """
        :param pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs'] dns: Logging configuration for DNS requests.
        :param pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs'] http: Logging configuration for HTTP requests.
        :param pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args'] l4: Logging configuration for layer 4 requests.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "http", http)
        pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs']:
        """
        Logging configuration for DNS requests.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs']):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def http(self) -> pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs']:
        """
        Logging configuration for HTTP requests.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs']):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def l4(self) -> pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args']:
        """
        Logging configuration for layer 4 requests.
        """
        return pulumi.get(self, "l4")

    @l4.setter
    def l4(self, value: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args']):
        pulumi.set(self, "l4", value)


if not MYPY:
    class TeamsAccountLoggingSettingsByRuleTypeDnsArgsDict(TypedDict):
        log_all: pulumi.Input[bool]
        """
        Whether to log all activity.
        """
        log_blocks: pulumi.Input[bool]
elif False:
    TeamsAccountLoggingSettingsByRuleTypeDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountLoggingSettingsByRuleTypeDnsArgs:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class TeamsAccountLoggingSettingsByRuleTypeHttpArgsDict(TypedDict):
        log_all: pulumi.Input[bool]
        """
        Whether to log all activity.
        """
        log_blocks: pulumi.Input[bool]
elif False:
    TeamsAccountLoggingSettingsByRuleTypeHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountLoggingSettingsByRuleTypeHttpArgs:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class TeamsAccountLoggingSettingsByRuleTypeL4ArgsDict(TypedDict):
        log_all: pulumi.Input[bool]
        """
        Whether to log all activity.
        """
        log_blocks: pulumi.Input[bool]
elif False:
    TeamsAccountLoggingSettingsByRuleTypeL4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountLoggingSettingsByRuleTypeL4Args:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class TeamsAccountPayloadLogArgsDict(TypedDict):
        public_key: pulumi.Input[str]
        """
        Public key used to encrypt matched payloads.
        """
elif False:
    TeamsAccountPayloadLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountPayloadLogArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: Public key used to encrypt matched payloads.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        Public key used to encrypt matched payloads.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class TeamsAccountProxyArgsDict(TypedDict):
        disable_for_time: pulumi.Input[int]
        """
        Sets the time limit in seconds that a user can use an override code to bypass WARP.
        """
        root_ca: pulumi.Input[bool]
        """
        Whether root ca is enabled account wide for ZT clients.
        """
        tcp: pulumi.Input[bool]
        """
        Whether gateway proxy is enabled on gateway devices for TCP traffic.
        """
        udp: pulumi.Input[bool]
        """
        Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        virtual_ip: pulumi.Input[bool]
        """
        Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
elif False:
    TeamsAccountProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountProxyArgs:
    def __init__(__self__, *,
                 disable_for_time: pulumi.Input[int],
                 root_ca: pulumi.Input[bool],
                 tcp: pulumi.Input[bool],
                 udp: pulumi.Input[bool],
                 virtual_ip: pulumi.Input[bool]):
        """
        :param pulumi.Input[int] disable_for_time: Sets the time limit in seconds that a user can use an override code to bypass WARP.
        :param pulumi.Input[bool] root_ca: Whether root ca is enabled account wide for ZT clients.
        :param pulumi.Input[bool] tcp: Whether gateway proxy is enabled on gateway devices for TCP traffic.
        :param pulumi.Input[bool] udp: Whether gateway proxy is enabled on gateway devices for UDP traffic.
        :param pulumi.Input[bool] virtual_ip: Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
        pulumi.set(__self__, "disable_for_time", disable_for_time)
        pulumi.set(__self__, "root_ca", root_ca)
        pulumi.set(__self__, "tcp", tcp)
        pulumi.set(__self__, "udp", udp)
        pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="disableForTime")
    def disable_for_time(self) -> pulumi.Input[int]:
        """
        Sets the time limit in seconds that a user can use an override code to bypass WARP.
        """
        return pulumi.get(self, "disable_for_time")

    @disable_for_time.setter
    def disable_for_time(self, value: pulumi.Input[int]):
        pulumi.set(self, "disable_for_time", value)

    @property
    @pulumi.getter(name="rootCa")
    def root_ca(self) -> pulumi.Input[bool]:
        """
        Whether root ca is enabled account wide for ZT clients.
        """
        return pulumi.get(self, "root_ca")

    @root_ca.setter
    def root_ca(self, value: pulumi.Input[bool]):
        pulumi.set(self, "root_ca", value)

    @property
    @pulumi.getter
    def tcp(self) -> pulumi.Input[bool]:
        """
        Whether gateway proxy is enabled on gateway devices for TCP traffic.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter
    def udp(self) -> pulumi.Input[bool]:
        """
        Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "udp", value)

    @property
    @pulumi.getter(name="virtualIp")
    def virtual_ip(self) -> pulumi.Input[bool]:
        """
        Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
        return pulumi.get(self, "virtual_ip")

    @virtual_ip.setter
    def virtual_ip(self, value: pulumi.Input[bool]):
        pulumi.set(self, "virtual_ip", value)


if not MYPY:
    class TeamsAccountSshSessionLogArgsDict(TypedDict):
        public_key: pulumi.Input[str]
        """
        Public key used to encrypt ssh session.
        """
elif False:
    TeamsAccountSshSessionLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSshSessionLogArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: Public key used to encrypt ssh session.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        Public key used to encrypt ssh session.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class TeamsListItemsWithDescriptionArgsDict(TypedDict):
        description: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    TeamsListItemsWithDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsListItemsWithDescriptionArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TeamsLocationNetworkArgsDict(TypedDict):
        network: pulumi.Input[str]
        """
        CIDR notation representation of the network IP.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of this resource.
        """
elif False:
    TeamsLocationNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network: CIDR notation representation of the network IP.
        :param pulumi.Input[str] id: The ID of this resource.
        """
        pulumi.set(__self__, "network", network)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TeamsRuleRuleSettingsArgsDict(TypedDict):
        add_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        allow_child_bypass: NotRequired[pulumi.Input[bool]]
        """
        Allow parent MSP accounts to enable bypass their children's rules.
        """
        audit_ssh: NotRequired[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgsDict']]
        """
        Settings for auditing SSH usage.
        """
        biso_admin_controls: NotRequired[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgsDict']]
        """
        Configure how browser isolation behaves.
        """
        block_page_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicator of block page enablement.
        """
        block_page_reason: NotRequired[pulumi.Input[str]]
        """
        The displayed reason for a user being blocked.
        """
        bypass_parent_rule: NotRequired[pulumi.Input[bool]]
        """
        Allow child MSP accounts to bypass their parent's rule.
        """
        check_session: NotRequired[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgsDict']]
        """
        Configure how session check behaves.
        """
        dns_resolvers: NotRequired[pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgsDict']]
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        """
        egress: NotRequired[pulumi.Input['TeamsRuleRuleSettingsEgressArgsDict']]
        """
        Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        """
        ignore_cname_category_matches: NotRequired[pulumi.Input[bool]]
        """
        Set to true, to ignore the category matches at CNAME domains in a response.
        """
        insecure_disable_dnssec_validation: NotRequired[pulumi.Input[bool]]
        """
        Disable DNSSEC validation (must be Allow rule).
        """
        ip_categories: NotRequired[pulumi.Input[bool]]
        """
        Turns on IP category based filter on dns if the rule contains dns category checks.
        """
        l4override: NotRequired[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgsDict']]
        """
        Settings to forward layer 4 traffic.
        """
        notification_settings: NotRequired[pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgsDict']]
        """
        Notification settings on a block rule.
        """
        override_host: NotRequired[pulumi.Input[str]]
        """
        The host to override matching DNS queries with.
        """
        override_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The IPs to override matching DNS queries with.
        """
        payload_log: NotRequired[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgsDict']]
        """
        Configure DLP Payload Logging settings for this rule.
        """
        resolve_dns_through_cloudflare: NotRequired[pulumi.Input[bool]]
        """
        Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        """
        untrusted_cert: NotRequired[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgsDict']]
        """
        Configure untrusted certificate settings for this rule.
        """
elif False:
    TeamsRuleRuleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsArgs:
    def __init__(__self__, *,
                 add_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allow_child_bypass: Optional[pulumi.Input[bool]] = None,
                 audit_ssh: Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']] = None,
                 biso_admin_controls: Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']] = None,
                 block_page_enabled: Optional[pulumi.Input[bool]] = None,
                 block_page_reason: Optional[pulumi.Input[str]] = None,
                 bypass_parent_rule: Optional[pulumi.Input[bool]] = None,
                 check_session: Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']] = None,
                 dns_resolvers: Optional[pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgs']] = None,
                 egress: Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']] = None,
                 ignore_cname_category_matches: Optional[pulumi.Input[bool]] = None,
                 insecure_disable_dnssec_validation: Optional[pulumi.Input[bool]] = None,
                 ip_categories: Optional[pulumi.Input[bool]] = None,
                 l4override: Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']] = None,
                 notification_settings: Optional[pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgs']] = None,
                 override_host: Optional[pulumi.Input[str]] = None,
                 override_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 payload_log: Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']] = None,
                 resolve_dns_through_cloudflare: Optional[pulumi.Input[bool]] = None,
                 untrusted_cert: Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] add_headers: Add custom headers to allowed requests in the form of key-value pairs.
        :param pulumi.Input[bool] allow_child_bypass: Allow parent MSP accounts to enable bypass their children's rules.
        :param pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs'] audit_ssh: Settings for auditing SSH usage.
        :param pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs'] biso_admin_controls: Configure how browser isolation behaves.
        :param pulumi.Input[bool] block_page_enabled: Indicator of block page enablement.
        :param pulumi.Input[str] block_page_reason: The displayed reason for a user being blocked.
        :param pulumi.Input[bool] bypass_parent_rule: Allow child MSP accounts to bypass their parent's rule.
        :param pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs'] check_session: Configure how session check behaves.
        :param pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgs'] dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        :param pulumi.Input['TeamsRuleRuleSettingsEgressArgs'] egress: Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        :param pulumi.Input[bool] ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response.
        :param pulumi.Input[bool] insecure_disable_dnssec_validation: Disable DNSSEC validation (must be Allow rule).
        :param pulumi.Input[bool] ip_categories: Turns on IP category based filter on dns if the rule contains dns category checks.
        :param pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs'] l4override: Settings to forward layer 4 traffic.
        :param pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgs'] notification_settings: Notification settings on a block rule.
        :param pulumi.Input[str] override_host: The host to override matching DNS queries with.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] override_ips: The IPs to override matching DNS queries with.
        :param pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs'] payload_log: Configure DLP Payload Logging settings for this rule.
        :param pulumi.Input[bool] resolve_dns_through_cloudflare: Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        :param pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs'] untrusted_cert: Configure untrusted certificate settings for this rule.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_page_reason is not None:
            pulumi.set(__self__, "block_page_reason", block_page_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if dns_resolvers is not None:
            pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ignore_cname_category_matches is not None:
            pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if resolve_dns_through_cloudflare is not None:
            pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        return pulumi.get(self, "add_headers")

    @add_headers.setter
    def add_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "add_headers", value)

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow parent MSP accounts to enable bypass their children's rules.
        """
        return pulumi.get(self, "allow_child_bypass")

    @allow_child_bypass.setter
    def allow_child_bypass(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_child_bypass", value)

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']]:
        """
        Settings for auditing SSH usage.
        """
        return pulumi.get(self, "audit_ssh")

    @audit_ssh.setter
    def audit_ssh(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']]):
        pulumi.set(self, "audit_ssh", value)

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']]:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @biso_admin_controls.setter
    def biso_admin_controls(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']]):
        pulumi.set(self, "biso_admin_controls", value)

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicator of block page enablement.
        """
        return pulumi.get(self, "block_page_enabled")

    @block_page_enabled.setter
    def block_page_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_page_enabled", value)

    @property
    @pulumi.getter(name="blockPageReason")
    def block_page_reason(self) -> Optional[pulumi.Input[str]]:
        """
        The displayed reason for a user being blocked.
        """
        return pulumi.get(self, "block_page_reason")

    @block_page_reason.setter
    def block_page_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_page_reason", value)

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow child MSP accounts to bypass their parent's rule.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @bypass_parent_rule.setter
    def bypass_parent_rule(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_parent_rule", value)

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']]:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @check_session.setter
    def check_session(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']]):
        pulumi.set(self, "check_session", value)

    @property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgs']]:
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        """
        return pulumi.get(self, "dns_resolvers")

    @dns_resolvers.setter
    def dns_resolvers(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgs']]):
        pulumi.set(self, "dns_resolvers", value)

    @property
    @pulumi.getter
    def egress(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']]:
        """
        Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        """
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']]):
        pulumi.set(self, "egress", value)

    @property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true, to ignore the category matches at CNAME domains in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @ignore_cname_category_matches.setter
    def ignore_cname_category_matches(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_cname_category_matches", value)

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable DNSSEC validation (must be Allow rule).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @insecure_disable_dnssec_validation.setter
    def insecure_disable_dnssec_validation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_disable_dnssec_validation", value)

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[pulumi.Input[bool]]:
        """
        Turns on IP category based filter on dns if the rule contains dns category checks.
        """
        return pulumi.get(self, "ip_categories")

    @ip_categories.setter
    def ip_categories(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_categories", value)

    @property
    @pulumi.getter
    def l4override(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']]:
        """
        Settings to forward layer 4 traffic.
        """
        return pulumi.get(self, "l4override")

    @l4override.setter
    def l4override(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']]):
        pulumi.set(self, "l4override", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgs']]:
        """
        Notification settings on a block rule.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[pulumi.Input[str]]:
        """
        The host to override matching DNS queries with.
        """
        return pulumi.get(self, "override_host")

    @override_host.setter
    def override_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_host", value)

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The IPs to override matching DNS queries with.
        """
        return pulumi.get(self, "override_ips")

    @override_ips.setter
    def override_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "override_ips", value)

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']]:
        """
        Configure DLP Payload Logging settings for this rule.
        """
        return pulumi.get(self, "payload_log")

    @payload_log.setter
    def payload_log(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']]):
        pulumi.set(self, "payload_log", value)

    @property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @resolve_dns_through_cloudflare.setter
    def resolve_dns_through_cloudflare(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolve_dns_through_cloudflare", value)

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']]:
        """
        Configure untrusted certificate settings for this rule.
        """
        return pulumi.get(self, "untrusted_cert")

    @untrusted_cert.setter
    def untrusted_cert(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']]):
        pulumi.set(self, "untrusted_cert", value)


if not MYPY:
    class TeamsRuleRuleSettingsAuditSshArgsDict(TypedDict):
        command_logging: pulumi.Input[bool]
        """
        Log all SSH commands.
        """
elif False:
    TeamsRuleRuleSettingsAuditSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsAuditSshArgs:
    def __init__(__self__, *,
                 command_logging: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] command_logging: Log all SSH commands.
        """
        pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> pulumi.Input[bool]:
        """
        Log all SSH commands.
        """
        return pulumi.get(self, "command_logging")

    @command_logging.setter
    def command_logging(self, value: pulumi.Input[bool]):
        pulumi.set(self, "command_logging", value)


if not MYPY:
    class TeamsRuleRuleSettingsBisoAdminControlsArgsDict(TypedDict):
        disable_clipboard_redirection: NotRequired[pulumi.Input[bool]]
        """
        Disable clipboard redirection.
        """
        disable_copy_paste: NotRequired[pulumi.Input[bool]]
        """
        Disable copy-paste.
        """
        disable_download: NotRequired[pulumi.Input[bool]]
        """
        Disable download.
        """
        disable_keyboard: NotRequired[pulumi.Input[bool]]
        """
        Disable keyboard usage.
        """
        disable_printing: NotRequired[pulumi.Input[bool]]
        """
        Disable printing.
        """
        disable_upload: NotRequired[pulumi.Input[bool]]
        """
        Disable upload.
        """
elif False:
    TeamsRuleRuleSettingsBisoAdminControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsBisoAdminControlsArgs:
    def __init__(__self__, *,
                 disable_clipboard_redirection: Optional[pulumi.Input[bool]] = None,
                 disable_copy_paste: Optional[pulumi.Input[bool]] = None,
                 disable_download: Optional[pulumi.Input[bool]] = None,
                 disable_keyboard: Optional[pulumi.Input[bool]] = None,
                 disable_printing: Optional[pulumi.Input[bool]] = None,
                 disable_upload: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable_clipboard_redirection: Disable clipboard redirection.
        :param pulumi.Input[bool] disable_copy_paste: Disable copy-paste.
        :param pulumi.Input[bool] disable_download: Disable download.
        :param pulumi.Input[bool] disable_keyboard: Disable keyboard usage.
        :param pulumi.Input[bool] disable_printing: Disable printing.
        :param pulumi.Input[bool] disable_upload: Disable upload.
        """
        if disable_clipboard_redirection is not None:
            pulumi.set(__self__, "disable_clipboard_redirection", disable_clipboard_redirection)
        if disable_copy_paste is not None:
            pulumi.set(__self__, "disable_copy_paste", disable_copy_paste)
        if disable_download is not None:
            pulumi.set(__self__, "disable_download", disable_download)
        if disable_keyboard is not None:
            pulumi.set(__self__, "disable_keyboard", disable_keyboard)
        if disable_printing is not None:
            pulumi.set(__self__, "disable_printing", disable_printing)
        if disable_upload is not None:
            pulumi.set(__self__, "disable_upload", disable_upload)

    @property
    @pulumi.getter(name="disableClipboardRedirection")
    def disable_clipboard_redirection(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable clipboard redirection.
        """
        return pulumi.get(self, "disable_clipboard_redirection")

    @disable_clipboard_redirection.setter
    def disable_clipboard_redirection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_clipboard_redirection", value)

    @property
    @pulumi.getter(name="disableCopyPaste")
    def disable_copy_paste(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable copy-paste.
        """
        return pulumi.get(self, "disable_copy_paste")

    @disable_copy_paste.setter
    def disable_copy_paste(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_copy_paste", value)

    @property
    @pulumi.getter(name="disableDownload")
    def disable_download(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable download.
        """
        return pulumi.get(self, "disable_download")

    @disable_download.setter
    def disable_download(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_download", value)

    @property
    @pulumi.getter(name="disableKeyboard")
    def disable_keyboard(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable keyboard usage.
        """
        return pulumi.get(self, "disable_keyboard")

    @disable_keyboard.setter
    def disable_keyboard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_keyboard", value)

    @property
    @pulumi.getter(name="disablePrinting")
    def disable_printing(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable printing.
        """
        return pulumi.get(self, "disable_printing")

    @disable_printing.setter
    def disable_printing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_printing", value)

    @property
    @pulumi.getter(name="disableUpload")
    def disable_upload(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable upload.
        """
        return pulumi.get(self, "disable_upload")

    @disable_upload.setter
    def disable_upload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_upload", value)


if not MYPY:
    class TeamsRuleRuleSettingsCheckSessionArgsDict(TypedDict):
        duration: pulumi.Input[str]
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        enforce: pulumi.Input[bool]
        """
        Enable session enforcement for this rule.
        """
elif False:
    TeamsRuleRuleSettingsCheckSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsCheckSessionArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 enforce: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] duration: Configure how fresh the session needs to be to be considered valid.
        :param pulumi.Input[bool] enforce: Enable session enforcement for this rule.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def enforce(self) -> pulumi.Input[bool]:
        """
        Enable session enforcement for this rule.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enforce", value)


if not MYPY:
    class TeamsRuleRuleSettingsDnsResolversArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4ArgsDict']]]]
        """
        IPv4 resolvers.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6ArgsDict']]]]
        """
        IPv6 resolvers.
        """
elif False:
    TeamsRuleRuleSettingsDnsResolversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsDnsResolversArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4Args']]] ipv4s: IPv4 resolvers.
        :param pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6Args']]] ipv6s: IPv6 resolvers.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4Args']]]]:
        """
        IPv4 resolvers.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6Args']]]]:
        """
        IPv6 resolvers.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class TeamsRuleRuleSettingsDnsResolversIpv4ArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        route_through_private_network: NotRequired[pulumi.Input[bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    TeamsRuleRuleSettingsDnsResolversIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsDnsResolversIpv4Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 route_through_private_network: Optional[pulumi.Input[bool]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: The IPv4 or IPv6 address of the upstream resolver.
        :param pulumi.Input[int] port: A port number to use for the upstream resolver. Defaults to `53`.
        :param pulumi.Input[bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        :param pulumi.Input[str] vnet_id: specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class TeamsRuleRuleSettingsDnsResolversIpv6ArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        route_through_private_network: NotRequired[pulumi.Input[bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    TeamsRuleRuleSettingsDnsResolversIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsDnsResolversIpv6Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 route_through_private_network: Optional[pulumi.Input[bool]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: The IPv4 or IPv6 address of the upstream resolver.
        :param pulumi.Input[int] port: A port number to use for the upstream resolver. Defaults to `53`.
        :param pulumi.Input[bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        :param pulumi.Input[str] vnet_id: specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class TeamsRuleRuleSettingsEgressArgsDict(TypedDict):
        ipv4: pulumi.Input[str]
        """
        The IPv4 address to be used for egress.
        """
        ipv6: pulumi.Input[str]
        """
        The IPv6 range to be used for egress.
        """
        ipv4_fallback: NotRequired[pulumi.Input[str]]
        """
        The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
elif False:
    TeamsRuleRuleSettingsEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsEgressArgs:
    def __init__(__self__, *,
                 ipv4: pulumi.Input[str],
                 ipv6: pulumi.Input[str],
                 ipv4_fallback: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv4: The IPv4 address to be used for egress.
        :param pulumi.Input[str] ipv6: The IPv6 range to be used for egress.
        :param pulumi.Input[str] ipv4_fallback: The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)

    @property
    @pulumi.getter
    def ipv4(self) -> pulumi.Input[str]:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> pulumi.Input[str]:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @ipv4_fallback.setter
    def ipv4_fallback(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_fallback", value)


if not MYPY:
    class TeamsRuleRuleSettingsL4overrideArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        Override IP to forward traffic to.
        """
        port: pulumi.Input[int]
        """
        Override Port to forward traffic to.
        """
elif False:
    TeamsRuleRuleSettingsL4overrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsL4overrideArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: pulumi.Input[int]):
        """
        :param pulumi.Input[str] ip: Override IP to forward traffic to.
        :param pulumi.Input[int] port: Override Port to forward traffic to.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        Override IP to forward traffic to.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Override Port to forward traffic to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class TeamsRuleRuleSettingsNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification settings.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Notification content.
        """
        support_url: NotRequired[pulumi.Input[str]]
        """
        Support URL to show in the notification.
        """
elif False:
    TeamsRuleRuleSettingsNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 support_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification settings.
        :param pulumi.Input[str] message: Notification content.
        :param pulumi.Input[str] support_url: Support URL to show in the notification.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Notification content.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[str]]:
        """
        Support URL to show in the notification.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class TeamsRuleRuleSettingsPayloadLogArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Enable or disable DLP Payload Logging for this rule.
        """
elif False:
    TeamsRuleRuleSettingsPayloadLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsPayloadLogArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Enable or disable DLP Payload Logging for this rule.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Enable or disable DLP Payload Logging for this rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamsRuleRuleSettingsUntrustedCertArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
elif False:
    TeamsRuleRuleSettingsUntrustedCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsUntrustedCertArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class TunnelConfigConfigArgsDict(TypedDict):
        ingress_rules: pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgsDict']]]
        """
        Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        """
        origin_request: NotRequired[pulumi.Input['TunnelConfigConfigOriginRequestArgsDict']]
        warp_routing: NotRequired[pulumi.Input['TunnelConfigConfigWarpRoutingArgsDict']]
        """
        If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
elif False:
    TunnelConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigArgs:
    def __init__(__self__, *,
                 ingress_rules: pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]],
                 origin_request: Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']] = None,
                 warp_routing: Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]] ingress_rules: Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        :param pulumi.Input['TunnelConfigConfigWarpRoutingArgs'] warp_routing: If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        pulumi.set(__self__, "ingress_rules", ingress_rules)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @property
    @pulumi.getter(name="ingressRules")
    def ingress_rules(self) -> pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]]:
        """
        Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        """
        return pulumi.get(self, "ingress_rules")

    @ingress_rules.setter
    def ingress_rules(self, value: pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]]):
        pulumi.set(self, "ingress_rules", value)

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']]:
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']]:
        """
        If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        return pulumi.get(self, "warp_routing")

    @warp_routing.setter
    def warp_routing(self, value: Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']]):
        pulumi.set(self, "warp_routing", value)


if not MYPY:
    class TunnelConfigConfigIngressRuleArgsDict(TypedDict):
        service: pulumi.Input[str]
        """
        Name of the service to which the request will be sent.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        """
        origin_request: NotRequired[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestArgsDict']]
        path: NotRequired[pulumi.Input[str]]
        """
        Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
elif False:
    TunnelConfigConfigIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigIngressRuleArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 hostname: Optional[pulumi.Input[str]] = None,
                 origin_request: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestArgs']] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service: Name of the service to which the request will be sent.
        :param pulumi.Input[str] hostname: Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        :param pulumi.Input[str] path: Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Name of the service to which the request will be sent.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestArgs']]:
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TunnelConfigConfigIngressRuleOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgsDict']]
        """
        Access rules for the ingress service.
        """
        bastion_mode: NotRequired[pulumi.Input[bool]]
        """
        Runs as jump host.
        """
        ca_pool: NotRequired[pulumi.Input[str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        connect_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        http2_origin: NotRequired[pulumi.Input[bool]]
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        http_host_header: NotRequired[pulumi.Input[str]]
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        ip_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgsDict']]]]
        """
        IP rules for the proxy service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        no_tls_verify: NotRequired[pulumi.Input[bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        origin_server_name: NotRequired[pulumi.Input[str]]
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        proxy_address: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        proxy_port: NotRequired[pulumi.Input[int]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        proxy_type: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[str]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        tls_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
elif False:
    TunnelConfigConfigIngressRuleOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigIngressRuleOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs']] = None,
                 bastion_mode: Optional[pulumi.Input[bool]] = None,
                 ca_pool: Optional[pulumi.Input[str]] = None,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
                 http2_origin: Optional[pulumi.Input[bool]] = None,
                 http_host_header: Optional[pulumi.Input[str]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]]] = None,
                 keep_alive_connections: Optional[pulumi.Input[int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[str]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None,
                 origin_server_name: Optional[pulumi.Input[str]] = None,
                 proxy_address: Optional[pulumi.Input[str]] = None,
                 proxy_port: Optional[pulumi.Input[int]] = None,
                 proxy_type: Optional[pulumi.Input[str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[str]] = None,
                 tls_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs'] access: Access rules for the ingress service.
        :param pulumi.Input[bool] bastion_mode: Runs as jump host.
        :param pulumi.Input[str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param pulumi.Input[str] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param pulumi.Input[bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param pulumi.Input[bool] http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param pulumi.Input[str] http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]] ip_rules: IP rules for the proxy service.
        :param pulumi.Input[int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param pulumi.Input[str] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param pulumi.Input[bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param pulumi.Input[bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param pulumi.Input[str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param pulumi.Input[str] proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param pulumi.Input[int] proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param pulumi.Input[str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param pulumi.Input[str] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param pulumi.Input[str] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs']]:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @bastion_mode.setter
    def bastion_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bastion_mode", value)

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_pool", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_origin", value)

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_host_header", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]]]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_server_name", value)

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @proxy_address.setter
    def proxy_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_address", value)

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[pulumi.Input[int]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @proxy_port.setter
    def proxy_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "proxy_port", value)

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_type", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class TunnelConfigConfigIngressRuleOriginRequestAccessArgsDict(TypedDict):
        aud_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Audience tags of the access rule.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Whether the access rule is required.
        """
        team_name: NotRequired[pulumi.Input[str]]
        """
        Name of the team to which the access rule applies.
        """
elif False:
    TunnelConfigConfigIngressRuleOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigIngressRuleOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 team_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aud_tags: Audience tags of the access rule.
        :param pulumi.Input[bool] required: Whether the access rule is required.
        :param pulumi.Input[str] team_name: Name of the team to which the access rule applies.
        """
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aud_tags", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)


if not MYPY:
    class TunnelConfigConfigIngressRuleOriginRequestIpRuleArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow the IP prefix.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Ports to use within the IP rule.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        IP rule prefix.
        """
elif False:
    TunnelConfigConfigIngressRuleOriginRequestIpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow: Whether to allow the IP prefix.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: Ports to use within the IP rule.
        :param pulumi.Input[str] prefix: IP rule prefix.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class TunnelConfigConfigOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgsDict']]
        """
        Access rules for the ingress service.
        """
        bastion_mode: NotRequired[pulumi.Input[bool]]
        """
        Runs as jump host.
        """
        ca_pool: NotRequired[pulumi.Input[str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        connect_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        http2_origin: NotRequired[pulumi.Input[bool]]
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        http_host_header: NotRequired[pulumi.Input[str]]
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        ip_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgsDict']]]]
        """
        IP rules for the proxy service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        no_tls_verify: NotRequired[pulumi.Input[bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        origin_server_name: NotRequired[pulumi.Input[str]]
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        proxy_address: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        proxy_port: NotRequired[pulumi.Input[int]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        proxy_type: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[str]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        tls_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
elif False:
    TunnelConfigConfigOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']] = None,
                 bastion_mode: Optional[pulumi.Input[bool]] = None,
                 ca_pool: Optional[pulumi.Input[str]] = None,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
                 http2_origin: Optional[pulumi.Input[bool]] = None,
                 http_host_header: Optional[pulumi.Input[str]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]]] = None,
                 keep_alive_connections: Optional[pulumi.Input[int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[str]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None,
                 origin_server_name: Optional[pulumi.Input[str]] = None,
                 proxy_address: Optional[pulumi.Input[str]] = None,
                 proxy_port: Optional[pulumi.Input[int]] = None,
                 proxy_type: Optional[pulumi.Input[str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[str]] = None,
                 tls_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs'] access: Access rules for the ingress service.
        :param pulumi.Input[bool] bastion_mode: Runs as jump host.
        :param pulumi.Input[str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param pulumi.Input[str] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param pulumi.Input[bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param pulumi.Input[bool] http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param pulumi.Input[str] http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]] ip_rules: IP rules for the proxy service.
        :param pulumi.Input[int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param pulumi.Input[str] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param pulumi.Input[bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param pulumi.Input[bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param pulumi.Input[str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param pulumi.Input[str] proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param pulumi.Input[int] proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param pulumi.Input[str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param pulumi.Input[str] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param pulumi.Input[str] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']]:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @bastion_mode.setter
    def bastion_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bastion_mode", value)

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_pool", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_origin", value)

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_host_header", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]]]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_server_name", value)

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @proxy_address.setter
    def proxy_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_address", value)

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[pulumi.Input[int]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @proxy_port.setter
    def proxy_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "proxy_port", value)

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_type", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class TunnelConfigConfigOriginRequestAccessArgsDict(TypedDict):
        aud_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Audience tags of the access rule.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Whether the access rule is required.
        """
        team_name: NotRequired[pulumi.Input[str]]
        """
        Name of the team to which the access rule applies.
        """
elif False:
    TunnelConfigConfigOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 team_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aud_tags: Audience tags of the access rule.
        :param pulumi.Input[bool] required: Whether the access rule is required.
        :param pulumi.Input[str] team_name: Name of the team to which the access rule applies.
        """
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aud_tags", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)


if not MYPY:
    class TunnelConfigConfigOriginRequestIpRuleArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow the IP prefix.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Ports to use within the IP rule.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        IP rule prefix.
        """
elif False:
    TunnelConfigConfigOriginRequestIpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigOriginRequestIpRuleArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow: Whether to allow the IP prefix.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: Ports to use within the IP rule.
        :param pulumi.Input[str] prefix: IP rule prefix.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class TunnelConfigConfigWarpRoutingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether WARP routing is enabled.
        """
elif False:
    TunnelConfigConfigWarpRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigWarpRoutingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether WARP routing is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether WARP routing is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class UserAgentBlockingRuleConfigurationArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        """
        value: pulumi.Input[str]
        """
        The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
elif False:
    UserAgentBlockingRuleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAgentBlockingRuleConfigurationArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target: The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        :param pulumi.Input[str] value: The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WaitingRoomAdditionalRouteArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        The additional host name for which the waiting room to be applied on (no wildcards).
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
elif False:
    WaitingRoomAdditionalRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomAdditionalRouteArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The additional host name for which the waiting room to be applied on (no wildcards).
        :param pulumi.Input[str] path: The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
        pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The additional host name for which the waiting room to be applied on (no wildcards).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class WaitingRoomRulesRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        """
        expression: pulumi.Input[str]
        """
        Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Brief summary of the waiting room rule and its intended use.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique rule identifier.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the waiting room rule.
        """
elif False:
    WaitingRoomRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomRulesRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 expression: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        :param pulumi.Input[str] expression: Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        :param pulumi.Input[str] description: Brief summary of the waiting room rule and its intended use.
        :param pulumi.Input[str] id: Unique rule identifier.
        :param pulumi.Input[str] status: Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        :param pulumi.Input[str] version: Version of the waiting room rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Brief summary of the waiting room rule and its intended use.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the waiting room rule.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class WorkerScriptAnalyticsEngineBindingArgsDict(TypedDict):
        dataset: pulumi.Input[str]
        """
        The name of the Analytics Engine dataset to write to.
        """
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
elif False:
    WorkerScriptAnalyticsEngineBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptAnalyticsEngineBindingArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset: The name of the Analytics Engine dataset to write to.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input[str]:
        """
        The name of the Analytics Engine dataset to write to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkerScriptD1DatabaseBindingArgsDict(TypedDict):
        database_id: pulumi.Input[str]
        """
        Database ID of D1 database to use.
        """
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
elif False:
    WorkerScriptD1DatabaseBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptD1DatabaseBindingArgs:
    def __init__(__self__, *,
                 database_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_id: Database ID of D1 database to use.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> pulumi.Input[str]:
        """
        Database ID of D1 database to use.
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkerScriptHyperdriveConfigBindingArgsDict(TypedDict):
        binding: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        id: pulumi.Input[str]
        """
        The ID of the Hyperdrive config to use.
        """
elif False:
    WorkerScriptHyperdriveConfigBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptHyperdriveConfigBindingArgs:
    def __init__(__self__, *,
                 binding: pulumi.Input[str],
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] binding: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] id: The ID of the Hyperdrive config to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def binding(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @binding.setter
    def binding(self, value: pulumi.Input[str]):
        pulumi.set(self, "binding", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Hyperdrive config to use.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class WorkerScriptKvNamespaceBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        namespace_id: pulumi.Input[str]
        """
        ID of the KV namespace you want to use.
        """
elif False:
    WorkerScriptKvNamespaceBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptKvNamespaceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] namespace_id: ID of the KV namespace you want to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> pulumi.Input[str]:
        """
        ID of the KV namespace you want to use.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class WorkerScriptPlacementArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        The placement mode for the Worker. Available values: `smart`.
        """
elif False:
    WorkerScriptPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptPlacementArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mode: The placement mode for the Worker. Available values: `smart`.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The placement mode for the Worker. Available values: `smart`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class WorkerScriptPlainTextBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        text: pulumi.Input[str]
        """
        The plain text you want to store.
        """
elif False:
    WorkerScriptPlainTextBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptPlainTextBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] text: The plain text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The plain text you want to store.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class WorkerScriptQueueBindingArgsDict(TypedDict):
        binding: pulumi.Input[str]
        """
        The name of the global variable for the binding in your Worker code.
        """
        queue: pulumi.Input[str]
        """
        Name of the queue you want to use.
        """
elif False:
    WorkerScriptQueueBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptQueueBindingArgs:
    def __init__(__self__, *,
                 binding: pulumi.Input[str],
                 queue: pulumi.Input[str]):
        """
        :param pulumi.Input[str] binding: The name of the global variable for the binding in your Worker code.
        :param pulumi.Input[str] queue: Name of the queue you want to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "queue", queue)

    @property
    @pulumi.getter
    def binding(self) -> pulumi.Input[str]:
        """
        The name of the global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @binding.setter
    def binding(self, value: pulumi.Input[str]):
        pulumi.set(self, "binding", value)

    @property
    @pulumi.getter
    def queue(self) -> pulumi.Input[str]:
        """
        Name of the queue you want to use.
        """
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue", value)


if not MYPY:
    class WorkerScriptR2BucketBindingArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        The name of the Bucket to bind to.
        """
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
elif False:
    WorkerScriptR2BucketBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptR2BucketBindingArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket_name: The name of the Bucket to bind to.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the Bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkerScriptSecretTextBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        text: pulumi.Input[str]
        """
        The secret text you want to store.
        """
elif False:
    WorkerScriptSecretTextBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptSecretTextBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] text: The secret text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The secret text you want to store.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class WorkerScriptServiceBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        service: pulumi.Input[str]
        """
        The name of the Worker to bind to.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        The name of the Worker environment to bind to.
        """
elif False:
    WorkerScriptServiceBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptServiceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] service: The name of the Worker to bind to.
        :param pulumi.Input[str] environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)


if not MYPY:
    class WorkerScriptWebassemblyBindingArgsDict(TypedDict):
        module: pulumi.Input[str]
        """
        The base64 encoded wasm module you want to store.
        """
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
elif False:
    WorkerScriptWebassemblyBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptWebassemblyBindingArgs:
    def __init__(__self__, *,
                 module: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] module: The base64 encoded wasm module you want to store.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "module", module)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def module(self) -> pulumi.Input[str]:
        """
        The base64 encoded wasm module you want to store.
        """
        return pulumi.get(self, "module")

    @module.setter
    def module(self, value: pulumi.Input[str]):
        pulumi.set(self, "module", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkersScriptAnalyticsEngineBindingArgsDict(TypedDict):
        dataset: pulumi.Input[str]
        """
        The name of the Analytics Engine dataset to write to.
        """
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
elif False:
    WorkersScriptAnalyticsEngineBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptAnalyticsEngineBindingArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset: The name of the Analytics Engine dataset to write to.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input[str]:
        """
        The name of the Analytics Engine dataset to write to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkersScriptD1DatabaseBindingArgsDict(TypedDict):
        database_id: pulumi.Input[str]
        """
        Database ID of D1 database to use.
        """
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
elif False:
    WorkersScriptD1DatabaseBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptD1DatabaseBindingArgs:
    def __init__(__self__, *,
                 database_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_id: Database ID of D1 database to use.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> pulumi.Input[str]:
        """
        Database ID of D1 database to use.
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkersScriptHyperdriveConfigBindingArgsDict(TypedDict):
        binding: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        id: pulumi.Input[str]
        """
        The ID of the Hyperdrive config to use.
        """
elif False:
    WorkersScriptHyperdriveConfigBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptHyperdriveConfigBindingArgs:
    def __init__(__self__, *,
                 binding: pulumi.Input[str],
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] binding: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] id: The ID of the Hyperdrive config to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def binding(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @binding.setter
    def binding(self, value: pulumi.Input[str]):
        pulumi.set(self, "binding", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Hyperdrive config to use.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class WorkersScriptKvNamespaceBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        namespace_id: pulumi.Input[str]
        """
        ID of the KV namespace you want to use.
        """
elif False:
    WorkersScriptKvNamespaceBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptKvNamespaceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] namespace_id: ID of the KV namespace you want to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> pulumi.Input[str]:
        """
        ID of the KV namespace you want to use.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class WorkersScriptPlacementArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        The placement mode for the Worker. Available values: `smart`.
        """
elif False:
    WorkersScriptPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptPlacementArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mode: The placement mode for the Worker. Available values: `smart`.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The placement mode for the Worker. Available values: `smart`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class WorkersScriptPlainTextBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        text: pulumi.Input[str]
        """
        The plain text you want to store.
        """
elif False:
    WorkersScriptPlainTextBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptPlainTextBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] text: The plain text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The plain text you want to store.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class WorkersScriptQueueBindingArgsDict(TypedDict):
        binding: pulumi.Input[str]
        """
        The name of the global variable for the binding in your Worker code.
        """
        queue: pulumi.Input[str]
        """
        Name of the queue you want to use.
        """
elif False:
    WorkersScriptQueueBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptQueueBindingArgs:
    def __init__(__self__, *,
                 binding: pulumi.Input[str],
                 queue: pulumi.Input[str]):
        """
        :param pulumi.Input[str] binding: The name of the global variable for the binding in your Worker code.
        :param pulumi.Input[str] queue: Name of the queue you want to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "queue", queue)

    @property
    @pulumi.getter
    def binding(self) -> pulumi.Input[str]:
        """
        The name of the global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @binding.setter
    def binding(self, value: pulumi.Input[str]):
        pulumi.set(self, "binding", value)

    @property
    @pulumi.getter
    def queue(self) -> pulumi.Input[str]:
        """
        Name of the queue you want to use.
        """
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue", value)


if not MYPY:
    class WorkersScriptR2BucketBindingArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        The name of the Bucket to bind to.
        """
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
elif False:
    WorkersScriptR2BucketBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptR2BucketBindingArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket_name: The name of the Bucket to bind to.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the Bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkersScriptSecretTextBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        text: pulumi.Input[str]
        """
        The secret text you want to store.
        """
elif False:
    WorkersScriptSecretTextBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptSecretTextBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] text: The secret text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The secret text you want to store.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class WorkersScriptServiceBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
        service: pulumi.Input[str]
        """
        The name of the Worker to bind to.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        The name of the Worker environment to bind to.
        """
elif False:
    WorkersScriptServiceBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptServiceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] service: The name of the Worker to bind to.
        :param pulumi.Input[str] environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)


if not MYPY:
    class WorkersScriptWebassemblyBindingArgsDict(TypedDict):
        module: pulumi.Input[str]
        """
        The base64 encoded wasm module you want to store.
        """
        name: pulumi.Input[str]
        """
        The global variable for the binding in your Worker code.
        """
elif False:
    WorkersScriptWebassemblyBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptWebassemblyBindingArgs:
    def __init__(__self__, *,
                 module: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] module: The base64 encoded wasm module you want to store.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "module", module)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def module(self) -> pulumi.Input[str]:
        """
        The base64 encoded wasm module you want to store.
        """
        return pulumi.get(self, "module")

    @module.setter
    def module(self, value: pulumi.Input[str]):
        pulumi.set(self, "module", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessApplicationCorsHeaderArgsDict(TypedDict):
        allow_all_headers: NotRequired[pulumi.Input[bool]]
        """
        Value to determine whether all HTTP headers are exposed.
        """
        allow_all_methods: NotRequired[pulumi.Input[bool]]
        """
        Value to determine whether all methods are exposed.
        """
        allow_all_origins: NotRequired[pulumi.Input[bool]]
        """
        Value to determine whether all origins are permitted to make CORS requests.
        """
        allow_credentials: NotRequired[pulumi.Input[bool]]
        """
        Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of HTTP headers to expose via CORS.
        """
        allowed_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of methods to expose via CORS.
        """
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of origins permitted to make CORS requests.
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        The maximum time a preflight request will be cached.
        """
elif False:
    ZeroTrustAccessApplicationCorsHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationCorsHeaderArgs:
    def __init__(__self__, *,
                 allow_all_headers: Optional[pulumi.Input[bool]] = None,
                 allow_all_methods: Optional[pulumi.Input[bool]] = None,
                 allow_all_origins: Optional[pulumi.Input[bool]] = None,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_all_headers: Value to determine whether all HTTP headers are exposed.
        :param pulumi.Input[bool] allow_all_methods: Value to determine whether all methods are exposed.
        :param pulumi.Input[bool] allow_all_origins: Value to determine whether all origins are permitted to make CORS requests.
        :param pulumi.Input[bool] allow_credentials: Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: List of HTTP headers to expose via CORS.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: List of methods to expose via CORS.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: List of origins permitted to make CORS requests.
        :param pulumi.Input[int] max_age: The maximum time a preflight request will be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all HTTP headers are exposed.
        """
        return pulumi.get(self, "allow_all_headers")

    @allow_all_headers.setter
    def allow_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_headers", value)

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all methods are exposed.
        """
        return pulumi.get(self, "allow_all_methods")

    @allow_all_methods.setter
    def allow_all_methods(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_methods", value)

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all origins are permitted to make CORS requests.
        """
        return pulumi.get(self, "allow_all_origins")

    @allow_all_origins.setter
    def allow_all_origins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_origins", value)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of HTTP headers to expose via CORS.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of methods to expose via CORS.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of origins permitted to make CORS requests.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum time a preflight request will be cached.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class ZeroTrustAccessApplicationDestinationArgsDict(TypedDict):
        uri: pulumi.Input[str]
        """
        The URI of the destination. Public destinations can include a domain and path with wildcards. Private destinations are an early access feature and gated behind a feature flag. Private destinations support private IPv4, IPv6, and Server Name Indications (SNI) with optional port ranges.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The destination type. Available values: `public`, `private`. Defaults to `public`.
        """
elif False:
    ZeroTrustAccessApplicationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationDestinationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: The URI of the destination. Public destinations can include a domain and path with wildcards. Private destinations are an early access feature and gated behind a feature flag. Private destinations support private IPv4, IPv6, and Server Name Indications (SNI) with optional port ranges.
        :param pulumi.Input[str] type: The destination type. Available values: `public`, `private`. Defaults to `public`.
        """
        pulumi.set(__self__, "uri", uri)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI of the destination. Public destinations can include a domain and path with wildcards. Private destinations are an early access feature and gated behind a feature flag. Private destinations support private IPv4, IPv6, and Server Name Indications (SNI) with optional port ranges.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The destination type. Available values: `public`, `private`. Defaults to `public`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ZeroTrustAccessApplicationFooterLinkArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the footer link.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL of the footer link.
        """
elif False:
    ZeroTrustAccessApplicationFooterLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationFooterLinkArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the footer link.
        :param pulumi.Input[str] url: The URL of the footer link.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the footer link.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the footer link.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ZeroTrustAccessApplicationLandingPageDesignArgsDict(TypedDict):
        button_color: NotRequired[pulumi.Input[str]]
        """
        The button color of the landing page.
        """
        button_text_color: NotRequired[pulumi.Input[str]]
        """
        The button text color of the landing page.
        """
        image_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the image to be displayed in the landing page.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The message of the landing page.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The title of the landing page.
        """
elif False:
    ZeroTrustAccessApplicationLandingPageDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationLandingPageDesignArgs:
    def __init__(__self__, *,
                 button_color: Optional[pulumi.Input[str]] = None,
                 button_text_color: Optional[pulumi.Input[str]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] button_color: The button color of the landing page.
        :param pulumi.Input[str] button_text_color: The button text color of the landing page.
        :param pulumi.Input[str] image_url: The URL of the image to be displayed in the landing page.
        :param pulumi.Input[str] message: The message of the landing page.
        :param pulumi.Input[str] title: The title of the landing page.
        """
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[pulumi.Input[str]]:
        """
        The button color of the landing page.
        """
        return pulumi.get(self, "button_color")

    @button_color.setter
    def button_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_color", value)

    @property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[pulumi.Input[str]]:
        """
        The button text color of the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @button_text_color.setter
    def button_text_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text_color", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the image to be displayed in the landing page.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The message of the landing page.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the landing page.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppArgsDict(TypedDict):
        access_token_lifetime: NotRequired[pulumi.Input[str]]
        """
        The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        allow_pkce_without_client_secret: NotRequired[pulumi.Input[bool]]
        """
        Allow PKCE flow without a client secret.
        """
        app_launcher_url: NotRequired[pulumi.Input[str]]
        """
        The URL where this applications tile redirects users.
        """
        auth_type: NotRequired[pulumi.Input[str]]
        """
        **Modifying this attribute will force creation of a new resource.**
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The application client id.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The application client secret, only returned on initial apply.
        """
        consumer_service_url: NotRequired[pulumi.Input[str]]
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict']]]]
        """
        Custom attribute mapped from IDPs.
        """
        custom_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict']]]]
        """
        Custom claim mapped from IDPs.
        """
        default_relay_state: NotRequired[pulumi.Input[str]]
        """
        The relay state used if not provided by the identity provider.
        """
        grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OIDC flows supported by this application.
        """
        group_filter_regex: NotRequired[pulumi.Input[str]]
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        """
        hybrid_and_implicit_options: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict']]
        """
        Hybrid and Implicit Flow options.
        """
        idp_entity_id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier for the SaaS application.
        """
        name_id_format: NotRequired[pulumi.Input[str]]
        """
        The format of the name identifier sent to the SaaS application.
        """
        name_id_transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        public_key: NotRequired[pulumi.Input[str]]
        """
        The public certificate that will be used to verify identities.
        """
        redirect_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        """
        refresh_token_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgsDict']]]]
        """
        Refresh token grant options.
        """
        saml_attribute_transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Define the user information shared with access.
        """
        sp_entity_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique name for an identity or service provider.
        """
        sso_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint where the SaaS application will send login requests.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppArgs:
    def __init__(__self__, *,
                 access_token_lifetime: Optional[pulumi.Input[str]] = None,
                 allow_pkce_without_client_secret: Optional[pulumi.Input[bool]] = None,
                 app_launcher_url: Optional[pulumi.Input[str]] = None,
                 auth_type: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 consumer_service_url: Optional[pulumi.Input[str]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]] = None,
                 custom_claims: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]] = None,
                 default_relay_state: Optional[pulumi.Input[str]] = None,
                 grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_filter_regex: Optional[pulumi.Input[str]] = None,
                 hybrid_and_implicit_options: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']] = None,
                 idp_entity_id: Optional[pulumi.Input[str]] = None,
                 name_id_format: Optional[pulumi.Input[str]] = None,
                 name_id_transform_jsonata: Optional[pulumi.Input[str]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 refresh_token_options: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgs']]]] = None,
                 saml_attribute_transform_jsonata: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sp_entity_id: Optional[pulumi.Input[str]] = None,
                 sso_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token_lifetime: The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        :param pulumi.Input[bool] allow_pkce_without_client_secret: Allow PKCE flow without a client secret.
        :param pulumi.Input[str] app_launcher_url: The URL where this applications tile redirects users.
        :param pulumi.Input[str] auth_type: **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] client_id: The application client id.
        :param pulumi.Input[str] client_secret: The application client secret, only returned on initial apply.
        :param pulumi.Input[str] consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]] custom_attributes: Custom attribute mapped from IDPs.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]] custom_claims: Custom claim mapped from IDPs.
        :param pulumi.Input[str] default_relay_state: The relay state used if not provided by the identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] grant_types: The OIDC flows supported by this application.
        :param pulumi.Input[str] group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        :param pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs'] hybrid_and_implicit_options: Hybrid and Implicit Flow options.
        :param pulumi.Input[str] idp_entity_id: The unique identifier for the SaaS application.
        :param pulumi.Input[str] name_id_format: The format of the name identifier sent to the SaaS application.
        :param pulumi.Input[str] name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param pulumi.Input[str] public_key: The public certificate that will be used to verify identities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgs']]] refresh_token_options: Refresh token grant options.
        :param pulumi.Input[str] saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: Define the user information shared with access.
        :param pulumi.Input[str] sp_entity_id: A globally unique name for an identity or service provider.
        :param pulumi.Input[str] sso_endpoint: The endpoint where the SaaS application will send login requests.
        """
        if access_token_lifetime is not None:
            pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        if allow_pkce_without_client_secret is not None:
            pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        if app_launcher_url is not None:
            pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if consumer_service_url is not None:
            pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if custom_claims is not None:
            pulumi.set(__self__, "custom_claims", custom_claims)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if group_filter_regex is not None:
            pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        if hybrid_and_implicit_options is not None:
            pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if name_id_transform_jsonata is not None:
            pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if refresh_token_options is not None:
            pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        if saml_attribute_transform_jsonata is not None:
            pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sso_endpoint is not None:
            pulumi.set(__self__, "sso_endpoint", sso_endpoint)

    @property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> Optional[pulumi.Input[str]]:
        """
        The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @access_token_lifetime.setter
    def access_token_lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_lifetime", value)

    @property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow PKCE flow without a client secret.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @allow_pkce_without_client_secret.setter
    def allow_pkce_without_client_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_pkce_without_client_secret", value)

    @property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL where this applications tile redirects users.
        """
        return pulumi.get(self, "app_launcher_url")

    @app_launcher_url.setter
    def app_launcher_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_launcher_url", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[str]]:
        """
        **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The application client id.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The application client secret, only returned on initial apply.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> Optional[pulumi.Input[str]]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @consumer_service_url.setter
    def consumer_service_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_service_url", value)

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]]:
        """
        Custom attribute mapped from IDPs.
        """
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]]):
        pulumi.set(self, "custom_attributes", value)

    @property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]]:
        """
        Custom claim mapped from IDPs.
        """
        return pulumi.get(self, "custom_claims")

    @custom_claims.setter
    def custom_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]]):
        pulumi.set(self, "custom_claims", value)

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[pulumi.Input[str]]:
        """
        The relay state used if not provided by the identity provider.
        """
        return pulumi.get(self, "default_relay_state")

    @default_relay_state.setter
    def default_relay_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_relay_state", value)

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OIDC flows supported by this application.
        """
        return pulumi.get(self, "grant_types")

    @grant_types.setter
    def grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "grant_types", value)

    @property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> Optional[pulumi.Input[str]]:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        """
        return pulumi.get(self, "group_filter_regex")

    @group_filter_regex.setter
    def group_filter_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_filter_regex", value)

    @property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']]:
        """
        Hybrid and Implicit Flow options.
        """
        return pulumi.get(self, "hybrid_and_implicit_options")

    @hybrid_and_implicit_options.setter
    def hybrid_and_implicit_options(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']]):
        pulumi.set(self, "hybrid_and_implicit_options", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier for the SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the name identifier sent to the SaaS application.
        """
        return pulumi.get(self, "name_id_format")

    @name_id_format.setter
    def name_id_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_format", value)

    @property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @name_id_transform_jsonata.setter
    def name_id_transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_transform_jsonata", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        The public certificate that will be used to verify identities.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        """
        return pulumi.get(self, "redirect_uris")

    @redirect_uris.setter
    def redirect_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "redirect_uris", value)

    @property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgs']]]]:
        """
        Refresh token grant options.
        """
        return pulumi.get(self, "refresh_token_options")

    @refresh_token_options.setter
    def refresh_token_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgs']]]]):
        pulumi.set(self, "refresh_token_options", value)

    @property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @saml_attribute_transform_jsonata.setter
    def saml_attribute_transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_attribute_transform_jsonata", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Define the user information shared with access.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sp_entity_id", value)

    @property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint where the SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")

    @sso_endpoint.setter
    def sso_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_endpoint", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict(TypedDict):
        source: pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict']
        friendly_name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the attribute as provided to the SaaS app.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the attribute as provided to the SaaS app.
        """
        name_format: NotRequired[pulumi.Input[str]]
        """
        A globally unique name for an identity or service provider.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        True if the attribute must be always present.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeArgs:
    def __init__(__self__, *,
                 source: pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs'],
                 friendly_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 name_format: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] friendly_name: A friendly name for the attribute as provided to the SaaS app.
        :param pulumi.Input[str] name: The name of the attribute as provided to the SaaS app.
        :param pulumi.Input[str] name_format: A globally unique name for an identity or service provider.
        :param pulumi.Input[bool] required: True if the attribute must be always present.
        """
        pulumi.set(__self__, "source", source)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_format is not None:
            pulumi.set(__self__, "name_format", name_format)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs']:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs']):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @name_format.setter
    def name_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_format", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the attribute as provided by the IDP.
        """
        name_by_idp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping from IdP ID to claim name.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 name_by_idp: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute as provided by the IDP.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the attribute as provided by the IDP.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")

    @name_by_idp.setter
    def name_by_idp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "name_by_idp", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict(TypedDict):
        source: pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict']
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the attribute as provided to the SaaS app.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        True if the attribute must be always present.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The scope of the claim.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomClaimArgs:
    def __init__(__self__, *,
                 source: pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs'],
                 name: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute as provided to the SaaS app.
        :param pulumi.Input[bool] required: True if the attribute must be always present.
        :param pulumi.Input[str] scope: The scope of the claim.
        """
        pulumi.set(__self__, "source", source)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs']:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs']):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The scope of the claim.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the attribute as provided by the IDP.
        """
        name_by_idp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping from IdP ID to claim name.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 name_by_idp: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute as provided by the IDP.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the attribute as provided by the IDP.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")

    @name_by_idp.setter
    def name_by_idp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "name_by_idp", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict(TypedDict):
        return_access_token_from_authorization_endpoint: NotRequired[pulumi.Input[bool]]
        """
        If true, the authorization endpoint will return an access token.
        """
        return_id_token_from_authorization_endpoint: NotRequired[pulumi.Input[bool]]
        """
        If true, the authorization endpoint will return an id token.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs:
    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: Optional[pulumi.Input[bool]] = None,
                 return_id_token_from_authorization_endpoint: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] return_access_token_from_authorization_endpoint: If true, the authorization endpoint will return an access token.
        :param pulumi.Input[bool] return_id_token_from_authorization_endpoint: If true, the authorization endpoint will return an id token.
        """
        if return_access_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        if return_id_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the authorization endpoint will return an access token.
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @return_access_token_from_authorization_endpoint.setter
    def return_access_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_access_token_from_authorization_endpoint", value)

    @property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the authorization endpoint will return an id token.
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")

    @return_id_token_from_authorization_endpoint.setter
    def return_id_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_id_token_from_authorization_endpoint", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgsDict(TypedDict):
        lifetime: NotRequired[pulumi.Input[str]]
        """
        How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgs:
    def __init__(__self__, *,
                 lifetime: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lifetime: How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
        if lifetime is not None:
            pulumi.set(__self__, "lifetime", lifetime)

    @property
    @pulumi.getter
    def lifetime(self) -> Optional[pulumi.Input[str]]:
        """
        How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")

    @lifetime.setter
    def lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifetime", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigArgsDict(TypedDict):
        idp_uid: pulumi.Input[str]
        """
        The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        """
        remote_uri: pulumi.Input[str]
        """
        The base URI for the application's SCIM-compatible API.
        """
        authentication: NotRequired[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict']]
        """
        Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        """
        deactivate_on_delete: NotRequired[pulumi.Input[bool]]
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether SCIM provisioning is turned on for this application.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgsDict']]]]
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigArgs:
    def __init__(__self__, *,
                 idp_uid: pulumi.Input[str],
                 remote_uri: pulumi.Input[str],
                 authentication: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']] = None,
                 deactivate_on_delete: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]] = None):
        """
        :param pulumi.Input[str] idp_uid: The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        :param pulumi.Input[str] remote_uri: The base URI for the application's SCIM-compatible API.
        :param pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs'] authentication: Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        :param pulumi.Input[bool] deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param pulumi.Input[bool] enabled: Whether SCIM provisioning is turned on for this application.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "remote_uri", remote_uri)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if deactivate_on_delete is not None:
            pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> pulumi.Input[str]:
        """
        The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @idp_uid.setter
    def idp_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_uid", value)

    @property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> pulumi.Input[str]:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")

    @remote_uri.setter
    def remote_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_uri", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']]:
        """
        Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @deactivate_on_delete.setter
    def deactivate_on_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deactivate_on_delete", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]]:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]]):
        pulumi.set(self, "mappings", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict(TypedDict):
        scheme: pulumi.Input[str]
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        authorization_url: NotRequired[pulumi.Input[str]]
        """
        URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        token_url: NotRequired[pulumi.Input[str]]
        """
        URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigAuthenticationArgs:
    def __init__(__self__, *,
                 scheme: pulumi.Input[str],
                 authorization_url: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 token_url: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scheme: The authentication scheme to use when making SCIM requests to this application.
        :param pulumi.Input[str] authorization_url: URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] password: Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] token: Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        :param pulumi.Input[str] token_url: URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        :param pulumi.Input[str] user: User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        pulumi.set(__self__, "scheme", scheme)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[str]:
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "authorization_url")

    @authorization_url.setter
    def authorization_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigMappingArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Which SCIM resource type this mapping applies to.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping is enabled.
        """
        filter: NotRequired[pulumi.Input[str]]
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        operations: NotRequired[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict']]
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        strictness: NotRequired[pulumi.Input[str]]
        """
        How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        """
        transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigMappingArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 filter: Optional[pulumi.Input[str]] = None,
                 operations: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']] = None,
                 strictness: Optional[pulumi.Input[str]] = None,
                 transform_jsonata: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] schema: Which SCIM resource type this mapping applies to.
        :param pulumi.Input[bool] enabled: Whether or not this mapping is enabled.
        :param pulumi.Input[str] filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs'] operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param pulumi.Input[str] strictness: How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        :param pulumi.Input[str] transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "schema", schema)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if strictness is not None:
            pulumi.set(__self__, "strictness", strictness)
        if transform_jsonata is not None:
            pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']]:
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def strictness(self) -> Optional[pulumi.Input[str]]:
        """
        How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        """
        return pulumi.get(self, "strictness")

    @strictness.setter
    def strictness(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strictness", value)

    @property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")

    @transform_jsonata.setter
    def transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_jsonata", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        delete: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to DELETE operations.
        """
        update: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigMappingOperationsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[bool]] = None,
                 delete: Optional[pulumi.Input[bool]] = None,
                 update: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] create: Whether or not this mapping applies to create (POST) operations.
        :param pulumi.Input[bool] delete: Whether or not this mapping applies to DELETE operations.
        :param pulumi.Input[bool] update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ZeroTrustAccessApplicationTargetCriteriaArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        protocol: pulumi.Input[str]
        """
        The communication protocol your application secures.
        """
        target_attributes: pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgsDict']]]
        """
        Contains a map of target attribute keys to target attribute values.
        """
elif False:
    ZeroTrustAccessApplicationTargetCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationTargetCriteriaArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 target_attributes: pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgs']]]):
        """
        :param pulumi.Input[int] port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param pulumi.Input[str] protocol: The communication protocol your application secures.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgs']]] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The communication protocol your application secures.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgs']]]:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")

    @target_attributes.setter
    def target_attributes(self, value: pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgs']]]):
        pulumi.set(self, "target_attributes", value)


if not MYPY:
    class ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The key of the attribute.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The values of the attribute.
        """
elif False:
    ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The key of the attribute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The values of the attribute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The key of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The values of the attribute.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict']]]]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    ZeroTrustAccessGroupExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluations: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']]]] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']]] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']]]]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @external_evaluations.setter
    def external_evaluations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']]]]):
        pulumi.set(self, "external_evaluations", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    ZeroTrustAccessGroupExcludeAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    ZeroTrustAccessGroupExcludeGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    ZeroTrustAccessGroupExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict']]]]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    ZeroTrustAccessGroupIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluations: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']]]] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']]] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']]]]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @external_evaluations.setter
    def external_evaluations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']]]]):
        pulumi.set(self, "external_evaluations", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    ZeroTrustAccessGroupIncludeAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    ZeroTrustAccessGroupIncludeGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    ZeroTrustAccessGroupIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgsDict']]]]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    ZeroTrustAccessGroupRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluations: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']]]] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']]] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']]]]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @external_evaluations.setter
    def external_evaluations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']]]]):
        pulumi.set(self, "external_evaluations", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    ZeroTrustAccessGroupRequireAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    ZeroTrustAccessGroupRequireGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    ZeroTrustAccessGroupRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessIdentityProviderConfigArgsDict(TypedDict):
        api_token: NotRequired[pulumi.Input[str]]
        apps_domain: NotRequired[pulumi.Input[str]]
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        auth_url: NotRequired[pulumi.Input[str]]
        authorization_server_id: NotRequired[pulumi.Input[str]]
        centrify_account: NotRequired[pulumi.Input[str]]
        centrify_app_id: NotRequired[pulumi.Input[str]]
        certs_url: NotRequired[pulumi.Input[str]]
        claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        client_id: NotRequired[pulumi.Input[str]]
        client_secret: NotRequired[pulumi.Input[str]]
        conditional_access_enabled: NotRequired[pulumi.Input[bool]]
        directory_id: NotRequired[pulumi.Input[str]]
        email_attribute_name: NotRequired[pulumi.Input[str]]
        email_claim_name: NotRequired[pulumi.Input[str]]
        idp_public_cert: NotRequired[pulumi.Input[str]]
        issuer_url: NotRequired[pulumi.Input[str]]
        okta_account: NotRequired[pulumi.Input[str]]
        onelogin_account: NotRequired[pulumi.Input[str]]
        ping_env_id: NotRequired[pulumi.Input[str]]
        pkce_enabled: NotRequired[pulumi.Input[bool]]
        redirect_url: NotRequired[pulumi.Input[str]]
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        sign_request: NotRequired[pulumi.Input[bool]]
        sso_target_url: NotRequired[pulumi.Input[str]]
        support_groups: NotRequired[pulumi.Input[bool]]
        token_url: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustAccessIdentityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessIdentityProviderConfigArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input[str]] = None,
                 apps_domain: Optional[pulumi.Input[str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 authorization_server_id: Optional[pulumi.Input[str]] = None,
                 centrify_account: Optional[pulumi.Input[str]] = None,
                 centrify_app_id: Optional[pulumi.Input[str]] = None,
                 certs_url: Optional[pulumi.Input[str]] = None,
                 claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 conditional_access_enabled: Optional[pulumi.Input[bool]] = None,
                 directory_id: Optional[pulumi.Input[str]] = None,
                 email_attribute_name: Optional[pulumi.Input[str]] = None,
                 email_claim_name: Optional[pulumi.Input[str]] = None,
                 idp_public_cert: Optional[pulumi.Input[str]] = None,
                 issuer_url: Optional[pulumi.Input[str]] = None,
                 okta_account: Optional[pulumi.Input[str]] = None,
                 onelogin_account: Optional[pulumi.Input[str]] = None,
                 ping_env_id: Optional[pulumi.Input[str]] = None,
                 pkce_enabled: Optional[pulumi.Input[bool]] = None,
                 redirect_url: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sign_request: Optional[pulumi.Input[bool]] = None,
                 sso_target_url: Optional[pulumi.Input[str]] = None,
                 support_groups: Optional[pulumi.Input[bool]] = None,
                 token_url: Optional[pulumi.Input[str]] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if conditional_access_enabled is not None:
            pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            pulumi.set(__self__, "email_claim_name", email_claim_name)
        if idp_public_cert is not None:
            pulumi.set(__self__, "idp_public_cert", idp_public_cert)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if ping_env_id is not None:
            pulumi.set(__self__, "ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "apps_domain")

    @apps_domain.setter
    def apps_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apps_domain", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "authorization_server_id")

    @authorization_server_id.setter
    def authorization_server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_server_id", value)

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "centrify_account")

    @centrify_account.setter
    def centrify_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "centrify_account", value)

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "centrify_app_id")

    @centrify_app_id.setter
    def centrify_app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "centrify_app_id", value)

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certs_url")

    @certs_url.setter
    def certs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certs_url", value)

    @property
    @pulumi.getter
    def claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "claims")

    @claims.setter
    def claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "claims", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "conditional_access_enabled")

    @conditional_access_enabled.setter
    def conditional_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditional_access_enabled", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory_id", value)

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_attribute_name")

    @email_attribute_name.setter
    def email_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_attribute_name", value)

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_claim_name")

    @email_claim_name.setter
    def email_claim_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_claim_name", value)

    @property
    @pulumi.getter(name="idpPublicCert")
    def idp_public_cert(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idp_public_cert")

    @idp_public_cert.setter
    def idp_public_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_public_cert", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "okta_account")

    @okta_account.setter
    def okta_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "okta_account", value)

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "onelogin_account")

    @onelogin_account.setter
    def onelogin_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "onelogin_account", value)

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ping_env_id")

    @ping_env_id.setter
    def ping_env_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ping_env_id", value)

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pkce_enabled")

    @pkce_enabled.setter
    def pkce_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pkce_enabled", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_request", value)

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sso_target_url")

    @sso_target_url.setter
    def sso_target_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_target_url", value)

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "support_groups")

    @support_groups.setter
    def support_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_groups", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)


if not MYPY:
    class ZeroTrustAccessIdentityProviderScimConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        group_member_deprovision: NotRequired[pulumi.Input[bool]]
        """
        Deprecated. Use `identity_update_behavior`.
        """
        identity_update_behavior: NotRequired[pulumi.Input[str]]
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        seat_deprovision: NotRequired[pulumi.Input[bool]]
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        user_deprovision: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
elif False:
    ZeroTrustAccessIdentityProviderScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessIdentityProviderScimConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 group_member_deprovision: Optional[pulumi.Input[bool]] = None,
                 identity_update_behavior: Optional[pulumi.Input[str]] = None,
                 seat_deprovision: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 user_deprovision: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: A flag to enable or disable SCIM for the identity provider.
        :param pulumi.Input[bool] group_member_deprovision: Deprecated. Use `identity_update_behavior`.
        :param pulumi.Input[str] identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        :param pulumi.Input[bool] seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param pulumi.Input[str] secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        :param pulumi.Input[bool] user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group_member_deprovision is not None:
            pulumi.set(__self__, "group_member_deprovision", group_member_deprovision)
        if identity_update_behavior is not None:
            pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="groupMemberDeprovision")
    def group_member_deprovision(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Use `identity_update_behavior`.
        """
        return pulumi.get(self, "group_member_deprovision")

    @group_member_deprovision.setter
    def group_member_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "group_member_deprovision", value)

    @property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        return pulumi.get(self, "identity_update_behavior")

    @identity_update_behavior.setter
    def identity_update_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_update_behavior", value)

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @seat_deprovision.setter
    def seat_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "seat_deprovision", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")

    @user_deprovision.setter
    def user_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_deprovision", value)


if not MYPY:
    class ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        The hostname that these settings apply to.
        """
        china_network: NotRequired[pulumi.Input[bool]]
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        client_certificate_forwarding: NotRequired[pulumi.Input[bool]]
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
elif False:
    ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessMtlsHostnameSettingsSettingArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 china_network: Optional[pulumi.Input[bool]] = None,
                 client_certificate_forwarding: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] hostname: The hostname that these settings apply to.
        :param pulumi.Input[bool] china_network: Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        :param pulumi.Input[bool] client_certificate_forwarding: Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        pulumi.set(__self__, "hostname", hostname)
        if china_network is not None:
            pulumi.set(__self__, "china_network", china_network)
        if client_certificate_forwarding is not None:
            pulumi.set(__self__, "client_certificate_forwarding", client_certificate_forwarding)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        The hostname that these settings apply to.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="chinaNetwork")
    def china_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        return pulumi.get(self, "china_network")

    @china_network.setter
    def china_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "china_network", value)

    @property
    @pulumi.getter(name="clientCertificateForwarding")
    def client_certificate_forwarding(self) -> Optional[pulumi.Input[bool]]:
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        return pulumi.get(self, "client_certificate_forwarding")

    @client_certificate_forwarding.setter
    def client_certificate_forwarding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_certificate_forwarding", value)


if not MYPY:
    class ZeroTrustAccessOrganizationCustomPageArgsDict(TypedDict):
        forbidden: NotRequired[pulumi.Input[str]]
        """
        The id of the forbidden page.
        """
        identity_denied: NotRequired[pulumi.Input[str]]
        """
        The id of the identity denied page.
        """
elif False:
    ZeroTrustAccessOrganizationCustomPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessOrganizationCustomPageArgs:
    def __init__(__self__, *,
                 forbidden: Optional[pulumi.Input[str]] = None,
                 identity_denied: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] forbidden: The id of the forbidden page.
        :param pulumi.Input[str] identity_denied: The id of the identity denied page.
        """
        if forbidden is not None:
            pulumi.set(__self__, "forbidden", forbidden)
        if identity_denied is not None:
            pulumi.set(__self__, "identity_denied", identity_denied)

    @property
    @pulumi.getter
    def forbidden(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the forbidden page.
        """
        return pulumi.get(self, "forbidden")

    @forbidden.setter
    def forbidden(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forbidden", value)

    @property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the identity denied page.
        """
        return pulumi.get(self, "identity_denied")

    @identity_denied.setter
    def identity_denied(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_denied", value)


if not MYPY:
    class ZeroTrustAccessOrganizationLoginDesignArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[str]]
        """
        The background color on the login page.
        """
        footer_text: NotRequired[pulumi.Input[str]]
        """
        The text at the bottom of the login page.
        """
        header_text: NotRequired[pulumi.Input[str]]
        """
        The text at the top of the login page.
        """
        logo_path: NotRequired[pulumi.Input[str]]
        """
        The URL of the logo on the login page.
        """
        text_color: NotRequired[pulumi.Input[str]]
        """
        The text color on the login page.
        """
elif False:
    ZeroTrustAccessOrganizationLoginDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessOrganizationLoginDesignArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None,
                 logo_path: Optional[pulumi.Input[str]] = None,
                 text_color: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_color: The background color on the login page.
        :param pulumi.Input[str] footer_text: The text at the bottom of the login page.
        :param pulumi.Input[str] header_text: The text at the top of the login page.
        :param pulumi.Input[str] logo_path: The URL of the logo on the login page.
        :param pulumi.Input[str] text_color: The text color on the login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color on the login page.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text at the bottom of the login page.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text at the top of the login page.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the logo on the login page.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_path", value)

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[pulumi.Input[str]]:
        """
        The text color on the login page.
        """
        return pulumi.get(self, "text_color")

    @text_color.setter
    def text_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_color", value)


if not MYPY:
    class ZeroTrustAccessPolicyApprovalGroupArgsDict(TypedDict):
        approvals_needed: pulumi.Input[int]
        """
        Number of approvals needed.
        """
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of emails to request approval from.
        """
        email_list_uuid: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustAccessPolicyApprovalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyApprovalGroupArgs:
    def __init__(__self__, *,
                 approvals_needed: pulumi.Input[int],
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_list_uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] approvals_needed: Number of approvals needed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_addresses: List of emails to request approval from.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> pulumi.Input[int]:
        """
        Number of approvals needed.
        """
        return pulumi.get(self, "approvals_needed")

    @approvals_needed.setter
    def approvals_needed(self, value: pulumi.Input[int]):
        pulumi.set(self, "approvals_needed", value)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of emails to request approval from.
        """
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_list_uuid")

    @email_list_uuid.setter
    def email_list_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_list_uuid", value)


if not MYPY:
    class ZeroTrustAccessPolicyConnectionRulesArgsDict(TypedDict):
        ssh: pulumi.Input['ZeroTrustAccessPolicyConnectionRulesSshArgsDict']
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
elif False:
    ZeroTrustAccessPolicyConnectionRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyConnectionRulesArgs:
    def __init__(__self__, *,
                 ssh: pulumi.Input['ZeroTrustAccessPolicyConnectionRulesSshArgs']):
        """
        :param pulumi.Input['ZeroTrustAccessPolicyConnectionRulesSshArgs'] ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def ssh(self) -> pulumi.Input['ZeroTrustAccessPolicyConnectionRulesSshArgs']:
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: pulumi.Input['ZeroTrustAccessPolicyConnectionRulesSshArgs']):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class ZeroTrustAccessPolicyConnectionRulesSshArgsDict(TypedDict):
        usernames: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        allow_email_alias: NotRequired[pulumi.Input[bool]]
        """
        Allows connecting to Unix username that matches the authenticating email prefix.
        """
elif False:
    ZeroTrustAccessPolicyConnectionRulesSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyConnectionRulesSshArgs:
    def __init__(__self__, *,
                 usernames: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allow_email_alias: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        :param pulumi.Input[bool] allow_email_alias: Allows connecting to Unix username that matches the authenticating email prefix.
        """
        pulumi.set(__self__, "usernames", usernames)
        if allow_email_alias is not None:
            pulumi.set(__self__, "allow_email_alias", allow_email_alias)

    @property
    @pulumi.getter
    def usernames(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "usernames", value)

    @property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows connecting to Unix username that matches the authenticating email prefix.
        """
        return pulumi.get(self, "allow_email_alias")

    @allow_email_alias.setter
    def allow_email_alias(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_email_alias", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict']]]]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    ZeroTrustAccessPolicyExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluations: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']]]] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']]] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']]]]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @external_evaluations.setter
    def external_evaluations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']]]]):
        pulumi.set(self, "external_evaluations", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    ZeroTrustAccessPolicyExcludeAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyExcludeGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    ZeroTrustAccessPolicyExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict']]]]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    ZeroTrustAccessPolicyIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluations: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']]]] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']]] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']]]]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @external_evaluations.setter
    def external_evaluations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']]]]):
        pulumi.set(self, "external_evaluations", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    ZeroTrustAccessPolicyIncludeAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyIncludeGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    ZeroTrustAccessPolicyIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid Access service token.
        """
        auth_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgsDict']]]]
        auth_method: NotRequired[pulumi.Input[str]]
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        azures: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAzureArgsDict']]]]
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        certificate: NotRequired[pulumi.Input[bool]]
        """
        Matches any valid client certificate.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Matches a valid client certificate common name.
        """
        common_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        device_postures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a device posture integration.
        """
        email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email domain to match.
        """
        email_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created email list.
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The email of the user.
        """
        everyone: NotRequired[pulumi.Input[bool]]
        """
        Matches everyone.
        """
        external_evaluations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict']]]]
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Matches a specific country.
        """
        githubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGithubArgsDict']]]]
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created Access group.
        """
        gsuites: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgsDict']]]]
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a previously created IP list.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An IPv4 or IPv6 CIDR block.
        """
        login_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of a configured identity provider.
        """
        oktas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgsDict']]]]
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        samls: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgsDict']]]]
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        service_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of an Access service token.
        """
elif False:
    ZeroTrustAccessPolicyRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 common_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluations: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']]]] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_valid_service_token: Matches any valid Access service token.
        :param pulumi.Input[str] auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAzureArgs']]] azures: Matches an Azure group. Requires an Azure identity provider.
        :param pulumi.Input[bool] certificate: Matches any valid client certificate.
        :param pulumi.Input[str] common_name: Matches a valid client certificate common name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_postures: The ID of a device posture integration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_domains: The email domain to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: The ID of a previously created email list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the user.
        :param pulumi.Input[bool] everyone: Matches everyone.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']]] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] geos: Matches a specific country.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGithubArgs']]] githubs: Matches a Github organization. Requires a Github identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The ID of a previously created Access group.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']]] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of a previously created IP list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_methods: The ID of a configured identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']]] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']]] samls: Matches a SAML group. Requires a SAML identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAzureArgs']]]]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @common_names.setter
    def common_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "common_names", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']]]]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @external_evaluations.setter
    def external_evaluations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']]]]):
        pulumi.set(self, "external_evaluations", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGithubArgs']]]]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']]]]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']]]]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']]]]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of the Authentication Context.
        """
        id: pulumi.Input[str]
        """
        The ID of the Authentication Context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of the Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireAzureArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Azure identity provider.
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the Azure group or user.
        """
elif False:
    ZeroTrustAccessPolicyRequireAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing your business logic.
        """
        keys_url: NotRequired[pulumi.Input[str]]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGithubArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Github identity provider.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the organization.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The teams that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyRequireGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGsuiteArgsDict(TypedDict):
        emails: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireOktaArgsDict(TypedDict):
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your Okta identity provider.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the Okta Group.
        """
elif False:
    ZeroTrustAccessPolicyRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireSamlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        The name of the SAML attribute.
        """
        attribute_value: NotRequired[pulumi.Input[str]]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustDeviceManagedNetworksConfigArgsDict(TypedDict):
        sha256: pulumi.Input[str]
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        tls_sockaddr: pulumi.Input[str]
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
elif False:
    ZeroTrustDeviceManagedNetworksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceManagedNetworksConfigArgs:
    def __init__(__self__, *,
                 sha256: pulumi.Input[str],
                 tls_sockaddr: pulumi.Input[str]):
        """
        :param pulumi.Input[str] sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        :param pulumi.Input[str] tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)

    @property
    @pulumi.getter
    def sha256(self) -> pulumi.Input[str]:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: pulumi.Input[str]):
        pulumi.set(self, "sha256", value)

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> pulumi.Input[str]:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")

    @tls_sockaddr.setter
    def tls_sockaddr(self, value: pulumi.Input[str]):
        pulumi.set(self, "tls_sockaddr", value)


if not MYPY:
    class ZeroTrustDevicePostureIntegrationConfigArgsDict(TypedDict):
        access_client_id: NotRequired[pulumi.Input[str]]
        """
        The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        """
        access_client_secret: NotRequired[pulumi.Input[str]]
        """
        The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        """
        api_url: NotRequired[pulumi.Input[str]]
        """
        The third-party API's URL.
        """
        auth_url: NotRequired[pulumi.Input[str]]
        """
        The third-party authorization API URL.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The client identifier for authenticating API calls.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        The client key for authenticating API calls.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret for authenticating API calls.
        """
        customer_id: NotRequired[pulumi.Input[str]]
        """
        The customer identifier for authenticating API calls.
        """
elif False:
    ZeroTrustDevicePostureIntegrationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureIntegrationConfigArgs:
    def __init__(__self__, *,
                 access_client_id: Optional[pulumi.Input[str]] = None,
                 access_client_secret: Optional[pulumi.Input[str]] = None,
                 api_url: Optional[pulumi.Input[str]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 customer_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_client_id: The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        :param pulumi.Input[str] access_client_secret: The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        :param pulumi.Input[str] api_url: The third-party API's URL.
        :param pulumi.Input[str] auth_url: The third-party authorization API URL.
        :param pulumi.Input[str] client_id: The client identifier for authenticating API calls.
        :param pulumi.Input[str] client_key: The client key for authenticating API calls.
        :param pulumi.Input[str] client_secret: The client secret for authenticating API calls.
        :param pulumi.Input[str] customer_id: The customer identifier for authenticating API calls.
        """
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        """
        return pulumi.get(self, "access_client_id")

    @access_client_id.setter
    def access_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_id", value)

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        """
        return pulumi.get(self, "access_client_secret")

    @access_client_secret.setter
    def access_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_secret", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The third-party API's URL.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        """
        The third-party authorization API URL.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client identifier for authenticating API calls.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The client key for authenticating API calls.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret for authenticating API calls.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The customer identifier for authenticating API calls.
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_id", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleInputArgsDict(TypedDict):
        active_threats: NotRequired[pulumi.Input[int]]
        """
        The number of active threats from SentinelOne.
        """
        certificate_id: NotRequired[pulumi.Input[str]]
        """
        The UUID of a Cloudflare managed certificate.
        """
        check_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific volume(s) to check for encryption.
        """
        check_private_key: NotRequired[pulumi.Input[bool]]
        """
        Confirm the certificate was not imported from another device.
        """
        cn: NotRequired[pulumi.Input[str]]
        """
        The common name for a certificate.
        """
        compliance_status: NotRequired[pulumi.Input[str]]
        """
        The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        """
        connection_id: NotRequired[pulumi.Input[str]]
        """
        The workspace one or intune connection id.
        """
        count_operator: NotRequired[pulumi.Input[str]]
        """
        The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        The domain that the client must join.
        """
        eid_last_seen: NotRequired[pulumi.Input[str]]
        """
        The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if the firewall must be enabled.
        """
        exists: NotRequired[pulumi.Input[bool]]
        """
        Checks if the file should exist.
        """
        extended_key_usages: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        """
        infected: NotRequired[pulumi.Input[bool]]
        """
        True if SentinelOne device is infected.
        """
        is_active: NotRequired[pulumi.Input[bool]]
        """
        True if SentinelOne device is active.
        """
        issue_count: NotRequired[pulumi.Input[str]]
        """
        The number of issues for kolide.
        """
        last_seen: NotRequired[pulumi.Input[str]]
        """
        The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationArgsDict']]]]
        """
        List of operating system locations to check for a client certificate..
        """
        network_status: NotRequired[pulumi.Input[str]]
        """
        The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        """
        operational_state: NotRequired[pulumi.Input[str]]
        """
        The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        os: NotRequired[pulumi.Input[str]]
        """
        OS signal score from Crowdstrike. Value must be between 1 and 100.
        """
        os_distro_name: NotRequired[pulumi.Input[str]]
        """
        The operating system excluding version information.
        """
        os_distro_revision: NotRequired[pulumi.Input[str]]
        """
        The operating system version excluding OS name information or release name.
        """
        os_version_extra: NotRequired[pulumi.Input[str]]
        """
        Extra version value following the operating system semantic version.
        """
        overall: NotRequired[pulumi.Input[str]]
        """
        Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path to the file.
        """
        require_all: NotRequired[pulumi.Input[bool]]
        """
        True if all drives must be encrypted.
        """
        risk_level: NotRequired[pulumi.Input[str]]
        """
        The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        """
        running: NotRequired[pulumi.Input[bool]]
        """
        Checks if the application should be running.
        """
        score: NotRequired[pulumi.Input[int]]
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        """
        sensor_config: NotRequired[pulumi.Input[str]]
        """
        Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        """
        sha256: NotRequired[pulumi.Input[str]]
        """
        The sha256 hash of the file.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        """
        thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the file certificate.
        """
        total_score: NotRequired[pulumi.Input[int]]
        """
        The total score from Tanium.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The operating system semantic version.
        """
        version_operator: NotRequired[pulumi.Input[str]]
        """
        The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
elif False:
    ZeroTrustDevicePostureRuleInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleInputArgs:
    def __init__(__self__, *,
                 active_threats: Optional[pulumi.Input[int]] = None,
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 check_disks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 check_private_key: Optional[pulumi.Input[bool]] = None,
                 cn: Optional[pulumi.Input[str]] = None,
                 compliance_status: Optional[pulumi.Input[str]] = None,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 count_operator: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 eid_last_seen: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exists: Optional[pulumi.Input[bool]] = None,
                 extended_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infected: Optional[pulumi.Input[bool]] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 issue_count: Optional[pulumi.Input[str]] = None,
                 last_seen: Optional[pulumi.Input[str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationArgs']]]] = None,
                 network_status: Optional[pulumi.Input[str]] = None,
                 operational_state: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 os: Optional[pulumi.Input[str]] = None,
                 os_distro_name: Optional[pulumi.Input[str]] = None,
                 os_distro_revision: Optional[pulumi.Input[str]] = None,
                 os_version_extra: Optional[pulumi.Input[str]] = None,
                 overall: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 require_all: Optional[pulumi.Input[bool]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None,
                 running: Optional[pulumi.Input[bool]] = None,
                 score: Optional[pulumi.Input[int]] = None,
                 sensor_config: Optional[pulumi.Input[str]] = None,
                 sha256: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 thumbprint: Optional[pulumi.Input[str]] = None,
                 total_score: Optional[pulumi.Input[int]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 version_operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] active_threats: The number of active threats from SentinelOne.
        :param pulumi.Input[str] certificate_id: The UUID of a Cloudflare managed certificate.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_disks: Specific volume(s) to check for encryption.
        :param pulumi.Input[bool] check_private_key: Confirm the certificate was not imported from another device.
        :param pulumi.Input[str] cn: The common name for a certificate.
        :param pulumi.Input[str] compliance_status: The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        :param pulumi.Input[str] connection_id: The workspace one or intune connection id.
        :param pulumi.Input[str] count_operator: The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param pulumi.Input[str] domain: The domain that the client must join.
        :param pulumi.Input[str] eid_last_seen: The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        :param pulumi.Input[bool] enabled: True if the firewall must be enabled.
        :param pulumi.Input[bool] exists: Checks if the file should exist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extended_key_usages: List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        :param pulumi.Input[str] id: The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        :param pulumi.Input[bool] infected: True if SentinelOne device is infected.
        :param pulumi.Input[bool] is_active: True if SentinelOne device is active.
        :param pulumi.Input[str] issue_count: The number of issues for kolide.
        :param pulumi.Input[str] last_seen: The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationArgs']]] locations: List of operating system locations to check for a client certificate..
        :param pulumi.Input[str] network_status: The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        :param pulumi.Input[str] operational_state: The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        :param pulumi.Input[str] operator: The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param pulumi.Input[str] os: OS signal score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] os_distro_name: The operating system excluding version information.
        :param pulumi.Input[str] os_distro_revision: The operating system version excluding OS name information or release name.
        :param pulumi.Input[str] os_version_extra: Extra version value following the operating system semantic version.
        :param pulumi.Input[str] overall: Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] path: The path to the file.
        :param pulumi.Input[bool] require_all: True if all drives must be encrypted.
        :param pulumi.Input[str] risk_level: The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        :param pulumi.Input[bool] running: Checks if the application should be running.
        :param pulumi.Input[int] score: A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        :param pulumi.Input[str] sensor_config: Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] sha256: The sha256 hash of the file.
        :param pulumi.Input[str] state: The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        :param pulumi.Input[str] thumbprint: The thumbprint of the file certificate.
        :param pulumi.Input[int] total_score: The total score from Tanium.
        :param pulumi.Input[str] version: The operating system semantic version.
        :param pulumi.Input[str] version_operator: The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if check_private_key is not None:
            pulumi.set(__self__, "check_private_key", check_private_key)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if eid_last_seen is not None:
            pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)
        if running is not None:
            pulumi.set(__self__, "running", running)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if total_score is not None:
            pulumi.set(__self__, "total_score", total_score)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[pulumi.Input[int]]:
        """
        The number of active threats from SentinelOne.
        """
        return pulumi.get(self, "active_threats")

    @active_threats.setter
    def active_threats(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_threats", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of a Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific volume(s) to check for encryption.
        """
        return pulumi.get(self, "check_disks")

    @check_disks.setter
    def check_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_disks", value)

    @property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Confirm the certificate was not imported from another device.
        """
        return pulumi.get(self, "check_private_key")

    @check_private_key.setter
    def check_private_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_private_key", value)

    @property
    @pulumi.getter
    def cn(self) -> Optional[pulumi.Input[str]]:
        """
        The common name for a certificate.
        """
        return pulumi.get(self, "cn")

    @cn.setter
    def cn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cn", value)

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[pulumi.Input[str]]:
        """
        The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        """
        return pulumi.get(self, "compliance_status")

    @compliance_status.setter
    def compliance_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compliance_status", value)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The workspace one or intune connection id.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "count_operator")

    @count_operator.setter
    def count_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count_operator", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The domain that the client must join.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[pulumi.Input[str]]:
        """
        The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        return pulumi.get(self, "eid_last_seen")

    @eid_last_seen.setter
    def eid_last_seen(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eid_last_seen", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the firewall must be enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def exists(self) -> Optional[pulumi.Input[bool]]:
        """
        Checks if the file should exist.
        """
        return pulumi.get(self, "exists")

    @exists.setter
    def exists(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exists", value)

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        """
        return pulumi.get(self, "extended_key_usages")

    @extended_key_usages.setter
    def extended_key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extended_key_usages", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infected(self) -> Optional[pulumi.Input[bool]]:
        """
        True if SentinelOne device is infected.
        """
        return pulumi.get(self, "infected")

    @infected.setter
    def infected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infected", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        True if SentinelOne device is active.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[pulumi.Input[str]]:
        """
        The number of issues for kolide.
        """
        return pulumi.get(self, "issue_count")

    @issue_count.setter
    def issue_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issue_count", value)

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[pulumi.Input[str]]:
        """
        The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        return pulumi.get(self, "last_seen")

    @last_seen.setter
    def last_seen(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_seen", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationArgs']]]]:
        """
        List of operating system locations to check for a client certificate..
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[pulumi.Input[str]]:
        """
        The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        """
        return pulumi.get(self, "network_status")

    @network_status.setter
    def network_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_status", value)

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[pulumi.Input[str]]:
        """
        The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        """
        return pulumi.get(self, "operational_state")

    @operational_state.setter
    def operational_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operational_state", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[str]]:
        """
        OS signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system excluding version information.
        """
        return pulumi.get(self, "os_distro_name")

    @os_distro_name.setter
    def os_distro_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_distro_name", value)

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system version excluding OS name information or release name.
        """
        return pulumi.get(self, "os_distro_revision")

    @os_distro_revision.setter
    def os_distro_revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_distro_revision", value)

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[pulumi.Input[str]]:
        """
        Extra version value following the operating system semantic version.
        """
        return pulumi.get(self, "os_version_extra")

    @os_version_extra.setter
    def os_version_extra(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_version_extra", value)

    @property
    @pulumi.getter
    def overall(self) -> Optional[pulumi.Input[str]]:
        """
        Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "overall")

    @overall.setter
    def overall(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overall", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[pulumi.Input[bool]]:
        """
        True if all drives must be encrypted.
        """
        return pulumi.get(self, "require_all")

    @require_all.setter
    def require_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)

    @property
    @pulumi.getter
    def running(self) -> Optional[pulumi.Input[bool]]:
        """
        Checks if the application should be running.
        """
        return pulumi.get(self, "running")

    @running.setter
    def running(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "running", value)

    @property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[int]]:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "score", value)

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[pulumi.Input[str]]:
        """
        Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "sensor_config")

    @sensor_config.setter
    def sensor_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensor_config", value)

    @property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[str]]:
        """
        The sha256 hash of the file.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the file certificate.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[pulumi.Input[int]]:
        """
        The total score from Tanium.
        """
        return pulumi.get(self, "total_score")

    @total_score.setter
    def total_score(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system semantic version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "version_operator")

    @version_operator.setter
    def version_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_operator", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleInputLocationArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of paths to check for client certificate rule.
        """
        trust_stores: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
elif False:
    ZeroTrustDevicePostureRuleInputLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleInputLocationArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 trust_stores: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: List of paths to check for client certificate rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] trust_stores: List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if trust_stores is not None:
            pulumi.set(__self__, "trust_stores", trust_stores)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of paths to check for client certificate rule.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
        return pulumi.get(self, "trust_stores")

    @trust_stores.setter
    def trust_stores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "trust_stores", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleMatchArgsDict(TypedDict):
        platform: NotRequired[pulumi.Input[str]]
        """
        The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
elif False:
    ZeroTrustDevicePostureRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleMatchArgs:
    def __init__(__self__, *,
                 platform: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] platform: The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        """
        The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)


if not MYPY:
    class ZeroTrustDexTestDataArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        """
        kind: pulumi.Input[str]
        """
        The type of Device Dex Test. Available values: `http`, `traceroute`.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The http request method. Available values: `GET`.
        """
elif False:
    ZeroTrustDexTestDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDexTestDataArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 kind: pulumi.Input[str],
                 method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        :param pulumi.Input[str] kind: The type of Device Dex Test. Available values: `http`, `traceroute`.
        :param pulumi.Input[str] method: The http request method. Available values: `GET`.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        The type of Device Dex Test. Available values: `http`, `traceroute`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The http request method. Available values: `GET`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)


if not MYPY:
    class ZeroTrustDlpProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['ZeroTrustDlpProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 skip: pulumi.Input['ZeroTrustDlpProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[bool] enabled: Scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['ZeroTrustDlpProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def skip(self) -> pulumi.Input['ZeroTrustDlpProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['ZeroTrustDlpProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class ZeroTrustDlpProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[bool]
        """
        Return all matches, regardless of context analysis result, if the data is a file.
        """
elif False:
    ZeroTrustDlpProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] files: Return all matches, regardless of context analysis result, if the data is a file.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> pulumi.Input[bool]:
        """
        Return all matches, regardless of context analysis result, if the data is a file.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class ZeroTrustDlpProfileEntryArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the entry to deploy.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the entry is active. Defaults to `false`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique entry identifier.
        """
        pattern: NotRequired[pulumi.Input['ZeroTrustDlpProfileEntryPatternArgsDict']]
elif False:
    ZeroTrustDlpProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpProfileEntryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 pattern: Optional[pulumi.Input['ZeroTrustDlpProfileEntryPatternArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the entry to deploy.
        :param pulumi.Input[bool] enabled: Whether the entry is active. Defaults to `false`.
        :param pulumi.Input[str] id: Unique entry identifier.
        """
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the entry to deploy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the entry is active. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique entry identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input['ZeroTrustDlpProfileEntryPatternArgs']]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input['ZeroTrustDlpProfileEntryPatternArgs']]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class ZeroTrustDlpProfileEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[str]
        """
        The regex that defines the pattern.
        """
        validation: NotRequired[pulumi.Input[str]]
        """
        The validation algorithm to apply with this pattern.
        """
elif False:
    ZeroTrustDlpProfileEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpProfileEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[str],
                 validation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: The regex that defines the pattern.
        :param pulumi.Input[str] validation: The validation algorithm to apply with this pattern.
        """
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        """
        The regex that defines the pattern.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input[str]]:
        """
        The validation algorithm to apply with this pattern.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDnsLocationNetworkArgsDict(TypedDict):
        network: pulumi.Input[str]
        """
        CIDR notation representation of the network IP.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of this resource.
        """
elif False:
    ZeroTrustDnsLocationNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network: CIDR notation representation of the network IP.
        :param pulumi.Input[str] id: The ID of this resource.
        """
        pulumi.set(__self__, "network", network)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsArgsDict(TypedDict):
        add_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        allow_child_bypass: NotRequired[pulumi.Input[bool]]
        """
        Allow parent MSP accounts to enable bypass their children's rules.
        """
        audit_ssh: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict']]
        """
        Settings for auditing SSH usage.
        """
        biso_admin_controls: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict']]
        """
        Configure how browser isolation behaves.
        """
        block_page_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicator of block page enablement.
        """
        block_page_reason: NotRequired[pulumi.Input[str]]
        """
        The displayed reason for a user being blocked.
        """
        bypass_parent_rule: NotRequired[pulumi.Input[bool]]
        """
        Allow child MSP accounts to bypass their parent's rule.
        """
        check_session: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict']]
        """
        Configure how session check behaves.
        """
        dns_resolvers: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict']]
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        """
        egress: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict']]
        """
        Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        """
        ignore_cname_category_matches: NotRequired[pulumi.Input[bool]]
        """
        Set to true, to ignore the category matches at CNAME domains in a response.
        """
        insecure_disable_dnssec_validation: NotRequired[pulumi.Input[bool]]
        """
        Disable DNSSEC validation (must be Allow rule).
        """
        ip_categories: NotRequired[pulumi.Input[bool]]
        """
        Turns on IP category based filter on dns if the rule contains dns category checks.
        """
        l4override: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict']]
        """
        Settings to forward layer 4 traffic.
        """
        notification_settings: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict']]
        """
        Notification settings on a block rule.
        """
        override_host: NotRequired[pulumi.Input[str]]
        """
        The host to override matching DNS queries with.
        """
        override_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The IPs to override matching DNS queries with.
        """
        payload_log: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict']]
        """
        Configure DLP Payload Logging settings for this rule.
        """
        resolve_dns_through_cloudflare: NotRequired[pulumi.Input[bool]]
        """
        Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        """
        untrusted_cert: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict']]
        """
        Configure untrusted certificate settings for this rule.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsArgs:
    def __init__(__self__, *,
                 add_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allow_child_bypass: Optional[pulumi.Input[bool]] = None,
                 audit_ssh: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']] = None,
                 biso_admin_controls: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']] = None,
                 block_page_enabled: Optional[pulumi.Input[bool]] = None,
                 block_page_reason: Optional[pulumi.Input[str]] = None,
                 bypass_parent_rule: Optional[pulumi.Input[bool]] = None,
                 check_session: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']] = None,
                 dns_resolvers: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']] = None,
                 egress: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']] = None,
                 ignore_cname_category_matches: Optional[pulumi.Input[bool]] = None,
                 insecure_disable_dnssec_validation: Optional[pulumi.Input[bool]] = None,
                 ip_categories: Optional[pulumi.Input[bool]] = None,
                 l4override: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']] = None,
                 notification_settings: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']] = None,
                 override_host: Optional[pulumi.Input[str]] = None,
                 override_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 payload_log: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']] = None,
                 resolve_dns_through_cloudflare: Optional[pulumi.Input[bool]] = None,
                 untrusted_cert: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] add_headers: Add custom headers to allowed requests in the form of key-value pairs.
        :param pulumi.Input[bool] allow_child_bypass: Allow parent MSP accounts to enable bypass their children's rules.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs'] audit_ssh: Settings for auditing SSH usage.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs'] biso_admin_controls: Configure how browser isolation behaves.
        :param pulumi.Input[bool] block_page_enabled: Indicator of block page enablement.
        :param pulumi.Input[str] block_page_reason: The displayed reason for a user being blocked.
        :param pulumi.Input[bool] bypass_parent_rule: Allow child MSP accounts to bypass their parent's rule.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs'] check_session: Configure how session check behaves.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs'] dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs'] egress: Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        :param pulumi.Input[bool] ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response.
        :param pulumi.Input[bool] insecure_disable_dnssec_validation: Disable DNSSEC validation (must be Allow rule).
        :param pulumi.Input[bool] ip_categories: Turns on IP category based filter on dns if the rule contains dns category checks.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs'] l4override: Settings to forward layer 4 traffic.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs'] notification_settings: Notification settings on a block rule.
        :param pulumi.Input[str] override_host: The host to override matching DNS queries with.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] override_ips: The IPs to override matching DNS queries with.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs'] payload_log: Configure DLP Payload Logging settings for this rule.
        :param pulumi.Input[bool] resolve_dns_through_cloudflare: Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs'] untrusted_cert: Configure untrusted certificate settings for this rule.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_page_reason is not None:
            pulumi.set(__self__, "block_page_reason", block_page_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if dns_resolvers is not None:
            pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ignore_cname_category_matches is not None:
            pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if resolve_dns_through_cloudflare is not None:
            pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        return pulumi.get(self, "add_headers")

    @add_headers.setter
    def add_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "add_headers", value)

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow parent MSP accounts to enable bypass their children's rules.
        """
        return pulumi.get(self, "allow_child_bypass")

    @allow_child_bypass.setter
    def allow_child_bypass(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_child_bypass", value)

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']]:
        """
        Settings for auditing SSH usage.
        """
        return pulumi.get(self, "audit_ssh")

    @audit_ssh.setter
    def audit_ssh(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']]):
        pulumi.set(self, "audit_ssh", value)

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']]:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @biso_admin_controls.setter
    def biso_admin_controls(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']]):
        pulumi.set(self, "biso_admin_controls", value)

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicator of block page enablement.
        """
        return pulumi.get(self, "block_page_enabled")

    @block_page_enabled.setter
    def block_page_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_page_enabled", value)

    @property
    @pulumi.getter(name="blockPageReason")
    def block_page_reason(self) -> Optional[pulumi.Input[str]]:
        """
        The displayed reason for a user being blocked.
        """
        return pulumi.get(self, "block_page_reason")

    @block_page_reason.setter
    def block_page_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_page_reason", value)

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow child MSP accounts to bypass their parent's rule.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @bypass_parent_rule.setter
    def bypass_parent_rule(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_parent_rule", value)

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']]:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @check_session.setter
    def check_session(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']]):
        pulumi.set(self, "check_session", value)

    @property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']]:
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        """
        return pulumi.get(self, "dns_resolvers")

    @dns_resolvers.setter
    def dns_resolvers(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']]):
        pulumi.set(self, "dns_resolvers", value)

    @property
    @pulumi.getter
    def egress(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']]:
        """
        Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        """
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']]):
        pulumi.set(self, "egress", value)

    @property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true, to ignore the category matches at CNAME domains in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @ignore_cname_category_matches.setter
    def ignore_cname_category_matches(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_cname_category_matches", value)

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable DNSSEC validation (must be Allow rule).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @insecure_disable_dnssec_validation.setter
    def insecure_disable_dnssec_validation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_disable_dnssec_validation", value)

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[pulumi.Input[bool]]:
        """
        Turns on IP category based filter on dns if the rule contains dns category checks.
        """
        return pulumi.get(self, "ip_categories")

    @ip_categories.setter
    def ip_categories(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_categories", value)

    @property
    @pulumi.getter
    def l4override(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']]:
        """
        Settings to forward layer 4 traffic.
        """
        return pulumi.get(self, "l4override")

    @l4override.setter
    def l4override(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']]):
        pulumi.set(self, "l4override", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']]:
        """
        Notification settings on a block rule.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[pulumi.Input[str]]:
        """
        The host to override matching DNS queries with.
        """
        return pulumi.get(self, "override_host")

    @override_host.setter
    def override_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_host", value)

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The IPs to override matching DNS queries with.
        """
        return pulumi.get(self, "override_ips")

    @override_ips.setter
    def override_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "override_ips", value)

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']]:
        """
        Configure DLP Payload Logging settings for this rule.
        """
        return pulumi.get(self, "payload_log")

    @payload_log.setter
    def payload_log(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']]):
        pulumi.set(self, "payload_log", value)

    @property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @resolve_dns_through_cloudflare.setter
    def resolve_dns_through_cloudflare(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolve_dns_through_cloudflare", value)

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']]:
        """
        Configure untrusted certificate settings for this rule.
        """
        return pulumi.get(self, "untrusted_cert")

    @untrusted_cert.setter
    def untrusted_cert(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']]):
        pulumi.set(self, "untrusted_cert", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict(TypedDict):
        command_logging: pulumi.Input[bool]
        """
        Log all SSH commands.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs:
    def __init__(__self__, *,
                 command_logging: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] command_logging: Log all SSH commands.
        """
        pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> pulumi.Input[bool]:
        """
        Log all SSH commands.
        """
        return pulumi.get(self, "command_logging")

    @command_logging.setter
    def command_logging(self, value: pulumi.Input[bool]):
        pulumi.set(self, "command_logging", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict(TypedDict):
        disable_clipboard_redirection: NotRequired[pulumi.Input[bool]]
        """
        Disable clipboard redirection.
        """
        disable_copy_paste: NotRequired[pulumi.Input[bool]]
        """
        Disable copy-paste.
        """
        disable_download: NotRequired[pulumi.Input[bool]]
        """
        Disable download.
        """
        disable_keyboard: NotRequired[pulumi.Input[bool]]
        """
        Disable keyboard usage.
        """
        disable_printing: NotRequired[pulumi.Input[bool]]
        """
        Disable printing.
        """
        disable_upload: NotRequired[pulumi.Input[bool]]
        """
        Disable upload.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs:
    def __init__(__self__, *,
                 disable_clipboard_redirection: Optional[pulumi.Input[bool]] = None,
                 disable_copy_paste: Optional[pulumi.Input[bool]] = None,
                 disable_download: Optional[pulumi.Input[bool]] = None,
                 disable_keyboard: Optional[pulumi.Input[bool]] = None,
                 disable_printing: Optional[pulumi.Input[bool]] = None,
                 disable_upload: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable_clipboard_redirection: Disable clipboard redirection.
        :param pulumi.Input[bool] disable_copy_paste: Disable copy-paste.
        :param pulumi.Input[bool] disable_download: Disable download.
        :param pulumi.Input[bool] disable_keyboard: Disable keyboard usage.
        :param pulumi.Input[bool] disable_printing: Disable printing.
        :param pulumi.Input[bool] disable_upload: Disable upload.
        """
        if disable_clipboard_redirection is not None:
            pulumi.set(__self__, "disable_clipboard_redirection", disable_clipboard_redirection)
        if disable_copy_paste is not None:
            pulumi.set(__self__, "disable_copy_paste", disable_copy_paste)
        if disable_download is not None:
            pulumi.set(__self__, "disable_download", disable_download)
        if disable_keyboard is not None:
            pulumi.set(__self__, "disable_keyboard", disable_keyboard)
        if disable_printing is not None:
            pulumi.set(__self__, "disable_printing", disable_printing)
        if disable_upload is not None:
            pulumi.set(__self__, "disable_upload", disable_upload)

    @property
    @pulumi.getter(name="disableClipboardRedirection")
    def disable_clipboard_redirection(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable clipboard redirection.
        """
        return pulumi.get(self, "disable_clipboard_redirection")

    @disable_clipboard_redirection.setter
    def disable_clipboard_redirection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_clipboard_redirection", value)

    @property
    @pulumi.getter(name="disableCopyPaste")
    def disable_copy_paste(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable copy-paste.
        """
        return pulumi.get(self, "disable_copy_paste")

    @disable_copy_paste.setter
    def disable_copy_paste(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_copy_paste", value)

    @property
    @pulumi.getter(name="disableDownload")
    def disable_download(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable download.
        """
        return pulumi.get(self, "disable_download")

    @disable_download.setter
    def disable_download(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_download", value)

    @property
    @pulumi.getter(name="disableKeyboard")
    def disable_keyboard(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable keyboard usage.
        """
        return pulumi.get(self, "disable_keyboard")

    @disable_keyboard.setter
    def disable_keyboard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_keyboard", value)

    @property
    @pulumi.getter(name="disablePrinting")
    def disable_printing(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable printing.
        """
        return pulumi.get(self, "disable_printing")

    @disable_printing.setter
    def disable_printing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_printing", value)

    @property
    @pulumi.getter(name="disableUpload")
    def disable_upload(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable upload.
        """
        return pulumi.get(self, "disable_upload")

    @disable_upload.setter
    def disable_upload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_upload", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict(TypedDict):
        duration: pulumi.Input[str]
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        enforce: pulumi.Input[bool]
        """
        Enable session enforcement for this rule.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 enforce: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] duration: Configure how fresh the session needs to be to be considered valid.
        :param pulumi.Input[bool] enforce: Enable session enforcement for this rule.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def enforce(self) -> pulumi.Input[bool]:
        """
        Enable session enforcement for this rule.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enforce", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict']]]]
        """
        IPv4 resolvers.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict']]]]
        """
        IPv6 resolvers.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]] ipv4s: IPv4 resolvers.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]] ipv6s: IPv6 resolvers.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]]:
        """
        IPv4 resolvers.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]]:
        """
        IPv6 resolvers.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        route_through_private_network: NotRequired[pulumi.Input[bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 route_through_private_network: Optional[pulumi.Input[bool]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: The IPv4 or IPv6 address of the upstream resolver.
        :param pulumi.Input[int] port: A port number to use for the upstream resolver. Defaults to `53`.
        :param pulumi.Input[bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        :param pulumi.Input[str] vnet_id: specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        route_through_private_network: NotRequired[pulumi.Input[bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 route_through_private_network: Optional[pulumi.Input[bool]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: The IPv4 or IPv6 address of the upstream resolver.
        :param pulumi.Input[int] port: A port number to use for the upstream resolver. Defaults to `53`.
        :param pulumi.Input[bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        :param pulumi.Input[str] vnet_id: specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict(TypedDict):
        ipv4: pulumi.Input[str]
        """
        The IPv4 address to be used for egress.
        """
        ipv6: pulumi.Input[str]
        """
        The IPv6 range to be used for egress.
        """
        ipv4_fallback: NotRequired[pulumi.Input[str]]
        """
        The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsEgressArgs:
    def __init__(__self__, *,
                 ipv4: pulumi.Input[str],
                 ipv6: pulumi.Input[str],
                 ipv4_fallback: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv4: The IPv4 address to be used for egress.
        :param pulumi.Input[str] ipv6: The IPv6 range to be used for egress.
        :param pulumi.Input[str] ipv4_fallback: The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)

    @property
    @pulumi.getter
    def ipv4(self) -> pulumi.Input[str]:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> pulumi.Input[str]:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @ipv4_fallback.setter
    def ipv4_fallback(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_fallback", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        Override IP to forward traffic to.
        """
        port: pulumi.Input[int]
        """
        Override Port to forward traffic to.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: pulumi.Input[int]):
        """
        :param pulumi.Input[str] ip: Override IP to forward traffic to.
        :param pulumi.Input[int] port: Override Port to forward traffic to.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        Override IP to forward traffic to.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Override Port to forward traffic to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification settings.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Notification content.
        """
        support_url: NotRequired[pulumi.Input[str]]
        """
        Support URL to show in the notification.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 support_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification settings.
        :param pulumi.Input[str] message: Notification content.
        :param pulumi.Input[str] support_url: Support URL to show in the notification.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Notification content.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[str]]:
        """
        Support URL to show in the notification.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Enable or disable DLP Payload Logging for this rule.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Enable or disable DLP Payload Logging for this rule.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Enable or disable DLP Payload Logging for this rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class ZeroTrustGatewaySettingsAntivirusArgsDict(TypedDict):
        enabled_download_phase: pulumi.Input[bool]
        """
        Scan on file download.
        """
        enabled_upload_phase: pulumi.Input[bool]
        """
        Scan on file upload.
        """
        fail_closed: pulumi.Input[bool]
        """
        Block requests for files that cannot be scanned.
        """
        notification_settings: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgsDict']]
        """
        Set notifications for antivirus.
        """
elif False:
    ZeroTrustGatewaySettingsAntivirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsAntivirusArgs:
    def __init__(__self__, *,
                 enabled_download_phase: pulumi.Input[bool],
                 enabled_upload_phase: pulumi.Input[bool],
                 fail_closed: pulumi.Input[bool],
                 notification_settings: Optional[pulumi.Input['ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs']] = None):
        """
        :param pulumi.Input[bool] enabled_download_phase: Scan on file download.
        :param pulumi.Input[bool] enabled_upload_phase: Scan on file upload.
        :param pulumi.Input[bool] fail_closed: Block requests for files that cannot be scanned.
        :param pulumi.Input['ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs'] notification_settings: Set notifications for antivirus.
        """
        pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        pulumi.set(__self__, "fail_closed", fail_closed)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> pulumi.Input[bool]:
        """
        Scan on file download.
        """
        return pulumi.get(self, "enabled_download_phase")

    @enabled_download_phase.setter
    def enabled_download_phase(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_download_phase", value)

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> pulumi.Input[bool]:
        """
        Scan on file upload.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @enabled_upload_phase.setter
    def enabled_upload_phase(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_upload_phase", value)

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> pulumi.Input[bool]:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @fail_closed.setter
    def fail_closed(self, value: pulumi.Input[bool]):
        pulumi.set(self, "fail_closed", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs']]:
        """
        Set notifications for antivirus.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)


if not MYPY:
    class ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable notification settings.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Notification content.
        """
        support_url: NotRequired[pulumi.Input[str]]
        """
        Support URL to show in the notification.
        """
elif False:
    ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 support_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable notification settings.
        :param pulumi.Input[str] message: Notification content.
        :param pulumi.Input[str] support_url: Support URL to show in the notification.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable notification settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Notification content.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[str]]:
        """
        Support URL to show in the notification.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class ZeroTrustGatewaySettingsBlockPageArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[str]]
        """
        Hex code of block page background color.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicator of enablement.
        """
        footer_text: NotRequired[pulumi.Input[str]]
        """
        Block page footer text.
        """
        header_text: NotRequired[pulumi.Input[str]]
        """
        Block page header text.
        """
        logo_path: NotRequired[pulumi.Input[str]]
        """
        URL of block page logo.
        """
        mailto_address: NotRequired[pulumi.Input[str]]
        """
        Admin email for users to contact.
        """
        mailto_subject: NotRequired[pulumi.Input[str]]
        """
        Subject line for emails created from block page.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of block page configuration.
        """
elif False:
    ZeroTrustGatewaySettingsBlockPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsBlockPageArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None,
                 logo_path: Optional[pulumi.Input[str]] = None,
                 mailto_address: Optional[pulumi.Input[str]] = None,
                 mailto_subject: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_color: Hex code of block page background color.
        :param pulumi.Input[bool] enabled: Indicator of enablement.
        :param pulumi.Input[str] footer_text: Block page footer text.
        :param pulumi.Input[str] header_text: Block page header text.
        :param pulumi.Input[str] logo_path: URL of block page logo.
        :param pulumi.Input[str] mailto_address: Admin email for users to contact.
        :param pulumi.Input[str] mailto_subject: Subject line for emails created from block page.
        :param pulumi.Input[str] name: Name of block page configuration.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Hex code of block page background color.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicator of enablement.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[str]]:
        """
        URL of block page logo.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_path", value)

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[pulumi.Input[str]]:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @mailto_address.setter
    def mailto_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mailto_address", value)

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @mailto_subject.setter
    def mailto_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mailto_subject", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of block page configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustGatewaySettingsBodyScanningArgsDict(TypedDict):
        inspection_mode: pulumi.Input[str]
        """
        Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
elif False:
    ZeroTrustGatewaySettingsBodyScanningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsBodyScanningArgs:
    def __init__(__self__, *,
                 inspection_mode: pulumi.Input[str]):
        """
        :param pulumi.Input[str] inspection_mode: Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
        pulumi.set(__self__, "inspection_mode", inspection_mode)

    @property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> pulumi.Input[str]:
        """
        Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
        return pulumi.get(self, "inspection_mode")

    @inspection_mode.setter
    def inspection_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "inspection_mode", value)


if not MYPY:
    class ZeroTrustGatewaySettingsCertificateArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of certificate for TLS interception.
        """
elif False:
    ZeroTrustGatewaySettingsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsCertificateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of certificate for TLS interception.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of certificate for TLS interception.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustGatewaySettingsCustomCertificateArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether TLS encryption should use a custom certificate.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of custom certificate.
        """
        updated_at: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustGatewaySettingsCustomCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsCustomCertificateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether TLS encryption should use a custom certificate.
        :param pulumi.Input[str] id: ID of custom certificate.
        """
        pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether TLS encryption should use a custom certificate.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of custom certificate.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ZeroTrustGatewaySettingsExtendedEmailMatchingArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
elif False:
    ZeroTrustGatewaySettingsExtendedEmailMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsExtendedEmailMatchingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsFipsArgsDict(TypedDict):
        tls: NotRequired[pulumi.Input[bool]]
        """
        Only allow FIPS-compliant TLS configuration.
        """
elif False:
    ZeroTrustGatewaySettingsFipsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsFipsArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] tls: Only allow FIPS-compliant TLS configuration.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Only allow FIPS-compliant TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class ZeroTrustGatewaySettingsLoggingArgsDict(TypedDict):
        redact_pii: pulumi.Input[bool]
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        """
        settings_by_rule_type: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgsDict']
        """
        Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
elif False:
    ZeroTrustGatewaySettingsLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsLoggingArgs:
    def __init__(__self__, *,
                 redact_pii: pulumi.Input[bool],
                 settings_by_rule_type: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs']):
        """
        :param pulumi.Input[bool] redact_pii: Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        :param pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs'] settings_by_rule_type: Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        pulumi.set(__self__, "redact_pii", redact_pii)
        pulumi.set(__self__, "settings_by_rule_type", settings_by_rule_type)

    @property
    @pulumi.getter(name="redactPii")
    def redact_pii(self) -> pulumi.Input[bool]:
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        """
        return pulumi.get(self, "redact_pii")

    @redact_pii.setter
    def redact_pii(self, value: pulumi.Input[bool]):
        pulumi.set(self, "redact_pii", value)

    @property
    @pulumi.getter(name="settingsByRuleType")
    def settings_by_rule_type(self) -> pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs']:
        """
        Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        return pulumi.get(self, "settings_by_rule_type")

    @settings_by_rule_type.setter
    def settings_by_rule_type(self, value: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs']):
        pulumi.set(self, "settings_by_rule_type", value)


if not MYPY:
    class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgsDict(TypedDict):
        dns: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgsDict']
        """
        Logging configuration for DNS requests.
        """
        http: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgsDict']
        """
        Logging configuration for HTTP requests.
        """
        l4: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4ArgsDict']
        """
        Logging configuration for layer 4 requests.
        """
elif False:
    ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs:
    def __init__(__self__, *,
                 dns: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs'],
                 http: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs'],
                 l4: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args']):
        """
        :param pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs'] dns: Logging configuration for DNS requests.
        :param pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs'] http: Logging configuration for HTTP requests.
        :param pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args'] l4: Logging configuration for layer 4 requests.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "http", http)
        pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs']:
        """
        Logging configuration for DNS requests.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs']):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def http(self) -> pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs']:
        """
        Logging configuration for HTTP requests.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs']):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def l4(self) -> pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args']:
        """
        Logging configuration for layer 4 requests.
        """
        return pulumi.get(self, "l4")

    @l4.setter
    def l4(self, value: pulumi.Input['ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args']):
        pulumi.set(self, "l4", value)


if not MYPY:
    class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgsDict(TypedDict):
        log_all: pulumi.Input[bool]
        """
        Whether to log all activity.
        """
        log_blocks: pulumi.Input[bool]
elif False:
    ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgsDict(TypedDict):
        log_all: pulumi.Input[bool]
        """
        Whether to log all activity.
        """
        log_blocks: pulumi.Input[bool]
elif False:
    ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4ArgsDict(TypedDict):
        log_all: pulumi.Input[bool]
        """
        Whether to log all activity.
        """
        log_blocks: pulumi.Input[bool]
elif False:
    ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class ZeroTrustGatewaySettingsPayloadLogArgsDict(TypedDict):
        public_key: pulumi.Input[str]
        """
        Public key used to encrypt matched payloads.
        """
elif False:
    ZeroTrustGatewaySettingsPayloadLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsPayloadLogArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: Public key used to encrypt matched payloads.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        Public key used to encrypt matched payloads.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class ZeroTrustGatewaySettingsProxyArgsDict(TypedDict):
        disable_for_time: pulumi.Input[int]
        """
        Sets the time limit in seconds that a user can use an override code to bypass WARP.
        """
        root_ca: pulumi.Input[bool]
        """
        Whether root ca is enabled account wide for ZT clients.
        """
        tcp: pulumi.Input[bool]
        """
        Whether gateway proxy is enabled on gateway devices for TCP traffic.
        """
        udp: pulumi.Input[bool]
        """
        Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        virtual_ip: pulumi.Input[bool]
        """
        Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
elif False:
    ZeroTrustGatewaySettingsProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsProxyArgs:
    def __init__(__self__, *,
                 disable_for_time: pulumi.Input[int],
                 root_ca: pulumi.Input[bool],
                 tcp: pulumi.Input[bool],
                 udp: pulumi.Input[bool],
                 virtual_ip: pulumi.Input[bool]):
        """
        :param pulumi.Input[int] disable_for_time: Sets the time limit in seconds that a user can use an override code to bypass WARP.
        :param pulumi.Input[bool] root_ca: Whether root ca is enabled account wide for ZT clients.
        :param pulumi.Input[bool] tcp: Whether gateway proxy is enabled on gateway devices for TCP traffic.
        :param pulumi.Input[bool] udp: Whether gateway proxy is enabled on gateway devices for UDP traffic.
        :param pulumi.Input[bool] virtual_ip: Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
        pulumi.set(__self__, "disable_for_time", disable_for_time)
        pulumi.set(__self__, "root_ca", root_ca)
        pulumi.set(__self__, "tcp", tcp)
        pulumi.set(__self__, "udp", udp)
        pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="disableForTime")
    def disable_for_time(self) -> pulumi.Input[int]:
        """
        Sets the time limit in seconds that a user can use an override code to bypass WARP.
        """
        return pulumi.get(self, "disable_for_time")

    @disable_for_time.setter
    def disable_for_time(self, value: pulumi.Input[int]):
        pulumi.set(self, "disable_for_time", value)

    @property
    @pulumi.getter(name="rootCa")
    def root_ca(self) -> pulumi.Input[bool]:
        """
        Whether root ca is enabled account wide for ZT clients.
        """
        return pulumi.get(self, "root_ca")

    @root_ca.setter
    def root_ca(self, value: pulumi.Input[bool]):
        pulumi.set(self, "root_ca", value)

    @property
    @pulumi.getter
    def tcp(self) -> pulumi.Input[bool]:
        """
        Whether gateway proxy is enabled on gateway devices for TCP traffic.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter
    def udp(self) -> pulumi.Input[bool]:
        """
        Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "udp", value)

    @property
    @pulumi.getter(name="virtualIp")
    def virtual_ip(self) -> pulumi.Input[bool]:
        """
        Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
        return pulumi.get(self, "virtual_ip")

    @virtual_ip.setter
    def virtual_ip(self, value: pulumi.Input[bool]):
        pulumi.set(self, "virtual_ip", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSshSessionLogArgsDict(TypedDict):
        public_key: pulumi.Input[str]
        """
        Public key used to encrypt ssh session.
        """
elif False:
    ZeroTrustGatewaySettingsSshSessionLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSshSessionLogArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: Public key used to encrypt ssh session.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        Public key used to encrypt ssh session.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class ZeroTrustInfrastructureAccessTargetIpArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv4ArgsDict']]
        """
        The target's IPv4 address.
        """
        ipv6: NotRequired[pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv6ArgsDict']]
        """
        The target's IPv6 address.
        """
elif False:
    ZeroTrustInfrastructureAccessTargetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustInfrastructureAccessTargetIpArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv6Args']] = None):
        """
        :param pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv4Args'] ipv4: The target's IPv4 address.
        :param pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv6Args'] ipv6: The target's IPv6 address.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv4Args']]:
        """
        The target's IPv4 address.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv6Args']]:
        """
        The target's IPv6 address.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['ZeroTrustInfrastructureAccessTargetIpIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ZeroTrustInfrastructureAccessTargetIpIpv4ArgsDict(TypedDict):
        ip_addr: pulumi.Input[str]
        """
        The IP address of the target.
        """
        virtual_network_id: pulumi.Input[str]
        """
        The private virtual network identifier for the target.
        """
elif False:
    ZeroTrustInfrastructureAccessTargetIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustInfrastructureAccessTargetIpIpv4Args:
    def __init__(__self__, *,
                 ip_addr: pulumi.Input[str],
                 virtual_network_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip_addr: The IP address of the target.
        :param pulumi.Input[str] virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> pulumi.Input[str]:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @ip_addr.setter
    def ip_addr(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_addr", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> pulumi.Input[str]:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class ZeroTrustInfrastructureAccessTargetIpIpv6ArgsDict(TypedDict):
        ip_addr: pulumi.Input[str]
        """
        The IP address of the target.
        """
        virtual_network_id: pulumi.Input[str]
        """
        The private virtual network identifier for the target.
        """
elif False:
    ZeroTrustInfrastructureAccessTargetIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustInfrastructureAccessTargetIpIpv6Args:
    def __init__(__self__, *,
                 ip_addr: pulumi.Input[str],
                 virtual_network_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip_addr: The IP address of the target.
        :param pulumi.Input[str] virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> pulumi.Input[str]:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @ip_addr.setter
    def ip_addr(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_addr", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> pulumi.Input[str]:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class ZeroTrustListItemsWithDescriptionArgsDict(TypedDict):
        description: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    ZeroTrustListItemsWithDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustListItemsWithDescriptionArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ZeroTrustLocalFallbackDomainDomainArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        The domain suffix to match when resolving locally.
        """
elif False:
    ZeroTrustLocalFallbackDomainDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustLocalFallbackDomainDomainArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP addresses to handle domain resolution.
        :param pulumi.Input[str] suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class ZeroTrustRiskBehaviorBehaviorArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether this risk behavior type is enabled.
        """
        name: pulumi.Input[str]
        """
        Name of this risk behavior type
        """
        risk_level: pulumi.Input[str]
        """
        Risk level. Available values: `low`, `medium`, `high`
        """
elif False:
    ZeroTrustRiskBehaviorBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustRiskBehaviorBehaviorArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 risk_level: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Whether this risk behavior type is enabled.
        :param pulumi.Input[str] name: Name of this risk behavior type
        :param pulumi.Input[str] risk_level: Risk level. Available values: `low`, `medium`, `high`
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether this risk behavior type is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of this risk behavior type
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> pulumi.Input[str]:
        """
        Risk level. Available values: `low`, `medium`, `high`
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "risk_level", value)


if not MYPY:
    class ZeroTrustSplitTunnelTunnelArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        The address for the tunnel.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description for the tunnel.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        The domain name for the tunnel.
        """
elif False:
    ZeroTrustSplitTunnelTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustSplitTunnelTunnelArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address for the tunnel.
        :param pulumi.Input[str] description: A description for the tunnel.
        :param pulumi.Input[str] host: The domain name for the tunnel.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address for the tunnel.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description for the tunnel.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name for the tunnel.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigArgsDict(TypedDict):
        ingress_rules: pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgsDict']]]
        """
        Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        """
        origin_request: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict']]
        warp_routing: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict']]
        """
        If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigArgs:
    def __init__(__self__, *,
                 ingress_rules: pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs']]],
                 origin_request: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']] = None,
                 warp_routing: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs']]] ingress_rules: Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs'] warp_routing: If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        pulumi.set(__self__, "ingress_rules", ingress_rules)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @property
    @pulumi.getter(name="ingressRules")
    def ingress_rules(self) -> pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs']]]:
        """
        Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        """
        return pulumi.get(self, "ingress_rules")

    @ingress_rules.setter
    def ingress_rules(self, value: pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs']]]):
        pulumi.set(self, "ingress_rules", value)

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']]:
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']]:
        """
        If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        return pulumi.get(self, "warp_routing")

    @warp_routing.setter
    def warp_routing(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']]):
        pulumi.set(self, "warp_routing", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgsDict(TypedDict):
        service: pulumi.Input[str]
        """
        Name of the service to which the request will be sent.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        """
        origin_request: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgsDict']]
        path: NotRequired[pulumi.Input[str]]
        """
        Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 hostname: Optional[pulumi.Input[str]] = None,
                 origin_request: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgs']] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service: Name of the service to which the request will be sent.
        :param pulumi.Input[str] hostname: Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        :param pulumi.Input[str] path: Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Name of the service to which the request will be sent.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgs']]:
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgsDict']]
        """
        Access rules for the ingress service.
        """
        bastion_mode: NotRequired[pulumi.Input[bool]]
        """
        Runs as jump host.
        """
        ca_pool: NotRequired[pulumi.Input[str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        connect_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        http2_origin: NotRequired[pulumi.Input[bool]]
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        http_host_header: NotRequired[pulumi.Input[str]]
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        ip_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgsDict']]]]
        """
        IP rules for the proxy service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        no_tls_verify: NotRequired[pulumi.Input[bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        origin_server_name: NotRequired[pulumi.Input[str]]
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        proxy_address: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        proxy_port: NotRequired[pulumi.Input[int]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        proxy_type: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[str]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        tls_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs']] = None,
                 bastion_mode: Optional[pulumi.Input[bool]] = None,
                 ca_pool: Optional[pulumi.Input[str]] = None,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
                 http2_origin: Optional[pulumi.Input[bool]] = None,
                 http_host_header: Optional[pulumi.Input[str]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgs']]]] = None,
                 keep_alive_connections: Optional[pulumi.Input[int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[str]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None,
                 origin_server_name: Optional[pulumi.Input[str]] = None,
                 proxy_address: Optional[pulumi.Input[str]] = None,
                 proxy_port: Optional[pulumi.Input[int]] = None,
                 proxy_type: Optional[pulumi.Input[str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[str]] = None,
                 tls_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs'] access: Access rules for the ingress service.
        :param pulumi.Input[bool] bastion_mode: Runs as jump host.
        :param pulumi.Input[str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param pulumi.Input[str] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param pulumi.Input[bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param pulumi.Input[bool] http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param pulumi.Input[str] http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgs']]] ip_rules: IP rules for the proxy service.
        :param pulumi.Input[int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param pulumi.Input[str] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param pulumi.Input[bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param pulumi.Input[bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param pulumi.Input[str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param pulumi.Input[str] proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param pulumi.Input[int] proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param pulumi.Input[str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param pulumi.Input[str] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param pulumi.Input[str] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs']]:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @bastion_mode.setter
    def bastion_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bastion_mode", value)

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_pool", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_origin", value)

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_host_header", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgs']]]]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_server_name", value)

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @proxy_address.setter
    def proxy_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_address", value)

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[pulumi.Input[int]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @proxy_port.setter
    def proxy_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "proxy_port", value)

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_type", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgsDict(TypedDict):
        aud_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Audience tags of the access rule.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Whether the access rule is required.
        """
        team_name: NotRequired[pulumi.Input[str]]
        """
        Name of the team to which the access rule applies.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 team_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aud_tags: Audience tags of the access rule.
        :param pulumi.Input[bool] required: Whether the access rule is required.
        :param pulumi.Input[str] team_name: Name of the team to which the access rule applies.
        """
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aud_tags", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow the IP prefix.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Ports to use within the IP rule.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        IP rule prefix.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow: Whether to allow the IP prefix.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: Ports to use within the IP rule.
        :param pulumi.Input[str] prefix: IP rule prefix.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict']]
        """
        Access rules for the ingress service.
        """
        bastion_mode: NotRequired[pulumi.Input[bool]]
        """
        Runs as jump host.
        """
        ca_pool: NotRequired[pulumi.Input[str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        connect_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        http2_origin: NotRequired[pulumi.Input[bool]]
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        http_host_header: NotRequired[pulumi.Input[str]]
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        ip_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgsDict']]]]
        """
        IP rules for the proxy service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        no_tls_verify: NotRequired[pulumi.Input[bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        origin_server_name: NotRequired[pulumi.Input[str]]
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        proxy_address: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        proxy_port: NotRequired[pulumi.Input[int]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        proxy_type: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[str]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        tls_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']] = None,
                 bastion_mode: Optional[pulumi.Input[bool]] = None,
                 ca_pool: Optional[pulumi.Input[str]] = None,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
                 http2_origin: Optional[pulumi.Input[bool]] = None,
                 http_host_header: Optional[pulumi.Input[str]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs']]]] = None,
                 keep_alive_connections: Optional[pulumi.Input[int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[str]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None,
                 origin_server_name: Optional[pulumi.Input[str]] = None,
                 proxy_address: Optional[pulumi.Input[str]] = None,
                 proxy_port: Optional[pulumi.Input[int]] = None,
                 proxy_type: Optional[pulumi.Input[str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[str]] = None,
                 tls_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs'] access: Access rules for the ingress service.
        :param pulumi.Input[bool] bastion_mode: Runs as jump host.
        :param pulumi.Input[str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param pulumi.Input[str] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param pulumi.Input[bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param pulumi.Input[bool] http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param pulumi.Input[str] http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs']]] ip_rules: IP rules for the proxy service.
        :param pulumi.Input[int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param pulumi.Input[str] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param pulumi.Input[bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param pulumi.Input[bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param pulumi.Input[str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param pulumi.Input[str] proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param pulumi.Input[int] proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param pulumi.Input[str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param pulumi.Input[str] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param pulumi.Input[str] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']]:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @bastion_mode.setter
    def bastion_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bastion_mode", value)

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_pool", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_origin", value)

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_host_header", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs']]]]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_server_name", value)

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @proxy_address.setter
    def proxy_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_address", value)

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[pulumi.Input[int]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @proxy_port.setter
    def proxy_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "proxy_port", value)

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_type", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict(TypedDict):
        aud_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Audience tags of the access rule.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Whether the access rule is required.
        """
        team_name: NotRequired[pulumi.Input[str]]
        """
        Name of the team to which the access rule applies.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 team_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aud_tags: Audience tags of the access rule.
        :param pulumi.Input[bool] required: Whether the access rule is required.
        :param pulumi.Input[str] team_name: Name of the team to which the access rule applies.
        """
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aud_tags", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow the IP prefix.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Ports to use within the IP rule.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        IP rule prefix.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow: Whether to allow the IP prefix.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: Ports to use within the IP rule.
        :param pulumi.Input[str] prefix: IP rule prefix.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether WARP routing is enabled.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether WARP routing is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether WARP routing is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZoneLockdownConfigurationArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The request property to target. Available values: `ip`, `ip_range`.
        """
        value: pulumi.Input[str]
        """
        The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
elif False:
    ZoneLockdownConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneLockdownConfigurationArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target: The request property to target. Available values: `ip`, `ip_range`.
        :param pulumi.Input[str] value: The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The request property to target. Available values: `ip`, `ip_range`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ZoneSettingsOverrideInitialSettingArgsDict(TypedDict):
        always_online: NotRequired[pulumi.Input[str]]
        always_use_https: NotRequired[pulumi.Input[str]]
        automatic_https_rewrites: NotRequired[pulumi.Input[str]]
        binary_ast: NotRequired[pulumi.Input[str]]
        brotli: NotRequired[pulumi.Input[str]]
        browser_cache_ttl: NotRequired[pulumi.Input[int]]
        browser_check: NotRequired[pulumi.Input[str]]
        cache_level: NotRequired[pulumi.Input[str]]
        challenge_ttl: NotRequired[pulumi.Input[int]]
        ciphers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cname_flattening: NotRequired[pulumi.Input[str]]
        development_mode: NotRequired[pulumi.Input[str]]
        early_hints: NotRequired[pulumi.Input[str]]
        email_obfuscation: NotRequired[pulumi.Input[str]]
        filter_logs_to_cloudflare: NotRequired[pulumi.Input[str]]
        fonts: NotRequired[pulumi.Input[str]]
        h2_prioritization: NotRequired[pulumi.Input[str]]
        hotlink_protection: NotRequired[pulumi.Input[str]]
        http2: NotRequired[pulumi.Input[str]]
        http3: NotRequired[pulumi.Input[str]]
        image_resizing: NotRequired[pulumi.Input[str]]
        ip_geolocation: NotRequired[pulumi.Input[str]]
        ipv6: NotRequired[pulumi.Input[str]]
        log_to_cloudflare: NotRequired[pulumi.Input[str]]
        max_upload: NotRequired[pulumi.Input[int]]
        min_tls_version: NotRequired[pulumi.Input[str]]
        minify: NotRequired[pulumi.Input['ZoneSettingsOverrideInitialSettingMinifyArgsDict']]
        mirage: NotRequired[pulumi.Input[str]]
        mobile_redirect: NotRequired[pulumi.Input['ZoneSettingsOverrideInitialSettingMobileRedirectArgsDict']]
        nel: NotRequired[pulumi.Input['ZoneSettingsOverrideInitialSettingNelArgsDict']]
        opportunistic_encryption: NotRequired[pulumi.Input[str]]
        opportunistic_onion: NotRequired[pulumi.Input[str]]
        orange_to_orange: NotRequired[pulumi.Input[str]]
        origin_error_page_pass_thru: NotRequired[pulumi.Input[str]]
        origin_max_http_version: NotRequired[pulumi.Input[str]]
        polish: NotRequired[pulumi.Input[str]]
        prefetch_preload: NotRequired[pulumi.Input[str]]
        privacy_pass: NotRequired[pulumi.Input[str]]
        proxy_read_timeout: NotRequired[pulumi.Input[str]]
        pseudo_ipv4: NotRequired[pulumi.Input[str]]
        replace_insecure_js: NotRequired[pulumi.Input[str]]
        response_buffering: NotRequired[pulumi.Input[str]]
        rocket_loader: NotRequired[pulumi.Input[str]]
        security_header: NotRequired[pulumi.Input['ZoneSettingsOverrideInitialSettingSecurityHeaderArgsDict']]
        security_level: NotRequired[pulumi.Input[str]]
        server_side_exclude: NotRequired[pulumi.Input[str]]
        sort_query_string_for_cache: NotRequired[pulumi.Input[str]]
        speed_brain: NotRequired[pulumi.Input[str]]
        ssl: NotRequired[pulumi.Input[str]]
        tls12_only: NotRequired[pulumi.Input[str]]
        tls13: NotRequired[pulumi.Input[str]]
        tls_client_auth: NotRequired[pulumi.Input[str]]
        true_client_ip_header: NotRequired[pulumi.Input[str]]
        universal_ssl: NotRequired[pulumi.Input[str]]
        visitor_ip: NotRequired[pulumi.Input[str]]
        waf: NotRequired[pulumi.Input[str]]
        webp: NotRequired[pulumi.Input[str]]
        websockets: NotRequired[pulumi.Input[str]]
        zero_rtt: NotRequired[pulumi.Input[str]]
elif False:
    ZoneSettingsOverrideInitialSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideInitialSettingArgs:
    def __init__(__self__, *,
                 always_online: Optional[pulumi.Input[str]] = None,
                 always_use_https: Optional[pulumi.Input[str]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
                 binary_ast: Optional[pulumi.Input[str]] = None,
                 brotli: Optional[pulumi.Input[str]] = None,
                 browser_cache_ttl: Optional[pulumi.Input[int]] = None,
                 browser_check: Optional[pulumi.Input[str]] = None,
                 cache_level: Optional[pulumi.Input[str]] = None,
                 challenge_ttl: Optional[pulumi.Input[int]] = None,
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cname_flattening: Optional[pulumi.Input[str]] = None,
                 development_mode: Optional[pulumi.Input[str]] = None,
                 early_hints: Optional[pulumi.Input[str]] = None,
                 email_obfuscation: Optional[pulumi.Input[str]] = None,
                 filter_logs_to_cloudflare: Optional[pulumi.Input[str]] = None,
                 fonts: Optional[pulumi.Input[str]] = None,
                 h2_prioritization: Optional[pulumi.Input[str]] = None,
                 hotlink_protection: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[str]] = None,
                 http3: Optional[pulumi.Input[str]] = None,
                 image_resizing: Optional[pulumi.Input[str]] = None,
                 ip_geolocation: Optional[pulumi.Input[str]] = None,
                 ipv6: Optional[pulumi.Input[str]] = None,
                 log_to_cloudflare: Optional[pulumi.Input[str]] = None,
                 max_upload: Optional[pulumi.Input[int]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 minify: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMinifyArgs']] = None,
                 mirage: Optional[pulumi.Input[str]] = None,
                 mobile_redirect: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMobileRedirectArgs']] = None,
                 nel: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingNelArgs']] = None,
                 opportunistic_encryption: Optional[pulumi.Input[str]] = None,
                 opportunistic_onion: Optional[pulumi.Input[str]] = None,
                 orange_to_orange: Optional[pulumi.Input[str]] = None,
                 origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
                 origin_max_http_version: Optional[pulumi.Input[str]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 prefetch_preload: Optional[pulumi.Input[str]] = None,
                 privacy_pass: Optional[pulumi.Input[str]] = None,
                 proxy_read_timeout: Optional[pulumi.Input[str]] = None,
                 pseudo_ipv4: Optional[pulumi.Input[str]] = None,
                 replace_insecure_js: Optional[pulumi.Input[str]] = None,
                 response_buffering: Optional[pulumi.Input[str]] = None,
                 rocket_loader: Optional[pulumi.Input[str]] = None,
                 security_header: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingSecurityHeaderArgs']] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 server_side_exclude: Optional[pulumi.Input[str]] = None,
                 sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
                 speed_brain: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 tls12_only: Optional[pulumi.Input[str]] = None,
                 tls13: Optional[pulumi.Input[str]] = None,
                 tls_client_auth: Optional[pulumi.Input[str]] = None,
                 true_client_ip_header: Optional[pulumi.Input[str]] = None,
                 universal_ssl: Optional[pulumi.Input[str]] = None,
                 visitor_ip: Optional[pulumi.Input[str]] = None,
                 waf: Optional[pulumi.Input[str]] = None,
                 webp: Optional[pulumi.Input[str]] = None,
                 websockets: Optional[pulumi.Input[str]] = None,
                 zero_rtt: Optional[pulumi.Input[str]] = None):
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            pulumi.set(__self__, "binary_ast", binary_ast)
        if brotli is not None:
            pulumi.set(__self__, "brotli", brotli)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if challenge_ttl is not None:
            pulumi.set(__self__, "challenge_ttl", challenge_ttl)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if cname_flattening is not None:
            pulumi.set(__self__, "cname_flattening", cname_flattening)
        if development_mode is not None:
            pulumi.set(__self__, "development_mode", development_mode)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            pulumi.set(__self__, "filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if h2_prioritization is not None:
            pulumi.set(__self__, "h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if http3 is not None:
            pulumi.set(__self__, "http3", http3)
        if image_resizing is not None:
            pulumi.set(__self__, "image_resizing", image_resizing)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if log_to_cloudflare is not None:
            pulumi.set(__self__, "log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            pulumi.set(__self__, "max_upload", max_upload)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minify is not None:
            pulumi.set(__self__, "minify", minify)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if mobile_redirect is not None:
            warnings.warn("""Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.""", DeprecationWarning)
            pulumi.log.warn("""mobile_redirect is deprecated: Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.""")
        if mobile_redirect is not None:
            pulumi.set(__self__, "mobile_redirect", mobile_redirect)
        if nel is not None:
            pulumi.set(__self__, "nel", nel)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            pulumi.set(__self__, "opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            pulumi.set(__self__, "orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if origin_max_http_version is not None:
            pulumi.set(__self__, "origin_max_http_version", origin_max_http_version)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if prefetch_preload is not None:
            pulumi.set(__self__, "prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            pulumi.set(__self__, "privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            pulumi.set(__self__, "proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            pulumi.set(__self__, "pseudo_ipv4", pseudo_ipv4)
        if replace_insecure_js is not None:
            pulumi.set(__self__, "replace_insecure_js", replace_insecure_js)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_header is not None:
            pulumi.set(__self__, "security_header", security_header)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if speed_brain is not None:
            pulumi.set(__self__, "speed_brain", speed_brain)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if tls12_only is not None:
            warnings.warn("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""", DeprecationWarning)
            pulumi.log.warn("""tls12_only is deprecated: tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")
        if tls12_only is not None:
            pulumi.set(__self__, "tls12_only", tls12_only)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)
        if tls_client_auth is not None:
            pulumi.set(__self__, "tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            pulumi.set(__self__, "universal_ssl", universal_ssl)
        if visitor_ip is not None:
            pulumi.set(__self__, "visitor_ip", visitor_ip)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)
        if zero_rtt is not None:
            pulumi.set(__self__, "zero_rtt", zero_rtt)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "always_online")

    @always_online.setter
    def always_online(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "always_online", value)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "always_use_https")

    @always_use_https.setter
    def always_use_https(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "always_use_https", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "binary_ast")

    @binary_ast.setter
    def binary_ast(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "binary_ast", value)

    @property
    @pulumi.getter
    def brotli(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "brotli")

    @brotli.setter
    def brotli(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "brotli", value)

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "browser_cache_ttl")

    @browser_cache_ttl.setter
    def browser_cache_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "browser_cache_ttl", value)

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "browser_check")

    @browser_check.setter
    def browser_check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_check", value)

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cache_level")

    @cache_level.setter
    def cache_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_level", value)

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "challenge_ttl")

    @challenge_ttl.setter
    def challenge_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "challenge_ttl", value)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ciphers", value)

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_flattening")

    @cname_flattening.setter
    def cname_flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_flattening", value)

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "development_mode")

    @development_mode.setter
    def development_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "development_mode", value)

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "early_hints")

    @early_hints.setter
    def early_hints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "early_hints", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @filter_logs_to_cloudflare.setter
    def filter_logs_to_cloudflare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_logs_to_cloudflare", value)

    @property
    @pulumi.getter
    def fonts(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fonts")

    @fonts.setter
    def fonts(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fonts", value)

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "h2_prioritization")

    @h2_prioritization.setter
    def h2_prioritization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h2_prioritization", value)

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hotlink_protection")

    @hotlink_protection.setter
    def hotlink_protection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hotlink_protection", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter
    def http3(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http3")

    @http3.setter
    def http3(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http3", value)

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_resizing")

    @image_resizing.setter
    def image_resizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_resizing", value)

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_geolocation")

    @ip_geolocation.setter
    def ip_geolocation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_geolocation", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_to_cloudflare")

    @log_to_cloudflare.setter
    def log_to_cloudflare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_to_cloudflare", value)

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_upload")

    @max_upload.setter
    def max_upload(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_upload", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter
    def minify(self) -> Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMinifyArgs']]:
        return pulumi.get(self, "minify")

    @minify.setter
    def minify(self, value: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMinifyArgs']]):
        pulumi.set(self, "minify", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="mobileRedirect")
    @_utilities.deprecated("""Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.""")
    def mobile_redirect(self) -> Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMobileRedirectArgs']]:
        return pulumi.get(self, "mobile_redirect")

    @mobile_redirect.setter
    def mobile_redirect(self, value: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMobileRedirectArgs']]):
        pulumi.set(self, "mobile_redirect", value)

    @property
    @pulumi.getter
    def nel(self) -> Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingNelArgs']]:
        return pulumi.get(self, "nel")

    @nel.setter
    def nel(self, value: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingNelArgs']]):
        pulumi.set(self, "nel", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opportunistic_onion")

    @opportunistic_onion.setter
    def opportunistic_onion(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_onion", value)

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "orange_to_orange")

    @orange_to_orange.setter
    def orange_to_orange(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "orange_to_orange", value)

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @origin_error_page_pass_thru.setter
    def origin_error_page_pass_thru(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_error_page_pass_thru", value)

    @property
    @pulumi.getter(name="originMaxHttpVersion")
    def origin_max_http_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "origin_max_http_version")

    @origin_max_http_version.setter
    def origin_max_http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_max_http_version", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefetch_preload")

    @prefetch_preload.setter
    def prefetch_preload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefetch_preload", value)

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "privacy_pass")

    @privacy_pass.setter
    def privacy_pass(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "privacy_pass", value)

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proxy_read_timeout")

    @proxy_read_timeout.setter
    def proxy_read_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_read_timeout", value)

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pseudo_ipv4")

    @pseudo_ipv4.setter
    def pseudo_ipv4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pseudo_ipv4", value)

    @property
    @pulumi.getter(name="replaceInsecureJs")
    def replace_insecure_js(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "replace_insecure_js")

    @replace_insecure_js.setter
    def replace_insecure_js(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_insecure_js", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingSecurityHeaderArgs']]:
        return pulumi.get(self, "security_header")

    @security_header.setter
    def security_header(self, value: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingSecurityHeaderArgs']]):
        pulumi.set(self, "security_header", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_side_exclude")

    @server_side_exclude.setter
    def server_side_exclude(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_side_exclude", value)

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @sort_query_string_for_cache.setter
    def sort_query_string_for_cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_query_string_for_cache", value)

    @property
    @pulumi.getter(name="speedBrain")
    def speed_brain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "speed_brain")

    @speed_brain.setter
    def speed_brain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed_brain", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="tls12Only")
    @_utilities.deprecated("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")
    def tls12_only(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls12_only")

    @tls12_only.setter
    def tls12_only(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls12_only", value)

    @property
    @pulumi.getter
    def tls13(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls13")

    @tls13.setter
    def tls13(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls13", value)

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls_client_auth")

    @tls_client_auth.setter
    def tls_client_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_auth", value)

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "true_client_ip_header")

    @true_client_ip_header.setter
    def true_client_ip_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "true_client_ip_header", value)

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "universal_ssl")

    @universal_ssl.setter
    def universal_ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "universal_ssl", value)

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visitor_ip")

    @visitor_ip.setter
    def visitor_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visitor_ip", value)

    @property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf", value)

    @property
    @pulumi.getter
    def webp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "webp")

    @webp.setter
    def webp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webp", value)

    @property
    @pulumi.getter
    def websockets(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "websockets")

    @websockets.setter
    def websockets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "websockets", value)

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zero_rtt")

    @zero_rtt.setter
    def zero_rtt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_rtt", value)


if not MYPY:
    class ZoneSettingsOverrideInitialSettingMinifyArgsDict(TypedDict):
        css: pulumi.Input[str]
        html: pulumi.Input[str]
        js: pulumi.Input[str]
elif False:
    ZoneSettingsOverrideInitialSettingMinifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideInitialSettingMinifyArgs:
    def __init__(__self__, *,
                 css: pulumi.Input[str],
                 html: pulumi.Input[str],
                 js: pulumi.Input[str]):
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> pulumi.Input[str]:
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: pulumi.Input[str]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> pulumi.Input[str]:
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: pulumi.Input[str]):
        pulumi.set(self, "js", value)


if not MYPY:
    class ZoneSettingsOverrideInitialSettingMobileRedirectArgsDict(TypedDict):
        mobile_subdomain: pulumi.Input[str]
        status: pulumi.Input[str]
        strip_uri: pulumi.Input[bool]
elif False:
    ZoneSettingsOverrideInitialSettingMobileRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideInitialSettingMobileRedirectArgs:
    def __init__(__self__, *,
                 mobile_subdomain: pulumi.Input[str],
                 status: pulumi.Input[str],
                 strip_uri: pulumi.Input[bool]):
        pulumi.set(__self__, "mobile_subdomain", mobile_subdomain)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mobile_subdomain")

    @mobile_subdomain.setter
    def mobile_subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "mobile_subdomain", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "strip_uri")

    @strip_uri.setter
    def strip_uri(self, value: pulumi.Input[bool]):
        pulumi.set(self, "strip_uri", value)


if not MYPY:
    class ZoneSettingsOverrideInitialSettingNelArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
elif False:
    ZoneSettingsOverrideInitialSettingNelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideInitialSettingNelArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZoneSettingsOverrideInitialSettingSecurityHeaderArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        include_subdomains: NotRequired[pulumi.Input[bool]]
        max_age: NotRequired[pulumi.Input[int]]
        nosniff: NotRequired[pulumi.Input[bool]]
        preload: NotRequired[pulumi.Input[bool]]
elif False:
    ZoneSettingsOverrideInitialSettingSecurityHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideInitialSettingSecurityHeaderArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 include_subdomains: Optional[pulumi.Input[bool]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 nosniff: Optional[pulumi.Input[bool]] = None,
                 preload: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if nosniff is not None:
            pulumi.set(__self__, "nosniff", nosniff)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nosniff")

    @nosniff.setter
    def nosniff(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nosniff", value)

    @property
    @pulumi.getter
    def preload(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preload")

    @preload.setter
    def preload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preload", value)


if not MYPY:
    class ZoneSettingsOverrideSettingsArgsDict(TypedDict):
        always_online: NotRequired[pulumi.Input[str]]
        always_use_https: NotRequired[pulumi.Input[str]]
        automatic_https_rewrites: NotRequired[pulumi.Input[str]]
        binary_ast: NotRequired[pulumi.Input[str]]
        brotli: NotRequired[pulumi.Input[str]]
        browser_cache_ttl: NotRequired[pulumi.Input[int]]
        browser_check: NotRequired[pulumi.Input[str]]
        cache_level: NotRequired[pulumi.Input[str]]
        challenge_ttl: NotRequired[pulumi.Input[int]]
        ciphers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cname_flattening: NotRequired[pulumi.Input[str]]
        development_mode: NotRequired[pulumi.Input[str]]
        early_hints: NotRequired[pulumi.Input[str]]
        email_obfuscation: NotRequired[pulumi.Input[str]]
        filter_logs_to_cloudflare: NotRequired[pulumi.Input[str]]
        fonts: NotRequired[pulumi.Input[str]]
        h2_prioritization: NotRequired[pulumi.Input[str]]
        hotlink_protection: NotRequired[pulumi.Input[str]]
        http2: NotRequired[pulumi.Input[str]]
        http3: NotRequired[pulumi.Input[str]]
        image_resizing: NotRequired[pulumi.Input[str]]
        ip_geolocation: NotRequired[pulumi.Input[str]]
        ipv6: NotRequired[pulumi.Input[str]]
        log_to_cloudflare: NotRequired[pulumi.Input[str]]
        max_upload: NotRequired[pulumi.Input[int]]
        min_tls_version: NotRequired[pulumi.Input[str]]
        minify: NotRequired[pulumi.Input['ZoneSettingsOverrideSettingsMinifyArgsDict']]
        mirage: NotRequired[pulumi.Input[str]]
        mobile_redirect: NotRequired[pulumi.Input['ZoneSettingsOverrideSettingsMobileRedirectArgsDict']]
        nel: NotRequired[pulumi.Input['ZoneSettingsOverrideSettingsNelArgsDict']]
        opportunistic_encryption: NotRequired[pulumi.Input[str]]
        opportunistic_onion: NotRequired[pulumi.Input[str]]
        orange_to_orange: NotRequired[pulumi.Input[str]]
        origin_error_page_pass_thru: NotRequired[pulumi.Input[str]]
        origin_max_http_version: NotRequired[pulumi.Input[str]]
        polish: NotRequired[pulumi.Input[str]]
        prefetch_preload: NotRequired[pulumi.Input[str]]
        privacy_pass: NotRequired[pulumi.Input[str]]
        proxy_read_timeout: NotRequired[pulumi.Input[str]]
        pseudo_ipv4: NotRequired[pulumi.Input[str]]
        replace_insecure_js: NotRequired[pulumi.Input[str]]
        response_buffering: NotRequired[pulumi.Input[str]]
        rocket_loader: NotRequired[pulumi.Input[str]]
        security_header: NotRequired[pulumi.Input['ZoneSettingsOverrideSettingsSecurityHeaderArgsDict']]
        security_level: NotRequired[pulumi.Input[str]]
        server_side_exclude: NotRequired[pulumi.Input[str]]
        sort_query_string_for_cache: NotRequired[pulumi.Input[str]]
        speed_brain: NotRequired[pulumi.Input[str]]
        ssl: NotRequired[pulumi.Input[str]]
        tls12_only: NotRequired[pulumi.Input[str]]
        tls13: NotRequired[pulumi.Input[str]]
        tls_client_auth: NotRequired[pulumi.Input[str]]
        true_client_ip_header: NotRequired[pulumi.Input[str]]
        universal_ssl: NotRequired[pulumi.Input[str]]
        visitor_ip: NotRequired[pulumi.Input[str]]
        waf: NotRequired[pulumi.Input[str]]
        webp: NotRequired[pulumi.Input[str]]
        websockets: NotRequired[pulumi.Input[str]]
        zero_rtt: NotRequired[pulumi.Input[str]]
elif False:
    ZoneSettingsOverrideSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideSettingsArgs:
    def __init__(__self__, *,
                 always_online: Optional[pulumi.Input[str]] = None,
                 always_use_https: Optional[pulumi.Input[str]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
                 binary_ast: Optional[pulumi.Input[str]] = None,
                 brotli: Optional[pulumi.Input[str]] = None,
                 browser_cache_ttl: Optional[pulumi.Input[int]] = None,
                 browser_check: Optional[pulumi.Input[str]] = None,
                 cache_level: Optional[pulumi.Input[str]] = None,
                 challenge_ttl: Optional[pulumi.Input[int]] = None,
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cname_flattening: Optional[pulumi.Input[str]] = None,
                 development_mode: Optional[pulumi.Input[str]] = None,
                 early_hints: Optional[pulumi.Input[str]] = None,
                 email_obfuscation: Optional[pulumi.Input[str]] = None,
                 filter_logs_to_cloudflare: Optional[pulumi.Input[str]] = None,
                 fonts: Optional[pulumi.Input[str]] = None,
                 h2_prioritization: Optional[pulumi.Input[str]] = None,
                 hotlink_protection: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[str]] = None,
                 http3: Optional[pulumi.Input[str]] = None,
                 image_resizing: Optional[pulumi.Input[str]] = None,
                 ip_geolocation: Optional[pulumi.Input[str]] = None,
                 ipv6: Optional[pulumi.Input[str]] = None,
                 log_to_cloudflare: Optional[pulumi.Input[str]] = None,
                 max_upload: Optional[pulumi.Input[int]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 minify: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMinifyArgs']] = None,
                 mirage: Optional[pulumi.Input[str]] = None,
                 mobile_redirect: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMobileRedirectArgs']] = None,
                 nel: Optional[pulumi.Input['ZoneSettingsOverrideSettingsNelArgs']] = None,
                 opportunistic_encryption: Optional[pulumi.Input[str]] = None,
                 opportunistic_onion: Optional[pulumi.Input[str]] = None,
                 orange_to_orange: Optional[pulumi.Input[str]] = None,
                 origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
                 origin_max_http_version: Optional[pulumi.Input[str]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 prefetch_preload: Optional[pulumi.Input[str]] = None,
                 privacy_pass: Optional[pulumi.Input[str]] = None,
                 proxy_read_timeout: Optional[pulumi.Input[str]] = None,
                 pseudo_ipv4: Optional[pulumi.Input[str]] = None,
                 replace_insecure_js: Optional[pulumi.Input[str]] = None,
                 response_buffering: Optional[pulumi.Input[str]] = None,
                 rocket_loader: Optional[pulumi.Input[str]] = None,
                 security_header: Optional[pulumi.Input['ZoneSettingsOverrideSettingsSecurityHeaderArgs']] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 server_side_exclude: Optional[pulumi.Input[str]] = None,
                 sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
                 speed_brain: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 tls12_only: Optional[pulumi.Input[str]] = None,
                 tls13: Optional[pulumi.Input[str]] = None,
                 tls_client_auth: Optional[pulumi.Input[str]] = None,
                 true_client_ip_header: Optional[pulumi.Input[str]] = None,
                 universal_ssl: Optional[pulumi.Input[str]] = None,
                 visitor_ip: Optional[pulumi.Input[str]] = None,
                 waf: Optional[pulumi.Input[str]] = None,
                 webp: Optional[pulumi.Input[str]] = None,
                 websockets: Optional[pulumi.Input[str]] = None,
                 zero_rtt: Optional[pulumi.Input[str]] = None):
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            pulumi.set(__self__, "binary_ast", binary_ast)
        if brotli is not None:
            pulumi.set(__self__, "brotli", brotli)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if challenge_ttl is not None:
            pulumi.set(__self__, "challenge_ttl", challenge_ttl)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if cname_flattening is not None:
            pulumi.set(__self__, "cname_flattening", cname_flattening)
        if development_mode is not None:
            pulumi.set(__self__, "development_mode", development_mode)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            pulumi.set(__self__, "filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if h2_prioritization is not None:
            pulumi.set(__self__, "h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if http3 is not None:
            pulumi.set(__self__, "http3", http3)
        if image_resizing is not None:
            pulumi.set(__self__, "image_resizing", image_resizing)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if log_to_cloudflare is not None:
            pulumi.set(__self__, "log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            pulumi.set(__self__, "max_upload", max_upload)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minify is not None:
            pulumi.set(__self__, "minify", minify)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if mobile_redirect is not None:
            warnings.warn("""Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.""", DeprecationWarning)
            pulumi.log.warn("""mobile_redirect is deprecated: Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.""")
        if mobile_redirect is not None:
            pulumi.set(__self__, "mobile_redirect", mobile_redirect)
        if nel is not None:
            pulumi.set(__self__, "nel", nel)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            pulumi.set(__self__, "opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            pulumi.set(__self__, "orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if origin_max_http_version is not None:
            pulumi.set(__self__, "origin_max_http_version", origin_max_http_version)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if prefetch_preload is not None:
            pulumi.set(__self__, "prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            pulumi.set(__self__, "privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            pulumi.set(__self__, "proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            pulumi.set(__self__, "pseudo_ipv4", pseudo_ipv4)
        if replace_insecure_js is not None:
            pulumi.set(__self__, "replace_insecure_js", replace_insecure_js)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_header is not None:
            pulumi.set(__self__, "security_header", security_header)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if speed_brain is not None:
            pulumi.set(__self__, "speed_brain", speed_brain)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if tls12_only is not None:
            warnings.warn("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""", DeprecationWarning)
            pulumi.log.warn("""tls12_only is deprecated: tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")
        if tls12_only is not None:
            pulumi.set(__self__, "tls12_only", tls12_only)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)
        if tls_client_auth is not None:
            pulumi.set(__self__, "tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            pulumi.set(__self__, "universal_ssl", universal_ssl)
        if visitor_ip is not None:
            pulumi.set(__self__, "visitor_ip", visitor_ip)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)
        if zero_rtt is not None:
            pulumi.set(__self__, "zero_rtt", zero_rtt)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "always_online")

    @always_online.setter
    def always_online(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "always_online", value)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "always_use_https")

    @always_use_https.setter
    def always_use_https(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "always_use_https", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "binary_ast")

    @binary_ast.setter
    def binary_ast(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "binary_ast", value)

    @property
    @pulumi.getter
    def brotli(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "brotli")

    @brotli.setter
    def brotli(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "brotli", value)

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "browser_cache_ttl")

    @browser_cache_ttl.setter
    def browser_cache_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "browser_cache_ttl", value)

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "browser_check")

    @browser_check.setter
    def browser_check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_check", value)

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cache_level")

    @cache_level.setter
    def cache_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_level", value)

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "challenge_ttl")

    @challenge_ttl.setter
    def challenge_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "challenge_ttl", value)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ciphers", value)

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_flattening")

    @cname_flattening.setter
    def cname_flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_flattening", value)

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "development_mode")

    @development_mode.setter
    def development_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "development_mode", value)

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "early_hints")

    @early_hints.setter
    def early_hints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "early_hints", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @filter_logs_to_cloudflare.setter
    def filter_logs_to_cloudflare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_logs_to_cloudflare", value)

    @property
    @pulumi.getter
    def fonts(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fonts")

    @fonts.setter
    def fonts(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fonts", value)

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "h2_prioritization")

    @h2_prioritization.setter
    def h2_prioritization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h2_prioritization", value)

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hotlink_protection")

    @hotlink_protection.setter
    def hotlink_protection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hotlink_protection", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter
    def http3(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http3")

    @http3.setter
    def http3(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http3", value)

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_resizing")

    @image_resizing.setter
    def image_resizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_resizing", value)

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_geolocation")

    @ip_geolocation.setter
    def ip_geolocation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_geolocation", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_to_cloudflare")

    @log_to_cloudflare.setter
    def log_to_cloudflare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_to_cloudflare", value)

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_upload")

    @max_upload.setter
    def max_upload(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_upload", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter
    def minify(self) -> Optional[pulumi.Input['ZoneSettingsOverrideSettingsMinifyArgs']]:
        return pulumi.get(self, "minify")

    @minify.setter
    def minify(self, value: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMinifyArgs']]):
        pulumi.set(self, "minify", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="mobileRedirect")
    @_utilities.deprecated("""Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.""")
    def mobile_redirect(self) -> Optional[pulumi.Input['ZoneSettingsOverrideSettingsMobileRedirectArgs']]:
        return pulumi.get(self, "mobile_redirect")

    @mobile_redirect.setter
    def mobile_redirect(self, value: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMobileRedirectArgs']]):
        pulumi.set(self, "mobile_redirect", value)

    @property
    @pulumi.getter
    def nel(self) -> Optional[pulumi.Input['ZoneSettingsOverrideSettingsNelArgs']]:
        return pulumi.get(self, "nel")

    @nel.setter
    def nel(self, value: Optional[pulumi.Input['ZoneSettingsOverrideSettingsNelArgs']]):
        pulumi.set(self, "nel", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opportunistic_onion")

    @opportunistic_onion.setter
    def opportunistic_onion(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_onion", value)

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "orange_to_orange")

    @orange_to_orange.setter
    def orange_to_orange(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "orange_to_orange", value)

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @origin_error_page_pass_thru.setter
    def origin_error_page_pass_thru(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_error_page_pass_thru", value)

    @property
    @pulumi.getter(name="originMaxHttpVersion")
    def origin_max_http_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "origin_max_http_version")

    @origin_max_http_version.setter
    def origin_max_http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_max_http_version", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefetch_preload")

    @prefetch_preload.setter
    def prefetch_preload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefetch_preload", value)

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "privacy_pass")

    @privacy_pass.setter
    def privacy_pass(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "privacy_pass", value)

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proxy_read_timeout")

    @proxy_read_timeout.setter
    def proxy_read_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_read_timeout", value)

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pseudo_ipv4")

    @pseudo_ipv4.setter
    def pseudo_ipv4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pseudo_ipv4", value)

    @property
    @pulumi.getter(name="replaceInsecureJs")
    def replace_insecure_js(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "replace_insecure_js")

    @replace_insecure_js.setter
    def replace_insecure_js(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_insecure_js", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional[pulumi.Input['ZoneSettingsOverrideSettingsSecurityHeaderArgs']]:
        return pulumi.get(self, "security_header")

    @security_header.setter
    def security_header(self, value: Optional[pulumi.Input['ZoneSettingsOverrideSettingsSecurityHeaderArgs']]):
        pulumi.set(self, "security_header", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_side_exclude")

    @server_side_exclude.setter
    def server_side_exclude(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_side_exclude", value)

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @sort_query_string_for_cache.setter
    def sort_query_string_for_cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_query_string_for_cache", value)

    @property
    @pulumi.getter(name="speedBrain")
    def speed_brain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "speed_brain")

    @speed_brain.setter
    def speed_brain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed_brain", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="tls12Only")
    @_utilities.deprecated("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")
    def tls12_only(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls12_only")

    @tls12_only.setter
    def tls12_only(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls12_only", value)

    @property
    @pulumi.getter
    def tls13(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls13")

    @tls13.setter
    def tls13(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls13", value)

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls_client_auth")

    @tls_client_auth.setter
    def tls_client_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_auth", value)

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "true_client_ip_header")

    @true_client_ip_header.setter
    def true_client_ip_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "true_client_ip_header", value)

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "universal_ssl")

    @universal_ssl.setter
    def universal_ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "universal_ssl", value)

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visitor_ip")

    @visitor_ip.setter
    def visitor_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visitor_ip", value)

    @property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf", value)

    @property
    @pulumi.getter
    def webp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "webp")

    @webp.setter
    def webp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webp", value)

    @property
    @pulumi.getter
    def websockets(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "websockets")

    @websockets.setter
    def websockets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "websockets", value)

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zero_rtt")

    @zero_rtt.setter
    def zero_rtt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_rtt", value)


if not MYPY:
    class ZoneSettingsOverrideSettingsMinifyArgsDict(TypedDict):
        css: pulumi.Input[str]
        html: pulumi.Input[str]
        js: pulumi.Input[str]
elif False:
    ZoneSettingsOverrideSettingsMinifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideSettingsMinifyArgs:
    def __init__(__self__, *,
                 css: pulumi.Input[str],
                 html: pulumi.Input[str],
                 js: pulumi.Input[str]):
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> pulumi.Input[str]:
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: pulumi.Input[str]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> pulumi.Input[str]:
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: pulumi.Input[str]):
        pulumi.set(self, "js", value)


if not MYPY:
    class ZoneSettingsOverrideSettingsMobileRedirectArgsDict(TypedDict):
        mobile_subdomain: pulumi.Input[str]
        status: pulumi.Input[str]
        strip_uri: pulumi.Input[bool]
elif False:
    ZoneSettingsOverrideSettingsMobileRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideSettingsMobileRedirectArgs:
    def __init__(__self__, *,
                 mobile_subdomain: pulumi.Input[str],
                 status: pulumi.Input[str],
                 strip_uri: pulumi.Input[bool]):
        pulumi.set(__self__, "mobile_subdomain", mobile_subdomain)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mobile_subdomain")

    @mobile_subdomain.setter
    def mobile_subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "mobile_subdomain", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "strip_uri")

    @strip_uri.setter
    def strip_uri(self, value: pulumi.Input[bool]):
        pulumi.set(self, "strip_uri", value)


if not MYPY:
    class ZoneSettingsOverrideSettingsNelArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
elif False:
    ZoneSettingsOverrideSettingsNelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideSettingsNelArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZoneSettingsOverrideSettingsSecurityHeaderArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        include_subdomains: NotRequired[pulumi.Input[bool]]
        max_age: NotRequired[pulumi.Input[int]]
        nosniff: NotRequired[pulumi.Input[bool]]
        preload: NotRequired[pulumi.Input[bool]]
elif False:
    ZoneSettingsOverrideSettingsSecurityHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSettingsOverrideSettingsSecurityHeaderArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 include_subdomains: Optional[pulumi.Input[bool]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 nosniff: Optional[pulumi.Input[bool]] = None,
                 preload: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if nosniff is not None:
            pulumi.set(__self__, "nosniff", nosniff)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nosniff")

    @nosniff.setter
    def nosniff(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nosniff", value)

    @property
    @pulumi.getter
    def preload(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preload")

    @preload.setter
    def preload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preload", value)


if not MYPY:
    class GetLoadBalancerPoolsFilterArgsDict(TypedDict):
        name: NotRequired[str]
        """
        A regular expression matching the name of the Load Balancer pool to lookup.
        """
elif False:
    GetLoadBalancerPoolsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerPoolsFilterArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: A regular expression matching the name of the Load Balancer pool to lookup.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A regular expression matching the name of the Load Balancer pool to lookup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetLoadBalancerPoolsPoolArgsDict(TypedDict):
        check_regions: Sequence[str]
        """
        List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        """
        created_on: str
        """
        The RFC3339 timestamp of when the load balancer was created.
        """
        description: str
        """
        Brief description of the Load Balancer Pool intention.
        """
        enabled: bool
        """
        Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        """
        id: str
        """
        ID for this load balancer pool.
        """
        latitude: float
        """
        Latitude this pool is physically located at; used for proximity steering.
        """
        load_sheddings: Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgsDict']
        """
        Setting for controlling load shedding for this pool.
        """
        longitude: float
        """
        Longitude this pool is physically located at; used for proximity steering.
        """
        minimum_origins: int
        """
        Minimum number of origins that must be healthy for this pool to serve traffic.
        """
        modified_on: str
        """
        The RFC3339 timestamp of when the load balancer was last modified.
        """
        monitor: str
        """
        ID of the Monitor to use for health checking origins within this pool.
        """
        name: str
        """
        Short name (tag) for the pool.
        """
        notification_email: str
        """
        Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        """
        origins: Sequence['GetLoadBalancerPoolsPoolOriginArgsDict']
        """
        The list of origins within this pool.
        """
elif False:
    GetLoadBalancerPoolsPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerPoolsPoolArgs:
    def __init__(__self__, *,
                 check_regions: Sequence[str],
                 created_on: str,
                 description: str,
                 enabled: bool,
                 id: str,
                 latitude: float,
                 load_sheddings: Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs'],
                 longitude: float,
                 minimum_origins: int,
                 modified_on: str,
                 monitor: str,
                 name: str,
                 notification_email: str,
                 origins: Sequence['GetLoadBalancerPoolsPoolOriginArgs']):
        """
        :param Sequence[str] check_regions: List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        :param str created_on: The RFC3339 timestamp of when the load balancer was created.
        :param str description: Brief description of the Load Balancer Pool intention.
        :param bool enabled: Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        :param str id: ID for this load balancer pool.
        :param float latitude: Latitude this pool is physically located at; used for proximity steering.
        :param Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs'] load_sheddings: Setting for controlling load shedding for this pool.
        :param float longitude: Longitude this pool is physically located at; used for proximity steering.
        :param int minimum_origins: Minimum number of origins that must be healthy for this pool to serve traffic.
        :param str modified_on: The RFC3339 timestamp of when the load balancer was last modified.
        :param str monitor: ID of the Monitor to use for health checking origins within this pool.
        :param str name: Short name (tag) for the pool.
        :param str notification_email: Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        :param Sequence['GetLoadBalancerPoolsPoolOriginArgs'] origins: The list of origins within this pool.
        """
        pulumi.set(__self__, "check_regions", check_regions)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "load_sheddings", load_sheddings)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "minimum_origins", minimum_origins)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "monitor", monitor)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_email", notification_email)
        pulumi.set(__self__, "origins", origins)

    @property
    @pulumi.getter(name="checkRegions")
    def check_regions(self) -> Sequence[str]:
        """
        List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        """
        return pulumi.get(self, "check_regions")

    @check_regions.setter
    def check_regions(self, value: Sequence[str]):
        pulumi.set(self, "check_regions", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The RFC3339 timestamp of when the load balancer was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: str):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Brief description of the Load Balancer Pool intention.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID for this load balancer pool.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def latitude(self) -> float:
        """
        Latitude this pool is physically located at; used for proximity steering.
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: float):
        pulumi.set(self, "latitude", value)

    @property
    @pulumi.getter(name="loadSheddings")
    def load_sheddings(self) -> Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs']:
        """
        Setting for controlling load shedding for this pool.
        """
        return pulumi.get(self, "load_sheddings")

    @load_sheddings.setter
    def load_sheddings(self, value: Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs']):
        pulumi.set(self, "load_sheddings", value)

    @property
    @pulumi.getter
    def longitude(self) -> float:
        """
        Longitude this pool is physically located at; used for proximity steering.
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: float):
        pulumi.set(self, "longitude", value)

    @property
    @pulumi.getter(name="minimumOrigins")
    def minimum_origins(self) -> int:
        """
        Minimum number of origins that must be healthy for this pool to serve traffic.
        """
        return pulumi.get(self, "minimum_origins")

    @minimum_origins.setter
    def minimum_origins(self, value: int):
        pulumi.set(self, "minimum_origins", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The RFC3339 timestamp of when the load balancer was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: str):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def monitor(self) -> str:
        """
        ID of the Monitor to use for health checking origins within this pool.
        """
        return pulumi.get(self, "monitor")

    @monitor.setter
    def monitor(self, value: str):
        pulumi.set(self, "monitor", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Short name (tag) for the pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="notificationEmail")
    def notification_email(self) -> str:
        """
        Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        """
        return pulumi.get(self, "notification_email")

    @notification_email.setter
    def notification_email(self, value: str):
        pulumi.set(self, "notification_email", value)

    @property
    @pulumi.getter
    def origins(self) -> Sequence['GetLoadBalancerPoolsPoolOriginArgs']:
        """
        The list of origins within this pool.
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: Sequence['GetLoadBalancerPoolsPoolOriginArgs']):
        pulumi.set(self, "origins", value)


if not MYPY:
    class GetLoadBalancerPoolsPoolLoadSheddingArgsDict(TypedDict):
        default_percent: NotRequired[float]
        """
        Percent of traffic to shed 0 - 100.
        """
        default_policy: NotRequired[str]
        """
        Method of shedding traffic. Available values: `""`, `hash`, `random`
        """
        session_percent: NotRequired[float]
        """
        Percent of session traffic to shed 0 - 100.
        """
        session_policy: NotRequired[str]
        """
        Method of shedding traffic. Available values: `""`, `hash`
        """
elif False:
    GetLoadBalancerPoolsPoolLoadSheddingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerPoolsPoolLoadSheddingArgs:
    def __init__(__self__, *,
                 default_percent: Optional[float] = None,
                 default_policy: Optional[str] = None,
                 session_percent: Optional[float] = None,
                 session_policy: Optional[str] = None):
        """
        :param float default_percent: Percent of traffic to shed 0 - 100.
        :param str default_policy: Method of shedding traffic. Available values: `""`, `hash`, `random`
        :param float session_percent: Percent of session traffic to shed 0 - 100.
        :param str session_policy: Method of shedding traffic. Available values: `""`, `hash`
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[float]:
        """
        Percent of traffic to shed 0 - 100.
        """
        return pulumi.get(self, "default_percent")

    @default_percent.setter
    def default_percent(self, value: Optional[float]):
        pulumi.set(self, "default_percent", value)

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[str]:
        """
        Method of shedding traffic. Available values: `""`, `hash`, `random`
        """
        return pulumi.get(self, "default_policy")

    @default_policy.setter
    def default_policy(self, value: Optional[str]):
        pulumi.set(self, "default_policy", value)

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[float]:
        """
        Percent of session traffic to shed 0 - 100.
        """
        return pulumi.get(self, "session_percent")

    @session_percent.setter
    def session_percent(self, value: Optional[float]):
        pulumi.set(self, "session_percent", value)

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[str]:
        """
        Method of shedding traffic. Available values: `""`, `hash`
        """
        return pulumi.get(self, "session_policy")

    @session_policy.setter
    def session_policy(self, value: Optional[str]):
        pulumi.set(self, "session_policy", value)


if not MYPY:
    class GetLoadBalancerPoolsPoolOriginArgsDict(TypedDict):
        address: str
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        """
        name: str
        """
        A human-identifiable name for the origin.
        """
        enabled: NotRequired[bool]
        """
        Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks.
        """
        headers: NotRequired[Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgsDict']]
        """
        HTTP request headers.
        """
        virtual_network_id: NotRequired[str]
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        weight: NotRequired[float]
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections.
        """
elif False:
    GetLoadBalancerPoolsPoolOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerPoolsPoolOriginArgs:
    def __init__(__self__, *,
                 address: str,
                 name: str,
                 enabled: Optional[bool] = None,
                 headers: Optional[Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs']] = None,
                 virtual_network_id: Optional[str] = None,
                 weight: Optional[float] = None):
        """
        :param str address: The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        :param str name: A human-identifiable name for the origin.
        :param bool enabled: Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks.
        :param Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs'] headers: HTTP request headers.
        :param str virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param float weight: The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: str):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs']]:
        """
        HTTP request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[str]):
        pulumi.set(self, "virtual_network_id", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[float]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GetLoadBalancerPoolsPoolOriginHeaderArgsDict(TypedDict):
        header: str
        """
        HTTP Header name.
        """
        values: Sequence[str]
        """
        Values for the HTTP headers.
        """
elif False:
    GetLoadBalancerPoolsPoolOriginHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerPoolsPoolOriginHeaderArgs:
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        """
        :param str header: HTTP Header name.
        :param Sequence[str] values: Values for the HTTP headers.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        HTTP Header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: str):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Values for the HTTP headers.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRulesetsFilterArgsDict(TypedDict):
        id: NotRequired[str]
        """
        The ID of the Ruleset to target.
        """
        kind: NotRequired[str]
        """
        Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        """
        name: NotRequired[str]
        """
        Name of the ruleset.
        """
        phase: NotRequired[str]
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        """
        version: NotRequired[str]
        """
        Version of the ruleset to filter on.
        """
elif False:
    GetRulesetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRulesetsFilterArgs:
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 phase: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: The ID of the Ruleset to target.
        :param str kind: Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        :param str name: Name of the ruleset.
        :param str phase: Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        :param str version: Version of the ruleset to filter on.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Ruleset to target.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[str]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the ruleset to filter on.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetZonesFilterArgsDict(TypedDict):
        account_id: NotRequired[str]
        """
        The account identifier to target for the resource.
        """
        lookup_type: NotRequired[str]
        """
        The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        """
        match: NotRequired[str]
        """
        A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        """
        name: NotRequired[str]
        """
        A string value to search for.
        """
        paused: NotRequired[bool]
        """
        Paused status of the zone to lookup. Defaults to `false`.
        """
        status: NotRequired[str]
        """
        Status of the zone to lookup.
        """
elif False:
    GetZonesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZonesFilterArgs:
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 lookup_type: Optional[str] = None,
                 match: Optional[str] = None,
                 name: Optional[str] = None,
                 paused: Optional[bool] = None,
                 status: Optional[str] = None):
        """
        :param str account_id: The account identifier to target for the resource.
        :param str lookup_type: The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        :param str match: A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        :param str name: A string value to search for.
        :param bool paused: Paused status of the zone to lookup. Defaults to `false`.
        :param str status: Status of the zone to lookup.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if lookup_type is not None:
            pulumi.set(__self__, "lookup_type", lookup_type)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The account identifier to target for the resource.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="lookupType")
    def lookup_type(self) -> Optional[str]:
        """
        The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        """
        return pulumi.get(self, "lookup_type")

    @lookup_type.setter
    def lookup_type(self, value: Optional[str]):
        pulumi.set(self, "lookup_type", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A string value to search for.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        Paused status of the zone to lookup. Defaults to `false`.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[bool]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the zone to lookup.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[str]):
        pulumi.set(self, "status", value)


