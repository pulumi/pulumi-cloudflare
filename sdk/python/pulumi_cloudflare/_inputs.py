# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AccessApplicationCorsHeaderArgs',
    'AccessApplicationSaasAppArgs',
    'AccessApplicationSaasAppCustomAttributeArgs',
    'AccessApplicationSaasAppCustomAttributeSourceArgs',
    'AccessGroupExcludeArgs',
    'AccessGroupExcludeAuthContextArgs',
    'AccessGroupExcludeAzureArgs',
    'AccessGroupExcludeExternalEvaluationArgs',
    'AccessGroupExcludeGithubArgs',
    'AccessGroupExcludeGsuiteArgs',
    'AccessGroupExcludeOktaArgs',
    'AccessGroupExcludeSamlArgs',
    'AccessGroupIncludeArgs',
    'AccessGroupIncludeAuthContextArgs',
    'AccessGroupIncludeAzureArgs',
    'AccessGroupIncludeExternalEvaluationArgs',
    'AccessGroupIncludeGithubArgs',
    'AccessGroupIncludeGsuiteArgs',
    'AccessGroupIncludeOktaArgs',
    'AccessGroupIncludeSamlArgs',
    'AccessGroupRequireArgs',
    'AccessGroupRequireAuthContextArgs',
    'AccessGroupRequireAzureArgs',
    'AccessGroupRequireExternalEvaluationArgs',
    'AccessGroupRequireGithubArgs',
    'AccessGroupRequireGsuiteArgs',
    'AccessGroupRequireOktaArgs',
    'AccessGroupRequireSamlArgs',
    'AccessIdentityProviderConfigArgs',
    'AccessIdentityProviderScimConfigArgs',
    'AccessOrganizationCustomPageArgs',
    'AccessOrganizationLoginDesignArgs',
    'AccessPolicyApprovalGroupArgs',
    'AccessPolicyExcludeArgs',
    'AccessPolicyExcludeAuthContextArgs',
    'AccessPolicyExcludeAzureArgs',
    'AccessPolicyExcludeExternalEvaluationArgs',
    'AccessPolicyExcludeGithubArgs',
    'AccessPolicyExcludeGsuiteArgs',
    'AccessPolicyExcludeOktaArgs',
    'AccessPolicyExcludeSamlArgs',
    'AccessPolicyIncludeArgs',
    'AccessPolicyIncludeAuthContextArgs',
    'AccessPolicyIncludeAzureArgs',
    'AccessPolicyIncludeExternalEvaluationArgs',
    'AccessPolicyIncludeGithubArgs',
    'AccessPolicyIncludeGsuiteArgs',
    'AccessPolicyIncludeOktaArgs',
    'AccessPolicyIncludeSamlArgs',
    'AccessPolicyRequireArgs',
    'AccessPolicyRequireAuthContextArgs',
    'AccessPolicyRequireAzureArgs',
    'AccessPolicyRequireExternalEvaluationArgs',
    'AccessPolicyRequireGithubArgs',
    'AccessPolicyRequireGsuiteArgs',
    'AccessPolicyRequireOktaArgs',
    'AccessPolicyRequireSamlArgs',
    'AccessRuleConfigurationArgs',
    'AddressMapIpArgs',
    'AddressMapMembershipArgs',
    'ApiShieldAuthIdCharacteristicArgs',
    'ApiTokenConditionArgs',
    'ApiTokenConditionRequestIpArgs',
    'ApiTokenPolicyArgs',
    'CertificatePackValidationErrorArgs',
    'CertificatePackValidationRecordArgs',
    'CustomHostnameSslArgs',
    'CustomHostnameSslSettingArgs',
    'CustomHostnameSslValidationErrorArgs',
    'CustomHostnameSslValidationRecordArgs',
    'CustomSslCustomSslOptionsArgs',
    'CustomSslCustomSslPriorityArgs',
    'DeviceDexTestDataArgs',
    'DeviceManagedNetworksConfigArgs',
    'DevicePostureIntegrationConfigArgs',
    'DevicePostureRuleInputArgs',
    'DevicePostureRuleMatchArgs',
    'DlpProfileEntryArgs',
    'DlpProfileEntryPatternArgs',
    'EmailRoutingCatchAllActionArgs',
    'EmailRoutingCatchAllMatcherArgs',
    'EmailRoutingRuleActionArgs',
    'EmailRoutingRuleMatcherArgs',
    'FallbackDomainDomainArgs',
    'HealthcheckHeaderArgs',
    'ListItemArgs',
    'ListItemHostnameArgs',
    'ListItemRedirectArgs',
    'ListItemValueArgs',
    'ListItemValueHostnameArgs',
    'ListItemValueRedirectArgs',
    'LoadBalancerAdaptiveRoutingArgs',
    'LoadBalancerCountryPoolArgs',
    'LoadBalancerLocationStrategyArgs',
    'LoadBalancerMonitorHeaderArgs',
    'LoadBalancerPoolLoadSheddingArgs',
    'LoadBalancerPoolOriginArgs',
    'LoadBalancerPoolOriginHeaderArgs',
    'LoadBalancerPoolOriginSteeringArgs',
    'LoadBalancerPopPoolArgs',
    'LoadBalancerRandomSteeringArgs',
    'LoadBalancerRegionPoolArgs',
    'LoadBalancerRuleArgs',
    'LoadBalancerRuleFixedResponseArgs',
    'LoadBalancerRuleOverrideArgs',
    'LoadBalancerRuleOverrideAdaptiveRoutingArgs',
    'LoadBalancerRuleOverrideCountryPoolArgs',
    'LoadBalancerRuleOverrideLocationStrategyArgs',
    'LoadBalancerRuleOverridePopPoolArgs',
    'LoadBalancerRuleOverrideRandomSteeringArgs',
    'LoadBalancerRuleOverrideRegionPoolArgs',
    'LoadBalancerRuleOverrideSessionAffinityAttributeArgs',
    'LoadBalancerSessionAffinityAttributeArgs',
    'ManagedHeadersManagedRequestHeaderArgs',
    'ManagedHeadersManagedResponseHeaderArgs',
    'NotificationPolicyEmailIntegrationArgs',
    'NotificationPolicyFiltersArgs',
    'NotificationPolicyPagerdutyIntegrationArgs',
    'NotificationPolicyWebhooksIntegrationArgs',
    'PageRuleActionsArgs',
    'PageRuleActionsCacheKeyFieldsArgs',
    'PageRuleActionsCacheKeyFieldsCookieArgs',
    'PageRuleActionsCacheKeyFieldsHeaderArgs',
    'PageRuleActionsCacheKeyFieldsHostArgs',
    'PageRuleActionsCacheKeyFieldsQueryStringArgs',
    'PageRuleActionsCacheKeyFieldsUserArgs',
    'PageRuleActionsCacheTtlByStatusArgs',
    'PageRuleActionsForwardingUrlArgs',
    'PageRuleActionsMinifyArgs',
    'PagesProjectBuildConfigArgs',
    'PagesProjectDeploymentConfigsArgs',
    'PagesProjectDeploymentConfigsPreviewArgs',
    'PagesProjectDeploymentConfigsPreviewPlacementArgs',
    'PagesProjectDeploymentConfigsPreviewServiceBindingArgs',
    'PagesProjectDeploymentConfigsProductionArgs',
    'PagesProjectDeploymentConfigsProductionPlacementArgs',
    'PagesProjectDeploymentConfigsProductionServiceBindingArgs',
    'PagesProjectSourceArgs',
    'PagesProjectSourceConfigArgs',
    'RateLimitActionArgs',
    'RateLimitActionResponseArgs',
    'RateLimitCorrelateArgs',
    'RateLimitMatchArgs',
    'RateLimitMatchRequestArgs',
    'RateLimitMatchResponseArgs',
    'RecordDataArgs',
    'RulesetRuleArgs',
    'RulesetRuleActionParametersArgs',
    'RulesetRuleActionParametersAlgorithmArgs',
    'RulesetRuleActionParametersAutominifyArgs',
    'RulesetRuleActionParametersBrowserTtlArgs',
    'RulesetRuleActionParametersCacheKeyArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyHostArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyUserArgs',
    'RulesetRuleActionParametersEdgeTtlArgs',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs',
    'RulesetRuleActionParametersFromListArgs',
    'RulesetRuleActionParametersFromValueArgs',
    'RulesetRuleActionParametersFromValueTargetUrlArgs',
    'RulesetRuleActionParametersHeaderArgs',
    'RulesetRuleActionParametersMatchedDataArgs',
    'RulesetRuleActionParametersOriginArgs',
    'RulesetRuleActionParametersOverridesArgs',
    'RulesetRuleActionParametersOverridesCategoryArgs',
    'RulesetRuleActionParametersOverridesRuleArgs',
    'RulesetRuleActionParametersResponseArgs',
    'RulesetRuleActionParametersServeStaleArgs',
    'RulesetRuleActionParametersSniArgs',
    'RulesetRuleActionParametersUriArgs',
    'RulesetRuleActionParametersUriPathArgs',
    'RulesetRuleActionParametersUriQueryArgs',
    'RulesetRuleExposedCredentialCheckArgs',
    'RulesetRuleLoggingArgs',
    'RulesetRuleRatelimitArgs',
    'SpectrumApplicationDnsArgs',
    'SpectrumApplicationEdgeIpsArgs',
    'SpectrumApplicationOriginDnsArgs',
    'SpectrumApplicationOriginPortRangeArgs',
    'SplitTunnelTunnelArgs',
    'TeamsAccountAntivirusArgs',
    'TeamsAccountBlockPageArgs',
    'TeamsAccountFipsArgs',
    'TeamsAccountLoggingArgs',
    'TeamsAccountLoggingSettingsByRuleTypeArgs',
    'TeamsAccountLoggingSettingsByRuleTypeDnsArgs',
    'TeamsAccountLoggingSettingsByRuleTypeHttpArgs',
    'TeamsAccountLoggingSettingsByRuleTypeL4Args',
    'TeamsAccountPayloadLogArgs',
    'TeamsAccountProxyArgs',
    'TeamsLocationNetworkArgs',
    'TeamsRuleRuleSettingsArgs',
    'TeamsRuleRuleSettingsAuditSshArgs',
    'TeamsRuleRuleSettingsBisoAdminControlsArgs',
    'TeamsRuleRuleSettingsCheckSessionArgs',
    'TeamsRuleRuleSettingsEgressArgs',
    'TeamsRuleRuleSettingsL4overrideArgs',
    'TeamsRuleRuleSettingsPayloadLogArgs',
    'TeamsRuleRuleSettingsUntrustedCertArgs',
    'TunnelConfigConfigArgs',
    'TunnelConfigConfigIngressRuleArgs',
    'TunnelConfigConfigIngressRuleOriginRequestArgs',
    'TunnelConfigConfigIngressRuleOriginRequestAccessArgs',
    'TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs',
    'TunnelConfigConfigOriginRequestArgs',
    'TunnelConfigConfigOriginRequestAccessArgs',
    'TunnelConfigConfigOriginRequestIpRuleArgs',
    'TunnelConfigConfigWarpRoutingArgs',
    'UserAgentBlockingRuleConfigurationArgs',
    'WaitingRoomAdditionalRouteArgs',
    'WaitingRoomRulesRuleArgs',
    'WorkerScriptAnalyticsEngineBindingArgs',
    'WorkerScriptKvNamespaceBindingArgs',
    'WorkerScriptPlainTextBindingArgs',
    'WorkerScriptQueueBindingArgs',
    'WorkerScriptR2BucketBindingArgs',
    'WorkerScriptSecretTextBindingArgs',
    'WorkerScriptServiceBindingArgs',
    'WorkerScriptWebassemblyBindingArgs',
    'ZoneLockdownConfigurationArgs',
    'ZoneSettingsOverrideInitialSettingArgs',
    'ZoneSettingsOverrideInitialSettingMinifyArgs',
    'ZoneSettingsOverrideInitialSettingMobileRedirectArgs',
    'ZoneSettingsOverrideInitialSettingSecurityHeaderArgs',
    'ZoneSettingsOverrideSettingsArgs',
    'ZoneSettingsOverrideSettingsMinifyArgs',
    'ZoneSettingsOverrideSettingsMobileRedirectArgs',
    'ZoneSettingsOverrideSettingsSecurityHeaderArgs',
    'GetLoadBalancerPoolsFilterArgs',
    'GetLoadBalancerPoolsPoolArgs',
    'GetLoadBalancerPoolsPoolLoadSheddingArgs',
    'GetLoadBalancerPoolsPoolOriginArgs',
    'GetLoadBalancerPoolsPoolOriginHeaderArgs',
    'GetRulesetsFilterArgs',
    'GetZonesFilterArgs',
]

@pulumi.input_type
class AccessApplicationCorsHeaderArgs:
    def __init__(__self__, *,
                 allow_all_headers: Optional[pulumi.Input[bool]] = None,
                 allow_all_methods: Optional[pulumi.Input[bool]] = None,
                 allow_all_origins: Optional[pulumi.Input[bool]] = None,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_all_headers: Value to determine whether all HTTP headers are exposed.
        :param pulumi.Input[bool] allow_all_methods: Value to determine whether all methods are exposed.
        :param pulumi.Input[bool] allow_all_origins: Value to determine whether all origins are permitted to make CORS requests.
        :param pulumi.Input[bool] allow_credentials: Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: List of HTTP headers to expose via CORS.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: List of methods to expose via CORS.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: List of origins permitted to make CORS requests.
        :param pulumi.Input[int] max_age: The maximum time a preflight request will be cached.
        """
        AccessApplicationCorsHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_all_headers=allow_all_headers,
            allow_all_methods=allow_all_methods,
            allow_all_origins=allow_all_origins,
            allow_credentials=allow_credentials,
            allowed_headers=allowed_headers,
            allowed_methods=allowed_methods,
            allowed_origins=allowed_origins,
            max_age=max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_all_headers: Optional[pulumi.Input[bool]] = None,
             allow_all_methods: Optional[pulumi.Input[bool]] = None,
             allow_all_origins: Optional[pulumi.Input[bool]] = None,
             allow_credentials: Optional[pulumi.Input[bool]] = None,
             allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             max_age: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_all_headers is not None:
            _setter("allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            _setter("allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            _setter("allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            _setter("allow_credentials", allow_credentials)
        if allowed_headers is not None:
            _setter("allowed_headers", allowed_headers)
        if allowed_methods is not None:
            _setter("allowed_methods", allowed_methods)
        if allowed_origins is not None:
            _setter("allowed_origins", allowed_origins)
        if max_age is not None:
            _setter("max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all HTTP headers are exposed.
        """
        return pulumi.get(self, "allow_all_headers")

    @allow_all_headers.setter
    def allow_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_headers", value)

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all methods are exposed.
        """
        return pulumi.get(self, "allow_all_methods")

    @allow_all_methods.setter
    def allow_all_methods(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_methods", value)

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine whether all origins are permitted to make CORS requests.
        """
        return pulumi.get(self, "allow_all_origins")

    @allow_all_origins.setter
    def allow_all_origins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_origins", value)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of HTTP headers to expose via CORS.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of methods to expose via CORS.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of origins permitted to make CORS requests.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum time a preflight request will be cached.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


@pulumi.input_type
class AccessApplicationSaasAppArgs:
    def __init__(__self__, *,
                 consumer_service_url: pulumi.Input[str],
                 sp_entity_id: pulumi.Input[str],
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]] = None,
                 name_id_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param pulumi.Input[str] sp_entity_id: A globally unique name for an identity or service provider.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]] custom_attributes: Custom attribute mapped from IDPs.
        :param pulumi.Input[str] name_id_format: The format of the name identifier sent to the SaaS application. Defaults to `email`.
        """
        AccessApplicationSaasAppArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_service_url=consumer_service_url,
            sp_entity_id=sp_entity_id,
            custom_attributes=custom_attributes,
            name_id_format=name_id_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_service_url: pulumi.Input[str],
             sp_entity_id: pulumi.Input[str],
             custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]] = None,
             name_id_format: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("consumer_service_url", consumer_service_url)
        _setter("sp_entity_id", sp_entity_id)
        if custom_attributes is not None:
            _setter("custom_attributes", custom_attributes)
        if name_id_format is not None:
            _setter("name_id_format", name_id_format)

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> pulumi.Input[str]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @consumer_service_url.setter
    def consumer_service_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_service_url", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> pulumi.Input[str]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "sp_entity_id", value)

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]]:
        """
        Custom attribute mapped from IDPs.
        """
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]]):
        pulumi.set(self, "custom_attributes", value)

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the name identifier sent to the SaaS application. Defaults to `email`.
        """
        return pulumi.get(self, "name_id_format")

    @name_id_format.setter
    def name_id_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_format", value)


@pulumi.input_type
class AccessApplicationSaasAppCustomAttributeArgs:
    def __init__(__self__, *,
                 source: pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs'],
                 friendly_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 name_format: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] friendly_name: A friendly name for the attribute as provided to the SaaS app.
        :param pulumi.Input[str] name: The name of the attribute as provided to the SaaS app.
        :param pulumi.Input[str] name_format: A globally unique name for an identity or service provider.
        :param pulumi.Input[bool] required: True if the attribute must be always present.
        """
        AccessApplicationSaasAppCustomAttributeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source=source,
            friendly_name=friendly_name,
            name=name,
            name_format=name_format,
            required=required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source: pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs'],
             friendly_name: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             name_format: Optional[pulumi.Input[str]] = None,
             required: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source", source)
        if friendly_name is not None:
            _setter("friendly_name", friendly_name)
        if name is not None:
            _setter("name", name)
        if name_format is not None:
            _setter("name_format", name_format)
        if required is not None:
            _setter("required", required)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs']:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs']):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @name_format.setter
    def name_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_format", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class AccessApplicationSaasAppCustomAttributeSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the attribute as provided to the SaaS app.
        """
        AccessApplicationSaasAppCustomAttributeSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AccessGroupExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of an existing IP list to reference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        """
        AccessGroupExcludeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            any_valid_service_token=any_valid_service_token,
            auth_contexts=auth_contexts,
            auth_method=auth_method,
            azures=azures,
            certificate=certificate,
            common_name=common_name,
            device_postures=device_postures,
            email_domains=email_domains,
            emails=emails,
            everyone=everyone,
            external_evaluation=external_evaluation,
            geos=geos,
            githubs=githubs,
            groups=groups,
            gsuites=gsuites,
            ip_lists=ip_lists,
            ips=ips,
            login_methods=login_methods,
            oktas=oktas,
            samls=samls,
            service_tokens=service_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             any_valid_service_token: Optional[pulumi.Input[bool]] = None,
             auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAuthContextArgs']]]] = None,
             auth_method: Optional[pulumi.Input[str]] = None,
             azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgs']]]] = None,
             certificate: Optional[pulumi.Input[bool]] = None,
             common_name: Optional[pulumi.Input[str]] = None,
             device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             everyone: Optional[pulumi.Input[bool]] = None,
             external_evaluation: Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']] = None,
             geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgs']]]] = None,
             groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgs']]]] = None,
             ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgs']]]] = None,
             samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgs']]]] = None,
             service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if any_valid_service_token is not None:
            _setter("any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            _setter("auth_contexts", auth_contexts)
        if auth_method is not None:
            _setter("auth_method", auth_method)
        if azures is not None:
            _setter("azures", azures)
        if certificate is not None:
            _setter("certificate", certificate)
        if common_name is not None:
            _setter("common_name", common_name)
        if device_postures is not None:
            _setter("device_postures", device_postures)
        if email_domains is not None:
            _setter("email_domains", email_domains)
        if emails is not None:
            _setter("emails", emails)
        if everyone is not None:
            _setter("everyone", everyone)
        if external_evaluation is not None:
            _setter("external_evaluation", external_evaluation)
        if geos is not None:
            _setter("geos", geos)
        if githubs is not None:
            _setter("githubs", githubs)
        if groups is not None:
            _setter("groups", groups)
        if gsuites is not None:
            _setter("gsuites", gsuites)
        if ip_lists is not None:
            _setter("ip_lists", ip_lists)
        if ips is not None:
            _setter("ips", ips)
        if login_methods is not None:
            _setter("login_methods", login_methods)
        if oktas is not None:
            _setter("oktas", oktas)
        if samls is not None:
            _setter("samls", samls)
        if service_tokens is not None:
            _setter("service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgs']]]]:
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgs']]]]:
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgs']]]]:
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an existing IP list to reference.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgs']]]]:
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgs']]]]:
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupExcludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


@pulumi.input_type
class AccessGroupExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupExcludeAuthContextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ac_id=ac_id,
            id=id,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ac_id: pulumi.Input[str],
             id: pulumi.Input[str],
             identity_provider_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ac_id", ac_id)
        _setter("id", id)
        _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessGroupExcludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Authentication Context.
        """
        AccessGroupExcludeAzureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            ids=ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if ids is not None:
            _setter("ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


@pulumi.input_type
class AccessGroupExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        AccessGroupExcludeExternalEvaluationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluate_url=evaluate_url,
            keys_url=keys_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluate_url: Optional[pulumi.Input[str]] = None,
             keys_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluate_url is not None:
            _setter("evaluate_url", evaluate_url)
        if keys_url is not None:
            _setter("keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


@pulumi.input_type
class AccessGroupExcludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupExcludeGithubArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            name=name,
            teams=teams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if name is not None:
            _setter("name", name)
        if teams is not None:
            _setter("teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


@pulumi.input_type
class AccessGroupExcludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupExcludeGsuiteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            emails=emails,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if emails is not None:
            _setter("emails", emails)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessGroupExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupExcludeOktaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            names=names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if names is not None:
            _setter("names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


@pulumi.input_type
class AccessGroupExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupExcludeSamlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_name=attribute_name,
            attribute_value=attribute_value,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_name: Optional[pulumi.Input[str]] = None,
             attribute_value: Optional[pulumi.Input[str]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_name is not None:
            _setter("attribute_name", attribute_name)
        if attribute_value is not None:
            _setter("attribute_value", attribute_value)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessGroupIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of an existing IP list to reference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        """
        AccessGroupIncludeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            any_valid_service_token=any_valid_service_token,
            auth_contexts=auth_contexts,
            auth_method=auth_method,
            azures=azures,
            certificate=certificate,
            common_name=common_name,
            device_postures=device_postures,
            email_domains=email_domains,
            emails=emails,
            everyone=everyone,
            external_evaluation=external_evaluation,
            geos=geos,
            githubs=githubs,
            groups=groups,
            gsuites=gsuites,
            ip_lists=ip_lists,
            ips=ips,
            login_methods=login_methods,
            oktas=oktas,
            samls=samls,
            service_tokens=service_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             any_valid_service_token: Optional[pulumi.Input[bool]] = None,
             auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAuthContextArgs']]]] = None,
             auth_method: Optional[pulumi.Input[str]] = None,
             azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgs']]]] = None,
             certificate: Optional[pulumi.Input[bool]] = None,
             common_name: Optional[pulumi.Input[str]] = None,
             device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             everyone: Optional[pulumi.Input[bool]] = None,
             external_evaluation: Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']] = None,
             geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgs']]]] = None,
             groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgs']]]] = None,
             ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgs']]]] = None,
             samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgs']]]] = None,
             service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if any_valid_service_token is not None:
            _setter("any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            _setter("auth_contexts", auth_contexts)
        if auth_method is not None:
            _setter("auth_method", auth_method)
        if azures is not None:
            _setter("azures", azures)
        if certificate is not None:
            _setter("certificate", certificate)
        if common_name is not None:
            _setter("common_name", common_name)
        if device_postures is not None:
            _setter("device_postures", device_postures)
        if email_domains is not None:
            _setter("email_domains", email_domains)
        if emails is not None:
            _setter("emails", emails)
        if everyone is not None:
            _setter("everyone", everyone)
        if external_evaluation is not None:
            _setter("external_evaluation", external_evaluation)
        if geos is not None:
            _setter("geos", geos)
        if githubs is not None:
            _setter("githubs", githubs)
        if groups is not None:
            _setter("groups", groups)
        if gsuites is not None:
            _setter("gsuites", gsuites)
        if ip_lists is not None:
            _setter("ip_lists", ip_lists)
        if ips is not None:
            _setter("ips", ips)
        if login_methods is not None:
            _setter("login_methods", login_methods)
        if oktas is not None:
            _setter("oktas", oktas)
        if samls is not None:
            _setter("samls", samls)
        if service_tokens is not None:
            _setter("service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgs']]]]:
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgs']]]]:
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgs']]]]:
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an existing IP list to reference.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgs']]]]:
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgs']]]]:
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupIncludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


@pulumi.input_type
class AccessGroupIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupIncludeAuthContextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ac_id=ac_id,
            id=id,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ac_id: pulumi.Input[str],
             id: pulumi.Input[str],
             identity_provider_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ac_id", ac_id)
        _setter("id", id)
        _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessGroupIncludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Authentication Context.
        """
        AccessGroupIncludeAzureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            ids=ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if ids is not None:
            _setter("ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


@pulumi.input_type
class AccessGroupIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        AccessGroupIncludeExternalEvaluationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluate_url=evaluate_url,
            keys_url=keys_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluate_url: Optional[pulumi.Input[str]] = None,
             keys_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluate_url is not None:
            _setter("evaluate_url", evaluate_url)
        if keys_url is not None:
            _setter("keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


@pulumi.input_type
class AccessGroupIncludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupIncludeGithubArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            name=name,
            teams=teams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if name is not None:
            _setter("name", name)
        if teams is not None:
            _setter("teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


@pulumi.input_type
class AccessGroupIncludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupIncludeGsuiteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            emails=emails,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if emails is not None:
            _setter("emails", emails)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessGroupIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupIncludeOktaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            names=names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if names is not None:
            _setter("names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


@pulumi.input_type
class AccessGroupIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupIncludeSamlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_name=attribute_name,
            attribute_value=attribute_value,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_name: Optional[pulumi.Input[str]] = None,
             attribute_value: Optional[pulumi.Input[str]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_name is not None:
            _setter("attribute_name", attribute_name)
        if attribute_value is not None:
            _setter("attribute_value", attribute_value)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessGroupRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of an existing IP list to reference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        """
        AccessGroupRequireArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            any_valid_service_token=any_valid_service_token,
            auth_contexts=auth_contexts,
            auth_method=auth_method,
            azures=azures,
            certificate=certificate,
            common_name=common_name,
            device_postures=device_postures,
            email_domains=email_domains,
            emails=emails,
            everyone=everyone,
            external_evaluation=external_evaluation,
            geos=geos,
            githubs=githubs,
            groups=groups,
            gsuites=gsuites,
            ip_lists=ip_lists,
            ips=ips,
            login_methods=login_methods,
            oktas=oktas,
            samls=samls,
            service_tokens=service_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             any_valid_service_token: Optional[pulumi.Input[bool]] = None,
             auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAuthContextArgs']]]] = None,
             auth_method: Optional[pulumi.Input[str]] = None,
             azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgs']]]] = None,
             certificate: Optional[pulumi.Input[bool]] = None,
             common_name: Optional[pulumi.Input[str]] = None,
             device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             everyone: Optional[pulumi.Input[bool]] = None,
             external_evaluation: Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']] = None,
             geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgs']]]] = None,
             groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgs']]]] = None,
             ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgs']]]] = None,
             samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgs']]]] = None,
             service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if any_valid_service_token is not None:
            _setter("any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            _setter("auth_contexts", auth_contexts)
        if auth_method is not None:
            _setter("auth_method", auth_method)
        if azures is not None:
            _setter("azures", azures)
        if certificate is not None:
            _setter("certificate", certificate)
        if common_name is not None:
            _setter("common_name", common_name)
        if device_postures is not None:
            _setter("device_postures", device_postures)
        if email_domains is not None:
            _setter("email_domains", email_domains)
        if emails is not None:
            _setter("emails", emails)
        if everyone is not None:
            _setter("everyone", everyone)
        if external_evaluation is not None:
            _setter("external_evaluation", external_evaluation)
        if geos is not None:
            _setter("geos", geos)
        if githubs is not None:
            _setter("githubs", githubs)
        if groups is not None:
            _setter("groups", groups)
        if gsuites is not None:
            _setter("gsuites", gsuites)
        if ip_lists is not None:
            _setter("ip_lists", ip_lists)
        if ips is not None:
            _setter("ips", ips)
        if login_methods is not None:
            _setter("login_methods", login_methods)
        if oktas is not None:
            _setter("oktas", oktas)
        if samls is not None:
            _setter("samls", samls)
        if service_tokens is not None:
            _setter("service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgs']]]]:
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgs']]]]:
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgs']]]]:
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an existing IP list to reference.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgs']]]]:
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgs']]]]:
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessGroupRequireSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


@pulumi.input_type
class AccessGroupRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupRequireAuthContextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ac_id=ac_id,
            id=id,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ac_id: pulumi.Input[str],
             id: pulumi.Input[str],
             identity_provider_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ac_id", ac_id)
        _setter("id", id)
        _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessGroupRequireAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Authentication Context.
        """
        AccessGroupRequireAzureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            ids=ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if ids is not None:
            _setter("ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


@pulumi.input_type
class AccessGroupRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        AccessGroupRequireExternalEvaluationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluate_url=evaluate_url,
            keys_url=keys_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluate_url: Optional[pulumi.Input[str]] = None,
             keys_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluate_url is not None:
            _setter("evaluate_url", evaluate_url)
        if keys_url is not None:
            _setter("keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


@pulumi.input_type
class AccessGroupRequireGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupRequireGithubArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            name=name,
            teams=teams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if name is not None:
            _setter("name", name)
        if teams is not None:
            _setter("teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


@pulumi.input_type
class AccessGroupRequireGsuiteArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupRequireGsuiteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            emails=emails,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if emails is not None:
            _setter("emails", emails)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessGroupRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupRequireOktaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            names=names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if names is not None:
            _setter("names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


@pulumi.input_type
class AccessGroupRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessGroupRequireSamlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_name=attribute_name,
            attribute_value=attribute_value,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_name: Optional[pulumi.Input[str]] = None,
             attribute_value: Optional[pulumi.Input[str]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_name is not None:
            _setter("attribute_name", attribute_name)
        if attribute_value is not None:
            _setter("attribute_value", attribute_value)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessIdentityProviderConfigArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input[str]] = None,
                 apps_domain: Optional[pulumi.Input[str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 authorization_server_id: Optional[pulumi.Input[str]] = None,
                 centrify_account: Optional[pulumi.Input[str]] = None,
                 centrify_app_id: Optional[pulumi.Input[str]] = None,
                 certs_url: Optional[pulumi.Input[str]] = None,
                 claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 conditional_access_enabled: Optional[pulumi.Input[bool]] = None,
                 directory_id: Optional[pulumi.Input[str]] = None,
                 email_attribute_name: Optional[pulumi.Input[str]] = None,
                 email_claim_name: Optional[pulumi.Input[str]] = None,
                 idp_public_cert: Optional[pulumi.Input[str]] = None,
                 issuer_url: Optional[pulumi.Input[str]] = None,
                 okta_account: Optional[pulumi.Input[str]] = None,
                 onelogin_account: Optional[pulumi.Input[str]] = None,
                 ping_env_id: Optional[pulumi.Input[str]] = None,
                 pkce_enabled: Optional[pulumi.Input[bool]] = None,
                 redirect_url: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sign_request: Optional[pulumi.Input[bool]] = None,
                 sso_target_url: Optional[pulumi.Input[str]] = None,
                 support_groups: Optional[pulumi.Input[bool]] = None,
                 token_url: Optional[pulumi.Input[str]] = None):
        AccessIdentityProviderConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_token=api_token,
            apps_domain=apps_domain,
            attributes=attributes,
            auth_url=auth_url,
            authorization_server_id=authorization_server_id,
            centrify_account=centrify_account,
            centrify_app_id=centrify_app_id,
            certs_url=certs_url,
            claims=claims,
            client_id=client_id,
            client_secret=client_secret,
            conditional_access_enabled=conditional_access_enabled,
            directory_id=directory_id,
            email_attribute_name=email_attribute_name,
            email_claim_name=email_claim_name,
            idp_public_cert=idp_public_cert,
            issuer_url=issuer_url,
            okta_account=okta_account,
            onelogin_account=onelogin_account,
            ping_env_id=ping_env_id,
            pkce_enabled=pkce_enabled,
            redirect_url=redirect_url,
            scopes=scopes,
            sign_request=sign_request,
            sso_target_url=sso_target_url,
            support_groups=support_groups,
            token_url=token_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_token: Optional[pulumi.Input[str]] = None,
             apps_domain: Optional[pulumi.Input[str]] = None,
             attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             auth_url: Optional[pulumi.Input[str]] = None,
             authorization_server_id: Optional[pulumi.Input[str]] = None,
             centrify_account: Optional[pulumi.Input[str]] = None,
             centrify_app_id: Optional[pulumi.Input[str]] = None,
             certs_url: Optional[pulumi.Input[str]] = None,
             claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret: Optional[pulumi.Input[str]] = None,
             conditional_access_enabled: Optional[pulumi.Input[bool]] = None,
             directory_id: Optional[pulumi.Input[str]] = None,
             email_attribute_name: Optional[pulumi.Input[str]] = None,
             email_claim_name: Optional[pulumi.Input[str]] = None,
             idp_public_cert: Optional[pulumi.Input[str]] = None,
             issuer_url: Optional[pulumi.Input[str]] = None,
             okta_account: Optional[pulumi.Input[str]] = None,
             onelogin_account: Optional[pulumi.Input[str]] = None,
             ping_env_id: Optional[pulumi.Input[str]] = None,
             pkce_enabled: Optional[pulumi.Input[bool]] = None,
             redirect_url: Optional[pulumi.Input[str]] = None,
             scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             sign_request: Optional[pulumi.Input[bool]] = None,
             sso_target_url: Optional[pulumi.Input[str]] = None,
             support_groups: Optional[pulumi.Input[bool]] = None,
             token_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if api_token is not None:
            _setter("api_token", api_token)
        if apps_domain is not None:
            _setter("apps_domain", apps_domain)
        if attributes is not None:
            _setter("attributes", attributes)
        if auth_url is not None:
            _setter("auth_url", auth_url)
        if authorization_server_id is not None:
            _setter("authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            _setter("centrify_account", centrify_account)
        if centrify_app_id is not None:
            _setter("centrify_app_id", centrify_app_id)
        if certs_url is not None:
            _setter("certs_url", certs_url)
        if claims is not None:
            _setter("claims", claims)
        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret is not None:
            _setter("client_secret", client_secret)
        if conditional_access_enabled is not None:
            _setter("conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            _setter("directory_id", directory_id)
        if email_attribute_name is not None:
            _setter("email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            _setter("email_claim_name", email_claim_name)
        if idp_public_cert is not None:
            _setter("idp_public_cert", idp_public_cert)
        if issuer_url is not None:
            _setter("issuer_url", issuer_url)
        if okta_account is not None:
            _setter("okta_account", okta_account)
        if onelogin_account is not None:
            _setter("onelogin_account", onelogin_account)
        if ping_env_id is not None:
            _setter("ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            _setter("pkce_enabled", pkce_enabled)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if scopes is not None:
            _setter("scopes", scopes)
        if sign_request is not None:
            _setter("sign_request", sign_request)
        if sso_target_url is not None:
            _setter("sso_target_url", sso_target_url)
        if support_groups is not None:
            _setter("support_groups", support_groups)
        if token_url is not None:
            _setter("token_url", token_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "apps_domain")

    @apps_domain.setter
    def apps_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apps_domain", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "authorization_server_id")

    @authorization_server_id.setter
    def authorization_server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_server_id", value)

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "centrify_account")

    @centrify_account.setter
    def centrify_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "centrify_account", value)

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "centrify_app_id")

    @centrify_app_id.setter
    def centrify_app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "centrify_app_id", value)

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certs_url")

    @certs_url.setter
    def certs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certs_url", value)

    @property
    @pulumi.getter
    def claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "claims")

    @claims.setter
    def claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "claims", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "conditional_access_enabled")

    @conditional_access_enabled.setter
    def conditional_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditional_access_enabled", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory_id", value)

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_attribute_name")

    @email_attribute_name.setter
    def email_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_attribute_name", value)

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_claim_name")

    @email_claim_name.setter
    def email_claim_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_claim_name", value)

    @property
    @pulumi.getter(name="idpPublicCert")
    def idp_public_cert(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idp_public_cert")

    @idp_public_cert.setter
    def idp_public_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_public_cert", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "okta_account")

    @okta_account.setter
    def okta_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "okta_account", value)

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "onelogin_account")

    @onelogin_account.setter
    def onelogin_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "onelogin_account", value)

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ping_env_id")

    @ping_env_id.setter
    def ping_env_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ping_env_id", value)

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pkce_enabled")

    @pkce_enabled.setter
    def pkce_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pkce_enabled", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_request", value)

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sso_target_url")

    @sso_target_url.setter
    def sso_target_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_target_url", value)

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "support_groups")

    @support_groups.setter
    def support_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_groups", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)


@pulumi.input_type
class AccessIdentityProviderScimConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 group_member_deprovision: Optional[pulumi.Input[bool]] = None,
                 seat_deprovision: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 user_deprovision: Optional[pulumi.Input[bool]] = None):
        AccessIdentityProviderScimConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            group_member_deprovision=group_member_deprovision,
            seat_deprovision=seat_deprovision,
            secret=secret,
            user_deprovision=user_deprovision,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             group_member_deprovision: Optional[pulumi.Input[bool]] = None,
             seat_deprovision: Optional[pulumi.Input[bool]] = None,
             secret: Optional[pulumi.Input[str]] = None,
             user_deprovision: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if group_member_deprovision is not None:
            _setter("group_member_deprovision", group_member_deprovision)
        if seat_deprovision is not None:
            _setter("seat_deprovision", seat_deprovision)
        if secret is not None:
            _setter("secret", secret)
        if user_deprovision is not None:
            _setter("user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="groupMemberDeprovision")
    def group_member_deprovision(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "group_member_deprovision")

    @group_member_deprovision.setter
    def group_member_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "group_member_deprovision", value)

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "seat_deprovision")

    @seat_deprovision.setter
    def seat_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "seat_deprovision", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "user_deprovision")

    @user_deprovision.setter
    def user_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_deprovision", value)


@pulumi.input_type
class AccessOrganizationCustomPageArgs:
    def __init__(__self__, *,
                 forbidden: Optional[pulumi.Input[str]] = None,
                 identity_denied: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] forbidden: The id of the forbidden page.
        :param pulumi.Input[str] identity_denied: The id of the identity denied page.
        """
        AccessOrganizationCustomPageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forbidden=forbidden,
            identity_denied=identity_denied,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forbidden: Optional[pulumi.Input[str]] = None,
             identity_denied: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if forbidden is not None:
            _setter("forbidden", forbidden)
        if identity_denied is not None:
            _setter("identity_denied", identity_denied)

    @property
    @pulumi.getter
    def forbidden(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the forbidden page.
        """
        return pulumi.get(self, "forbidden")

    @forbidden.setter
    def forbidden(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forbidden", value)

    @property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the identity denied page.
        """
        return pulumi.get(self, "identity_denied")

    @identity_denied.setter
    def identity_denied(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_denied", value)


@pulumi.input_type
class AccessOrganizationLoginDesignArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None,
                 logo_path: Optional[pulumi.Input[str]] = None,
                 text_color: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_color: The background color on the login page.
        :param pulumi.Input[str] footer_text: The text at the bottom of the login page.
        :param pulumi.Input[str] header_text: The text at the top of the login page.
        :param pulumi.Input[str] logo_path: The URL of the logo on the login page.
        :param pulumi.Input[str] text_color: The text color on the login page.
        """
        AccessOrganizationLoginDesignArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            footer_text=footer_text,
            header_text=header_text,
            logo_path=logo_path,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional[pulumi.Input[str]] = None,
             footer_text: Optional[pulumi.Input[str]] = None,
             header_text: Optional[pulumi.Input[str]] = None,
             logo_path: Optional[pulumi.Input[str]] = None,
             text_color: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if footer_text is not None:
            _setter("footer_text", footer_text)
        if header_text is not None:
            _setter("header_text", header_text)
        if logo_path is not None:
            _setter("logo_path", logo_path)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color on the login page.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text at the bottom of the login page.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text at the top of the login page.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the logo on the login page.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_path", value)

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[pulumi.Input[str]]:
        """
        The text color on the login page.
        """
        return pulumi.get(self, "text_color")

    @text_color.setter
    def text_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_color", value)


@pulumi.input_type
class AccessPolicyApprovalGroupArgs:
    def __init__(__self__, *,
                 approvals_needed: pulumi.Input[int],
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_list_uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] approvals_needed: Number of approvals needed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_addresses: List of emails to request approval from.
        """
        AccessPolicyApprovalGroupArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            approvals_needed=approvals_needed,
            email_addresses=email_addresses,
            email_list_uuid=email_list_uuid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             approvals_needed: pulumi.Input[int],
             email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             email_list_uuid: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("approvals_needed", approvals_needed)
        if email_addresses is not None:
            _setter("email_addresses", email_addresses)
        if email_list_uuid is not None:
            _setter("email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> pulumi.Input[int]:
        """
        Number of approvals needed.
        """
        return pulumi.get(self, "approvals_needed")

    @approvals_needed.setter
    def approvals_needed(self, value: pulumi.Input[int]):
        pulumi.set(self, "approvals_needed", value)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of emails to request approval from.
        """
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_list_uuid")

    @email_list_uuid.setter
    def email_list_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_list_uuid", value)


@pulumi.input_type
class AccessPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of an existing IP list to reference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        """
        AccessPolicyExcludeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            any_valid_service_token=any_valid_service_token,
            auth_contexts=auth_contexts,
            auth_method=auth_method,
            azures=azures,
            certificate=certificate,
            common_name=common_name,
            device_postures=device_postures,
            email_domains=email_domains,
            emails=emails,
            everyone=everyone,
            external_evaluation=external_evaluation,
            geos=geos,
            githubs=githubs,
            groups=groups,
            gsuites=gsuites,
            ip_lists=ip_lists,
            ips=ips,
            login_methods=login_methods,
            oktas=oktas,
            samls=samls,
            service_tokens=service_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             any_valid_service_token: Optional[pulumi.Input[bool]] = None,
             auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]]] = None,
             auth_method: Optional[pulumi.Input[str]] = None,
             azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgs']]]] = None,
             certificate: Optional[pulumi.Input[bool]] = None,
             common_name: Optional[pulumi.Input[str]] = None,
             device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             everyone: Optional[pulumi.Input[bool]] = None,
             external_evaluation: Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']] = None,
             geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgs']]]] = None,
             groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]]] = None,
             ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgs']]]] = None,
             samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgs']]]] = None,
             service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if any_valid_service_token is not None:
            _setter("any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            _setter("auth_contexts", auth_contexts)
        if auth_method is not None:
            _setter("auth_method", auth_method)
        if azures is not None:
            _setter("azures", azures)
        if certificate is not None:
            _setter("certificate", certificate)
        if common_name is not None:
            _setter("common_name", common_name)
        if device_postures is not None:
            _setter("device_postures", device_postures)
        if email_domains is not None:
            _setter("email_domains", email_domains)
        if emails is not None:
            _setter("emails", emails)
        if everyone is not None:
            _setter("everyone", everyone)
        if external_evaluation is not None:
            _setter("external_evaluation", external_evaluation)
        if geos is not None:
            _setter("geos", geos)
        if githubs is not None:
            _setter("githubs", githubs)
        if groups is not None:
            _setter("groups", groups)
        if gsuites is not None:
            _setter("gsuites", gsuites)
        if ip_lists is not None:
            _setter("ip_lists", ip_lists)
        if ips is not None:
            _setter("ips", ips)
        if login_methods is not None:
            _setter("login_methods", login_methods)
        if oktas is not None:
            _setter("oktas", oktas)
        if samls is not None:
            _setter("samls", samls)
        if service_tokens is not None:
            _setter("service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgs']]]]:
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgs']]]]:
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]]]:
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an existing IP list to reference.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgs']]]]:
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgs']]]]:
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyExcludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


@pulumi.input_type
class AccessPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyExcludeAuthContextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ac_id=ac_id,
            id=id,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ac_id: pulumi.Input[str],
             id: pulumi.Input[str],
             identity_provider_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ac_id", ac_id)
        _setter("id", id)
        _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessPolicyExcludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Authentication Context.
        """
        AccessPolicyExcludeAzureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            ids=ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if ids is not None:
            _setter("ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


@pulumi.input_type
class AccessPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        AccessPolicyExcludeExternalEvaluationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluate_url=evaluate_url,
            keys_url=keys_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluate_url: Optional[pulumi.Input[str]] = None,
             keys_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluate_url is not None:
            _setter("evaluate_url", evaluate_url)
        if keys_url is not None:
            _setter("keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


@pulumi.input_type
class AccessPolicyExcludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyExcludeGithubArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            name=name,
            teams=teams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if name is not None:
            _setter("name", name)
        if teams is not None:
            _setter("teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


@pulumi.input_type
class AccessPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyExcludeGsuiteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            emails=emails,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if emails is not None:
            _setter("emails", emails)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyExcludeOktaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            names=names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if names is not None:
            _setter("names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


@pulumi.input_type
class AccessPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyExcludeSamlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_name=attribute_name,
            attribute_value=attribute_value,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_name: Optional[pulumi.Input[str]] = None,
             attribute_value: Optional[pulumi.Input[str]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_name is not None:
            _setter("attribute_name", attribute_name)
        if attribute_value is not None:
            _setter("attribute_value", attribute_value)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of an existing IP list to reference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        """
        AccessPolicyIncludeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            any_valid_service_token=any_valid_service_token,
            auth_contexts=auth_contexts,
            auth_method=auth_method,
            azures=azures,
            certificate=certificate,
            common_name=common_name,
            device_postures=device_postures,
            email_domains=email_domains,
            emails=emails,
            everyone=everyone,
            external_evaluation=external_evaluation,
            geos=geos,
            githubs=githubs,
            groups=groups,
            gsuites=gsuites,
            ip_lists=ip_lists,
            ips=ips,
            login_methods=login_methods,
            oktas=oktas,
            samls=samls,
            service_tokens=service_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             any_valid_service_token: Optional[pulumi.Input[bool]] = None,
             auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]]] = None,
             auth_method: Optional[pulumi.Input[str]] = None,
             azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgs']]]] = None,
             certificate: Optional[pulumi.Input[bool]] = None,
             common_name: Optional[pulumi.Input[str]] = None,
             device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             everyone: Optional[pulumi.Input[bool]] = None,
             external_evaluation: Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']] = None,
             geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgs']]]] = None,
             groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]]] = None,
             ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgs']]]] = None,
             samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgs']]]] = None,
             service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if any_valid_service_token is not None:
            _setter("any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            _setter("auth_contexts", auth_contexts)
        if auth_method is not None:
            _setter("auth_method", auth_method)
        if azures is not None:
            _setter("azures", azures)
        if certificate is not None:
            _setter("certificate", certificate)
        if common_name is not None:
            _setter("common_name", common_name)
        if device_postures is not None:
            _setter("device_postures", device_postures)
        if email_domains is not None:
            _setter("email_domains", email_domains)
        if emails is not None:
            _setter("emails", emails)
        if everyone is not None:
            _setter("everyone", everyone)
        if external_evaluation is not None:
            _setter("external_evaluation", external_evaluation)
        if geos is not None:
            _setter("geos", geos)
        if githubs is not None:
            _setter("githubs", githubs)
        if groups is not None:
            _setter("groups", groups)
        if gsuites is not None:
            _setter("gsuites", gsuites)
        if ip_lists is not None:
            _setter("ip_lists", ip_lists)
        if ips is not None:
            _setter("ips", ips)
        if login_methods is not None:
            _setter("login_methods", login_methods)
        if oktas is not None:
            _setter("oktas", oktas)
        if samls is not None:
            _setter("samls", samls)
        if service_tokens is not None:
            _setter("service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgs']]]]:
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgs']]]]:
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]]]:
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an existing IP list to reference.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgs']]]]:
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgs']]]]:
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyIncludeSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


@pulumi.input_type
class AccessPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyIncludeAuthContextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ac_id=ac_id,
            id=id,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ac_id: pulumi.Input[str],
             id: pulumi.Input[str],
             identity_provider_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ac_id", ac_id)
        _setter("id", id)
        _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessPolicyIncludeAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Authentication Context.
        """
        AccessPolicyIncludeAzureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            ids=ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if ids is not None:
            _setter("ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


@pulumi.input_type
class AccessPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        AccessPolicyIncludeExternalEvaluationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluate_url=evaluate_url,
            keys_url=keys_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluate_url: Optional[pulumi.Input[str]] = None,
             keys_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluate_url is not None:
            _setter("evaluate_url", evaluate_url)
        if keys_url is not None:
            _setter("keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


@pulumi.input_type
class AccessPolicyIncludeGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyIncludeGithubArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            name=name,
            teams=teams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if name is not None:
            _setter("name", name)
        if teams is not None:
            _setter("teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


@pulumi.input_type
class AccessPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyIncludeGsuiteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            emails=emails,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if emails is not None:
            _setter("emails", emails)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyIncludeOktaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            names=names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if names is not None:
            _setter("names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


@pulumi.input_type
class AccessPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyIncludeSamlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_name=attribute_name,
            attribute_value=attribute_value,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_name: Optional[pulumi.Input[str]] = None,
             attribute_value: Optional[pulumi.Input[str]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_name is not None:
            _setter("attribute_name", attribute_name)
        if attribute_value is not None:
            _setter("attribute_value", attribute_value)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input[bool]] = None,
                 auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAuthContextArgs']]]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgs']]]] = None,
                 certificate: Optional[pulumi.Input[bool]] = None,
                 common_name: Optional[pulumi.Input[str]] = None,
                 device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 everyone: Optional[pulumi.Input[bool]] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']] = None,
                 geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgs']]]] = None,
                 ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgs']]]] = None,
                 service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lists: The ID of an existing IP list to reference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: An IPv4 or IPv6 CIDR block.
        """
        AccessPolicyRequireArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            any_valid_service_token=any_valid_service_token,
            auth_contexts=auth_contexts,
            auth_method=auth_method,
            azures=azures,
            certificate=certificate,
            common_name=common_name,
            device_postures=device_postures,
            email_domains=email_domains,
            emails=emails,
            everyone=everyone,
            external_evaluation=external_evaluation,
            geos=geos,
            githubs=githubs,
            groups=groups,
            gsuites=gsuites,
            ip_lists=ip_lists,
            ips=ips,
            login_methods=login_methods,
            oktas=oktas,
            samls=samls,
            service_tokens=service_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             any_valid_service_token: Optional[pulumi.Input[bool]] = None,
             auth_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAuthContextArgs']]]] = None,
             auth_method: Optional[pulumi.Input[str]] = None,
             azures: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgs']]]] = None,
             certificate: Optional[pulumi.Input[bool]] = None,
             common_name: Optional[pulumi.Input[str]] = None,
             device_postures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             everyone: Optional[pulumi.Input[bool]] = None,
             external_evaluation: Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']] = None,
             geos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             githubs: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgs']]]] = None,
             groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             gsuites: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgs']]]] = None,
             ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             login_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             oktas: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgs']]]] = None,
             samls: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgs']]]] = None,
             service_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if any_valid_service_token is not None:
            _setter("any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            _setter("auth_contexts", auth_contexts)
        if auth_method is not None:
            _setter("auth_method", auth_method)
        if azures is not None:
            _setter("azures", azures)
        if certificate is not None:
            _setter("certificate", certificate)
        if common_name is not None:
            _setter("common_name", common_name)
        if device_postures is not None:
            _setter("device_postures", device_postures)
        if email_domains is not None:
            _setter("email_domains", email_domains)
        if emails is not None:
            _setter("emails", emails)
        if everyone is not None:
            _setter("everyone", everyone)
        if external_evaluation is not None:
            _setter("external_evaluation", external_evaluation)
        if geos is not None:
            _setter("geos", geos)
        if githubs is not None:
            _setter("githubs", githubs)
        if groups is not None:
            _setter("groups", groups)
        if gsuites is not None:
            _setter("gsuites", gsuites)
        if ip_lists is not None:
            _setter("ip_lists", ip_lists)
        if ips is not None:
            _setter("ips", ips)
        if login_methods is not None:
            _setter("login_methods", login_methods)
        if oktas is not None:
            _setter("oktas", oktas)
        if samls is not None:
            _setter("samls", samls)
        if service_tokens is not None:
            _setter("service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAuthContextArgs']]]]:
        return pulumi.get(self, "auth_contexts")

    @auth_contexts.setter
    def auth_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAuthContextArgs']]]]):
        pulumi.set(self, "auth_contexts", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter
    def azures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgs']]]]:
        return pulumi.get(self, "azures")

    @azures.setter
    def azures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireAzureArgs']]]]):
        pulumi.set(self, "azures", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_postures")

    @device_postures.setter
    def device_postures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_postures", value)

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_domains")

    @email_domains.setter
    def email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_domains", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "geos")

    @geos.setter
    def geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "geos", value)

    @property
    @pulumi.getter
    def githubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgs']]]]:
        return pulumi.get(self, "githubs")

    @githubs.setter
    def githubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGithubArgs']]]]):
        pulumi.set(self, "githubs", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgs']]]]:
        return pulumi.get(self, "gsuites")

    @gsuites.setter
    def gsuites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireGsuiteArgs']]]]):
        pulumi.set(self, "gsuites", value)

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of an existing IP list to reference.
        """
        return pulumi.get(self, "ip_lists")

    @ip_lists.setter
    def ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lists", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "login_methods")

    @login_methods.setter
    def login_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_methods", value)

    @property
    @pulumi.getter
    def oktas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgs']]]]:
        return pulumi.get(self, "oktas")

    @oktas.setter
    def oktas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireOktaArgs']]]]):
        pulumi.set(self, "oktas", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgs']]]]:
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPolicyRequireSamlArgs']]]]):
        pulumi.set(self, "samls", value)

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "service_tokens")

    @service_tokens.setter
    def service_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_tokens", value)


@pulumi.input_type
class AccessPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of the Authentication Context.
        :param pulumi.Input[str] id: The ID of the Authentication Context.
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyRequireAuthContextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ac_id=ac_id,
            id=id,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ac_id: pulumi.Input[str],
             id: pulumi.Input[str],
             identity_provider_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ac_id", ac_id)
        _setter("id", id)
        _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessPolicyRequireAzureArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The ID of the Authentication Context.
        """
        AccessPolicyRequireAzureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            ids=ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if ids is not None:
            _setter("ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


@pulumi.input_type
class AccessPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: Optional[pulumi.Input[str]] = None,
                 keys_url: Optional[pulumi.Input[str]] = None):
        AccessPolicyRequireExternalEvaluationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluate_url=evaluate_url,
            keys_url=keys_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluate_url: Optional[pulumi.Input[str]] = None,
             keys_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluate_url is not None:
            _setter("evaluate_url", evaluate_url)
        if keys_url is not None:
            _setter("keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys_url", value)


@pulumi.input_type
class AccessPolicyRequireGithubArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyRequireGithubArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            name=name,
            teams=teams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if name is not None:
            _setter("name", name)
        if teams is not None:
            _setter("teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)


@pulumi.input_type
class AccessPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyRequireGsuiteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            emails=emails,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if emails is not None:
            _setter("emails", emails)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyRequireOktaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider_id=identity_provider_id,
            names=names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)
        if names is not None:
            _setter("names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


@pulumi.input_type
class AccessPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None,
                 identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of the Azure Identity provider.
        """
        AccessPolicyRequireSamlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_name=attribute_name,
            attribute_value=attribute_value,
            identity_provider_id=identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_name: Optional[pulumi.Input[str]] = None,
             attribute_value: Optional[pulumi.Input[str]] = None,
             identity_provider_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_name is not None:
            _setter("attribute_name", attribute_name)
        if attribute_value is not None:
            _setter("attribute_value", attribute_value)
        if identity_provider_id is not None:
            _setter("identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Azure Identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_provider_id", value)


@pulumi.input_type
class AccessRuleConfigurationArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target: The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] value: The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
        AccessRuleConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        _setter("value", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class AddressMapIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 address.
        """
        AddressMapIpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class AddressMapMembershipArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str],
                 kind: pulumi.Input[str],
                 can_delete: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] identifier: Identifier of the account or zone.
        :param pulumi.Input[str] kind: The type of the membership.
        :param pulumi.Input[bool] can_delete: Controls whether the membership can be deleted via the API or not.
        """
        AddressMapMembershipArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
            kind=kind,
            can_delete=can_delete,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: pulumi.Input[str],
             kind: pulumi.Input[str],
             can_delete: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("identifier", identifier)
        _setter("kind", kind)
        if can_delete is not None:
            _setter("can_delete", can_delete)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        Identifier of the account or zone.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        The type of the membership.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether the membership can be deleted via the API or not.
        """
        return pulumi.get(self, "can_delete")

    @can_delete.setter
    def can_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_delete", value)


@pulumi.input_type
class ApiShieldAuthIdCharacteristicArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the characteristic.
        :param pulumi.Input[str] type: The type of characteristic. Available values: `header`, `cookie`.
        """
        ApiShieldAuthIdCharacteristicArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the characteristic.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of characteristic. Available values: `header`, `cookie`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApiTokenConditionArgs:
    def __init__(__self__, *,
                 request_ip: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']] = None):
        """
        :param pulumi.Input['ApiTokenConditionRequestIpArgs'] request_ip: Request IP related conditions.
        """
        ApiTokenConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request_ip=request_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request_ip: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if request_ip is not None:
            _setter("request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']]:
        """
        Request IP related conditions.
        """
        return pulumi.get(self, "request_ip")

    @request_ip.setter
    def request_ip(self, value: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']]):
        pulumi.set(self, "request_ip", value)


@pulumi.input_type
class ApiTokenConditionRequestIpArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ins: List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] not_ins: List of IP addresses or CIDR notation where the token should not be used from.
        """
        ApiTokenConditionRequestIpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ins=ins,
            not_ins=not_ins,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ins is not None:
            _setter("ins", ins)
        if not_ins is not None:
            _setter("not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
        """
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP addresses or CIDR notation where the token should not be used from.
        """
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


@pulumi.input_type
class ApiTokenPolicyArgs:
    def __init__(__self__, *,
                 permission_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 resources: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 effect: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permission_groups: List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] resources: Describes what operations against which resources are allowed or denied.
        :param pulumi.Input[str] effect: Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
        ApiTokenPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permission_groups=permission_groups,
            resources=resources,
            effect=effect,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permission_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
             resources: pulumi.Input[Mapping[str, pulumi.Input[str]]],
             effect: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("permission_groups", permission_groups)
        _setter("resources", resources)
        if effect is not None:
            _setter("effect", effect)

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        """
        return pulumi.get(self, "permission_groups")

    @permission_groups.setter
    def permission_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permission_groups", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Describes what operations against which resources are allowed or denied.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)


@pulumi.input_type
class CertificatePackValidationErrorArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None):
        CertificatePackValidationErrorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if message is not None:
            _setter("message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


@pulumi.input_type
class CertificatePackValidationRecordArgs:
    def __init__(__self__, *,
                 cname_name: Optional[pulumi.Input[str]] = None,
                 cname_target: Optional[pulumi.Input[str]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http_body: Optional[pulumi.Input[str]] = None,
                 http_url: Optional[pulumi.Input[str]] = None,
                 txt_name: Optional[pulumi.Input[str]] = None,
                 txt_value: Optional[pulumi.Input[str]] = None):
        CertificatePackValidationRecordArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cname_name=cname_name,
            cname_target=cname_target,
            emails=emails,
            http_body=http_body,
            http_url=http_url,
            txt_name=txt_name,
            txt_value=txt_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cname_name: Optional[pulumi.Input[str]] = None,
             cname_target: Optional[pulumi.Input[str]] = None,
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             http_body: Optional[pulumi.Input[str]] = None,
             http_url: Optional[pulumi.Input[str]] = None,
             txt_name: Optional[pulumi.Input[str]] = None,
             txt_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cname_name is not None:
            _setter("cname_name", cname_name)
        if cname_target is not None:
            _setter("cname_target", cname_target)
        if emails is not None:
            _setter("emails", emails)
        if http_body is not None:
            _setter("http_body", http_body)
        if http_url is not None:
            _setter("http_url", http_url)
        if txt_name is not None:
            _setter("txt_name", txt_name)
        if txt_value is not None:
            _setter("txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_name")

    @cname_name.setter
    def cname_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_name", value)

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_target")

    @cname_target.setter
    def cname_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_target", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_body")

    @http_body.setter
    def http_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_body", value)

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_url", value)

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_name")

    @txt_name.setter
    def txt_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_name", value)

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_value")

    @txt_value.setter
    def txt_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_value", value)


@pulumi.input_type
class CustomHostnameSslArgs:
    def __init__(__self__, *,
                 bundle_method: Optional[pulumi.Input[str]] = None,
                 certificate_authority: Optional[pulumi.Input[str]] = None,
                 custom_certificate: Optional[pulumi.Input[str]] = None,
                 custom_key: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 validation_errors: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationErrorArgs']]]] = None,
                 validation_records: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationRecordArgs']]]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        :param pulumi.Input[str] custom_certificate: If a custom uploaded certificate is used.
        :param pulumi.Input[str] custom_key: The key for a custom uploaded certificate.
        :param pulumi.Input[str] method: Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        :param pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]] settings: SSL/TLS settings for the certificate.
        :param pulumi.Input[str] type: Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        :param pulumi.Input[bool] wildcard: Indicates whether the certificate covers a wildcard.
        """
        CustomHostnameSslArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bundle_method=bundle_method,
            certificate_authority=certificate_authority,
            custom_certificate=custom_certificate,
            custom_key=custom_key,
            method=method,
            settings=settings,
            status=status,
            type=type,
            validation_errors=validation_errors,
            validation_records=validation_records,
            wildcard=wildcard,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bundle_method: Optional[pulumi.Input[str]] = None,
             certificate_authority: Optional[pulumi.Input[str]] = None,
             custom_certificate: Optional[pulumi.Input[str]] = None,
             custom_key: Optional[pulumi.Input[str]] = None,
             method: Optional[pulumi.Input[str]] = None,
             settings: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]]] = None,
             status: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             validation_errors: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationErrorArgs']]]] = None,
             validation_records: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationRecordArgs']]]] = None,
             wildcard: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bundle_method is not None:
            _setter("bundle_method", bundle_method)
        if certificate_authority is not None:
            _setter("certificate_authority", certificate_authority)
        if custom_certificate is not None:
            _setter("custom_certificate", custom_certificate)
        if custom_key is not None:
            _setter("custom_key", custom_key)
        if method is not None:
            _setter("method", method)
        if settings is not None:
            _setter("settings", settings)
        if status is not None:
            _setter("status", status)
        if type is not None:
            _setter("type", type)
        if validation_errors is not None:
            _setter("validation_errors", validation_errors)
        if validation_records is not None:
            _setter("validation_records", validation_records)
        if wildcard is not None:
            _setter("wildcard", wildcard)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[pulumi.Input[str]]:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @bundle_method.setter
    def bundle_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bundle_method", value)

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_authority", value)

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_certificate", value)

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_key", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]]]:
        """
        SSL/TLS settings for the certificate.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslSettingArgs']]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationErrorArgs']]]]:
        return pulumi.get(self, "validation_errors")

    @validation_errors.setter
    def validation_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationErrorArgs']]]]):
        pulumi.set(self, "validation_errors", value)

    @property
    @pulumi.getter(name="validationRecords")
    def validation_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationRecordArgs']]]]:
        return pulumi.get(self, "validation_records")

    @validation_records.setter
    def validation_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslValidationRecordArgs']]]]):
        pulumi.set(self, "validation_records", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)


@pulumi.input_type
class CustomHostnameSslSettingArgs:
    def __init__(__self__, *,
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 early_hints: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[str]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 tls13: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ciphers: List of SSL/TLS ciphers to associate with this certificate.
        :param pulumi.Input[str] early_hints: Whether early hints should be supported. Available values: `on`, `off`.
        :param pulumi.Input[str] http2: Whether HTTP2 should be supported. Available values: `on`, `off`.
        :param pulumi.Input[str] min_tls_version: Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
        :param pulumi.Input[str] tls13: Whether TLSv1.3 should be supported. Available values: `on`, `off`.
        """
        CustomHostnameSslSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ciphers=ciphers,
            early_hints=early_hints,
            http2=http2,
            min_tls_version=min_tls_version,
            tls13=tls13,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             early_hints: Optional[pulumi.Input[str]] = None,
             http2: Optional[pulumi.Input[str]] = None,
             min_tls_version: Optional[pulumi.Input[str]] = None,
             tls13: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ciphers is not None:
            _setter("ciphers", ciphers)
        if early_hints is not None:
            _setter("early_hints", early_hints)
        if http2 is not None:
            _setter("http2", http2)
        if min_tls_version is not None:
            _setter("min_tls_version", min_tls_version)
        if tls13 is not None:
            _setter("tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of SSL/TLS ciphers to associate with this certificate.
        """
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ciphers", value)

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[pulumi.Input[str]]:
        """
        Whether early hints should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "early_hints")

    @early_hints.setter
    def early_hints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "early_hints", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[str]]:
        """
        Whether HTTP2 should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter
    def tls13(self) -> Optional[pulumi.Input[str]]:
        """
        Whether TLSv1.3 should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "tls13")

    @tls13.setter
    def tls13(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls13", value)


@pulumi.input_type
class CustomHostnameSslValidationErrorArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None):
        CustomHostnameSslValidationErrorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if message is not None:
            _setter("message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


@pulumi.input_type
class CustomHostnameSslValidationRecordArgs:
    def __init__(__self__, *,
                 cname_name: Optional[pulumi.Input[str]] = None,
                 cname_target: Optional[pulumi.Input[str]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http_body: Optional[pulumi.Input[str]] = None,
                 http_url: Optional[pulumi.Input[str]] = None,
                 txt_name: Optional[pulumi.Input[str]] = None,
                 txt_value: Optional[pulumi.Input[str]] = None):
        CustomHostnameSslValidationRecordArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cname_name=cname_name,
            cname_target=cname_target,
            emails=emails,
            http_body=http_body,
            http_url=http_url,
            txt_name=txt_name,
            txt_value=txt_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cname_name: Optional[pulumi.Input[str]] = None,
             cname_target: Optional[pulumi.Input[str]] = None,
             emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             http_body: Optional[pulumi.Input[str]] = None,
             http_url: Optional[pulumi.Input[str]] = None,
             txt_name: Optional[pulumi.Input[str]] = None,
             txt_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cname_name is not None:
            _setter("cname_name", cname_name)
        if cname_target is not None:
            _setter("cname_target", cname_target)
        if emails is not None:
            _setter("emails", emails)
        if http_body is not None:
            _setter("http_body", http_body)
        if http_url is not None:
            _setter("http_url", http_url)
        if txt_name is not None:
            _setter("txt_name", txt_name)
        if txt_value is not None:
            _setter("txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_name")

    @cname_name.setter
    def cname_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_name", value)

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_target")

    @cname_target.setter
    def cname_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_target", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_body")

    @http_body.setter
    def http_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_body", value)

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_url", value)

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_name")

    @txt_name.setter
    def txt_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_name", value)

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_value")

    @txt_value.setter
    def txt_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_value", value)


@pulumi.input_type
class CustomSslCustomSslOptionsArgs:
    def __init__(__self__, *,
                 bundle_method: Optional[pulumi.Input[str]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 geo_restrictions: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bundle_method: Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        :param pulumi.Input[str] certificate: Certificate certificate and the intermediate(s).
        :param pulumi.Input[str] geo_restrictions: Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        :param pulumi.Input[str] private_key: Certificate's private key.
        :param pulumi.Input[str] type: Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
        CustomSslCustomSslOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bundle_method=bundle_method,
            certificate=certificate,
            geo_restrictions=geo_restrictions,
            private_key=private_key,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bundle_method: Optional[pulumi.Input[str]] = None,
             certificate: Optional[pulumi.Input[str]] = None,
             geo_restrictions: Optional[pulumi.Input[str]] = None,
             private_key: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bundle_method is not None:
            _setter("bundle_method", bundle_method)
        if certificate is not None:
            _setter("certificate", certificate)
        if geo_restrictions is not None:
            _setter("geo_restrictions", geo_restrictions)
        if private_key is not None:
            _setter("private_key", private_key)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[pulumi.Input[str]]:
        """
        Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @bundle_method.setter
    def bundle_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bundle_method", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate certificate and the intermediate(s).
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="geoRestrictions")
    def geo_restrictions(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        """
        return pulumi.get(self, "geo_restrictions")

    @geo_restrictions.setter
    def geo_restrictions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "geo_restrictions", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate's private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CustomSslCustomSslPriorityArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        """
        CustomSslCustomSslPriorityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            priority=priority,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if priority is not None:
            _setter("priority", priority)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class DeviceDexTestDataArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 kind: pulumi.Input[str],
                 method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        :param pulumi.Input[str] kind: The type of Device Dex Test. Available values: `http`, `traceroute`.
        :param pulumi.Input[str] method: The http request method. Available values: `GET`.
        """
        DeviceDexTestDataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            kind=kind,
            method=method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: pulumi.Input[str],
             kind: pulumi.Input[str],
             method: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("host", host)
        _setter("kind", kind)
        if method is not None:
            _setter("method", method)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        The type of Device Dex Test. Available values: `http`, `traceroute`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The http request method. Available values: `GET`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)


@pulumi.input_type
class DeviceManagedNetworksConfigArgs:
    def __init__(__self__, *,
                 sha256: pulumi.Input[str],
                 tls_sockaddr: pulumi.Input[str]):
        """
        :param pulumi.Input[str] sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        :param pulumi.Input[str] tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        DeviceManagedNetworksConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sha256=sha256,
            tls_sockaddr=tls_sockaddr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sha256: pulumi.Input[str],
             tls_sockaddr: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sha256", sha256)
        _setter("tls_sockaddr", tls_sockaddr)

    @property
    @pulumi.getter
    def sha256(self) -> pulumi.Input[str]:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: pulumi.Input[str]):
        pulumi.set(self, "sha256", value)

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> pulumi.Input[str]:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")

    @tls_sockaddr.setter
    def tls_sockaddr(self, value: pulumi.Input[str]):
        pulumi.set(self, "tls_sockaddr", value)


@pulumi.input_type
class DevicePostureIntegrationConfigArgs:
    def __init__(__self__, *,
                 api_url: Optional[pulumi.Input[str]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 customer_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_url: The third-party API's URL.
        :param pulumi.Input[str] auth_url: The third-party authorization API URL.
        :param pulumi.Input[str] client_id: The client identifier for authenticating API calls.
        :param pulumi.Input[str] client_key: The client key for authenticating API calls.
        :param pulumi.Input[str] client_secret: The client secret for authenticating API calls.
        :param pulumi.Input[str] customer_id: The customer identifier for authenticating API calls.
        """
        DevicePostureIntegrationConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_url=api_url,
            auth_url=auth_url,
            client_id=client_id,
            client_key=client_key,
            client_secret=client_secret,
            customer_id=customer_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_url: Optional[pulumi.Input[str]] = None,
             auth_url: Optional[pulumi.Input[str]] = None,
             client_id: Optional[pulumi.Input[str]] = None,
             client_key: Optional[pulumi.Input[str]] = None,
             client_secret: Optional[pulumi.Input[str]] = None,
             customer_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if api_url is not None:
            _setter("api_url", api_url)
        if auth_url is not None:
            _setter("auth_url", auth_url)
        if client_id is not None:
            _setter("client_id", client_id)
        if client_key is not None:
            _setter("client_key", client_key)
        if client_secret is not None:
            _setter("client_secret", client_secret)
        if customer_id is not None:
            _setter("customer_id", customer_id)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The third-party API's URL.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        """
        The third-party authorization API URL.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client identifier for authenticating API calls.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The client key for authenticating API calls.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret for authenticating API calls.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The customer identifier for authenticating API calls.
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_id", value)


@pulumi.input_type
class DevicePostureRuleInputArgs:
    def __init__(__self__, *,
                 active_threats: Optional[pulumi.Input[int]] = None,
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 check_disks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cn: Optional[pulumi.Input[str]] = None,
                 compliance_status: Optional[pulumi.Input[str]] = None,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 count_operator: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 eid_last_seen: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exists: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infected: Optional[pulumi.Input[bool]] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 issue_count: Optional[pulumi.Input[str]] = None,
                 network_status: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 os: Optional[pulumi.Input[str]] = None,
                 os_distro_name: Optional[pulumi.Input[str]] = None,
                 os_distro_revision: Optional[pulumi.Input[str]] = None,
                 overall: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 require_all: Optional[pulumi.Input[bool]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None,
                 running: Optional[pulumi.Input[bool]] = None,
                 sensor_config: Optional[pulumi.Input[str]] = None,
                 sha256: Optional[pulumi.Input[str]] = None,
                 thumbprint: Optional[pulumi.Input[str]] = None,
                 total_score: Optional[pulumi.Input[int]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 version_operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] active_threats: The number of active threats from SentinelOne.
        :param pulumi.Input[str] certificate_id: The UUID of a Cloudflare managed certificate.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_disks: Specific volume(s) to check for encryption.
        :param pulumi.Input[str] cn: The common name for a certificate.
        :param pulumi.Input[str] compliance_status: The workspace one device compliance status. Available values: `compliant`, `noncompliant`.
        :param pulumi.Input[str] connection_id: The workspace one connection id.
        :param pulumi.Input[str] count_operator: The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param pulumi.Input[str] domain: The domain that the client must join.
        :param pulumi.Input[str] eid_last_seen: The datetime a device last seen in RFC 3339 format from Tanium.
        :param pulumi.Input[bool] enabled: True if the firewall must be enabled.
        :param pulumi.Input[bool] exists: Checks if the file should exist.
        :param pulumi.Input[str] id: The Teams List id.
        :param pulumi.Input[bool] infected: True if SentinelOne device is infected.
        :param pulumi.Input[bool] is_active: True if SentinelOne device is active.
        :param pulumi.Input[str] issue_count: The number of issues for kolide.
        :param pulumi.Input[str] network_status: The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        :param pulumi.Input[str] operator: The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param pulumi.Input[str] os: OS signal score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] os_distro_name: The operating system excluding version information.
        :param pulumi.Input[str] os_distro_revision: The operating system version excluding OS name information or release name.
        :param pulumi.Input[str] overall: Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] path: The path to the file.
        :param pulumi.Input[bool] require_all: True if all drives must be encrypted.
        :param pulumi.Input[str] risk_level: The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        :param pulumi.Input[bool] running: Checks if the application should be running.
        :param pulumi.Input[str] sensor_config: Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        :param pulumi.Input[str] sha256: The sha256 hash of the file.
        :param pulumi.Input[str] thumbprint: The thumbprint of the file certificate.
        :param pulumi.Input[int] total_score: The total score from Tanium.
        :param pulumi.Input[str] version: The operating system semantic version.
        :param pulumi.Input[str] version_operator: The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        DevicePostureRuleInputArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active_threats=active_threats,
            certificate_id=certificate_id,
            check_disks=check_disks,
            cn=cn,
            compliance_status=compliance_status,
            connection_id=connection_id,
            count_operator=count_operator,
            domain=domain,
            eid_last_seen=eid_last_seen,
            enabled=enabled,
            exists=exists,
            id=id,
            infected=infected,
            is_active=is_active,
            issue_count=issue_count,
            network_status=network_status,
            operator=operator,
            os=os,
            os_distro_name=os_distro_name,
            os_distro_revision=os_distro_revision,
            overall=overall,
            path=path,
            require_all=require_all,
            risk_level=risk_level,
            running=running,
            sensor_config=sensor_config,
            sha256=sha256,
            thumbprint=thumbprint,
            total_score=total_score,
            version=version,
            version_operator=version_operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active_threats: Optional[pulumi.Input[int]] = None,
             certificate_id: Optional[pulumi.Input[str]] = None,
             check_disks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cn: Optional[pulumi.Input[str]] = None,
             compliance_status: Optional[pulumi.Input[str]] = None,
             connection_id: Optional[pulumi.Input[str]] = None,
             count_operator: Optional[pulumi.Input[str]] = None,
             domain: Optional[pulumi.Input[str]] = None,
             eid_last_seen: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             exists: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             infected: Optional[pulumi.Input[bool]] = None,
             is_active: Optional[pulumi.Input[bool]] = None,
             issue_count: Optional[pulumi.Input[str]] = None,
             network_status: Optional[pulumi.Input[str]] = None,
             operator: Optional[pulumi.Input[str]] = None,
             os: Optional[pulumi.Input[str]] = None,
             os_distro_name: Optional[pulumi.Input[str]] = None,
             os_distro_revision: Optional[pulumi.Input[str]] = None,
             overall: Optional[pulumi.Input[str]] = None,
             path: Optional[pulumi.Input[str]] = None,
             require_all: Optional[pulumi.Input[bool]] = None,
             risk_level: Optional[pulumi.Input[str]] = None,
             running: Optional[pulumi.Input[bool]] = None,
             sensor_config: Optional[pulumi.Input[str]] = None,
             sha256: Optional[pulumi.Input[str]] = None,
             thumbprint: Optional[pulumi.Input[str]] = None,
             total_score: Optional[pulumi.Input[int]] = None,
             version: Optional[pulumi.Input[str]] = None,
             version_operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if active_threats is not None:
            _setter("active_threats", active_threats)
        if certificate_id is not None:
            _setter("certificate_id", certificate_id)
        if check_disks is not None:
            _setter("check_disks", check_disks)
        if cn is not None:
            _setter("cn", cn)
        if compliance_status is not None:
            _setter("compliance_status", compliance_status)
        if connection_id is not None:
            _setter("connection_id", connection_id)
        if count_operator is not None:
            _setter("count_operator", count_operator)
        if domain is not None:
            _setter("domain", domain)
        if eid_last_seen is not None:
            _setter("eid_last_seen", eid_last_seen)
        if enabled is not None:
            _setter("enabled", enabled)
        if exists is not None:
            _setter("exists", exists)
        if id is not None:
            _setter("id", id)
        if infected is not None:
            _setter("infected", infected)
        if is_active is not None:
            _setter("is_active", is_active)
        if issue_count is not None:
            _setter("issue_count", issue_count)
        if network_status is not None:
            _setter("network_status", network_status)
        if operator is not None:
            _setter("operator", operator)
        if os is not None:
            _setter("os", os)
        if os_distro_name is not None:
            _setter("os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            _setter("os_distro_revision", os_distro_revision)
        if overall is not None:
            _setter("overall", overall)
        if path is not None:
            _setter("path", path)
        if require_all is not None:
            _setter("require_all", require_all)
        if risk_level is not None:
            _setter("risk_level", risk_level)
        if running is not None:
            _setter("running", running)
        if sensor_config is not None:
            _setter("sensor_config", sensor_config)
        if sha256 is not None:
            _setter("sha256", sha256)
        if thumbprint is not None:
            _setter("thumbprint", thumbprint)
        if total_score is not None:
            _setter("total_score", total_score)
        if version is not None:
            _setter("version", version)
        if version_operator is not None:
            _setter("version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[pulumi.Input[int]]:
        """
        The number of active threats from SentinelOne.
        """
        return pulumi.get(self, "active_threats")

    @active_threats.setter
    def active_threats(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_threats", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of a Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific volume(s) to check for encryption.
        """
        return pulumi.get(self, "check_disks")

    @check_disks.setter
    def check_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_disks", value)

    @property
    @pulumi.getter
    def cn(self) -> Optional[pulumi.Input[str]]:
        """
        The common name for a certificate.
        """
        return pulumi.get(self, "cn")

    @cn.setter
    def cn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cn", value)

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[pulumi.Input[str]]:
        """
        The workspace one device compliance status. Available values: `compliant`, `noncompliant`.
        """
        return pulumi.get(self, "compliance_status")

    @compliance_status.setter
    def compliance_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compliance_status", value)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The workspace one connection id.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "count_operator")

    @count_operator.setter
    def count_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count_operator", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The domain that the client must join.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[pulumi.Input[str]]:
        """
        The datetime a device last seen in RFC 3339 format from Tanium.
        """
        return pulumi.get(self, "eid_last_seen")

    @eid_last_seen.setter
    def eid_last_seen(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eid_last_seen", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the firewall must be enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def exists(self) -> Optional[pulumi.Input[bool]]:
        """
        Checks if the file should exist.
        """
        return pulumi.get(self, "exists")

    @exists.setter
    def exists(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exists", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The Teams List id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infected(self) -> Optional[pulumi.Input[bool]]:
        """
        True if SentinelOne device is infected.
        """
        return pulumi.get(self, "infected")

    @infected.setter
    def infected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infected", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        True if SentinelOne device is active.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[pulumi.Input[str]]:
        """
        The number of issues for kolide.
        """
        return pulumi.get(self, "issue_count")

    @issue_count.setter
    def issue_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issue_count", value)

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[pulumi.Input[str]]:
        """
        The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        """
        return pulumi.get(self, "network_status")

    @network_status.setter
    def network_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_status", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[str]]:
        """
        OS signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system excluding version information.
        """
        return pulumi.get(self, "os_distro_name")

    @os_distro_name.setter
    def os_distro_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_distro_name", value)

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system version excluding OS name information or release name.
        """
        return pulumi.get(self, "os_distro_revision")

    @os_distro_revision.setter
    def os_distro_revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_distro_revision", value)

    @property
    @pulumi.getter
    def overall(self) -> Optional[pulumi.Input[str]]:
        """
        Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "overall")

    @overall.setter
    def overall(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overall", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[pulumi.Input[bool]]:
        """
        True if all drives must be encrypted.
        """
        return pulumi.get(self, "require_all")

    @require_all.setter
    def require_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)

    @property
    @pulumi.getter
    def running(self) -> Optional[pulumi.Input[bool]]:
        """
        Checks if the application should be running.
        """
        return pulumi.get(self, "running")

    @running.setter
    def running(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "running", value)

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[pulumi.Input[str]]:
        """
        Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "sensor_config")

    @sensor_config.setter
    def sensor_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensor_config", value)

    @property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[str]]:
        """
        The sha256 hash of the file.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256", value)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the file certificate.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[pulumi.Input[int]]:
        """
        The total score from Tanium.
        """
        return pulumi.get(self, "total_score")

    @total_score.setter
    def total_score(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The operating system semantic version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "version_operator")

    @version_operator.setter
    def version_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_operator", value)


@pulumi.input_type
class DevicePostureRuleMatchArgs:
    def __init__(__self__, *,
                 platform: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] platform: The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        DevicePostureRuleMatchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            platform=platform,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             platform: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if platform is not None:
            _setter("platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        """
        The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)


@pulumi.input_type
class DlpProfileEntryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 pattern: Optional[pulumi.Input['DlpProfileEntryPatternArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the entry to deploy.
        :param pulumi.Input[bool] enabled: Whether the entry is active. Defaults to `false`.
        :param pulumi.Input[str] id: Unique entry identifier.
        """
        DlpProfileEntryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            enabled=enabled,
            id=id,
            pattern=pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             enabled: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             pattern: Optional[pulumi.Input['DlpProfileEntryPatternArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if enabled is not None:
            _setter("enabled", enabled)
        if id is not None:
            _setter("id", id)
        if pattern is not None:
            _setter("pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the entry to deploy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the entry is active. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique entry identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input['DlpProfileEntryPatternArgs']]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input['DlpProfileEntryPatternArgs']]):
        pulumi.set(self, "pattern", value)


@pulumi.input_type
class DlpProfileEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[str],
                 validation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: The regex that defines the pattern.
        :param pulumi.Input[str] validation: The validation algorithm to apply with this pattern.
        """
        DlpProfileEntryPatternArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex=regex,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex: pulumi.Input[str],
             validation: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("regex", regex)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        """
        The regex that defines the pattern.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input[str]]:
        """
        The validation algorithm to apply with this pattern.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation", value)


@pulumi.input_type
class EmailRoutingCatchAllActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] type: Type of supported action. Available values: `drop`, `forward`, `worker`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list with items in the following form.
        """
        EmailRoutingCatchAllActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        _setter("values", values)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of supported action. Available values: `drop`, `forward`, `worker`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list with items in the following form.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EmailRoutingCatchAllMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Type of matcher. Available values: `all`.
        """
        EmailRoutingCatchAllMatcherArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of matcher. Available values: `all`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EmailRoutingRuleActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] type: Type of supported action.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: An array with items in the following form.
        """
        EmailRoutingRuleActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        _setter("values", values)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of supported action.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array with items in the following form.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EmailRoutingRuleMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 field: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of matcher.
        :param pulumi.Input[str] field: Field for type matcher.
        :param pulumi.Input[str] value: Value for matcher.
        """
        EmailRoutingRuleMatcherArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            field=field,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             field: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if field is not None:
            _setter("field", field)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of matcher.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        Field for type matcher.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value for matcher.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class FallbackDomainDomainArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP addresses to handle domain resolution.
        :param pulumi.Input[str] suffix: The domain suffix to match when resolving locally.
        """
        FallbackDomainDomainArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            dns_servers=dns_servers,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[pulumi.Input[str]] = None,
             dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             suffix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if description is not None:
            _setter("description", description)
        if dns_servers is not None:
            _setter("dns_servers", dns_servers)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


@pulumi.input_type
class HealthcheckHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] header: The header name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of string values for the header.
        """
        HealthcheckHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            header=header,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             header: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("header", header)
        _setter("values", values)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of string values for the header.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class ListItemArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['ListItemValueArgs'],
                 comment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comment: An optional comment for the item.
        """
        ListItemArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
            comment=comment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: pulumi.Input['ListItemValueArgs'],
             comment: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)
        if comment is not None:
            _setter("comment", comment)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['ListItemValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['ListItemValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        An optional comment for the item.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)


@pulumi.input_type
class ListItemHostnameArgs:
    def __init__(__self__, *,
                 url_hostname: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url_hostname: The FQDN to match on.
        """
        ListItemHostnameArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url_hostname=url_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url_hostname: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> pulumi.Input[str]:
        """
        The FQDN to match on.
        """
        return pulumi.get(self, "url_hostname")

    @url_hostname.setter
    def url_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "url_hostname", value)


@pulumi.input_type
class ListItemRedirectArgs:
    def __init__(__self__, *,
                 source_url: pulumi.Input[str],
                 target_url: pulumi.Input[str],
                 include_subdomains: Optional[pulumi.Input[str]] = None,
                 preserve_path_suffix: Optional[pulumi.Input[str]] = None,
                 preserve_query_string: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 subpath_matching: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_url: The source url of the redirect.
        :param pulumi.Input[str] target_url: The target url of the redirect.
        :param pulumi.Input[str] include_subdomains: Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        :param pulumi.Input[str] preserve_path_suffix: Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        :param pulumi.Input[str] preserve_query_string: Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        :param pulumi.Input[int] status_code: The status code to be used when redirecting a request.
        :param pulumi.Input[str] subpath_matching: Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        ListItemRedirectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_url=source_url,
            target_url=target_url,
            include_subdomains=include_subdomains,
            preserve_path_suffix=preserve_path_suffix,
            preserve_query_string=preserve_query_string,
            status_code=status_code,
            subpath_matching=subpath_matching,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_url: pulumi.Input[str],
             target_url: pulumi.Input[str],
             include_subdomains: Optional[pulumi.Input[str]] = None,
             preserve_path_suffix: Optional[pulumi.Input[str]] = None,
             preserve_query_string: Optional[pulumi.Input[str]] = None,
             status_code: Optional[pulumi.Input[int]] = None,
             subpath_matching: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_url", source_url)
        _setter("target_url", target_url)
        if include_subdomains is not None:
            _setter("include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            _setter("preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            _setter("preserve_query_string", preserve_query_string)
        if status_code is not None:
            _setter("status_code", status_code)
        if subpath_matching is not None:
            _setter("subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        """
        The source url of the redirect.
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_url", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target url of the redirect.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_path_suffix")

    @preserve_path_suffix.setter
    def preserve_path_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preserve_path_suffix", value)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preserve_query_string", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The status code to be used when redirecting a request.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "subpath_matching")

    @subpath_matching.setter
    def subpath_matching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subpath_matching", value)


@pulumi.input_type
class ListItemValueArgs:
    def __init__(__self__, *,
                 asn: Optional[pulumi.Input[int]] = None,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueHostnameArgs']]]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 redirects: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueRedirectArgs']]]] = None):
        ListItemValueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            asn=asn,
            hostnames=hostnames,
            ip=ip,
            redirects=redirects,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             asn: Optional[pulumi.Input[int]] = None,
             hostnames: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueHostnameArgs']]]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             redirects: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueRedirectArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if asn is not None:
            _setter("asn", asn)
        if hostnames is not None:
            _setter("hostnames", hostnames)
        if ip is not None:
            _setter("ip", ip)
        if redirects is not None:
            _setter("redirects", redirects)

    @property
    @pulumi.getter
    def asn(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "asn", value)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueHostnameArgs']]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueHostnameArgs']]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueRedirectArgs']]]]:
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListItemValueRedirectArgs']]]]):
        pulumi.set(self, "redirects", value)


@pulumi.input_type
class ListItemValueHostnameArgs:
    def __init__(__self__, *,
                 url_hostname: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url_hostname: The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
        """
        ListItemValueHostnameArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url_hostname=url_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url_hostname: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> pulumi.Input[str]:
        """
        The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
        """
        return pulumi.get(self, "url_hostname")

    @url_hostname.setter
    def url_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "url_hostname", value)


@pulumi.input_type
class ListItemValueRedirectArgs:
    def __init__(__self__, *,
                 source_url: pulumi.Input[str],
                 target_url: pulumi.Input[str],
                 include_subdomains: Optional[pulumi.Input[str]] = None,
                 preserve_path_suffix: Optional[pulumi.Input[str]] = None,
                 preserve_query_string: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 subpath_matching: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_url: The source url of the redirect.
        :param pulumi.Input[str] target_url: The target url of the redirect.
        :param pulumi.Input[str] include_subdomains: Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        :param pulumi.Input[str] preserve_path_suffix: Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        :param pulumi.Input[str] preserve_query_string: Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        :param pulumi.Input[int] status_code: The status code to be used when redirecting a request.
        :param pulumi.Input[str] subpath_matching: Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        ListItemValueRedirectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_url=source_url,
            target_url=target_url,
            include_subdomains=include_subdomains,
            preserve_path_suffix=preserve_path_suffix,
            preserve_query_string=preserve_query_string,
            status_code=status_code,
            subpath_matching=subpath_matching,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_url: pulumi.Input[str],
             target_url: pulumi.Input[str],
             include_subdomains: Optional[pulumi.Input[str]] = None,
             preserve_path_suffix: Optional[pulumi.Input[str]] = None,
             preserve_query_string: Optional[pulumi.Input[str]] = None,
             status_code: Optional[pulumi.Input[int]] = None,
             subpath_matching: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_url", source_url)
        _setter("target_url", target_url)
        if include_subdomains is not None:
            _setter("include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            _setter("preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            _setter("preserve_query_string", preserve_query_string)
        if status_code is not None:
            _setter("status_code", status_code)
        if subpath_matching is not None:
            _setter("subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        """
        The source url of the redirect.
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_url", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target url of the redirect.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_path_suffix")

    @preserve_path_suffix.setter
    def preserve_path_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preserve_path_suffix", value)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preserve_query_string", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The status code to be used when redirecting a request.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "subpath_matching")

    @subpath_matching.setter
    def subpath_matching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subpath_matching", value)


@pulumi.input_type
class LoadBalancerAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
        LoadBalancerAdaptiveRoutingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failover_across_pools=failover_across_pools,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failover_across_pools: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if failover_across_pools is not None:
            _setter("failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[bool]]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failover_across_pools", value)


@pulumi.input_type
class LoadBalancerCountryPoolArgs:
    def __init__(__self__, *,
                 country: pulumi.Input[str],
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] country: A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use in the given country.
        """
        LoadBalancerCountryPoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country=country,
            pool_ids=pool_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country: pulumi.Input[str],
             pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("country", country)
        _setter("pool_ids", pool_ids)

    @property
    @pulumi.getter
    def country(self) -> pulumi.Input[str]:
        """
        A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[str]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use in the given country.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)


@pulumi.input_type
class LoadBalancerLocationStrategyArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 prefer_ecs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        :param pulumi.Input[str] prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
        LoadBalancerLocationStrategyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            prefer_ecs=prefer_ecs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[pulumi.Input[str]] = None,
             prefer_ecs: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mode is not None:
            _setter("mode", mode)
        if prefer_ecs is not None:
            _setter("prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
        return pulumi.get(self, "prefer_ecs")

    @prefer_ecs.setter
    def prefer_ecs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_ecs", value)


@pulumi.input_type
class LoadBalancerMonitorHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] header: The header name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values for the header.
        """
        LoadBalancerMonitorHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            header=header,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             header: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("header", header)
        _setter("values", values)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values for the header.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class LoadBalancerPoolLoadSheddingArgs:
    def __init__(__self__, *,
                 default_percent: Optional[pulumi.Input[float]] = None,
                 default_policy: Optional[pulumi.Input[str]] = None,
                 session_percent: Optional[pulumi.Input[float]] = None,
                 session_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] default_percent: Percent of traffic to shed 0 - 100. Defaults to `0`.
        :param pulumi.Input[str] default_policy: Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        :param pulumi.Input[float] session_percent: Percent of session traffic to shed 0 - 100. Defaults to `0`.
        :param pulumi.Input[str] session_policy: Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
        LoadBalancerPoolLoadSheddingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_percent=default_percent,
            default_policy=default_policy,
            session_percent=session_percent,
            session_policy=session_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_percent: Optional[pulumi.Input[float]] = None,
             default_policy: Optional[pulumi.Input[str]] = None,
             session_percent: Optional[pulumi.Input[float]] = None,
             session_policy: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_percent is not None:
            _setter("default_percent", default_percent)
        if default_policy is not None:
            _setter("default_policy", default_policy)
        if session_percent is not None:
            _setter("session_percent", session_percent)
        if session_policy is not None:
            _setter("session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[pulumi.Input[float]]:
        """
        Percent of traffic to shed 0 - 100. Defaults to `0`.
        """
        return pulumi.get(self, "default_percent")

    @default_percent.setter
    def default_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_percent", value)

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        """
        return pulumi.get(self, "default_policy")

    @default_policy.setter
    def default_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_policy", value)

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[pulumi.Input[float]]:
        """
        Percent of session traffic to shed 0 - 100. Defaults to `0`.
        """
        return pulumi.get(self, "session_percent")

    @session_percent.setter
    def session_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "session_percent", value)

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
        return pulumi.get(self, "session_policy")

    @session_policy.setter
    def session_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_policy", value)


@pulumi.input_type
class LoadBalancerPoolOriginArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]]] = None,
                 weight: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] address: The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        :param pulumi.Input[str] name: A human-identifiable name for the origin.
        :param pulumi.Input[bool] enabled: Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]] headers: HTTP request headers.
        :param pulumi.Input[float] weight: The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. Defaults to `1`.
        """
        LoadBalancerPoolOriginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            name=name,
            enabled=enabled,
            headers=headers,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: pulumi.Input[str],
             name: pulumi.Input[str],
             enabled: Optional[pulumi.Input[bool]] = None,
             headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]]] = None,
             weight: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("address", address)
        _setter("name", name)
        if enabled is not None:
            _setter("enabled", enabled)
        if headers is not None:
            _setter("headers", headers)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]]]:
        """
        HTTP request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[float]]:
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. Defaults to `1`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class LoadBalancerPoolOriginHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] header: HTTP request headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Values for the HTTP headers.
        """
        LoadBalancerPoolOriginHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            header=header,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             header: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("header", header)
        _setter("values", values)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        HTTP request headers.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values for the HTTP headers.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class LoadBalancerPoolOriginSteeringArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy: Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Available values: `""`, `hash`, `random`, `least_outstanding_requests`. Defaults to `random`.
        """
        LoadBalancerPoolOriginSteeringArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if policy is not None:
            _setter("policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Available values: `""`, `hash`, `random`, `least_outstanding_requests`. Defaults to `random`.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)


@pulumi.input_type
class LoadBalancerPopPoolArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pop: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param pulumi.Input[str] pop: A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        LoadBalancerPopPoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pool_ids=pool_ids,
            pop=pop,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
             pop: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("pool_ids", pool_ids)
        _setter("pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def pop(self) -> pulumi.Input[str]:
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        return pulumi.get(self, "pop")

    @pop.setter
    def pop(self, value: pulumi.Input[str]):
        pulumi.set(self, "pop", value)


@pulumi.input_type
class LoadBalancerRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[float]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[float] default_weight: The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        LoadBalancerRandomSteeringArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_weight=default_weight,
            pool_weights=pool_weights,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_weight: Optional[pulumi.Input[float]] = None,
             pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_weight is not None:
            _setter("default_weight", default_weight)
        if pool_weights is not None:
            _setter("pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[float]]:
        """
        The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_weight", value)

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "pool_weights", value)


@pulumi.input_type
class LoadBalancerRegionPoolArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use in the given region.
        :param pulumi.Input[str] region: A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        LoadBalancerRegionPoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pool_ids=pool_ids,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
             region: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("pool_ids", pool_ids)
        _setter("region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use in the given region.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class LoadBalancerRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 fixed_response: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 terminates: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: Human readable name for this rule.
        :param pulumi.Input[str] condition: The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        :param pulumi.Input[bool] disabled: A disabled rule will not be executed.
        :param pulumi.Input['LoadBalancerRuleFixedResponseArgs'] fixed_response: Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]] overrides: The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.
        :param pulumi.Input[int] priority: Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
        :param pulumi.Input[bool] terminates: Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.
        """
        LoadBalancerRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            condition=condition,
            disabled=disabled,
            fixed_response=fixed_response,
            overrides=overrides,
            priority=priority,
            terminates=terminates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             condition: Optional[pulumi.Input[str]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             fixed_response: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']] = None,
             overrides: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             terminates: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if condition is not None:
            _setter("condition", condition)
        if disabled is not None:
            _setter("disabled", disabled)
        if fixed_response is not None:
            _setter("fixed_response", fixed_response)
        if overrides is not None:
            _setter("overrides", overrides)
        if priority is not None:
            _setter("priority", priority)
        if terminates is not None:
            _setter("terminates", terminates)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Human readable name for this rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A disabled rule will not be executed.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]:
        """
        Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.
        """
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]]]:
        """
        The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideArgs']]]]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def terminates(self) -> Optional[pulumi.Input[bool]]:
        """
        Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.
        """
        return pulumi.get(self, "terminates")

    @terminates.setter
    def terminates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "terminates", value)


@pulumi.input_type
class LoadBalancerRuleFixedResponseArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 message_body: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] content_type: The value of the HTTP context-type header for this fixed response.
        :param pulumi.Input[str] location: The value of the HTTP location header for this fixed response.
        :param pulumi.Input[str] message_body: The text used as the html body for this fixed response.
        :param pulumi.Input[int] status_code: The HTTP status code used for this fixed response.
        """
        LoadBalancerRuleFixedResponseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_type=content_type,
            location=location,
            message_body=message_body,
            status_code=status_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_type: Optional[pulumi.Input[str]] = None,
             location: Optional[pulumi.Input[str]] = None,
             message_body: Optional[pulumi.Input[str]] = None,
             status_code: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if content_type is not None:
            _setter("content_type", content_type)
        if location is not None:
            _setter("location", location)
        if message_body is not None:
            _setter("message_body", message_body)
        if status_code is not None:
            _setter("status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the HTTP context-type header for this fixed response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the HTTP location header for this fixed response.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[pulumi.Input[str]]:
        """
        The text used as the html body for this fixed response.
        """
        return pulumi.get(self, "message_body")

    @message_body.setter
    def message_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_body", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTP status code used for this fixed response.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


@pulumi.input_type
class LoadBalancerRuleOverrideArgs:
    def __init__(__self__, *,
                 adaptive_routings: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]]] = None,
                 country_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]]] = None,
                 default_pools: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fallback_pool: Optional[pulumi.Input[str]] = None,
                 location_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]]] = None,
                 pop_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]]] = None,
                 random_steerings: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]]] = None,
                 region_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]]] = None,
                 session_affinity: Optional[pulumi.Input[str]] = None,
                 session_affinity_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]]] = None,
                 session_affinity_ttl: Optional[pulumi.Input[int]] = None,
                 steering_policy: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]] adaptive_routings: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]] country_pools: A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_pools: A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        :param pulumi.Input[str] fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]] location_strategies: Controls location-based steering for non-proxied requests.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]] pop_pools: A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]] random_steerings: Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]] region_pools: A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        :param pulumi.Input[str] session_affinity: Configure attributes for session affinity.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]] session_affinity_attributes: Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        :param pulumi.Input[int] session_affinity_ttl: Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        :param pulumi.Input[str] steering_policy: The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `""` Defaults to `""`.
        :param pulumi.Input[int] ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        """
        LoadBalancerRuleOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            adaptive_routings=adaptive_routings,
            country_pools=country_pools,
            default_pools=default_pools,
            fallback_pool=fallback_pool,
            location_strategies=location_strategies,
            pop_pools=pop_pools,
            random_steerings=random_steerings,
            region_pools=region_pools,
            session_affinity=session_affinity,
            session_affinity_attributes=session_affinity_attributes,
            session_affinity_ttl=session_affinity_ttl,
            steering_policy=steering_policy,
            ttl=ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             adaptive_routings: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]]] = None,
             country_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]]] = None,
             default_pools: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             fallback_pool: Optional[pulumi.Input[str]] = None,
             location_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]]] = None,
             pop_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]]] = None,
             random_steerings: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]]] = None,
             region_pools: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]]] = None,
             session_affinity: Optional[pulumi.Input[str]] = None,
             session_affinity_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]]] = None,
             session_affinity_ttl: Optional[pulumi.Input[int]] = None,
             steering_policy: Optional[pulumi.Input[str]] = None,
             ttl: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if adaptive_routings is not None:
            _setter("adaptive_routings", adaptive_routings)
        if country_pools is not None:
            _setter("country_pools", country_pools)
        if default_pools is not None:
            _setter("default_pools", default_pools)
        if fallback_pool is not None:
            _setter("fallback_pool", fallback_pool)
        if location_strategies is not None:
            _setter("location_strategies", location_strategies)
        if pop_pools is not None:
            _setter("pop_pools", pop_pools)
        if random_steerings is not None:
            _setter("random_steerings", random_steerings)
        if region_pools is not None:
            _setter("region_pools", region_pools)
        if session_affinity is not None:
            _setter("session_affinity", session_affinity)
        if session_affinity_attributes is not None:
            _setter("session_affinity_attributes", session_affinity_attributes)
        if session_affinity_ttl is not None:
            _setter("session_affinity_ttl", session_affinity_ttl)
        if steering_policy is not None:
            _setter("steering_policy", steering_policy)
        if ttl is not None:
            _setter("ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRoutings")
    def adaptive_routings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]]]:
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        """
        return pulumi.get(self, "adaptive_routings")

    @adaptive_routings.setter
    def adaptive_routings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideAdaptiveRoutingArgs']]]]):
        pulumi.set(self, "adaptive_routings", value)

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]]]:
        """
        A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        """
        return pulumi.get(self, "country_pools")

    @country_pools.setter
    def country_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideCountryPoolArgs']]]]):
        pulumi.set(self, "country_pools", value)

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        """
        return pulumi.get(self, "default_pools")

    @default_pools.setter
    def default_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_pools", value)

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> Optional[pulumi.Input[str]]:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @fallback_pool.setter
    def fallback_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_pool", value)

    @property
    @pulumi.getter(name="locationStrategies")
    def location_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]]]:
        """
        Controls location-based steering for non-proxied requests.
        """
        return pulumi.get(self, "location_strategies")

    @location_strategies.setter
    def location_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideLocationStrategyArgs']]]]):
        pulumi.set(self, "location_strategies", value)

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]]]:
        """
        A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        """
        return pulumi.get(self, "pop_pools")

    @pop_pools.setter
    def pop_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverridePopPoolArgs']]]]):
        pulumi.set(self, "pop_pools", value)

    @property
    @pulumi.getter(name="randomSteerings")
    def random_steerings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]]]:
        """
        Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests.
        """
        return pulumi.get(self, "random_steerings")

    @random_steerings.setter
    def random_steerings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRandomSteeringArgs']]]]):
        pulumi.set(self, "random_steerings", value)

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]]]:
        """
        A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        """
        return pulumi.get(self, "region_pools")

    @region_pools.setter
    def region_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideRegionPoolArgs']]]]):
        pulumi.set(self, "region_pools", value)

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        Configure attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_affinity", value)

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]]]:
        """
        Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @session_affinity_attributes.setter
    def session_affinity_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleOverrideSessionAffinityAttributeArgs']]]]):
        pulumi.set(self, "session_affinity_attributes", value)

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        """
        return pulumi.get(self, "session_affinity_ttl")

    @session_affinity_ttl.setter
    def session_affinity_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_affinity_ttl", value)

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `""` Defaults to `""`.
        """
        return pulumi.get(self, "steering_policy")

    @steering_policy.setter
    def steering_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "steering_policy", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


@pulumi.input_type
class LoadBalancerRuleOverrideAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
        LoadBalancerRuleOverrideAdaptiveRoutingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failover_across_pools=failover_across_pools,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failover_across_pools: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if failover_across_pools is not None:
            _setter("failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[bool]]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failover_across_pools", value)


@pulumi.input_type
class LoadBalancerRuleOverrideCountryPoolArgs:
    def __init__(__self__, *,
                 country: pulumi.Input[str],
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] country: A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use in the given country.
        """
        LoadBalancerRuleOverrideCountryPoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country=country,
            pool_ids=pool_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country: pulumi.Input[str],
             pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("country", country)
        _setter("pool_ids", pool_ids)

    @property
    @pulumi.getter
    def country(self) -> pulumi.Input[str]:
        """
        A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[str]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use in the given country.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)


@pulumi.input_type
class LoadBalancerRuleOverrideLocationStrategyArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 prefer_ecs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        :param pulumi.Input[str] prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
        LoadBalancerRuleOverrideLocationStrategyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            prefer_ecs=prefer_ecs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[pulumi.Input[str]] = None,
             prefer_ecs: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mode is not None:
            _setter("mode", mode)
        if prefer_ecs is not None:
            _setter("prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
        return pulumi.get(self, "prefer_ecs")

    @prefer_ecs.setter
    def prefer_ecs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_ecs", value)


@pulumi.input_type
class LoadBalancerRuleOverridePopPoolArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pop: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param pulumi.Input[str] pop: A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        LoadBalancerRuleOverridePopPoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pool_ids=pool_ids,
            pop=pop,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
             pop: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("pool_ids", pool_ids)
        _setter("pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def pop(self) -> pulumi.Input[str]:
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        return pulumi.get(self, "pop")

    @pop.setter
    def pop(self, value: pulumi.Input[str]):
        pulumi.set(self, "pop", value)


@pulumi.input_type
class LoadBalancerRuleOverrideRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[float]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[float] default_weight: The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        LoadBalancerRuleOverrideRandomSteeringArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_weight=default_weight,
            pool_weights=pool_weights,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_weight: Optional[pulumi.Input[float]] = None,
             pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_weight is not None:
            _setter("default_weight", default_weight)
        if pool_weights is not None:
            _setter("pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[float]]:
        """
        The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_weight", value)

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "pool_weights", value)


@pulumi.input_type
class LoadBalancerRuleOverrideRegionPoolArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: A list of pool IDs in failover priority to use in the given region.
        :param pulumi.Input[str] region: A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        LoadBalancerRuleOverrideRegionPoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pool_ids=pool_ids,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pool_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
             region: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("pool_ids", pool_ids)
        _setter("region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pool IDs in failover priority to use in the given region.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class LoadBalancerRuleOverrideSessionAffinityAttributeArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 require_all_headers: Optional[pulumi.Input[bool]] = None,
                 samesite: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[str]] = None,
                 zero_downtime_failover: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: Configures the HTTP header names to use when header session affinity is enabled.
        :param pulumi.Input[bool] require_all_headers: Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        :param pulumi.Input[str] samesite: Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        :param pulumi.Input[str] secure: Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        :param pulumi.Input[str] zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
        LoadBalancerRuleOverrideSessionAffinityAttributeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            require_all_headers=require_all_headers,
            samesite=samesite,
            secure=secure,
            zero_downtime_failover=zero_downtime_failover,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             require_all_headers: Optional[pulumi.Input[bool]] = None,
             samesite: Optional[pulumi.Input[str]] = None,
             secure: Optional[pulumi.Input[str]] = None,
             zero_downtime_failover: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if headers is not None:
            _setter("headers", headers)
        if require_all_headers is not None:
            _setter("require_all_headers", require_all_headers)
        if samesite is not None:
            _setter("samesite", samesite)
        if secure is not None:
            _setter("secure", secure)
        if zero_downtime_failover is not None:
            _setter("zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Configures the HTTP header names to use when header session affinity is enabled.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        """
        return pulumi.get(self, "require_all_headers")

    @require_all_headers.setter
    def require_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all_headers", value)

    @property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samesite", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
        return pulumi.get(self, "zero_downtime_failover")

    @zero_downtime_failover.setter
    def zero_downtime_failover(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_downtime_failover", value)


@pulumi.input_type
class LoadBalancerSessionAffinityAttributeArgs:
    def __init__(__self__, *,
                 drain_duration: Optional[pulumi.Input[int]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 require_all_headers: Optional[pulumi.Input[bool]] = None,
                 samesite: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[str]] = None,
                 zero_downtime_failover: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: Configures the HTTP header names to use when header session affinity is enabled.
        :param pulumi.Input[bool] require_all_headers: Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        :param pulumi.Input[str] samesite: Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        :param pulumi.Input[str] secure: Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        :param pulumi.Input[str] zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
        LoadBalancerSessionAffinityAttributeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            drain_duration=drain_duration,
            headers=headers,
            require_all_headers=require_all_headers,
            samesite=samesite,
            secure=secure,
            zero_downtime_failover=zero_downtime_failover,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             drain_duration: Optional[pulumi.Input[int]] = None,
             headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             require_all_headers: Optional[pulumi.Input[bool]] = None,
             samesite: Optional[pulumi.Input[str]] = None,
             secure: Optional[pulumi.Input[str]] = None,
             zero_downtime_failover: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if drain_duration is not None:
            _setter("drain_duration", drain_duration)
        if headers is not None:
            _setter("headers", headers)
        if require_all_headers is not None:
            _setter("require_all_headers", require_all_headers)
        if samesite is not None:
            _setter("samesite", samesite)
        if secure is not None:
            _setter("secure", secure)
        if zero_downtime_failover is not None:
            _setter("zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[pulumi.Input[int]]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
        """
        return pulumi.get(self, "drain_duration")

    @drain_duration.setter
    def drain_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "drain_duration", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Configures the HTTP header names to use when header session affinity is enabled.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        """
        return pulumi.get(self, "require_all_headers")

    @require_all_headers.setter
    def require_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all_headers", value)

    @property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samesite", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
        return pulumi.get(self, "zero_downtime_failover")

    @zero_downtime_failover.setter
    def zero_downtime_failover(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_downtime_failover", value)


@pulumi.input_type
class ManagedHeadersManagedRequestHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Whether the headers rule is active.
        :param pulumi.Input[str] id: Unique headers rule identifier.
        """
        ManagedHeadersManagedRequestHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        _setter("id", id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique headers rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ManagedHeadersManagedResponseHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Whether the headers rule is active.
        :param pulumi.Input[str] id: Unique headers rule identifier.
        """
        ManagedHeadersManagedResponseHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        _setter("id", id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique headers rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class NotificationPolicyEmailIntegrationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        """
        NotificationPolicyEmailIntegrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class NotificationPolicyFiltersArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 alert_trigger_preferences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 event_sources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 event_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 health_check_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limits: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 megabits_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_healths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 packets_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 requests_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 slos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_zone_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wheres: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Targeted actions for alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alert_trigger_preferences: Alert trigger preferences. Example: `slo`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] enableds: State of the pool to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] environments: Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] event_sources: Source configuration to alert on for pool or origin.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] event_types: Stream event type to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Alert grouping.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] health_check_ids: Identifier health check. Required when using `filters.0.status`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_ids: Stream input id to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limits: A numerical limit. Example: `100`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] megabits_per_seconds: Megabits per second threshold for dos alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_healths: Health status to alert on for pool or origin.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] packets_per_seconds: Packets per second threshold for dos alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: Load balancer pool identifier.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] products: Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] project_ids: Identifier of pages project.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: Protocol to alert on for dos.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] requests_per_seconds: Requests per second threshold for dos alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] slos: A numerical limit. Example: `99.9`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] statuses: Status to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_hostnames: Target host to alert on for dos.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_zone_names: Target domain to alert on.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wheres: Filter for alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: A list of zone identifiers.
        """
        NotificationPolicyFiltersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            alert_trigger_preferences=alert_trigger_preferences,
            enableds=enableds,
            environments=environments,
            event_sources=event_sources,
            event_types=event_types,
            events=events,
            group_bies=group_bies,
            health_check_ids=health_check_ids,
            input_ids=input_ids,
            limits=limits,
            megabits_per_seconds=megabits_per_seconds,
            new_healths=new_healths,
            packets_per_seconds=packets_per_seconds,
            pool_ids=pool_ids,
            products=products,
            project_ids=project_ids,
            protocols=protocols,
            requests_per_seconds=requests_per_seconds,
            services=services,
            slos=slos,
            statuses=statuses,
            target_hostnames=target_hostnames,
            target_zone_names=target_zone_names,
            wheres=wheres,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             alert_trigger_preferences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             enableds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             environments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             event_sources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             event_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             health_check_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             input_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             limits: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             megabits_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             new_healths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             packets_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             products: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             requests_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             slos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             target_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             target_zone_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             wheres: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if actions is not None:
            _setter("actions", actions)
        if alert_trigger_preferences is not None:
            _setter("alert_trigger_preferences", alert_trigger_preferences)
        if enableds is not None:
            _setter("enableds", enableds)
        if environments is not None:
            _setter("environments", environments)
        if event_sources is not None:
            _setter("event_sources", event_sources)
        if event_types is not None:
            _setter("event_types", event_types)
        if events is not None:
            _setter("events", events)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if health_check_ids is not None:
            _setter("health_check_ids", health_check_ids)
        if input_ids is not None:
            _setter("input_ids", input_ids)
        if limits is not None:
            _setter("limits", limits)
        if megabits_per_seconds is not None:
            _setter("megabits_per_seconds", megabits_per_seconds)
        if new_healths is not None:
            _setter("new_healths", new_healths)
        if packets_per_seconds is not None:
            _setter("packets_per_seconds", packets_per_seconds)
        if pool_ids is not None:
            _setter("pool_ids", pool_ids)
        if products is not None:
            _setter("products", products)
        if project_ids is not None:
            _setter("project_ids", project_ids)
        if protocols is not None:
            _setter("protocols", protocols)
        if requests_per_seconds is not None:
            _setter("requests_per_seconds", requests_per_seconds)
        if services is not None:
            _setter("services", services)
        if slos is not None:
            _setter("slos", slos)
        if statuses is not None:
            _setter("statuses", statuses)
        if target_hostnames is not None:
            _setter("target_hostnames", target_hostnames)
        if target_zone_names is not None:
            _setter("target_zone_names", target_zone_names)
        if wheres is not None:
            _setter("wheres", wheres)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Targeted actions for alert.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Alert trigger preferences. Example: `slo`.
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @alert_trigger_preferences.setter
    def alert_trigger_preferences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alert_trigger_preferences", value)

    @property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        State of the pool to alert on.
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "enableds", value)

    @property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Source configuration to alert on for pool or origin.
        """
        return pulumi.get(self, "event_sources")

    @event_sources.setter
    def event_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "event_sources", value)

    @property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Stream event type to alert on.
        """
        return pulumi.get(self, "event_types")

    @event_types.setter
    def event_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "event_types", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Alert grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Identifier health check. Required when using `filters.0.status`.
        """
        return pulumi.get(self, "health_check_ids")

    @health_check_ids.setter
    def health_check_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "health_check_ids", value)

    @property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Stream input id to alert on.
        """
        return pulumi.get(self, "input_ids")

    @input_ids.setter
    def input_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_ids", value)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A numerical limit. Example: `100`.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Megabits per second threshold for dos alert.
        """
        return pulumi.get(self, "megabits_per_seconds")

    @megabits_per_seconds.setter
    def megabits_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "megabits_per_seconds", value)

    @property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Health status to alert on for pool or origin.
        """
        return pulumi.get(self, "new_healths")

    @new_healths.setter
    def new_healths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_healths", value)

    @property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Packets per second threshold for dos alert.
        """
        return pulumi.get(self, "packets_per_seconds")

    @packets_per_seconds.setter
    def packets_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "packets_per_seconds", value)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Load balancer pool identifier.
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Identifier of pages project.
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "project_ids", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Protocol to alert on for dos.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Requests per second threshold for dos alert.
        """
        return pulumi.get(self, "requests_per_seconds")

    @requests_per_seconds.setter
    def requests_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "requests_per_seconds", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def slos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A numerical limit. Example: `99.9`.
        """
        return pulumi.get(self, "slos")

    @slos.setter
    def slos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "slos", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Status to alert on.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statuses", value)

    @property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Target host to alert on for dos.
        """
        return pulumi.get(self, "target_hostnames")

    @target_hostnames.setter
    def target_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_hostnames", value)

    @property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Target domain to alert on.
        """
        return pulumi.get(self, "target_zone_names")

    @target_zone_names.setter
    def target_zone_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_zone_names", value)

    @property
    @pulumi.getter
    def wheres(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Filter for alert.
        """
        return pulumi.get(self, "wheres")

    @wheres.setter
    def wheres(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wheres", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of zone identifiers.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


@pulumi.input_type
class NotificationPolicyPagerdutyIntegrationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        """
        NotificationPolicyPagerdutyIntegrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class NotificationPolicyWebhooksIntegrationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        """
        NotificationPolicyWebhooksIntegrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class PageRuleActionsArgs:
    def __init__(__self__, *,
                 always_use_https: Optional[pulumi.Input[bool]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
                 browser_cache_ttl: Optional[pulumi.Input[str]] = None,
                 browser_check: Optional[pulumi.Input[str]] = None,
                 bypass_cache_on_cookie: Optional[pulumi.Input[str]] = None,
                 cache_by_device_type: Optional[pulumi.Input[str]] = None,
                 cache_deception_armor: Optional[pulumi.Input[str]] = None,
                 cache_key_fields: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']] = None,
                 cache_level: Optional[pulumi.Input[str]] = None,
                 cache_on_cookie: Optional[pulumi.Input[str]] = None,
                 cache_ttl_by_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]]] = None,
                 disable_apps: Optional[pulumi.Input[bool]] = None,
                 disable_performance: Optional[pulumi.Input[bool]] = None,
                 disable_railgun: Optional[pulumi.Input[bool]] = None,
                 disable_security: Optional[pulumi.Input[bool]] = None,
                 disable_zaraz: Optional[pulumi.Input[bool]] = None,
                 edge_cache_ttl: Optional[pulumi.Input[int]] = None,
                 email_obfuscation: Optional[pulumi.Input[str]] = None,
                 explicit_cache_control: Optional[pulumi.Input[str]] = None,
                 forwarding_url: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']] = None,
                 host_header_override: Optional[pulumi.Input[str]] = None,
                 ip_geolocation: Optional[pulumi.Input[str]] = None,
                 minifies: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]]] = None,
                 mirage: Optional[pulumi.Input[str]] = None,
                 opportunistic_encryption: Optional[pulumi.Input[str]] = None,
                 origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 resolve_override: Optional[pulumi.Input[str]] = None,
                 respect_strong_etag: Optional[pulumi.Input[str]] = None,
                 response_buffering: Optional[pulumi.Input[str]] = None,
                 rocket_loader: Optional[pulumi.Input[str]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 server_side_exclude: Optional[pulumi.Input[str]] = None,
                 sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 true_client_ip_header: Optional[pulumi.Input[str]] = None,
                 waf: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] always_use_https: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[str] automatic_https_rewrites: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] browser_cache_ttl: The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        :param pulumi.Input[str] browser_check: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] bypass_cache_on_cookie: String value of cookie name to conditionally bypass cache the page.
        :param pulumi.Input[str] cache_by_device_type: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] cache_deception_armor: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsArgs'] cache_key_fields: Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        :param pulumi.Input[str] cache_level: Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        :param pulumi.Input[str] cache_on_cookie: String value of cookie name to conditionally cache the page.
        :param pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]] cache_ttl_by_statuses: Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        :param pulumi.Input[bool] disable_apps: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_performance: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_railgun: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_security: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_zaraz: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[int] edge_cache_ttl: The Time To Live for the edge cache.
        :param pulumi.Input[str] email_obfuscation: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] explicit_cache_control: Whether origin Cache-Control action is `"on"` or `"off"`.
        :param pulumi.Input['PageRuleActionsForwardingUrlArgs'] forwarding_url: The URL to forward to, and with what status. See below.
        :param pulumi.Input[str] host_header_override: Value of the Host header to send.
        :param pulumi.Input[str] ip_geolocation: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]] minifies: The configuration for HTML, CSS and JS minification. See below for full list of options.
        :param pulumi.Input[str] mirage: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] opportunistic_encryption: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] origin_error_page_pass_thru: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] polish: Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        :param pulumi.Input[str] resolve_override: Overridden origin server name.
        :param pulumi.Input[str] respect_strong_etag: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] response_buffering: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] rocket_loader: Whether to set the rocket loader to `"on"`, `"off"`.
        :param pulumi.Input[str] security_level: Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        :param pulumi.Input[str] server_side_exclude: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] sort_query_string_for_cache: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] ssl: Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        :param pulumi.Input[str] true_client_ip_header: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] waf: Whether this action is `"on"` or `"off"`.
        """
        PageRuleActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            always_use_https=always_use_https,
            automatic_https_rewrites=automatic_https_rewrites,
            browser_cache_ttl=browser_cache_ttl,
            browser_check=browser_check,
            bypass_cache_on_cookie=bypass_cache_on_cookie,
            cache_by_device_type=cache_by_device_type,
            cache_deception_armor=cache_deception_armor,
            cache_key_fields=cache_key_fields,
            cache_level=cache_level,
            cache_on_cookie=cache_on_cookie,
            cache_ttl_by_statuses=cache_ttl_by_statuses,
            disable_apps=disable_apps,
            disable_performance=disable_performance,
            disable_railgun=disable_railgun,
            disable_security=disable_security,
            disable_zaraz=disable_zaraz,
            edge_cache_ttl=edge_cache_ttl,
            email_obfuscation=email_obfuscation,
            explicit_cache_control=explicit_cache_control,
            forwarding_url=forwarding_url,
            host_header_override=host_header_override,
            ip_geolocation=ip_geolocation,
            minifies=minifies,
            mirage=mirage,
            opportunistic_encryption=opportunistic_encryption,
            origin_error_page_pass_thru=origin_error_page_pass_thru,
            polish=polish,
            resolve_override=resolve_override,
            respect_strong_etag=respect_strong_etag,
            response_buffering=response_buffering,
            rocket_loader=rocket_loader,
            security_level=security_level,
            server_side_exclude=server_side_exclude,
            sort_query_string_for_cache=sort_query_string_for_cache,
            ssl=ssl,
            true_client_ip_header=true_client_ip_header,
            waf=waf,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             always_use_https: Optional[pulumi.Input[bool]] = None,
             automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
             browser_cache_ttl: Optional[pulumi.Input[str]] = None,
             browser_check: Optional[pulumi.Input[str]] = None,
             bypass_cache_on_cookie: Optional[pulumi.Input[str]] = None,
             cache_by_device_type: Optional[pulumi.Input[str]] = None,
             cache_deception_armor: Optional[pulumi.Input[str]] = None,
             cache_key_fields: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']] = None,
             cache_level: Optional[pulumi.Input[str]] = None,
             cache_on_cookie: Optional[pulumi.Input[str]] = None,
             cache_ttl_by_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]]] = None,
             disable_apps: Optional[pulumi.Input[bool]] = None,
             disable_performance: Optional[pulumi.Input[bool]] = None,
             disable_railgun: Optional[pulumi.Input[bool]] = None,
             disable_security: Optional[pulumi.Input[bool]] = None,
             disable_zaraz: Optional[pulumi.Input[bool]] = None,
             edge_cache_ttl: Optional[pulumi.Input[int]] = None,
             email_obfuscation: Optional[pulumi.Input[str]] = None,
             explicit_cache_control: Optional[pulumi.Input[str]] = None,
             forwarding_url: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']] = None,
             host_header_override: Optional[pulumi.Input[str]] = None,
             ip_geolocation: Optional[pulumi.Input[str]] = None,
             minifies: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]]] = None,
             mirage: Optional[pulumi.Input[str]] = None,
             opportunistic_encryption: Optional[pulumi.Input[str]] = None,
             origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
             polish: Optional[pulumi.Input[str]] = None,
             resolve_override: Optional[pulumi.Input[str]] = None,
             respect_strong_etag: Optional[pulumi.Input[str]] = None,
             response_buffering: Optional[pulumi.Input[str]] = None,
             rocket_loader: Optional[pulumi.Input[str]] = None,
             security_level: Optional[pulumi.Input[str]] = None,
             server_side_exclude: Optional[pulumi.Input[str]] = None,
             sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
             ssl: Optional[pulumi.Input[str]] = None,
             true_client_ip_header: Optional[pulumi.Input[str]] = None,
             waf: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if always_use_https is not None:
            _setter("always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            _setter("automatic_https_rewrites", automatic_https_rewrites)
        if browser_cache_ttl is not None:
            _setter("browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            _setter("browser_check", browser_check)
        if bypass_cache_on_cookie is not None:
            _setter("bypass_cache_on_cookie", bypass_cache_on_cookie)
        if cache_by_device_type is not None:
            _setter("cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            _setter("cache_deception_armor", cache_deception_armor)
        if cache_key_fields is not None:
            _setter("cache_key_fields", cache_key_fields)
        if cache_level is not None:
            _setter("cache_level", cache_level)
        if cache_on_cookie is not None:
            _setter("cache_on_cookie", cache_on_cookie)
        if cache_ttl_by_statuses is not None:
            _setter("cache_ttl_by_statuses", cache_ttl_by_statuses)
        if disable_apps is not None:
            _setter("disable_apps", disable_apps)
        if disable_performance is not None:
            _setter("disable_performance", disable_performance)
        if disable_railgun is not None:
            _setter("disable_railgun", disable_railgun)
        if disable_security is not None:
            _setter("disable_security", disable_security)
        if disable_zaraz is not None:
            _setter("disable_zaraz", disable_zaraz)
        if edge_cache_ttl is not None:
            _setter("edge_cache_ttl", edge_cache_ttl)
        if email_obfuscation is not None:
            _setter("email_obfuscation", email_obfuscation)
        if explicit_cache_control is not None:
            _setter("explicit_cache_control", explicit_cache_control)
        if forwarding_url is not None:
            _setter("forwarding_url", forwarding_url)
        if host_header_override is not None:
            _setter("host_header_override", host_header_override)
        if ip_geolocation is not None:
            _setter("ip_geolocation", ip_geolocation)
        if minifies is not None:
            _setter("minifies", minifies)
        if mirage is not None:
            _setter("mirage", mirage)
        if opportunistic_encryption is not None:
            _setter("opportunistic_encryption", opportunistic_encryption)
        if origin_error_page_pass_thru is not None:
            _setter("origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            _setter("polish", polish)
        if resolve_override is not None:
            _setter("resolve_override", resolve_override)
        if respect_strong_etag is not None:
            _setter("respect_strong_etag", respect_strong_etag)
        if response_buffering is not None:
            _setter("response_buffering", response_buffering)
        if rocket_loader is not None:
            _setter("rocket_loader", rocket_loader)
        if security_level is not None:
            _setter("security_level", security_level)
        if server_side_exclude is not None:
            _setter("server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            _setter("sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            _setter("ssl", ssl)
        if true_client_ip_header is not None:
            _setter("true_client_ip_header", true_client_ip_header)
        if waf is not None:
            _setter("waf", waf)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "always_use_https")

    @always_use_https.setter
    def always_use_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_use_https", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[pulumi.Input[str]]:
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        return pulumi.get(self, "browser_cache_ttl")

    @browser_cache_ttl.setter
    def browser_cache_ttl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_cache_ttl", value)

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "browser_check")

    @browser_check.setter
    def browser_check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_check", value)

    @property
    @pulumi.getter(name="bypassCacheOnCookie")
    def bypass_cache_on_cookie(self) -> Optional[pulumi.Input[str]]:
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        return pulumi.get(self, "bypass_cache_on_cookie")

    @bypass_cache_on_cookie.setter
    def bypass_cache_on_cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bypass_cache_on_cookie", value)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_by_device_type")

    @cache_by_device_type.setter
    def cache_by_device_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_by_device_type", value)

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_deception_armor")

    @cache_deception_armor.setter
    def cache_deception_armor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_deception_armor", value)

    @property
    @pulumi.getter(name="cacheKeyFields")
    def cache_key_fields(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']]:
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        return pulumi.get(self, "cache_key_fields")

    @cache_key_fields.setter
    def cache_key_fields(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']]):
        pulumi.set(self, "cache_key_fields", value)

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        return pulumi.get(self, "cache_level")

    @cache_level.setter
    def cache_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_level", value)

    @property
    @pulumi.getter(name="cacheOnCookie")
    def cache_on_cookie(self) -> Optional[pulumi.Input[str]]:
        """
        String value of cookie name to conditionally cache the page.
        """
        return pulumi.get(self, "cache_on_cookie")

    @cache_on_cookie.setter
    def cache_on_cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_on_cookie", value)

    @property
    @pulumi.getter(name="cacheTtlByStatuses")
    def cache_ttl_by_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]]]:
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        return pulumi.get(self, "cache_ttl_by_statuses")

    @cache_ttl_by_statuses.setter
    def cache_ttl_by_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsCacheTtlByStatusArgs']]]]):
        pulumi.set(self, "cache_ttl_by_statuses", value)

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_apps")

    @disable_apps.setter
    def disable_apps(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_apps", value)

    @property
    @pulumi.getter(name="disablePerformance")
    def disable_performance(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_performance")

    @disable_performance.setter
    def disable_performance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_performance", value)

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_railgun")

    @disable_railgun.setter
    def disable_railgun(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_railgun", value)

    @property
    @pulumi.getter(name="disableSecurity")
    def disable_security(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_security")

    @disable_security.setter
    def disable_security(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_security", value)

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_zaraz")

    @disable_zaraz.setter
    def disable_zaraz(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_zaraz", value)

    @property
    @pulumi.getter(name="edgeCacheTtl")
    def edge_cache_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The Time To Live for the edge cache.
        """
        return pulumi.get(self, "edge_cache_ttl")

    @edge_cache_ttl.setter
    def edge_cache_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "edge_cache_ttl", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter(name="explicitCacheControl")
    def explicit_cache_control(self) -> Optional[pulumi.Input[str]]:
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "explicit_cache_control")

    @explicit_cache_control.setter
    def explicit_cache_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "explicit_cache_control", value)

    @property
    @pulumi.getter(name="forwardingUrl")
    def forwarding_url(self) -> Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']]:
        """
        The URL to forward to, and with what status. See below.
        """
        return pulumi.get(self, "forwarding_url")

    @forwarding_url.setter
    def forwarding_url(self, value: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']]):
        pulumi.set(self, "forwarding_url", value)

    @property
    @pulumi.getter(name="hostHeaderOverride")
    def host_header_override(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the Host header to send.
        """
        return pulumi.get(self, "host_header_override")

    @host_header_override.setter
    def host_header_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header_override", value)

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "ip_geolocation")

    @ip_geolocation.setter
    def ip_geolocation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_geolocation", value)

    @property
    @pulumi.getter
    def minifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]]]:
        """
        The configuration for HTML, CSS and JS minification. See below for full list of options.
        """
        return pulumi.get(self, "minifies")

    @minifies.setter
    def minifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PageRuleActionsMinifyArgs']]]]):
        pulumi.set(self, "minifies", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "origin_error_page_pass_thru")

    @origin_error_page_pass_thru.setter
    def origin_error_page_pass_thru(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_error_page_pass_thru", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter(name="resolveOverride")
    def resolve_override(self) -> Optional[pulumi.Input[str]]:
        """
        Overridden origin server name.
        """
        return pulumi.get(self, "resolve_override")

    @resolve_override.setter
    def resolve_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolve_override", value)

    @property
    @pulumi.getter(name="respectStrongEtag")
    def respect_strong_etag(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "respect_strong_etag")

    @respect_strong_etag.setter
    def respect_strong_etag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "respect_strong_etag", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "server_side_exclude")

    @server_side_exclude.setter
    def server_side_exclude(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_side_exclude", value)

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "sort_query_string_for_cache")

    @sort_query_string_for_cache.setter
    def sort_query_string_for_cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_query_string_for_cache", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "true_client_ip_header")

    @true_client_ip_header.setter
    def true_client_ip_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "true_client_ip_header", value)

    @property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf", value)


@pulumi.input_type
class PageRuleActionsCacheKeyFieldsArgs:
    def __init__(__self__, *,
                 host: pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs'],
                 query_string: pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs'],
                 user: pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs'],
                 cookie: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']] = None,
                 header: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']] = None):
        """
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs'] host: Controls which Host header goes into Cache Key:
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs'] query_string: Controls which URL query string parameters go into the Cache Key.
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs'] user: Controls which end user-related features go into the Cache Key.
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs'] cookie: Controls what cookies go into Cache Key:
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs'] header: Controls what HTTP headers go into Cache Key:
        """
        PageRuleActionsCacheKeyFieldsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            query_string=query_string,
            user=user,
            cookie=cookie,
            header=header,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs'],
             query_string: pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs'],
             user: pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs'],
             cookie: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']] = None,
             header: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("host", host)
        _setter("query_string", query_string)
        _setter("user", user)
        if cookie is not None:
            _setter("cookie", cookie)
        if header is not None:
            _setter("header", header)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']:
        """
        Controls which Host header goes into Cache Key:
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']:
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']:
        """
        Controls which end user-related features go into the Cache Key.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']]:
        """
        Controls what cookies go into Cache Key:
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']]:
        """
        Controls what HTTP headers go into Cache Key:
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']]):
        pulumi.set(self, "header", value)


@pulumi.input_type
class PageRuleActionsCacheKeyFieldsCookieArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: Check for presence of specified HTTP headers, without including their actual values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Only use values of specified query string parameters in Cache Key.
        """
        PageRuleActionsCacheKeyFieldsCookieArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check_presences=check_presences,
            includes=includes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if check_presences is not None:
            _setter("check_presences", check_presences)
        if includes is not None:
            _setter("includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class PageRuleActionsCacheKeyFieldsHeaderArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: Check for presence of specified HTTP headers, without including their actual values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Exclude these query string parameters from Cache Key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Only use values of specified query string parameters in Cache Key.
        """
        PageRuleActionsCacheKeyFieldsHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check_presences=check_presences,
            excludes=excludes,
            includes=includes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if check_presences is not None:
            _setter("check_presences", check_presences)
        if excludes is not None:
            _setter("excludes", excludes)
        if includes is not None:
            _setter("includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Exclude these query string parameters from Cache Key.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class PageRuleActionsCacheKeyFieldsHostArgs:
    def __init__(__self__, *,
                 resolved: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] resolved: `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        PageRuleActionsCacheKeyFieldsHostArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resolved=resolved,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resolved: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if resolved is not None:
            _setter("resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input[bool]]:
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolved", value)


@pulumi.input_type
class PageRuleActionsCacheKeyFieldsQueryStringArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ignore: Optional[pulumi.Input[bool]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Exclude these query string parameters from Cache Key.
        :param pulumi.Input[bool] ignore: `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Only use values of specified query string parameters in Cache Key.
        """
        PageRuleActionsCacheKeyFieldsQueryStringArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excludes=excludes,
            ignore=ignore,
            includes=includes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ignore: Optional[pulumi.Input[bool]] = None,
             includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if excludes is not None:
            _setter("excludes", excludes)
        if ignore is not None:
            _setter("ignore", ignore)
        if includes is not None:
            _setter("includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Exclude these query string parameters from Cache Key.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def ignore(self) -> Optional[pulumi.Input[bool]]:
        """
        `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        """
        return pulumi.get(self, "ignore")

    @ignore.setter
    def ignore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class PageRuleActionsCacheKeyFieldsUserArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[bool]] = None,
                 geo: Optional[pulumi.Input[bool]] = None,
                 lang: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] device_type: `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
        :param pulumi.Input[bool] geo: `true` - includes the client’s country, derived from the IP address; defaults to `false`.
        :param pulumi.Input[bool] lang: `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
               
               Example:
               
               ```python
               import pulumi
               import pulumi_cloudflare as cloudflare
               
               # Unrealistic example with all features used
               foobar = cloudflare.PageRule("foobar",
                   zone_id=var["cloudflare_zone_id"],
                   target=f"{var['cloudflare_zone']}/app/*",
                   priority=1,
                   actions=cloudflare.PageRuleActionsArgs(
                       cache_key_fields=cloudflare.PageRuleActionsCacheKeyFieldsArgs(
                           cookie=cloudflare.PageRuleActionsCacheKeyFieldsCookieArgs(
                               check_presences=["wordpress_test_cookie"],
                           ),
                           header=cloudflare.PageRuleActionsCacheKeyFieldsHeaderArgs(
                               check_presences=["header_present"],
                               excludes=["origin"],
                               includes=[
                                   "api-key",
                                   "dnt",
                               ],
                           ),
                           host=cloudflare.PageRuleActionsCacheKeyFieldsHostArgs(
                               resolved=True,
                           ),
                           query_string=cloudflare.PageRuleActionsCacheKeyFieldsQueryStringArgs(
                               ignore=True,
                           ),
                           user=cloudflare.PageRuleActionsCacheKeyFieldsUserArgs(
                               device_type=False,
                               geo=True,
                               lang=True,
                           ),
                       ),
                   ))
               ```
        """
        PageRuleActionsCacheKeyFieldsUserArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_type=device_type,
            geo=geo,
            lang=lang,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_type: Optional[pulumi.Input[bool]] = None,
             geo: Optional[pulumi.Input[bool]] = None,
             lang: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if device_type is not None:
            _setter("device_type", device_type)
        if geo is not None:
            _setter("geo", geo)
        if lang is not None:
            _setter("lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - includes the client’s country, derived from the IP address; defaults to `false`.
        """
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.

        Example:

        ```python
        import pulumi
        import pulumi_cloudflare as cloudflare

        # Unrealistic example with all features used
        foobar = cloudflare.PageRule("foobar",
            zone_id=var["cloudflare_zone_id"],
            target=f"{var['cloudflare_zone']}/app/*",
            priority=1,
            actions=cloudflare.PageRuleActionsArgs(
                cache_key_fields=cloudflare.PageRuleActionsCacheKeyFieldsArgs(
                    cookie=cloudflare.PageRuleActionsCacheKeyFieldsCookieArgs(
                        check_presences=["wordpress_test_cookie"],
                    ),
                    header=cloudflare.PageRuleActionsCacheKeyFieldsHeaderArgs(
                        check_presences=["header_present"],
                        excludes=["origin"],
                        includes=[
                            "api-key",
                            "dnt",
                        ],
                    ),
                    host=cloudflare.PageRuleActionsCacheKeyFieldsHostArgs(
                        resolved=True,
                    ),
                    query_string=cloudflare.PageRuleActionsCacheKeyFieldsQueryStringArgs(
                        ignore=True,
                    ),
                    user=cloudflare.PageRuleActionsCacheKeyFieldsUserArgs(
                        device_type=False,
                        geo=True,
                        lang=True,
                    ),
                ),
            ))
        ```
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lang", value)


@pulumi.input_type
class PageRuleActionsCacheTtlByStatusArgs:
    def __init__(__self__, *,
                 codes: pulumi.Input[str],
                 ttl: pulumi.Input[int]):
        """
        :param pulumi.Input[str] codes: A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        :param pulumi.Input[int] ttl: Duration a resource lives in the Cloudflare cache.
               - positive number - cache for specified duration in seconds
        """
        PageRuleActionsCacheTtlByStatusArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            codes=codes,
            ttl=ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             codes: pulumi.Input[str],
             ttl: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("codes", codes)
        _setter("ttl", ttl)

    @property
    @pulumi.getter
    def codes(self) -> pulumi.Input[str]:
        """
        A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        """
        return pulumi.get(self, "codes")

    @codes.setter
    def codes(self, value: pulumi.Input[str]):
        pulumi.set(self, "codes", value)

    @property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[int]:
        """
        Duration a resource lives in the Cloudflare cache.
        - positive number - cache for specified duration in seconds
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[int]):
        pulumi.set(self, "ttl", value)


@pulumi.input_type
class PageRuleActionsForwardingUrlArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[int],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[int] status_code: The status code to use for the redirection.
        :param pulumi.Input[str] url: The URL to which the page rule should forward.
        """
        PageRuleActionsForwardingUrlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status_code=status_code,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status_code: pulumi.Input[int],
             url: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status_code", status_code)
        _setter("url", url)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[int]:
        """
        The status code to use for the redirection.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to which the page rule should forward.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class PageRuleActionsMinifyArgs:
    def __init__(__self__, *,
                 css: pulumi.Input[str],
                 html: pulumi.Input[str],
                 js: pulumi.Input[str]):
        """
        :param pulumi.Input[str] css: Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        :param pulumi.Input[str] html: Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        :param pulumi.Input[str] js: Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        PageRuleActionsMinifyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            css=css,
            html=html,
            js=js,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             css: pulumi.Input[str],
             html: pulumi.Input[str],
             js: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("css", css)
        _setter("html", html)
        _setter("js", js)

    @property
    @pulumi.getter
    def css(self) -> pulumi.Input[str]:
        """
        Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: pulumi.Input[str]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        """
        Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> pulumi.Input[str]:
        """
        Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: pulumi.Input[str]):
        pulumi.set(self, "js", value)


@pulumi.input_type
class PagesProjectBuildConfigArgs:
    def __init__(__self__, *,
                 build_command: Optional[pulumi.Input[str]] = None,
                 destination_dir: Optional[pulumi.Input[str]] = None,
                 root_dir: Optional[pulumi.Input[str]] = None,
                 web_analytics_tag: Optional[pulumi.Input[str]] = None,
                 web_analytics_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] build_command: Command used to build project.
        :param pulumi.Input[str] destination_dir: Output directory of the build.
        :param pulumi.Input[str] root_dir: Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        :param pulumi.Input[str] web_analytics_tag: The classifying tag for analytics.
        :param pulumi.Input[str] web_analytics_token: The auth token for analytics.
        """
        PagesProjectBuildConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            build_command=build_command,
            destination_dir=destination_dir,
            root_dir=root_dir,
            web_analytics_tag=web_analytics_tag,
            web_analytics_token=web_analytics_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             build_command: Optional[pulumi.Input[str]] = None,
             destination_dir: Optional[pulumi.Input[str]] = None,
             root_dir: Optional[pulumi.Input[str]] = None,
             web_analytics_tag: Optional[pulumi.Input[str]] = None,
             web_analytics_token: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if build_command is not None:
            _setter("build_command", build_command)
        if destination_dir is not None:
            _setter("destination_dir", destination_dir)
        if root_dir is not None:
            _setter("root_dir", root_dir)
        if web_analytics_tag is not None:
            _setter("web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            _setter("web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @destination_dir.setter
    def destination_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_dir", value)

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        """
        return pulumi.get(self, "root_dir")

    @root_dir.setter
    def root_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_dir", value)

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @web_analytics_tag.setter
    def web_analytics_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_tag", value)

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[pulumi.Input[str]]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")

    @web_analytics_token.setter
    def web_analytics_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_token", value)


@pulumi.input_type
class PagesProjectDeploymentConfigsArgs:
    def __init__(__self__, *,
                 preview: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']] = None,
                 production: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']] = None):
        """
        :param pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs'] preview: Configuration for preview deploys.
        :param pulumi.Input['PagesProjectDeploymentConfigsProductionArgs'] production: Configuration for production deploys.
        """
        PagesProjectDeploymentConfigsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preview=preview,
            production=production,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preview: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']] = None,
             production: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if preview is not None:
            _setter("preview", preview)
        if production is not None:
            _setter("production", production)

    @property
    @pulumi.getter
    def preview(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']]:
        """
        Configuration for preview deploys.
        """
        return pulumi.get(self, "preview")

    @preview.setter
    def preview(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']]):
        pulumi.set(self, "preview", value)

    @property
    @pulumi.getter
    def production(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']]:
        """
        Configuration for production deploys.
        """
        return pulumi.get(self, "production")

    @production.setter
    def production(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']]):
        pulumi.set(self, "production", value)


@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewArgs:
    def __init__(__self__, *,
                 always_use_latest_compatibility_date: Optional[pulumi.Input[bool]] = None,
                 compatibility_date: Optional[pulumi.Input[str]] = None,
                 compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 d1_databases: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 durable_object_namespaces: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 fail_open: Optional[pulumi.Input[bool]] = None,
                 kv_namespaces: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']] = None,
                 r2_buckets: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 service_bindings: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]]] = None,
                 usage_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] always_use_latest_compatibility_date: Use latest compatibility date for Pages Functions. Defaults to `false`.
        :param pulumi.Input[str] compatibility_date: Compatibility date used for Pages Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compatibility_flags: Compatibility flags used for Pages Functions.
        :param pulumi.Input[Mapping[str, Any]] d1_databases: D1 Databases used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, Any]] durable_object_namespaces: Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, Any]] environment_variables: Environment variables for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[bool] fail_open: Fail open used for Pages Functions. Defaults to `false`.
        :param pulumi.Input[Mapping[str, Any]] kv_namespaces: KV namespaces used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs'] placement: Configuration for placement in the Cloudflare Pages project.
        :param pulumi.Input[Mapping[str, Any]] r2_buckets: R2 Buckets used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, Any]] secrets: Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]] service_bindings: Services used for Pages Functions.
        :param pulumi.Input[str] usage_model: Usage model used for Pages Functions. Defaults to `bundled`.
        """
        PagesProjectDeploymentConfigsPreviewArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            always_use_latest_compatibility_date=always_use_latest_compatibility_date,
            compatibility_date=compatibility_date,
            compatibility_flags=compatibility_flags,
            d1_databases=d1_databases,
            durable_object_namespaces=durable_object_namespaces,
            environment_variables=environment_variables,
            fail_open=fail_open,
            kv_namespaces=kv_namespaces,
            placement=placement,
            r2_buckets=r2_buckets,
            secrets=secrets,
            service_bindings=service_bindings,
            usage_model=usage_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             always_use_latest_compatibility_date: Optional[pulumi.Input[bool]] = None,
             compatibility_date: Optional[pulumi.Input[str]] = None,
             compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             d1_databases: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             durable_object_namespaces: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             environment_variables: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             fail_open: Optional[pulumi.Input[bool]] = None,
             kv_namespaces: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']] = None,
             r2_buckets: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             secrets: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             service_bindings: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]]] = None,
             usage_model: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if always_use_latest_compatibility_date is not None:
            _setter("always_use_latest_compatibility_date", always_use_latest_compatibility_date)
        if compatibility_date is not None:
            _setter("compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            _setter("compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            _setter("d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            _setter("durable_object_namespaces", durable_object_namespaces)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if fail_open is not None:
            _setter("fail_open", fail_open)
        if kv_namespaces is not None:
            _setter("kv_namespaces", kv_namespaces)
        if placement is not None:
            _setter("placement", placement)
        if r2_buckets is not None:
            _setter("r2_buckets", r2_buckets)
        if secrets is not None:
            _setter("secrets", secrets)
        if service_bindings is not None:
            _setter("service_bindings", service_bindings)
        if usage_model is not None:
            _setter("usage_model", usage_model)

    @property
    @pulumi.getter(name="alwaysUseLatestCompatibilityDate")
    def always_use_latest_compatibility_date(self) -> Optional[pulumi.Input[bool]]:
        """
        Use latest compatibility date for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "always_use_latest_compatibility_date")

    @always_use_latest_compatibility_date.setter
    def always_use_latest_compatibility_date(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_use_latest_compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[pulumi.Input[str]]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @compatibility_date.setter
    def compatibility_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @compatibility_flags.setter
    def compatibility_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compatibility_flags", value)

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        D1 Databases used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "d1_databases")

    @d1_databases.setter
    def d1_databases(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "d1_databases", value)

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @durable_object_namespaces.setter
    def durable_object_namespaces(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "durable_object_namespaces", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[bool]]:
        """
        Fail open used for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_open", value)

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        KV namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "kv_namespaces")

    @kv_namespaces.setter
    def kv_namespaces(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "kv_namespaces", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']]:
        """
        Configuration for placement in the Cloudflare Pages project.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        R2 Buckets used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "r2_buckets")

    @r2_buckets.setter
    def r2_buckets(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "r2_buckets", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="serviceBindings")
    def service_bindings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]]]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "service_bindings")

    @service_bindings.setter
    def service_bindings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsPreviewServiceBindingArgs']]]]):
        pulumi.set(self, "service_bindings", value)

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[pulumi.Input[str]]:
        """
        Usage model used for Pages Functions. Defaults to `bundled`.
        """
        return pulumi.get(self, "usage_model")

    @usage_model.setter
    def usage_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage_model", value)


@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Placement Mode for the Pages Function.
        """
        PagesProjectDeploymentConfigsPreviewPlacementArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Placement Mode for the Pages Function.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewServiceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] service: The name of the Worker to bind to.
        :param pulumi.Input[str] environment: The name of the Worker environment to bind to.
        """
        PagesProjectDeploymentConfigsPreviewServiceBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            service=service,
            environment=environment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             service: pulumi.Input[str],
             environment: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("service", service)
        if environment is not None:
            _setter("environment", environment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)


@pulumi.input_type
class PagesProjectDeploymentConfigsProductionArgs:
    def __init__(__self__, *,
                 always_use_latest_compatibility_date: Optional[pulumi.Input[bool]] = None,
                 compatibility_date: Optional[pulumi.Input[str]] = None,
                 compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 d1_databases: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 durable_object_namespaces: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 fail_open: Optional[pulumi.Input[bool]] = None,
                 kv_namespaces: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']] = None,
                 r2_buckets: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 service_bindings: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]]] = None,
                 usage_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] always_use_latest_compatibility_date: Use latest compatibility date for Pages Functions. Defaults to `false`.
        :param pulumi.Input[str] compatibility_date: Compatibility date used for Pages Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compatibility_flags: Compatibility flags used for Pages Functions.
        :param pulumi.Input[Mapping[str, Any]] d1_databases: D1 Databases used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, Any]] durable_object_namespaces: Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, Any]] environment_variables: Environment variables for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[bool] fail_open: Fail open used for Pages Functions. Defaults to `false`.
        :param pulumi.Input[Mapping[str, Any]] kv_namespaces: KV namespaces used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs'] placement: Configuration for placement in the Cloudflare Pages project.
        :param pulumi.Input[Mapping[str, Any]] r2_buckets: R2 Buckets used for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Mapping[str, Any]] secrets: Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        :param pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]] service_bindings: Services used for Pages Functions.
        :param pulumi.Input[str] usage_model: Usage model used for Pages Functions. Defaults to `bundled`.
        """
        PagesProjectDeploymentConfigsProductionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            always_use_latest_compatibility_date=always_use_latest_compatibility_date,
            compatibility_date=compatibility_date,
            compatibility_flags=compatibility_flags,
            d1_databases=d1_databases,
            durable_object_namespaces=durable_object_namespaces,
            environment_variables=environment_variables,
            fail_open=fail_open,
            kv_namespaces=kv_namespaces,
            placement=placement,
            r2_buckets=r2_buckets,
            secrets=secrets,
            service_bindings=service_bindings,
            usage_model=usage_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             always_use_latest_compatibility_date: Optional[pulumi.Input[bool]] = None,
             compatibility_date: Optional[pulumi.Input[str]] = None,
             compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             d1_databases: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             durable_object_namespaces: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             environment_variables: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             fail_open: Optional[pulumi.Input[bool]] = None,
             kv_namespaces: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']] = None,
             r2_buckets: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             secrets: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             service_bindings: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]]] = None,
             usage_model: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if always_use_latest_compatibility_date is not None:
            _setter("always_use_latest_compatibility_date", always_use_latest_compatibility_date)
        if compatibility_date is not None:
            _setter("compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            _setter("compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            _setter("d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            _setter("durable_object_namespaces", durable_object_namespaces)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if fail_open is not None:
            _setter("fail_open", fail_open)
        if kv_namespaces is not None:
            _setter("kv_namespaces", kv_namespaces)
        if placement is not None:
            _setter("placement", placement)
        if r2_buckets is not None:
            _setter("r2_buckets", r2_buckets)
        if secrets is not None:
            _setter("secrets", secrets)
        if service_bindings is not None:
            _setter("service_bindings", service_bindings)
        if usage_model is not None:
            _setter("usage_model", usage_model)

    @property
    @pulumi.getter(name="alwaysUseLatestCompatibilityDate")
    def always_use_latest_compatibility_date(self) -> Optional[pulumi.Input[bool]]:
        """
        Use latest compatibility date for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "always_use_latest_compatibility_date")

    @always_use_latest_compatibility_date.setter
    def always_use_latest_compatibility_date(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_use_latest_compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[pulumi.Input[str]]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @compatibility_date.setter
    def compatibility_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @compatibility_flags.setter
    def compatibility_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compatibility_flags", value)

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        D1 Databases used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "d1_databases")

    @d1_databases.setter
    def d1_databases(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "d1_databases", value)

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @durable_object_namespaces.setter
    def durable_object_namespaces(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "durable_object_namespaces", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[bool]]:
        """
        Fail open used for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_open", value)

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        KV namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "kv_namespaces")

    @kv_namespaces.setter
    def kv_namespaces(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "kv_namespaces", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']]:
        """
        Configuration for placement in the Cloudflare Pages project.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        R2 Buckets used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "r2_buckets")

    @r2_buckets.setter
    def r2_buckets(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "r2_buckets", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="serviceBindings")
    def service_bindings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]]]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "service_bindings")

    @service_bindings.setter
    def service_bindings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectDeploymentConfigsProductionServiceBindingArgs']]]]):
        pulumi.set(self, "service_bindings", value)

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[pulumi.Input[str]]:
        """
        Usage model used for Pages Functions. Defaults to `bundled`.
        """
        return pulumi.get(self, "usage_model")

    @usage_model.setter
    def usage_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage_model", value)


@pulumi.input_type
class PagesProjectDeploymentConfigsProductionPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Placement Mode for the Pages Function.
        """
        PagesProjectDeploymentConfigsProductionPlacementArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Placement Mode for the Pages Function.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class PagesProjectDeploymentConfigsProductionServiceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] service: The name of the Worker to bind to.
        :param pulumi.Input[str] environment: The name of the Worker environment to bind to.
        """
        PagesProjectDeploymentConfigsProductionServiceBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            service=service,
            environment=environment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             service: pulumi.Input[str],
             environment: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("service", service)
        if environment is not None:
            _setter("environment", environment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)


@pulumi.input_type
class PagesProjectSourceArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['PagesProjectSourceConfigArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PagesProjectSourceConfigArgs'] config: Configuration for the source of the Cloudflare Pages project.
        :param pulumi.Input[str] type: Project host type.
        """
        PagesProjectSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[pulumi.Input['PagesProjectSourceConfigArgs']] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if config is not None:
            _setter("config", config)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['PagesProjectSourceConfigArgs']]:
        """
        Configuration for the source of the Cloudflare Pages project.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['PagesProjectSourceConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Project host type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PagesProjectSourceConfigArgs:
    def __init__(__self__, *,
                 production_branch: pulumi.Input[str],
                 deployments_enabled: Optional[pulumi.Input[bool]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 pr_comments_enabled: Optional[pulumi.Input[bool]] = None,
                 preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_deployment_setting: Optional[pulumi.Input[str]] = None,
                 production_deployment_enabled: Optional[pulumi.Input[bool]] = None,
                 repo_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] production_branch: Project production branch name.
        :param pulumi.Input[bool] deployments_enabled: Toggle deployments on this repo. Defaults to `true`.
        :param pulumi.Input[str] owner: Project owner username. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[bool] pr_comments_enabled: Enable Pages to comment on Pull Requests. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] preview_branch_excludes: Branches will be excluded from automatic deployment.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] preview_branch_includes: Branches will be included for automatic deployment.
        :param pulumi.Input[str] preview_deployment_setting: Preview Deployment Setting. Defaults to `all`.
        :param pulumi.Input[bool] production_deployment_enabled: Enable production deployments. Defaults to `true`.
        :param pulumi.Input[str] repo_name: Project repository name. **Modifying this attribute will force creation of a new resource.**
        """
        PagesProjectSourceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            production_branch=production_branch,
            deployments_enabled=deployments_enabled,
            owner=owner,
            pr_comments_enabled=pr_comments_enabled,
            preview_branch_excludes=preview_branch_excludes,
            preview_branch_includes=preview_branch_includes,
            preview_deployment_setting=preview_deployment_setting,
            production_deployment_enabled=production_deployment_enabled,
            repo_name=repo_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             production_branch: pulumi.Input[str],
             deployments_enabled: Optional[pulumi.Input[bool]] = None,
             owner: Optional[pulumi.Input[str]] = None,
             pr_comments_enabled: Optional[pulumi.Input[bool]] = None,
             preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             preview_deployment_setting: Optional[pulumi.Input[str]] = None,
             production_deployment_enabled: Optional[pulumi.Input[bool]] = None,
             repo_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("production_branch", production_branch)
        if deployments_enabled is not None:
            _setter("deployments_enabled", deployments_enabled)
        if owner is not None:
            _setter("owner", owner)
        if pr_comments_enabled is not None:
            _setter("pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            _setter("preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            _setter("preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            _setter("preview_deployment_setting", preview_deployment_setting)
        if production_deployment_enabled is not None:
            _setter("production_deployment_enabled", production_deployment_enabled)
        if repo_name is not None:
            _setter("repo_name", repo_name)

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> pulumi.Input[str]:
        """
        Project production branch name.
        """
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: pulumi.Input[str]):
        pulumi.set(self, "production_branch", value)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Toggle deployments on this repo. Defaults to `true`.
        """
        return pulumi.get(self, "deployments_enabled")

    @deployments_enabled.setter
    def deployments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deployments_enabled", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Project owner username. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Pages to comment on Pull Requests. Defaults to `true`.
        """
        return pulumi.get(self, "pr_comments_enabled")

    @pr_comments_enabled.setter
    def pr_comments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pr_comments_enabled", value)

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Branches will be excluded from automatic deployment.
        """
        return pulumi.get(self, "preview_branch_excludes")

    @preview_branch_excludes.setter
    def preview_branch_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_excludes", value)

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Branches will be included for automatic deployment.
        """
        return pulumi.get(self, "preview_branch_includes")

    @preview_branch_includes.setter
    def preview_branch_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_includes", value)

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[pulumi.Input[str]]:
        """
        Preview Deployment Setting. Defaults to `all`.
        """
        return pulumi.get(self, "preview_deployment_setting")

    @preview_deployment_setting.setter
    def preview_deployment_setting(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preview_deployment_setting", value)

    @property
    @pulumi.getter(name="productionDeploymentEnabled")
    def production_deployment_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable production deployments. Defaults to `true`.
        """
        return pulumi.get(self, "production_deployment_enabled")

    @production_deployment_enabled.setter
    def production_deployment_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "production_deployment_enabled", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[str]]:
        """
        Project repository name. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_name", value)


@pulumi.input_type
class RateLimitActionArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 response: Optional[pulumi.Input['RateLimitActionResponseArgs']] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        :param pulumi.Input['RateLimitActionResponseArgs'] response: Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        :param pulumi.Input[int] timeout: The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
        RateLimitActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            response=response,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: pulumi.Input[str],
             response: Optional[pulumi.Input['RateLimitActionResponseArgs']] = None,
             timeout: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mode", mode)
        if response is not None:
            _setter("response", response)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RateLimitActionResponseArgs']]:
        """
        Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RateLimitActionResponseArgs']]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class RateLimitActionResponseArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[str],
                 content_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] body: The body to return, the content here should conform to the `content_type`.
        :param pulumi.Input[str] content_type: The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
        """
        RateLimitActionResponseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body=body,
            content_type=content_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body: pulumi.Input[str],
             content_type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("body", body)
        _setter("content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> pulumi.Input[str]:
        """
        The body to return, the content here should conform to the `content_type`.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[str]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)


@pulumi.input_type
class RateLimitCorrelateArgs:
    def __init__(__self__, *,
                 by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] by: If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
        RateLimitCorrelateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            by=by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             by: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if by is not None:
            _setter("by", by)

    @property
    @pulumi.getter
    def by(self) -> Optional[pulumi.Input[str]]:
        """
        If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
        return pulumi.get(self, "by")

    @by.setter
    def by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "by", value)


@pulumi.input_type
class RateLimitMatchArgs:
    def __init__(__self__, *,
                 request: Optional[pulumi.Input['RateLimitMatchRequestArgs']] = None,
                 response: Optional[pulumi.Input['RateLimitMatchResponseArgs']] = None):
        """
        :param pulumi.Input['RateLimitMatchRequestArgs'] request: Matches HTTP requests (from the client to Cloudflare).
        :param pulumi.Input['RateLimitMatchResponseArgs'] response: Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
        RateLimitMatchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request=request,
            response=response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request: Optional[pulumi.Input['RateLimitMatchRequestArgs']] = None,
             response: Optional[pulumi.Input['RateLimitMatchResponseArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if request is not None:
            _setter("request", request)
        if response is not None:
            _setter("response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['RateLimitMatchRequestArgs']]:
        """
        Matches HTTP requests (from the client to Cloudflare).
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['RateLimitMatchRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RateLimitMatchResponseArgs']]:
        """
        Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RateLimitMatchResponseArgs']]):
        pulumi.set(self, "response", value)


@pulumi.input_type
class RateLimitMatchRequestArgs:
    def __init__(__self__, *,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 schemes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 url_pattern: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schemes: HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
        :param pulumi.Input[str] url_pattern: The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
        """
        RateLimitMatchRequestArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            methods=methods,
            schemes=schemes,
            url_pattern=url_pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             schemes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             url_pattern: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if methods is not None:
            _setter("methods", methods)
        if schemes is not None:
            _setter("schemes", schemes)
        if url_pattern is not None:
            _setter("url_pattern", url_pattern)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def schemes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
        """
        return pulumi.get(self, "schemes")

    @schemes.setter
    def schemes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schemes", value)

    @property
    @pulumi.getter(name="urlPattern")
    def url_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
        """
        return pulumi.get(self, "url_pattern")

    @url_pattern.setter
    def url_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_pattern", value)


@pulumi.input_type
class RateLimitMatchResponseArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]] = None,
                 origin_traffic: Optional[pulumi.Input[bool]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]] headers: List of HTTP headers maps to match the origin response on.
        :param pulumi.Input[bool] origin_traffic: Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] statuses: HTTP Status codes, can be one, many or indicate all by not providing this value.
        """
        RateLimitMatchResponseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            origin_traffic=origin_traffic,
            statuses=statuses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]] = None,
             origin_traffic: Optional[pulumi.Input[bool]] = None,
             statuses: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if headers is not None:
            _setter("headers", headers)
        if origin_traffic is not None:
            _setter("origin_traffic", origin_traffic)
        if statuses is not None:
            _setter("statuses", statuses)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]:
        """
        List of HTTP headers maps to match the origin response on.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> Optional[pulumi.Input[bool]]:
        """
        Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
        """
        return pulumi.get(self, "origin_traffic")

    @origin_traffic.setter
    def origin_traffic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_traffic", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        HTTP Status codes, can be one, many or indicate all by not providing this value.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "statuses", value)


@pulumi.input_type
class RecordDataArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[int]] = None,
                 altitude: Optional[pulumi.Input[float]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 digest: Optional[pulumi.Input[str]] = None,
                 digest_type: Optional[pulumi.Input[int]] = None,
                 fingerprint: Optional[pulumi.Input[str]] = None,
                 flags: Optional[pulumi.Input[str]] = None,
                 key_tag: Optional[pulumi.Input[int]] = None,
                 lat_degrees: Optional[pulumi.Input[int]] = None,
                 lat_direction: Optional[pulumi.Input[str]] = None,
                 lat_minutes: Optional[pulumi.Input[int]] = None,
                 lat_seconds: Optional[pulumi.Input[float]] = None,
                 long_degrees: Optional[pulumi.Input[int]] = None,
                 long_direction: Optional[pulumi.Input[str]] = None,
                 long_minutes: Optional[pulumi.Input[int]] = None,
                 long_seconds: Optional[pulumi.Input[float]] = None,
                 matching_type: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 precision_horz: Optional[pulumi.Input[float]] = None,
                 precision_vert: Optional[pulumi.Input[float]] = None,
                 preference: Optional[pulumi.Input[int]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 proto: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[int]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 replacement: Optional[pulumi.Input[str]] = None,
                 selector: Optional[pulumi.Input[int]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[float]] = None,
                 tag: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[int]] = None,
                 usage: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        RecordDataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            altitude=altitude,
            certificate=certificate,
            content=content,
            digest=digest,
            digest_type=digest_type,
            fingerprint=fingerprint,
            flags=flags,
            key_tag=key_tag,
            lat_degrees=lat_degrees,
            lat_direction=lat_direction,
            lat_minutes=lat_minutes,
            lat_seconds=lat_seconds,
            long_degrees=long_degrees,
            long_direction=long_direction,
            long_minutes=long_minutes,
            long_seconds=long_seconds,
            matching_type=matching_type,
            name=name,
            order=order,
            port=port,
            precision_horz=precision_horz,
            precision_vert=precision_vert,
            preference=preference,
            priority=priority,
            proto=proto,
            protocol=protocol,
            public_key=public_key,
            regex=regex,
            replacement=replacement,
            selector=selector,
            service=service,
            size=size,
            tag=tag,
            target=target,
            type=type,
            usage=usage,
            value=value,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[pulumi.Input[int]] = None,
             altitude: Optional[pulumi.Input[float]] = None,
             certificate: Optional[pulumi.Input[str]] = None,
             content: Optional[pulumi.Input[str]] = None,
             digest: Optional[pulumi.Input[str]] = None,
             digest_type: Optional[pulumi.Input[int]] = None,
             fingerprint: Optional[pulumi.Input[str]] = None,
             flags: Optional[pulumi.Input[str]] = None,
             key_tag: Optional[pulumi.Input[int]] = None,
             lat_degrees: Optional[pulumi.Input[int]] = None,
             lat_direction: Optional[pulumi.Input[str]] = None,
             lat_minutes: Optional[pulumi.Input[int]] = None,
             lat_seconds: Optional[pulumi.Input[float]] = None,
             long_degrees: Optional[pulumi.Input[int]] = None,
             long_direction: Optional[pulumi.Input[str]] = None,
             long_minutes: Optional[pulumi.Input[int]] = None,
             long_seconds: Optional[pulumi.Input[float]] = None,
             matching_type: Optional[pulumi.Input[int]] = None,
             name: Optional[pulumi.Input[str]] = None,
             order: Optional[pulumi.Input[int]] = None,
             port: Optional[pulumi.Input[int]] = None,
             precision_horz: Optional[pulumi.Input[float]] = None,
             precision_vert: Optional[pulumi.Input[float]] = None,
             preference: Optional[pulumi.Input[int]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             proto: Optional[pulumi.Input[str]] = None,
             protocol: Optional[pulumi.Input[int]] = None,
             public_key: Optional[pulumi.Input[str]] = None,
             regex: Optional[pulumi.Input[str]] = None,
             replacement: Optional[pulumi.Input[str]] = None,
             selector: Optional[pulumi.Input[int]] = None,
             service: Optional[pulumi.Input[str]] = None,
             size: Optional[pulumi.Input[float]] = None,
             tag: Optional[pulumi.Input[str]] = None,
             target: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[int]] = None,
             usage: Optional[pulumi.Input[int]] = None,
             value: Optional[pulumi.Input[str]] = None,
             weight: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if algorithm is not None:
            _setter("algorithm", algorithm)
        if altitude is not None:
            _setter("altitude", altitude)
        if certificate is not None:
            _setter("certificate", certificate)
        if content is not None:
            _setter("content", content)
        if digest is not None:
            _setter("digest", digest)
        if digest_type is not None:
            _setter("digest_type", digest_type)
        if fingerprint is not None:
            _setter("fingerprint", fingerprint)
        if flags is not None:
            _setter("flags", flags)
        if key_tag is not None:
            _setter("key_tag", key_tag)
        if lat_degrees is not None:
            _setter("lat_degrees", lat_degrees)
        if lat_direction is not None:
            _setter("lat_direction", lat_direction)
        if lat_minutes is not None:
            _setter("lat_minutes", lat_minutes)
        if lat_seconds is not None:
            _setter("lat_seconds", lat_seconds)
        if long_degrees is not None:
            _setter("long_degrees", long_degrees)
        if long_direction is not None:
            _setter("long_direction", long_direction)
        if long_minutes is not None:
            _setter("long_minutes", long_minutes)
        if long_seconds is not None:
            _setter("long_seconds", long_seconds)
        if matching_type is not None:
            _setter("matching_type", matching_type)
        if name is not None:
            _setter("name", name)
        if order is not None:
            _setter("order", order)
        if port is not None:
            _setter("port", port)
        if precision_horz is not None:
            _setter("precision_horz", precision_horz)
        if precision_vert is not None:
            _setter("precision_vert", precision_vert)
        if preference is not None:
            _setter("preference", preference)
        if priority is not None:
            _setter("priority", priority)
        if proto is not None:
            _setter("proto", proto)
        if protocol is not None:
            _setter("protocol", protocol)
        if public_key is not None:
            _setter("public_key", public_key)
        if regex is not None:
            _setter("regex", regex)
        if replacement is not None:
            _setter("replacement", replacement)
        if selector is not None:
            _setter("selector", selector)
        if service is not None:
            _setter("service", service)
        if size is not None:
            _setter("size", size)
        if tag is not None:
            _setter("tag", tag)
        if target is not None:
            _setter("target", target)
        if type is not None:
            _setter("type", type)
        if usage is not None:
            _setter("usage", usage)
        if value is not None:
            _setter("value", value)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def altitude(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "altitude")

    @altitude.setter
    def altitude(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "altitude", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "digest", value)

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "digest_type")

    @digest_type.setter
    def digest_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "digest_type", value)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "key_tag")

    @key_tag.setter
    def key_tag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "key_tag", value)

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lat_degrees")

    @lat_degrees.setter
    def lat_degrees(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lat_degrees", value)

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lat_direction")

    @lat_direction.setter
    def lat_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lat_direction", value)

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lat_minutes")

    @lat_minutes.setter
    def lat_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lat_minutes", value)

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "lat_seconds")

    @lat_seconds.setter
    def lat_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lat_seconds", value)

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "long_degrees")

    @long_degrees.setter
    def long_degrees(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "long_degrees", value)

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "long_direction")

    @long_direction.setter
    def long_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_direction", value)

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "long_minutes")

    @long_minutes.setter
    def long_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "long_minutes", value)

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "long_seconds")

    @long_seconds.setter
    def long_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_seconds", value)

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "matching_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "precision_horz")

    @precision_horz.setter
    def precision_horz(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision_horz", value)

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "precision_vert")

    @precision_vert.setter
    def precision_vert(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision_vert", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def proto(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proto")

    @proto.setter
    def proto(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proto", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class RulesetRuleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None,
                 action_parameters: Optional[pulumi.Input['RulesetRuleActionParametersArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exposed_credential_check: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 last_updated: Optional[pulumi.Input[str]] = None,
                 logging: Optional[pulumi.Input['RulesetRuleLoggingArgs']] = None,
                 ratelimit: Optional[pulumi.Input['RulesetRuleRatelimitArgs']] = None,
                 ref: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] action: Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param pulumi.Input['RulesetRuleActionParametersArgs'] action_parameters: List of parameters that configure the behavior of the ruleset rule action.
        :param pulumi.Input[str] description: Brief summary of the ruleset rule and its intended use.
        :param pulumi.Input[bool] enabled: Whether the rule is active.
        :param pulumi.Input['RulesetRuleExposedCredentialCheckArgs'] exposed_credential_check: List of parameters that configure exposed credential checks.
        :param pulumi.Input[str] id: Unique rule identifier.
        :param pulumi.Input[str] last_updated: The most recent update to this rule.
        :param pulumi.Input['RulesetRuleLoggingArgs'] logging: List parameters to configure how the rule generates logs.
        :param pulumi.Input['RulesetRuleRatelimitArgs'] ratelimit: List of parameters that configure HTTP rate limiting behaviour.
        :param pulumi.Input[str] ref: Rule reference.
        :param pulumi.Input[str] version: Version of the ruleset to deploy.
        """
        RulesetRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            action=action,
            action_parameters=action_parameters,
            description=description,
            enabled=enabled,
            exposed_credential_check=exposed_credential_check,
            id=id,
            last_updated=last_updated,
            logging=logging,
            ratelimit=ratelimit,
            ref=ref,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: pulumi.Input[str],
             action: Optional[pulumi.Input[str]] = None,
             action_parameters: Optional[pulumi.Input['RulesetRuleActionParametersArgs']] = None,
             description: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             exposed_credential_check: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']] = None,
             id: Optional[pulumi.Input[str]] = None,
             last_updated: Optional[pulumi.Input[str]] = None,
             logging: Optional[pulumi.Input['RulesetRuleLoggingArgs']] = None,
             ratelimit: Optional[pulumi.Input['RulesetRuleRatelimitArgs']] = None,
             ref: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if action is not None:
            _setter("action", action)
        if action_parameters is not None:
            _setter("action_parameters", action_parameters)
        if description is not None:
            _setter("description", description)
        if enabled is not None:
            _setter("enabled", enabled)
        if exposed_credential_check is not None:
            _setter("exposed_credential_check", exposed_credential_check)
        if id is not None:
            _setter("id", id)
        if last_updated is not None:
            _setter("last_updated", last_updated)
        if logging is not None:
            _setter("logging", logging)
        if ratelimit is not None:
            _setter("ratelimit", ratelimit)
        if ref is not None:
            _setter("ref", ref)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional[pulumi.Input['RulesetRuleActionParametersArgs']]:
        """
        List of parameters that configure the behavior of the ruleset rule action.
        """
        return pulumi.get(self, "action_parameters")

    @action_parameters.setter
    def action_parameters(self, value: Optional[pulumi.Input['RulesetRuleActionParametersArgs']]):
        pulumi.set(self, "action_parameters", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Brief summary of the ruleset rule and its intended use.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']]:
        """
        List of parameters that configure exposed credential checks.
        """
        return pulumi.get(self, "exposed_credential_check")

    @exposed_credential_check.setter
    def exposed_credential_check(self, value: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']]):
        pulumi.set(self, "exposed_credential_check", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The most recent update to this rule.
        """
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['RulesetRuleLoggingArgs']]:
        """
        List parameters to configure how the rule generates logs.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['RulesetRuleLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional[pulumi.Input['RulesetRuleRatelimitArgs']]:
        """
        List of parameters that configure HTTP rate limiting behaviour.
        """
        return pulumi.get(self, "ratelimit")

    @ratelimit.setter
    def ratelimit(self, value: Optional[pulumi.Input['RulesetRuleRatelimitArgs']]):
        pulumi.set(self, "ratelimit", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[str]]:
        """
        Rule reference.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the ruleset to deploy.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class RulesetRuleActionParametersArgs:
    def __init__(__self__, *,
                 algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[bool]] = None,
                 autominifies: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]]] = None,
                 bic: Optional[pulumi.Input[bool]] = None,
                 browser_ttl: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']] = None,
                 cache: Optional[pulumi.Input[bool]] = None,
                 cache_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 cookie_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disable_apps: Optional[pulumi.Input[bool]] = None,
                 disable_railgun: Optional[pulumi.Input[bool]] = None,
                 disable_zaraz: Optional[pulumi.Input[bool]] = None,
                 edge_ttl: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']] = None,
                 email_obfuscation: Optional[pulumi.Input[bool]] = None,
                 from_list: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']] = None,
                 from_value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 hotlink_protection: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 increment: Optional[pulumi.Input[int]] = None,
                 matched_data: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']] = None,
                 mirage: Optional[pulumi.Input[bool]] = None,
                 opportunistic_encryption: Optional[pulumi.Input[bool]] = None,
                 origin: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']] = None,
                 origin_cache_control: Optional[pulumi.Input[bool]] = None,
                 origin_error_page_passthru: Optional[pulumi.Input[bool]] = None,
                 overrides: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']] = None,
                 phases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 read_timeout: Optional[pulumi.Input[int]] = None,
                 request_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 respect_strong_etags: Optional[pulumi.Input[bool]] = None,
                 response_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 responses: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]]] = None,
                 rocket_loader: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ruleset: Optional[pulumi.Input[str]] = None,
                 rulesets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 serve_stale: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']] = None,
                 server_side_excludes: Optional[pulumi.Input[bool]] = None,
                 sni: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 sxg: Optional[pulumi.Input[bool]] = None,
                 uri: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]] algorithms: Compression algorithms to use in order of preference.
        :param pulumi.Input[bool] automatic_https_rewrites: Turn on or off Cloudflare Automatic HTTPS rewrites.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]] autominifies: Indicate which file extensions to minify automatically.
        :param pulumi.Input[bool] bic: Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        :param pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs'] browser_ttl: List of browser TTL parameters to apply to the request.
        :param pulumi.Input[bool] cache: Whether to cache if expression matches.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyArgs'] cache_key: List of cache key parameters to apply to the request.
        :param pulumi.Input[str] content: Content of the custom error response.
        :param pulumi.Input[str] content_type: Content-Type of the custom error response.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cookie_fields: List of cookie values to include as part of custom fields logging.
        :param pulumi.Input[bool] disable_apps: Turn off all active Cloudflare Apps.
        :param pulumi.Input[bool] disable_railgun: Turn off railgun feature of the Cloudflare Speed app.
        :param pulumi.Input[bool] disable_zaraz: Turn off zaraz feature.
        :param pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs'] edge_ttl: List of edge TTL parameters to apply to the request.
        :param pulumi.Input[bool] email_obfuscation: Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        :param pulumi.Input['RulesetRuleActionParametersFromListArgs'] from_list: Use a list to lookup information for the action.
        :param pulumi.Input['RulesetRuleActionParametersFromValueArgs'] from_value: Use a value to lookup information for the action.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]] headers: List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
        :param pulumi.Input[str] host_header: Host Header that request origin receives.
        :param pulumi.Input[bool] hotlink_protection: Turn on or off the hotlink protection feature.
        :param pulumi.Input[str] id: Identifier of the action parameter to modify.
        :param pulumi.Input['RulesetRuleActionParametersMatchedDataArgs'] matched_data: List of properties to configure WAF payload logging.
        :param pulumi.Input[bool] mirage: Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        :param pulumi.Input[bool] opportunistic_encryption: Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        :param pulumi.Input['RulesetRuleActionParametersOriginArgs'] origin: List of properties to change request origin.
        :param pulumi.Input[bool] origin_cache_control: Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
        :param pulumi.Input[bool] origin_error_page_passthru: Pass-through error page for origin.
        :param pulumi.Input['RulesetRuleActionParametersOverridesArgs'] overrides: List of override configurations to apply to the ruleset.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] phases: Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        :param pulumi.Input[str] polish: Apply options from the Polish feature of the Cloudflare Speed app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] products: Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
        :param pulumi.Input[int] read_timeout: Specifies a maximum timeout for reading content from an origin server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] request_fields: List of request headers to include as part of custom fields logging, in lowercase.
        :param pulumi.Input[bool] respect_strong_etags: Respect strong ETags.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] response_fields: List of response headers to include as part of custom fields logging, in lowercase.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]] responses: List of parameters that configure the response given to end users.
        :param pulumi.Input[bool] rocket_loader: Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] rules: List of rule-based overrides.
        :param pulumi.Input[str] ruleset: Which ruleset ID to target.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] rulesets: List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
        :param pulumi.Input[str] security_level: Control options for the Security Level feature from the Security app.
        :param pulumi.Input['RulesetRuleActionParametersServeStaleArgs'] serve_stale: List of serve stale parameters to apply to the request.
        :param pulumi.Input[bool] server_side_excludes: Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        :param pulumi.Input['RulesetRuleActionParametersSniArgs'] sni: List of properties to manange Server Name Indication.
        :param pulumi.Input[str] ssl: Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        :param pulumi.Input[int] status_code: Status code for which the edge TTL is applied.
        :param pulumi.Input[bool] sxg: Turn on or off the SXG feature.
        :param pulumi.Input['RulesetRuleActionParametersUriArgs'] uri: List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        :param pulumi.Input[str] version: Version of the ruleset to deploy.
        """
        RulesetRuleActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithms=algorithms,
            automatic_https_rewrites=automatic_https_rewrites,
            autominifies=autominifies,
            bic=bic,
            browser_ttl=browser_ttl,
            cache=cache,
            cache_key=cache_key,
            content=content,
            content_type=content_type,
            cookie_fields=cookie_fields,
            disable_apps=disable_apps,
            disable_railgun=disable_railgun,
            disable_zaraz=disable_zaraz,
            edge_ttl=edge_ttl,
            email_obfuscation=email_obfuscation,
            from_list=from_list,
            from_value=from_value,
            headers=headers,
            host_header=host_header,
            hotlink_protection=hotlink_protection,
            id=id,
            increment=increment,
            matched_data=matched_data,
            mirage=mirage,
            opportunistic_encryption=opportunistic_encryption,
            origin=origin,
            origin_cache_control=origin_cache_control,
            origin_error_page_passthru=origin_error_page_passthru,
            overrides=overrides,
            phases=phases,
            polish=polish,
            products=products,
            read_timeout=read_timeout,
            request_fields=request_fields,
            respect_strong_etags=respect_strong_etags,
            response_fields=response_fields,
            responses=responses,
            rocket_loader=rocket_loader,
            rules=rules,
            ruleset=ruleset,
            rulesets=rulesets,
            security_level=security_level,
            serve_stale=serve_stale,
            server_side_excludes=server_side_excludes,
            sni=sni,
            ssl=ssl,
            status_code=status_code,
            sxg=sxg,
            uri=uri,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]] = None,
             automatic_https_rewrites: Optional[pulumi.Input[bool]] = None,
             autominifies: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]]] = None,
             bic: Optional[pulumi.Input[bool]] = None,
             browser_ttl: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']] = None,
             cache: Optional[pulumi.Input[bool]] = None,
             cache_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']] = None,
             content: Optional[pulumi.Input[str]] = None,
             content_type: Optional[pulumi.Input[str]] = None,
             cookie_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             disable_apps: Optional[pulumi.Input[bool]] = None,
             disable_railgun: Optional[pulumi.Input[bool]] = None,
             disable_zaraz: Optional[pulumi.Input[bool]] = None,
             edge_ttl: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']] = None,
             email_obfuscation: Optional[pulumi.Input[bool]] = None,
             from_list: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']] = None,
             from_value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']] = None,
             headers: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]]] = None,
             host_header: Optional[pulumi.Input[str]] = None,
             hotlink_protection: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             increment: Optional[pulumi.Input[int]] = None,
             matched_data: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']] = None,
             mirage: Optional[pulumi.Input[bool]] = None,
             opportunistic_encryption: Optional[pulumi.Input[bool]] = None,
             origin: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']] = None,
             origin_cache_control: Optional[pulumi.Input[bool]] = None,
             origin_error_page_passthru: Optional[pulumi.Input[bool]] = None,
             overrides: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']] = None,
             phases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             polish: Optional[pulumi.Input[str]] = None,
             products: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             read_timeout: Optional[pulumi.Input[int]] = None,
             request_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             respect_strong_etags: Optional[pulumi.Input[bool]] = None,
             response_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             responses: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]]] = None,
             rocket_loader: Optional[pulumi.Input[bool]] = None,
             rules: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             ruleset: Optional[pulumi.Input[str]] = None,
             rulesets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             security_level: Optional[pulumi.Input[str]] = None,
             serve_stale: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']] = None,
             server_side_excludes: Optional[pulumi.Input[bool]] = None,
             sni: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']] = None,
             ssl: Optional[pulumi.Input[str]] = None,
             status_code: Optional[pulumi.Input[int]] = None,
             sxg: Optional[pulumi.Input[bool]] = None,
             uri: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if algorithms is not None:
            _setter("algorithms", algorithms)
        if automatic_https_rewrites is not None:
            _setter("automatic_https_rewrites", automatic_https_rewrites)
        if autominifies is not None:
            _setter("autominifies", autominifies)
        if bic is not None:
            _setter("bic", bic)
        if browser_ttl is not None:
            _setter("browser_ttl", browser_ttl)
        if cache is not None:
            _setter("cache", cache)
        if cache_key is not None:
            _setter("cache_key", cache_key)
        if content is not None:
            _setter("content", content)
        if content_type is not None:
            _setter("content_type", content_type)
        if cookie_fields is not None:
            _setter("cookie_fields", cookie_fields)
        if disable_apps is not None:
            _setter("disable_apps", disable_apps)
        if disable_railgun is not None:
            _setter("disable_railgun", disable_railgun)
        if disable_zaraz is not None:
            _setter("disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            _setter("edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            _setter("email_obfuscation", email_obfuscation)
        if from_list is not None:
            _setter("from_list", from_list)
        if from_value is not None:
            _setter("from_value", from_value)
        if headers is not None:
            _setter("headers", headers)
        if host_header is not None:
            _setter("host_header", host_header)
        if hotlink_protection is not None:
            _setter("hotlink_protection", hotlink_protection)
        if id is not None:
            _setter("id", id)
        if increment is not None:
            _setter("increment", increment)
        if matched_data is not None:
            _setter("matched_data", matched_data)
        if mirage is not None:
            _setter("mirage", mirage)
        if opportunistic_encryption is not None:
            _setter("opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            _setter("origin", origin)
        if origin_cache_control is not None:
            _setter("origin_cache_control", origin_cache_control)
        if origin_error_page_passthru is not None:
            _setter("origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            _setter("overrides", overrides)
        if phases is not None:
            _setter("phases", phases)
        if polish is not None:
            _setter("polish", polish)
        if products is not None:
            _setter("products", products)
        if read_timeout is not None:
            _setter("read_timeout", read_timeout)
        if request_fields is not None:
            _setter("request_fields", request_fields)
        if respect_strong_etags is not None:
            _setter("respect_strong_etags", respect_strong_etags)
        if response_fields is not None:
            _setter("response_fields", response_fields)
        if responses is not None:
            _setter("responses", responses)
        if rocket_loader is not None:
            _setter("rocket_loader", rocket_loader)
        if rules is not None:
            _setter("rules", rules)
        if ruleset is not None:
            _setter("ruleset", ruleset)
        if rulesets is not None:
            _setter("rulesets", rulesets)
        if security_level is not None:
            _setter("security_level", security_level)
        if serve_stale is not None:
            _setter("serve_stale", serve_stale)
        if server_side_excludes is not None:
            _setter("server_side_excludes", server_side_excludes)
        if sni is not None:
            _setter("sni", sni)
        if ssl is not None:
            _setter("ssl", ssl)
        if status_code is not None:
            _setter("status_code", status_code)
        if sxg is not None:
            _setter("sxg", sxg)
        if uri is not None:
            _setter("uri", uri)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]]:
        """
        Compression algorithms to use in order of preference.
        """
        return pulumi.get(self, "algorithms")

    @algorithms.setter
    def algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]]):
        pulumi.set(self, "algorithms", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Cloudflare Automatic HTTPS rewrites.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter
    def autominifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]]]:
        """
        Indicate which file extensions to minify automatically.
        """
        return pulumi.get(self, "autominifies")

    @autominifies.setter
    def autominifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]]]):
        pulumi.set(self, "autominifies", value)

    @property
    @pulumi.getter
    def bic(self) -> Optional[pulumi.Input[bool]]:
        """
        Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        """
        return pulumi.get(self, "bic")

    @bic.setter
    def bic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bic", value)

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']]:
        """
        List of browser TTL parameters to apply to the request.
        """
        return pulumi.get(self, "browser_ttl")

    @browser_ttl.setter
    def browser_ttl(self, value: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']]):
        pulumi.set(self, "browser_ttl", value)

    @property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to cache if expression matches.
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache", value)

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']]:
        """
        List of cache key parameters to apply to the request.
        """
        return pulumi.get(self, "cache_key")

    @cache_key.setter
    def cache_key(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']]):
        pulumi.set(self, "cache_key", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Content of the custom error response.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        Content-Type of the custom error response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookie values to include as part of custom fields logging.
        """
        return pulumi.get(self, "cookie_fields")

    @cookie_fields.setter
    def cookie_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cookie_fields", value)

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off all active Cloudflare Apps.
        """
        return pulumi.get(self, "disable_apps")

    @disable_apps.setter
    def disable_apps(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_apps", value)

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off railgun feature of the Cloudflare Speed app.
        """
        return pulumi.get(self, "disable_railgun")

    @disable_railgun.setter
    def disable_railgun(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_railgun", value)

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off zaraz feature.
        """
        return pulumi.get(self, "disable_zaraz")

    @disable_zaraz.setter
    def disable_zaraz(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_zaraz", value)

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']]:
        """
        List of edge TTL parameters to apply to the request.
        """
        return pulumi.get(self, "edge_ttl")

    @edge_ttl.setter
    def edge_ttl(self, value: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']]):
        pulumi.set(self, "edge_ttl", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        """
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']]:
        """
        Use a list to lookup information for the action.
        """
        return pulumi.get(self, "from_list")

    @from_list.setter
    def from_list(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']]):
        pulumi.set(self, "from_list", value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']]:
        """
        Use a value to lookup information for the action.
        """
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']]):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]]]:
        """
        List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Host Header that request origin receives.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the hotlink protection feature.
        """
        return pulumi.get(self, "hotlink_protection")

    @hotlink_protection.setter
    def hotlink_protection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hotlink_protection", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the action parameter to modify.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def increment(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']]:
        """
        List of properties to configure WAF payload logging.
        """
        return pulumi.get(self, "matched_data")

    @matched_data.setter
    def matched_data(self, value: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']]):
        pulumi.set(self, "matched_data", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        """
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']]:
        """
        List of properties to change request origin.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter(name="originCacheControl")
    def origin_cache_control(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
        """
        return pulumi.get(self, "origin_cache_control")

    @origin_cache_control.setter
    def origin_cache_control(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_cache_control", value)

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[pulumi.Input[bool]]:
        """
        Pass-through error page for origin.
        """
        return pulumi.get(self, "origin_error_page_passthru")

    @origin_error_page_passthru.setter
    def origin_error_page_passthru(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_error_page_passthru", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']]:
        """
        List of override configurations to apply to the ruleset.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        """
        return pulumi.get(self, "phases")

    @phases.setter
    def phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "phases", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        """
        Apply options from the Polish feature of the Cloudflare Speed app.
        """
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a maximum timeout for reading content from an origin server.
        """
        return pulumi.get(self, "read_timeout")

    @read_timeout.setter
    def read_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_timeout", value)

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of request headers to include as part of custom fields logging, in lowercase.
        """
        return pulumi.get(self, "request_fields")

    @request_fields.setter
    def request_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "request_fields", value)

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[pulumi.Input[bool]]:
        """
        Respect strong ETags.
        """
        return pulumi.get(self, "respect_strong_etags")

    @respect_strong_etags.setter
    def respect_strong_etags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_strong_etags", value)

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of response headers to include as part of custom fields logging, in lowercase.
        """
        return pulumi.get(self, "response_fields")

    @response_fields.setter
    def response_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "response_fields", value)

    @property
    @pulumi.getter
    def responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]]]:
        """
        List of parameters that configure the response given to end users.
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseArgs']]]]):
        pulumi.set(self, "responses", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        """
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        List of rule-based overrides.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[pulumi.Input[str]]:
        """
        Which ruleset ID to target.
        """
        return pulumi.get(self, "ruleset")

    @ruleset.setter
    def ruleset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ruleset", value)

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
        """
        return pulumi.get(self, "rulesets")

    @rulesets.setter
    def rulesets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "rulesets", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Control options for the Security Level feature from the Security app.
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']]:
        """
        List of serve stale parameters to apply to the request.
        """
        return pulumi.get(self, "serve_stale")

    @serve_stale.setter
    def serve_stale(self, value: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']]):
        pulumi.set(self, "serve_stale", value)

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        """
        return pulumi.get(self, "server_side_excludes")

    @server_side_excludes.setter
    def server_side_excludes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_side_excludes", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']]:
        """
        List of properties to manange Server Name Indication.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        Status code for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def sxg(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the SXG feature.
        """
        return pulumi.get(self, "sxg")

    @sxg.setter
    def sxg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sxg", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']]:
        """
        List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the ruleset to deploy.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class RulesetRuleActionParametersAlgorithmArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
        """
        RulesetRuleActionParametersAlgorithmArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RulesetRuleActionParametersAutominifyArgs:
    def __init__(__self__, *,
                 css: Optional[pulumi.Input[bool]] = None,
                 html: Optional[pulumi.Input[bool]] = None,
                 js: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] css: CSS minification.
        :param pulumi.Input[bool] html: HTML minification.
        :param pulumi.Input[bool] js: JS minification.
        """
        RulesetRuleActionParametersAutominifyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            css=css,
            html=html,
            js=js,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             css: Optional[pulumi.Input[bool]] = None,
             html: Optional[pulumi.Input[bool]] = None,
             js: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if css is not None:
            _setter("css", css)
        if html is not None:
            _setter("html", html)
        if js is not None:
            _setter("js", js)

    @property
    @pulumi.getter
    def css(self) -> Optional[pulumi.Input[bool]]:
        """
        CSS minification.
        """
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> Optional[pulumi.Input[bool]]:
        """
        HTML minification.
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> Optional[pulumi.Input[bool]]:
        """
        JS minification.
        """
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "js", value)


@pulumi.input_type
class RulesetRuleActionParametersBrowserTtlArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 default: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        :param pulumi.Input[int] default: Default browser TTL. This value is required when override_origin is set
        """
        RulesetRuleActionParametersBrowserTtlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            default=default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: pulumi.Input[str],
             default: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mode", mode)
        if default is not None:
            _setter("default", default)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        Default browser TTL. This value is required when override_origin is set
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)


@pulumi.input_type
class RulesetRuleActionParametersCacheKeyArgs:
    def __init__(__self__, *,
                 cache_by_device_type: Optional[pulumi.Input[bool]] = None,
                 cache_deception_armor: Optional[pulumi.Input[bool]] = None,
                 custom_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']] = None,
                 ignore_query_strings_order: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] cache_by_device_type: Cache by device type.
        :param pulumi.Input[bool] cache_deception_armor: Cache deception armor.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs'] custom_key: Custom key parameters for the request.
        :param pulumi.Input[bool] ignore_query_strings_order: Ignore query strings order.
        """
        RulesetRuleActionParametersCacheKeyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_by_device_type=cache_by_device_type,
            cache_deception_armor=cache_deception_armor,
            custom_key=custom_key,
            ignore_query_strings_order=ignore_query_strings_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_by_device_type: Optional[pulumi.Input[bool]] = None,
             cache_deception_armor: Optional[pulumi.Input[bool]] = None,
             custom_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']] = None,
             ignore_query_strings_order: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cache_by_device_type is not None:
            _setter("cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            _setter("cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            _setter("custom_key", custom_key)
        if ignore_query_strings_order is not None:
            _setter("ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Cache by device type.
        """
        return pulumi.get(self, "cache_by_device_type")

    @cache_by_device_type.setter
    def cache_by_device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_by_device_type", value)

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[pulumi.Input[bool]]:
        """
        Cache deception armor.
        """
        return pulumi.get(self, "cache_deception_armor")

    @cache_deception_armor.setter
    def cache_deception_armor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_deception_armor", value)

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']]:
        """
        Custom key parameters for the request.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']]):
        pulumi.set(self, "custom_key", value)

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[pulumi.Input[bool]]:
        """
        Ignore query strings order.
        """
        return pulumi.get(self, "ignore_query_strings_order")

    @ignore_query_strings_order.setter
    def ignore_query_strings_order(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_query_strings_order", value)


@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']] = None,
                 header: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']] = None,
                 host: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']] = None,
                 query_string: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']] = None,
                 user: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs'] cookie: Cookie parameters for the custom key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs'] header: Header parameters for the custom key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs'] host: Host parameters for the custom key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs'] query_string: Query string parameters for the custom key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs'] user: User parameters for the custom key.
        """
        RulesetRuleActionParametersCacheKeyCustomKeyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cookie=cookie,
            header=header,
            host=host,
            query_string=query_string,
            user=user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cookie: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']] = None,
             header: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']] = None,
             host: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']] = None,
             query_string: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']] = None,
             user: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cookie is not None:
            _setter("cookie", cookie)
        if header is not None:
            _setter("header", header)
        if host is not None:
            _setter("host", host)
        if query_string is not None:
            _setter("query_string", query_string)
        if user is not None:
            _setter("user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']]:
        """
        Cookie parameters for the custom key.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']]:
        """
        Header parameters for the custom key.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']]:
        """
        Host parameters for the custom key.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']]:
        """
        Query string parameters for the custom key.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']]:
        """
        User parameters for the custom key.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: List of cookies to check for presence in the custom key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of cookies to include in the custom key.
        """
        RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check_presences=check_presences,
            includes=includes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if check_presences is not None:
            _setter("check_presences", check_presences)
        if includes is not None:
            _setter("includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookies to check for presence in the custom key.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookies to include in the custom key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_origin: Optional[pulumi.Input[bool]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: List of cookies to check for presence in the custom key.
        :param pulumi.Input[bool] exclude_origin: Exclude the origin header from the custom key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of cookies to include in the custom key.
        """
        RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check_presences=check_presences,
            exclude_origin=exclude_origin,
            includes=includes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             exclude_origin: Optional[pulumi.Input[bool]] = None,
             includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if check_presences is not None:
            _setter("check_presences", check_presences)
        if exclude_origin is not None:
            _setter("exclude_origin", exclude_origin)
        if includes is not None:
            _setter("includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookies to check for presence in the custom key.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Exclude the origin header from the custom key.
        """
        return pulumi.get(self, "exclude_origin")

    @exclude_origin.setter
    def exclude_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_origin", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookies to include in the custom key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyHostArgs:
    def __init__(__self__, *,
                 resolved: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] resolved: Resolve hostname to IP address.
        """
        RulesetRuleActionParametersCacheKeyCustomKeyHostArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resolved=resolved,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resolved: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if resolved is not None:
            _setter("resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input[bool]]:
        """
        Resolve hostname to IP address.
        """
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolved", value)


@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of query string parameters to exclude from the custom key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of cookies to include in the custom key.
        """
        RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excludes=excludes,
            includes=includes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if excludes is not None:
            _setter("excludes", excludes)
        if includes is not None:
            _setter("includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of query string parameters to exclude from the custom key.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cookies to include in the custom key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyUserArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[bool]] = None,
                 geo: Optional[pulumi.Input[bool]] = None,
                 lang: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] device_type: Add device type to the custom key.
        :param pulumi.Input[bool] geo: Add geo data to the custom key.
        :param pulumi.Input[bool] lang: Add language data to the custom key.
        """
        RulesetRuleActionParametersCacheKeyCustomKeyUserArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_type=device_type,
            geo=geo,
            lang=lang,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_type: Optional[pulumi.Input[bool]] = None,
             geo: Optional[pulumi.Input[bool]] = None,
             lang: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if device_type is not None:
            _setter("device_type", device_type)
        if geo is not None:
            _setter("geo", geo)
        if lang is not None:
            _setter("lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Add device type to the custom key.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input[bool]]:
        """
        Add geo data to the custom key.
        """
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[bool]]:
        """
        Add language data to the custom key.
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lang", value)


@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 default: Optional[pulumi.Input[int]] = None,
                 status_code_ttls: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]] = None):
        """
        :param pulumi.Input[str] mode: Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        :param pulumi.Input[int] default: Default browser TTL. This value is required when override_origin is set
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]] status_code_ttls: Edge TTL for the status codes.
        """
        RulesetRuleActionParametersEdgeTtlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            default=default,
            status_code_ttls=status_code_ttls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: pulumi.Input[str],
             default: Optional[pulumi.Input[int]] = None,
             status_code_ttls: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mode", mode)
        if default is not None:
            _setter("default", default)
        if status_code_ttls is not None:
            _setter("status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        Default browser TTL. This value is required when override_origin is set
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]]:
        """
        Edge TTL for the status codes.
        """
        return pulumi.get(self, "status_code_ttls")

    @status_code_ttls.setter
    def status_code_ttls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]]):
        pulumi.set(self, "status_code_ttls", value)


@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs:
    def __init__(__self__, *,
                 status_code: Optional[pulumi.Input[int]] = None,
                 status_code_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] status_code: Status code for which the edge TTL is applied.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]] status_code_ranges: Status code range for which the edge TTL is applied.
        :param pulumi.Input[int] value: Status code edge TTL value.
        """
        RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status_code=status_code,
            status_code_ranges=status_code_ranges,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status_code: Optional[pulumi.Input[int]] = None,
             status_code_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]]] = None,
             value: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if status_code is not None:
            _setter("status_code", status_code)
        if status_code_ranges is not None:
            _setter("status_code_ranges", status_code_ranges)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        Status code for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]]]:
        """
        Status code range for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code_ranges")

    @status_code_ranges.setter
    def status_code_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]]]):
        pulumi.set(self, "status_code_ranges", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[int]] = None,
                 to: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_: From status code.
        :param pulumi.Input[int] to: To status code.
        """
        RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[pulumi.Input[int]] = None,
             to: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[int]]:
        """
        From status code.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[int]]:
        """
        To status code.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class RulesetRuleActionParametersFromListArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Expression to use for the list lookup.
        :param pulumi.Input[str] name: Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
        """
        RulesetRuleActionParametersFromListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Expression to use for the list lookup.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RulesetRuleActionParametersFromValueArgs:
    def __init__(__self__, *,
                 preserve_query_string: Optional[pulumi.Input[bool]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 target_url: Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']] = None):
        """
        :param pulumi.Input[bool] preserve_query_string: Preserve query string for redirect URL.
        :param pulumi.Input[int] status_code: Status code for which the edge TTL is applied.
        :param pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs'] target_url: Target URL for redirect.
        """
        RulesetRuleActionParametersFromValueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preserve_query_string=preserve_query_string,
            status_code=status_code,
            target_url=target_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preserve_query_string: Optional[pulumi.Input[bool]] = None,
             status_code: Optional[pulumi.Input[int]] = None,
             target_url: Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if preserve_query_string is not None:
            _setter("preserve_query_string", preserve_query_string)
        if status_code is not None:
            _setter("status_code", status_code)
        if target_url is not None:
            _setter("target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Preserve query string for redirect URL.
        """
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_query_string", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        Status code for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']]:
        """
        Target URL for redirect.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']]):
        pulumi.set(self, "target_url", value)


@pulumi.input_type
class RulesetRuleActionParametersFromValueTargetUrlArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] value: Status code edge TTL value.
        """
        RulesetRuleActionParametersFromValueTargetUrlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if expression is not None:
            _setter("expression", expression)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionParametersHeaderArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 operation: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] name: Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
        :param pulumi.Input[str] operation: Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
        :param pulumi.Input[str] value: Status code edge TTL value.
        """
        RulesetRuleActionParametersHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            name=name,
            operation=operation,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             operation: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if expression is not None:
            _setter("expression", expression)
        if name is not None:
            _setter("name", name)
        if operation is not None:
            _setter("operation", operation)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionParametersMatchedDataArgs:
    def __init__(__self__, *,
                 public_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] public_key: Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
        RulesetRuleActionParametersMatchedDataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if public_key is not None:
            _setter("public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)


@pulumi.input_type
class RulesetRuleActionParametersOriginArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: Host parameters for the custom key.
        :param pulumi.Input[int] port: Origin Port where request is sent.
        """
        RulesetRuleActionParametersOriginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if host is not None:
            _setter("host", host)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host parameters for the custom key.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Origin Port where request is sent.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class RulesetRuleActionParametersOverridesArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]] categories: List of tag-based overrides.
        :param pulumi.Input[bool] enabled: Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]] rules: List of rule-based overrides.
        :param pulumi.Input[str] sensitivity_level: Sensitivity level for a ruleset rule override.
        """
        RulesetRuleActionParametersOverridesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            categories=categories,
            enabled=enabled,
            rules=rules,
            sensitivity_level=sensitivity_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[str]] = None,
             categories: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]] = None,
             sensitivity_level: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if action is not None:
            _setter("action", action)
        if categories is not None:
            _setter("categories", categories)
        if enabled is not None:
            _setter("enabled", enabled)
        if rules is not None:
            _setter("rules", rules)
        if sensitivity_level is not None:
            _setter("sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]]:
        """
        List of tag-based overrides.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]]:
        """
        List of rule-based overrides.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity level for a ruleset rule override.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


@pulumi.input_type
class RulesetRuleActionParametersOverridesCategoryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 category: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] action: Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param pulumi.Input[str] category: Tag name to apply the ruleset rule override to.
        :param pulumi.Input[bool] enabled: Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        RulesetRuleActionParametersOverridesCategoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            category=category,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[str]] = None,
             category: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if action is not None:
            _setter("action", action)
        if category is not None:
            _setter("category", category)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        Tag name to apply the ruleset rule override to.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class RulesetRuleActionParametersOverridesRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 score_threshold: Optional[pulumi.Input[int]] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param pulumi.Input[bool] enabled: Whether the rule is active.
        :param pulumi.Input[str] id: Unique rule identifier.
        :param pulumi.Input[int] score_threshold: Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        :param pulumi.Input[str] sensitivity_level: Sensitivity level for a ruleset rule override.
        """
        RulesetRuleActionParametersOverridesRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            enabled=enabled,
            id=id,
            score_threshold=score_threshold,
            sensitivity_level=sensitivity_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             score_threshold: Optional[pulumi.Input[int]] = None,
             sensitivity_level: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if action is not None:
            _setter("action", action)
        if enabled is not None:
            _setter("enabled", enabled)
        if id is not None:
            _setter("id", id)
        if score_threshold is not None:
            _setter("score_threshold", score_threshold)
        if sensitivity_level is not None:
            _setter("sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the rule is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        """
        return pulumi.get(self, "score_threshold")

    @score_threshold.setter
    def score_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "score_threshold", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity level for a ruleset rule override.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


@pulumi.input_type
class RulesetRuleActionParametersResponseArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] content: Content of the custom error response.
        :param pulumi.Input[str] content_type: Content-Type of the custom error response.
        :param pulumi.Input[int] status_code: Status code for which the edge TTL is applied.
        """
        RulesetRuleActionParametersResponseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            content_type=content_type,
            status_code=status_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: Optional[pulumi.Input[str]] = None,
             content_type: Optional[pulumi.Input[str]] = None,
             status_code: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if content is not None:
            _setter("content", content)
        if content_type is not None:
            _setter("content_type", content_type)
        if status_code is not None:
            _setter("status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Content of the custom error response.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        Content-Type of the custom error response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        Status code for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


@pulumi.input_type
class RulesetRuleActionParametersServeStaleArgs:
    def __init__(__self__, *,
                 disable_stale_while_updating: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable_stale_while_updating: Disable stale while updating.
        """
        RulesetRuleActionParametersServeStaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_stale_while_updating=disable_stale_while_updating,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_stale_while_updating: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if disable_stale_while_updating is not None:
            _setter("disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable stale while updating.
        """
        return pulumi.get(self, "disable_stale_while_updating")

    @disable_stale_while_updating.setter
    def disable_stale_while_updating(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_stale_while_updating", value)


@pulumi.input_type
class RulesetRuleActionParametersSniArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Status code edge TTL value.
        """
        RulesetRuleActionParametersSniArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionParametersUriArgs:
    def __init__(__self__, *,
                 origin: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']] = None,
                 query: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']] = None):
        """
        :param pulumi.Input[bool] origin: List of properties to change request origin.
        :param pulumi.Input['RulesetRuleActionParametersUriPathArgs'] path: URI path configuration when performing a URL rewrite.
        :param pulumi.Input['RulesetRuleActionParametersUriQueryArgs'] query: Query string configuration when performing a URL rewrite.
        """
        RulesetRuleActionParametersUriArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            origin=origin,
            path=path,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             origin: Optional[pulumi.Input[bool]] = None,
             path: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']] = None,
             query: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if origin is not None:
            _setter("origin", origin)
        if path is not None:
            _setter("path", path)
        if query is not None:
            _setter("query", query)

    @property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[bool]]:
        """
        List of properties to change request origin.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']]:
        """
        URI path configuration when performing a URL rewrite.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']]:
        """
        Query string configuration when performing a URL rewrite.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class RulesetRuleActionParametersUriPathArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] value: Status code edge TTL value.
        """
        RulesetRuleActionParametersUriPathArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if expression is not None:
            _setter("expression", expression)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionParametersUriQueryArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[str] value: Status code edge TTL value.
        """
        RulesetRuleActionParametersUriQueryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if expression is not None:
            _setter("expression", expression)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleExposedCredentialCheckArgs:
    def __init__(__self__, *,
                 password_expression: Optional[pulumi.Input[str]] = None,
                 username_expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        :param pulumi.Input[str] username_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        RulesetRuleExposedCredentialCheckArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_expression=password_expression,
            username_expression=username_expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_expression: Optional[pulumi.Input[str]] = None,
             username_expression: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if password_expression is not None:
            _setter("password_expression", password_expression)
        if username_expression is not None:
            _setter("username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "password_expression")

    @password_expression.setter
    def password_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_expression", value)

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "username_expression")

    @username_expression.setter
    def username_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_expression", value)


@pulumi.input_type
class RulesetRuleLoggingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        RulesetRuleLoggingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class RulesetRuleRatelimitArgs:
    def __init__(__self__, *,
                 requests_to_origin: pulumi.Input[bool],
                 characteristics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 counting_expression: Optional[pulumi.Input[str]] = None,
                 mitigation_timeout: Optional[pulumi.Input[int]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 requests_per_period: Optional[pulumi.Input[int]] = None,
                 score_per_period: Optional[pulumi.Input[int]] = None,
                 score_response_header_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] requests_to_origin: Whether to include requests to origin within the Rate Limiting count.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] characteristics: List of parameters that define how Cloudflare tracks the request rate for this rule.
        :param pulumi.Input[str] counting_expression: Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param pulumi.Input[int] mitigation_timeout: Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        :param pulumi.Input[int] period: The period of time to consider (in seconds) when evaluating the request rate.
        :param pulumi.Input[int] requests_per_period: The number of requests over the period of time that will trigger the Rate Limiting rule.
        :param pulumi.Input[int] score_per_period: The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        :param pulumi.Input[str] score_response_header_name: Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
        RulesetRuleRatelimitArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            requests_to_origin=requests_to_origin,
            characteristics=characteristics,
            counting_expression=counting_expression,
            mitigation_timeout=mitigation_timeout,
            period=period,
            requests_per_period=requests_per_period,
            score_per_period=score_per_period,
            score_response_header_name=score_response_header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             requests_to_origin: pulumi.Input[bool],
             characteristics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             counting_expression: Optional[pulumi.Input[str]] = None,
             mitigation_timeout: Optional[pulumi.Input[int]] = None,
             period: Optional[pulumi.Input[int]] = None,
             requests_per_period: Optional[pulumi.Input[int]] = None,
             score_per_period: Optional[pulumi.Input[int]] = None,
             score_response_header_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("requests_to_origin", requests_to_origin)
        if characteristics is not None:
            _setter("characteristics", characteristics)
        if counting_expression is not None:
            _setter("counting_expression", counting_expression)
        if mitigation_timeout is not None:
            _setter("mitigation_timeout", mitigation_timeout)
        if period is not None:
            _setter("period", period)
        if requests_per_period is not None:
            _setter("requests_per_period", requests_per_period)
        if score_per_period is not None:
            _setter("score_per_period", score_per_period)
        if score_response_header_name is not None:
            _setter("score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> pulumi.Input[bool]:
        """
        Whether to include requests to origin within the Rate Limiting count.
        """
        return pulumi.get(self, "requests_to_origin")

    @requests_to_origin.setter
    def requests_to_origin(self, value: pulumi.Input[bool]):
        pulumi.set(self, "requests_to_origin", value)

    @property
    @pulumi.getter
    def characteristics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of parameters that define how Cloudflare tracks the request rate for this rule.
        """
        return pulumi.get(self, "characteristics")

    @characteristics.setter
    def characteristics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "characteristics", value)

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "counting_expression")

    @counting_expression.setter
    def counting_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "counting_expression", value)

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        """
        return pulumi.get(self, "mitigation_timeout")

    @mitigation_timeout.setter
    def mitigation_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mitigation_timeout", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        The period of time to consider (in seconds) when evaluating the request rate.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[pulumi.Input[int]]:
        """
        The number of requests over the period of time that will trigger the Rate Limiting rule.
        """
        return pulumi.get(self, "requests_per_period")

    @requests_per_period.setter
    def requests_per_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "requests_per_period", value)

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        """
        return pulumi.get(self, "score_per_period")

    @score_per_period.setter
    def score_per_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "score_per_period", value)

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
        return pulumi.get(self, "score_response_header_name")

    @score_response_header_name.setter
    def score_response_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "score_response_header_name", value)


@pulumi.input_type
class SpectrumApplicationDnsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the DNS record associated with the application.
        :param pulumi.Input[str] type: The type of DNS record associated with the application.
        """
        SpectrumApplicationDnsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the DNS record associated with the application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of DNS record associated with the application.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SpectrumApplicationEdgeIpsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 connectivity: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        :param pulumi.Input[str] connectivity: The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
        SpectrumApplicationEdgeIpsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            connectivity=connectivity,
            ips=ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             connectivity: Optional[pulumi.Input[str]] = None,
             ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if connectivity is not None:
            _setter("connectivity", connectivity)
        if ips is not None:
            _setter("ips", ips)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def connectivity(self) -> Optional[pulumi.Input[str]]:
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        """
        return pulumi.get(self, "connectivity")

    @connectivity.setter
    def connectivity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connectivity", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)


@pulumi.input_type
class SpectrumApplicationOriginDnsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Fully qualified domain name of the origin.
        """
        SpectrumApplicationOriginDnsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Fully qualified domain name of the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SpectrumApplicationOriginPortRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[int],
                 start: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end: Upper bound of the origin port range.
        :param pulumi.Input[int] start: Lower bound of the origin port range.
        """
        SpectrumApplicationOriginPortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: pulumi.Input[int],
             start: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[int]:
        """
        Upper bound of the origin port range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[int]:
        """
        Lower bound of the origin port range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[int]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class SplitTunnelTunnelArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address for the tunnel.
        :param pulumi.Input[str] description: A description for the tunnel.
        :param pulumi.Input[str] host: The domain name for the tunnel.
        """
        SplitTunnelTunnelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            description=description,
            host=host,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             host: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if address is not None:
            _setter("address", address)
        if description is not None:
            _setter("description", description)
        if host is not None:
            _setter("host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address for the tunnel.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description for the tunnel.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name for the tunnel.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


@pulumi.input_type
class TeamsAccountAntivirusArgs:
    def __init__(__self__, *,
                 enabled_download_phase: pulumi.Input[bool],
                 enabled_upload_phase: pulumi.Input[bool],
                 fail_closed: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled_download_phase: Scan on file download.
        :param pulumi.Input[bool] enabled_upload_phase: Scan on file upload.
        :param pulumi.Input[bool] fail_closed: Block requests for files that cannot be scanned.
        """
        TeamsAccountAntivirusArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled_download_phase=enabled_download_phase,
            enabled_upload_phase=enabled_upload_phase,
            fail_closed=fail_closed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled_download_phase: pulumi.Input[bool],
             enabled_upload_phase: pulumi.Input[bool],
             fail_closed: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled_download_phase", enabled_download_phase)
        _setter("enabled_upload_phase", enabled_upload_phase)
        _setter("fail_closed", fail_closed)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> pulumi.Input[bool]:
        """
        Scan on file download.
        """
        return pulumi.get(self, "enabled_download_phase")

    @enabled_download_phase.setter
    def enabled_download_phase(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_download_phase", value)

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> pulumi.Input[bool]:
        """
        Scan on file upload.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @enabled_upload_phase.setter
    def enabled_upload_phase(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_upload_phase", value)

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> pulumi.Input[bool]:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @fail_closed.setter
    def fail_closed(self, value: pulumi.Input[bool]):
        pulumi.set(self, "fail_closed", value)


@pulumi.input_type
class TeamsAccountBlockPageArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None,
                 logo_path: Optional[pulumi.Input[str]] = None,
                 mailto_address: Optional[pulumi.Input[str]] = None,
                 mailto_subject: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_color: Hex code of block page background color.
        :param pulumi.Input[bool] enabled: Indicator of enablement.
        :param pulumi.Input[str] footer_text: Block page footer text.
        :param pulumi.Input[str] header_text: Block page header text.
        :param pulumi.Input[str] logo_path: URL of block page logo.
        :param pulumi.Input[str] mailto_address: Admin email for users to contact.
        :param pulumi.Input[str] mailto_subject: Subject line for emails created from block page.
        :param pulumi.Input[str] name: Name of block page configuration.
        """
        TeamsAccountBlockPageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            enabled=enabled,
            footer_text=footer_text,
            header_text=header_text,
            logo_path=logo_path,
            mailto_address=mailto_address,
            mailto_subject=mailto_subject,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             footer_text: Optional[pulumi.Input[str]] = None,
             header_text: Optional[pulumi.Input[str]] = None,
             logo_path: Optional[pulumi.Input[str]] = None,
             mailto_address: Optional[pulumi.Input[str]] = None,
             mailto_subject: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if enabled is not None:
            _setter("enabled", enabled)
        if footer_text is not None:
            _setter("footer_text", footer_text)
        if header_text is not None:
            _setter("header_text", header_text)
        if logo_path is not None:
            _setter("logo_path", logo_path)
        if mailto_address is not None:
            _setter("mailto_address", mailto_address)
        if mailto_subject is not None:
            _setter("mailto_subject", mailto_subject)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Hex code of block page background color.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicator of enablement.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[str]]:
        """
        URL of block page logo.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_path", value)

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[pulumi.Input[str]]:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @mailto_address.setter
    def mailto_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mailto_address", value)

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @mailto_subject.setter
    def mailto_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mailto_subject", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of block page configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class TeamsAccountFipsArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] tls: Only allow FIPS-compliant TLS configuration.
        """
        TeamsAccountFipsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if tls is not None:
            _setter("tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Only allow FIPS-compliant TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class TeamsAccountLoggingArgs:
    def __init__(__self__, *,
                 redact_pii: pulumi.Input[bool],
                 settings_by_rule_type: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs']):
        """
        :param pulumi.Input[bool] redact_pii: Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        :param pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs'] settings_by_rule_type: Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        TeamsAccountLoggingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redact_pii=redact_pii,
            settings_by_rule_type=settings_by_rule_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redact_pii: pulumi.Input[bool],
             settings_by_rule_type: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("redact_pii", redact_pii)
        _setter("settings_by_rule_type", settings_by_rule_type)

    @property
    @pulumi.getter(name="redactPii")
    def redact_pii(self) -> pulumi.Input[bool]:
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        """
        return pulumi.get(self, "redact_pii")

    @redact_pii.setter
    def redact_pii(self, value: pulumi.Input[bool]):
        pulumi.set(self, "redact_pii", value)

    @property
    @pulumi.getter(name="settingsByRuleType")
    def settings_by_rule_type(self) -> pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs']:
        """
        Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        return pulumi.get(self, "settings_by_rule_type")

    @settings_by_rule_type.setter
    def settings_by_rule_type(self, value: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeArgs']):
        pulumi.set(self, "settings_by_rule_type", value)


@pulumi.input_type
class TeamsAccountLoggingSettingsByRuleTypeArgs:
    def __init__(__self__, *,
                 dns: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs'],
                 http: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs'],
                 l4: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args']):
        """
        :param pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs'] dns: Logging configuration for DNS requests.
        :param pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs'] http: Logging configuration for HTTP requests.
        :param pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args'] l4: Logging configuration for layer 4 requests.
        """
        TeamsAccountLoggingSettingsByRuleTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns=dns,
            http=http,
            l4=l4,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs'],
             http: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs'],
             l4: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dns", dns)
        _setter("http", http)
        _setter("l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs']:
        """
        Logging configuration for DNS requests.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeDnsArgs']):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def http(self) -> pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs']:
        """
        Logging configuration for HTTP requests.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeHttpArgs']):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def l4(self) -> pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args']:
        """
        Logging configuration for layer 4 requests.
        """
        return pulumi.get(self, "l4")

    @l4.setter
    def l4(self, value: pulumi.Input['TeamsAccountLoggingSettingsByRuleTypeL4Args']):
        pulumi.set(self, "l4", value)


@pulumi.input_type
class TeamsAccountLoggingSettingsByRuleTypeDnsArgs:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        TeamsAccountLoggingSettingsByRuleTypeDnsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_all=log_all,
            log_blocks=log_blocks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_all: pulumi.Input[bool],
             log_blocks: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_all", log_all)
        _setter("log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


@pulumi.input_type
class TeamsAccountLoggingSettingsByRuleTypeHttpArgs:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        TeamsAccountLoggingSettingsByRuleTypeHttpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_all=log_all,
            log_blocks=log_blocks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_all: pulumi.Input[bool],
             log_blocks: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_all", log_all)
        _setter("log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


@pulumi.input_type
class TeamsAccountLoggingSettingsByRuleTypeL4Args:
    def __init__(__self__, *,
                 log_all: pulumi.Input[bool],
                 log_blocks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] log_all: Whether to log all activity.
        """
        TeamsAccountLoggingSettingsByRuleTypeL4Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_all=log_all,
            log_blocks=log_blocks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_all: pulumi.Input[bool],
             log_blocks: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_all", log_all)
        _setter("log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> pulumi.Input[bool]:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_all", value)

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "log_blocks", value)


@pulumi.input_type
class TeamsAccountPayloadLogArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: Public key used to encrypt matched payloads.
        """
        TeamsAccountPayloadLogArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_key: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        Public key used to encrypt matched payloads.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)


@pulumi.input_type
class TeamsAccountProxyArgs:
    def __init__(__self__, *,
                 root_ca: pulumi.Input[bool],
                 tcp: pulumi.Input[bool],
                 udp: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] root_ca: Whether root ca is enabled account wide for ZT clients.
        :param pulumi.Input[bool] tcp: Whether gateway proxy is enabled on gateway devices for TCP traffic.
        :param pulumi.Input[bool] udp: Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        TeamsAccountProxyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            root_ca=root_ca,
            tcp=tcp,
            udp=udp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             root_ca: pulumi.Input[bool],
             tcp: pulumi.Input[bool],
             udp: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("root_ca", root_ca)
        _setter("tcp", tcp)
        _setter("udp", udp)

    @property
    @pulumi.getter(name="rootCa")
    def root_ca(self) -> pulumi.Input[bool]:
        """
        Whether root ca is enabled account wide for ZT clients.
        """
        return pulumi.get(self, "root_ca")

    @root_ca.setter
    def root_ca(self, value: pulumi.Input[bool]):
        pulumi.set(self, "root_ca", value)

    @property
    @pulumi.getter
    def tcp(self) -> pulumi.Input[bool]:
        """
        Whether gateway proxy is enabled on gateway devices for TCP traffic.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter
    def udp(self) -> pulumi.Input[bool]:
        """
        Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "udp", value)


@pulumi.input_type
class TeamsLocationNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network: CIDR notation representation of the network IP.
        :param pulumi.Input[str] id: The ID of this resource.
        """
        TeamsLocationNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network=network,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network", network)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class TeamsRuleRuleSettingsArgs:
    def __init__(__self__, *,
                 add_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allow_child_bypass: Optional[pulumi.Input[bool]] = None,
                 audit_ssh: Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']] = None,
                 biso_admin_controls: Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']] = None,
                 block_page_enabled: Optional[pulumi.Input[bool]] = None,
                 block_page_reason: Optional[pulumi.Input[str]] = None,
                 bypass_parent_rule: Optional[pulumi.Input[bool]] = None,
                 check_session: Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']] = None,
                 egress: Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']] = None,
                 insecure_disable_dnssec_validation: Optional[pulumi.Input[bool]] = None,
                 ip_categories: Optional[pulumi.Input[bool]] = None,
                 l4override: Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']] = None,
                 override_host: Optional[pulumi.Input[str]] = None,
                 override_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 payload_log: Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']] = None,
                 untrusted_cert: Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] add_headers: Add custom headers to allowed requests in the form of key-value pairs.
        :param pulumi.Input[bool] allow_child_bypass: Allow parent MSP accounts to enable bypass their children's rules.
        :param pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs'] audit_ssh: Settings for auditing SSH usage.
        :param pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs'] biso_admin_controls: Configure how browser isolation behaves.
        :param pulumi.Input[bool] block_page_enabled: Indicator of block page enablement.
        :param pulumi.Input[str] block_page_reason: The displayed reason for a user being blocked.
        :param pulumi.Input[bool] bypass_parent_rule: Allow child MSP accounts to bypass their parent's rule.
        :param pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs'] check_session: Configure how session check behaves.
        :param pulumi.Input['TeamsRuleRuleSettingsEgressArgs'] egress: Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        :param pulumi.Input[bool] insecure_disable_dnssec_validation: Disable DNSSEC validation (must be Allow rule).
        :param pulumi.Input[bool] ip_categories: Turns on IP category based filter on dns if the rule contains dns category checks.
        :param pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs'] l4override: Settings to forward layer 4 traffic.
        :param pulumi.Input[str] override_host: The host to override matching DNS queries with.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] override_ips: The IPs to override matching DNS queries with.
        :param pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs'] payload_log: Configure DLP Payload Logging settings for this rule.
        :param pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs'] untrusted_cert: Configure untrusted certificate settings for this rule.
        """
        TeamsRuleRuleSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            add_headers=add_headers,
            allow_child_bypass=allow_child_bypass,
            audit_ssh=audit_ssh,
            biso_admin_controls=biso_admin_controls,
            block_page_enabled=block_page_enabled,
            block_page_reason=block_page_reason,
            bypass_parent_rule=bypass_parent_rule,
            check_session=check_session,
            egress=egress,
            insecure_disable_dnssec_validation=insecure_disable_dnssec_validation,
            ip_categories=ip_categories,
            l4override=l4override,
            override_host=override_host,
            override_ips=override_ips,
            payload_log=payload_log,
            untrusted_cert=untrusted_cert,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             add_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             allow_child_bypass: Optional[pulumi.Input[bool]] = None,
             audit_ssh: Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']] = None,
             biso_admin_controls: Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']] = None,
             block_page_enabled: Optional[pulumi.Input[bool]] = None,
             block_page_reason: Optional[pulumi.Input[str]] = None,
             bypass_parent_rule: Optional[pulumi.Input[bool]] = None,
             check_session: Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']] = None,
             egress: Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']] = None,
             insecure_disable_dnssec_validation: Optional[pulumi.Input[bool]] = None,
             ip_categories: Optional[pulumi.Input[bool]] = None,
             l4override: Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']] = None,
             override_host: Optional[pulumi.Input[str]] = None,
             override_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             payload_log: Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']] = None,
             untrusted_cert: Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if add_headers is not None:
            _setter("add_headers", add_headers)
        if allow_child_bypass is not None:
            _setter("allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            _setter("audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            _setter("biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            _setter("block_page_enabled", block_page_enabled)
        if block_page_reason is not None:
            _setter("block_page_reason", block_page_reason)
        if bypass_parent_rule is not None:
            _setter("bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            _setter("check_session", check_session)
        if egress is not None:
            _setter("egress", egress)
        if insecure_disable_dnssec_validation is not None:
            _setter("insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            _setter("ip_categories", ip_categories)
        if l4override is not None:
            _setter("l4override", l4override)
        if override_host is not None:
            _setter("override_host", override_host)
        if override_ips is not None:
            _setter("override_ips", override_ips)
        if payload_log is not None:
            _setter("payload_log", payload_log)
        if untrusted_cert is not None:
            _setter("untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        return pulumi.get(self, "add_headers")

    @add_headers.setter
    def add_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "add_headers", value)

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow parent MSP accounts to enable bypass their children's rules.
        """
        return pulumi.get(self, "allow_child_bypass")

    @allow_child_bypass.setter
    def allow_child_bypass(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_child_bypass", value)

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']]:
        """
        Settings for auditing SSH usage.
        """
        return pulumi.get(self, "audit_ssh")

    @audit_ssh.setter
    def audit_ssh(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']]):
        pulumi.set(self, "audit_ssh", value)

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']]:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @biso_admin_controls.setter
    def biso_admin_controls(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']]):
        pulumi.set(self, "biso_admin_controls", value)

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicator of block page enablement.
        """
        return pulumi.get(self, "block_page_enabled")

    @block_page_enabled.setter
    def block_page_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_page_enabled", value)

    @property
    @pulumi.getter(name="blockPageReason")
    def block_page_reason(self) -> Optional[pulumi.Input[str]]:
        """
        The displayed reason for a user being blocked.
        """
        return pulumi.get(self, "block_page_reason")

    @block_page_reason.setter
    def block_page_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_page_reason", value)

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow child MSP accounts to bypass their parent's rule.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @bypass_parent_rule.setter
    def bypass_parent_rule(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_parent_rule", value)

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']]:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @check_session.setter
    def check_session(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']]):
        pulumi.set(self, "check_session", value)

    @property
    @pulumi.getter
    def egress(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']]:
        """
        Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        """
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']]):
        pulumi.set(self, "egress", value)

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable DNSSEC validation (must be Allow rule).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @insecure_disable_dnssec_validation.setter
    def insecure_disable_dnssec_validation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_disable_dnssec_validation", value)

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[pulumi.Input[bool]]:
        """
        Turns on IP category based filter on dns if the rule contains dns category checks.
        """
        return pulumi.get(self, "ip_categories")

    @ip_categories.setter
    def ip_categories(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_categories", value)

    @property
    @pulumi.getter
    def l4override(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']]:
        """
        Settings to forward layer 4 traffic.
        """
        return pulumi.get(self, "l4override")

    @l4override.setter
    def l4override(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']]):
        pulumi.set(self, "l4override", value)

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[pulumi.Input[str]]:
        """
        The host to override matching DNS queries with.
        """
        return pulumi.get(self, "override_host")

    @override_host.setter
    def override_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_host", value)

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The IPs to override matching DNS queries with.
        """
        return pulumi.get(self, "override_ips")

    @override_ips.setter
    def override_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "override_ips", value)

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']]:
        """
        Configure DLP Payload Logging settings for this rule.
        """
        return pulumi.get(self, "payload_log")

    @payload_log.setter
    def payload_log(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']]):
        pulumi.set(self, "payload_log", value)

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']]:
        """
        Configure untrusted certificate settings for this rule.
        """
        return pulumi.get(self, "untrusted_cert")

    @untrusted_cert.setter
    def untrusted_cert(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']]):
        pulumi.set(self, "untrusted_cert", value)


@pulumi.input_type
class TeamsRuleRuleSettingsAuditSshArgs:
    def __init__(__self__, *,
                 command_logging: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] command_logging: Log all SSH commands.
        """
        TeamsRuleRuleSettingsAuditSshArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command_logging=command_logging,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command_logging: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> pulumi.Input[bool]:
        """
        Log all SSH commands.
        """
        return pulumi.get(self, "command_logging")

    @command_logging.setter
    def command_logging(self, value: pulumi.Input[bool]):
        pulumi.set(self, "command_logging", value)


@pulumi.input_type
class TeamsRuleRuleSettingsBisoAdminControlsArgs:
    def __init__(__self__, *,
                 disable_copy_paste: Optional[pulumi.Input[bool]] = None,
                 disable_download: Optional[pulumi.Input[bool]] = None,
                 disable_keyboard: Optional[pulumi.Input[bool]] = None,
                 disable_printing: Optional[pulumi.Input[bool]] = None,
                 disable_upload: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable_copy_paste: Disable copy-paste.
        :param pulumi.Input[bool] disable_download: Disable download.
        :param pulumi.Input[bool] disable_keyboard: Disable keyboard usage.
        :param pulumi.Input[bool] disable_printing: Disable printing.
        :param pulumi.Input[bool] disable_upload: Disable upload.
        """
        TeamsRuleRuleSettingsBisoAdminControlsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_copy_paste=disable_copy_paste,
            disable_download=disable_download,
            disable_keyboard=disable_keyboard,
            disable_printing=disable_printing,
            disable_upload=disable_upload,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_copy_paste: Optional[pulumi.Input[bool]] = None,
             disable_download: Optional[pulumi.Input[bool]] = None,
             disable_keyboard: Optional[pulumi.Input[bool]] = None,
             disable_printing: Optional[pulumi.Input[bool]] = None,
             disable_upload: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if disable_copy_paste is not None:
            _setter("disable_copy_paste", disable_copy_paste)
        if disable_download is not None:
            _setter("disable_download", disable_download)
        if disable_keyboard is not None:
            _setter("disable_keyboard", disable_keyboard)
        if disable_printing is not None:
            _setter("disable_printing", disable_printing)
        if disable_upload is not None:
            _setter("disable_upload", disable_upload)

    @property
    @pulumi.getter(name="disableCopyPaste")
    def disable_copy_paste(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable copy-paste.
        """
        return pulumi.get(self, "disable_copy_paste")

    @disable_copy_paste.setter
    def disable_copy_paste(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_copy_paste", value)

    @property
    @pulumi.getter(name="disableDownload")
    def disable_download(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable download.
        """
        return pulumi.get(self, "disable_download")

    @disable_download.setter
    def disable_download(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_download", value)

    @property
    @pulumi.getter(name="disableKeyboard")
    def disable_keyboard(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable keyboard usage.
        """
        return pulumi.get(self, "disable_keyboard")

    @disable_keyboard.setter
    def disable_keyboard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_keyboard", value)

    @property
    @pulumi.getter(name="disablePrinting")
    def disable_printing(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable printing.
        """
        return pulumi.get(self, "disable_printing")

    @disable_printing.setter
    def disable_printing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_printing", value)

    @property
    @pulumi.getter(name="disableUpload")
    def disable_upload(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable upload.
        """
        return pulumi.get(self, "disable_upload")

    @disable_upload.setter
    def disable_upload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_upload", value)


@pulumi.input_type
class TeamsRuleRuleSettingsCheckSessionArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 enforce: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] duration: Configure how fresh the session needs to be to be considered valid.
        :param pulumi.Input[bool] enforce: Enable session enforcement for this rule.
        """
        TeamsRuleRuleSettingsCheckSessionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
            enforce=enforce,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: pulumi.Input[str],
             enforce: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("duration", duration)
        _setter("enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def enforce(self) -> pulumi.Input[bool]:
        """
        Enable session enforcement for this rule.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enforce", value)


@pulumi.input_type
class TeamsRuleRuleSettingsEgressArgs:
    def __init__(__self__, *,
                 ipv4: pulumi.Input[str],
                 ipv6: pulumi.Input[str],
                 ipv4_fallback: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv4: The IPv4 address to be used for egress.
        :param pulumi.Input[str] ipv6: The IPv6 range to be used for egress.
        :param pulumi.Input[str] ipv4_fallback: The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        TeamsRuleRuleSettingsEgressArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv4=ipv4,
            ipv6=ipv6,
            ipv4_fallback=ipv4_fallback,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv4: pulumi.Input[str],
             ipv6: pulumi.Input[str],
             ipv4_fallback: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ipv4", ipv4)
        _setter("ipv6", ipv6)
        if ipv4_fallback is not None:
            _setter("ipv4_fallback", ipv4_fallback)

    @property
    @pulumi.getter
    def ipv4(self) -> pulumi.Input[str]:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> pulumi.Input[str]:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @ipv4_fallback.setter
    def ipv4_fallback(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_fallback", value)


@pulumi.input_type
class TeamsRuleRuleSettingsL4overrideArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: pulumi.Input[int]):
        """
        :param pulumi.Input[str] ip: Override IP to forward traffic to.
        :param pulumi.Input[int] port: Override Port to forward traffic to.
        """
        TeamsRuleRuleSettingsL4overrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: pulumi.Input[str],
             port: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip", ip)
        _setter("port", port)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        Override IP to forward traffic to.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Override Port to forward traffic to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class TeamsRuleRuleSettingsPayloadLogArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Enable or disable DLP Payload Logging for this rule.
        """
        TeamsRuleRuleSettingsPayloadLogArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Enable or disable DLP Payload Logging for this rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class TeamsRuleRuleSettingsUntrustedCertArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        TeamsRuleRuleSettingsUntrustedCertArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if action is not None:
            _setter("action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


@pulumi.input_type
class TunnelConfigConfigArgs:
    def __init__(__self__, *,
                 ingress_rules: pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]],
                 origin_request: Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']] = None,
                 warp_routing: Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]] ingress_rules: Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        :param pulumi.Input['TunnelConfigConfigWarpRoutingArgs'] warp_routing: If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        TunnelConfigConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ingress_rules=ingress_rules,
            origin_request=origin_request,
            warp_routing=warp_routing,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ingress_rules: pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]],
             origin_request: Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']] = None,
             warp_routing: Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ingress_rules", ingress_rules)
        if origin_request is not None:
            _setter("origin_request", origin_request)
        if warp_routing is not None:
            _setter("warp_routing", warp_routing)

    @property
    @pulumi.getter(name="ingressRules")
    def ingress_rules(self) -> pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]]:
        """
        Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        """
        return pulumi.get(self, "ingress_rules")

    @ingress_rules.setter
    def ingress_rules(self, value: pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleArgs']]]):
        pulumi.set(self, "ingress_rules", value)

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']]:
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']]:
        """
        If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        return pulumi.get(self, "warp_routing")

    @warp_routing.setter
    def warp_routing(self, value: Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']]):
        pulumi.set(self, "warp_routing", value)


@pulumi.input_type
class TunnelConfigConfigIngressRuleArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 hostname: Optional[pulumi.Input[str]] = None,
                 origin_request: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestArgs']] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service: Name of the service to which the request will be sent.
        :param pulumi.Input[str] hostname: Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        :param pulumi.Input[str] path: Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        TunnelConfigConfigIngressRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service=service,
            hostname=hostname,
            origin_request=origin_request,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service: pulumi.Input[str],
             hostname: Optional[pulumi.Input[str]] = None,
             origin_request: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestArgs']] = None,
             path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("service", service)
        if hostname is not None:
            _setter("hostname", hostname)
        if origin_request is not None:
            _setter("origin_request", origin_request)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Name of the service to which the request will be sent.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestArgs']]:
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class TunnelConfigConfigIngressRuleOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs']] = None,
                 bastion_mode: Optional[pulumi.Input[bool]] = None,
                 ca_pool: Optional[pulumi.Input[str]] = None,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
                 http2_origin: Optional[pulumi.Input[bool]] = None,
                 http_host_header: Optional[pulumi.Input[str]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]]] = None,
                 keep_alive_connections: Optional[pulumi.Input[int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[str]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None,
                 origin_server_name: Optional[pulumi.Input[str]] = None,
                 proxy_address: Optional[pulumi.Input[str]] = None,
                 proxy_port: Optional[pulumi.Input[int]] = None,
                 proxy_type: Optional[pulumi.Input[str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[str]] = None,
                 tls_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs'] access: Access rules for the ingress service.
        :param pulumi.Input[bool] bastion_mode: Runs as jump host.
        :param pulumi.Input[str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param pulumi.Input[str] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param pulumi.Input[bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param pulumi.Input[bool] http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param pulumi.Input[str] http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]] ip_rules: IP rules for the proxy service.
        :param pulumi.Input[int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param pulumi.Input[str] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param pulumi.Input[bool] no_happy_eyeballs: Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param pulumi.Input[bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param pulumi.Input[str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param pulumi.Input[str] proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param pulumi.Input[int] proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param pulumi.Input[str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param pulumi.Input[str] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param pulumi.Input[str] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        TunnelConfigConfigIngressRuleOriginRequestArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access=access,
            bastion_mode=bastion_mode,
            ca_pool=ca_pool,
            connect_timeout=connect_timeout,
            disable_chunked_encoding=disable_chunked_encoding,
            http2_origin=http2_origin,
            http_host_header=http_host_header,
            ip_rules=ip_rules,
            keep_alive_connections=keep_alive_connections,
            keep_alive_timeout=keep_alive_timeout,
            no_happy_eyeballs=no_happy_eyeballs,
            no_tls_verify=no_tls_verify,
            origin_server_name=origin_server_name,
            proxy_address=proxy_address,
            proxy_port=proxy_port,
            proxy_type=proxy_type,
            tcp_keep_alive=tcp_keep_alive,
            tls_timeout=tls_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs']] = None,
             bastion_mode: Optional[pulumi.Input[bool]] = None,
             ca_pool: Optional[pulumi.Input[str]] = None,
             connect_timeout: Optional[pulumi.Input[str]] = None,
             disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
             http2_origin: Optional[pulumi.Input[bool]] = None,
             http_host_header: Optional[pulumi.Input[str]] = None,
             ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]]] = None,
             keep_alive_connections: Optional[pulumi.Input[int]] = None,
             keep_alive_timeout: Optional[pulumi.Input[str]] = None,
             no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
             no_tls_verify: Optional[pulumi.Input[bool]] = None,
             origin_server_name: Optional[pulumi.Input[str]] = None,
             proxy_address: Optional[pulumi.Input[str]] = None,
             proxy_port: Optional[pulumi.Input[int]] = None,
             proxy_type: Optional[pulumi.Input[str]] = None,
             tcp_keep_alive: Optional[pulumi.Input[str]] = None,
             tls_timeout: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access is not None:
            _setter("access", access)
        if bastion_mode is not None:
            _setter("bastion_mode", bastion_mode)
        if ca_pool is not None:
            _setter("ca_pool", ca_pool)
        if connect_timeout is not None:
            _setter("connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            _setter("disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            _setter("http2_origin", http2_origin)
        if http_host_header is not None:
            _setter("http_host_header", http_host_header)
        if ip_rules is not None:
            _setter("ip_rules", ip_rules)
        if keep_alive_connections is not None:
            _setter("keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            _setter("keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            _setter("no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            _setter("no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            _setter("origin_server_name", origin_server_name)
        if proxy_address is not None:
            _setter("proxy_address", proxy_address)
        if proxy_port is not None:
            _setter("proxy_port", proxy_port)
        if proxy_type is not None:
            _setter("proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            _setter("tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            _setter("tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs']]:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @bastion_mode.setter
    def bastion_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bastion_mode", value)

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_pool", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_origin", value)

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_host_header", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]]]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_server_name", value)

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @proxy_address.setter
    def proxy_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_address", value)

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[pulumi.Input[int]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @proxy_port.setter
    def proxy_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "proxy_port", value)

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_type", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_timeout", value)


@pulumi.input_type
class TunnelConfigConfigIngressRuleOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 team_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aud_tags: Audience tags of the access rule.
        :param pulumi.Input[bool] required: Whether the access rule is required.
        :param pulumi.Input[str] team_name: Name of the team to which the access rule applies.
        """
        TunnelConfigConfigIngressRuleOriginRequestAccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aud_tags=aud_tags,
            required=required,
            team_name=team_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aud_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             required: Optional[pulumi.Input[bool]] = None,
             team_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aud_tags is not None:
            _setter("aud_tags", aud_tags)
        if required is not None:
            _setter("required", required)
        if team_name is not None:
            _setter("team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aud_tags", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)


@pulumi.input_type
class TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow: Whether to allow the IP prefix.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: Ports to use within the IP rule.
        :param pulumi.Input[str] prefix: IP rule prefix.
        """
        TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            ports=ports,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional[pulumi.Input[bool]] = None,
             ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow is not None:
            _setter("allow", allow)
        if ports is not None:
            _setter("ports", ports)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class TunnelConfigConfigOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']] = None,
                 bastion_mode: Optional[pulumi.Input[bool]] = None,
                 ca_pool: Optional[pulumi.Input[str]] = None,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
                 http2_origin: Optional[pulumi.Input[bool]] = None,
                 http_host_header: Optional[pulumi.Input[str]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]]] = None,
                 keep_alive_connections: Optional[pulumi.Input[int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[str]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None,
                 origin_server_name: Optional[pulumi.Input[str]] = None,
                 proxy_address: Optional[pulumi.Input[str]] = None,
                 proxy_port: Optional[pulumi.Input[int]] = None,
                 proxy_type: Optional[pulumi.Input[str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[str]] = None,
                 tls_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs'] access: Access rules for the ingress service.
        :param pulumi.Input[bool] bastion_mode: Runs as jump host.
        :param pulumi.Input[str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param pulumi.Input[str] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param pulumi.Input[bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param pulumi.Input[bool] http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param pulumi.Input[str] http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]] ip_rules: IP rules for the proxy service.
        :param pulumi.Input[int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param pulumi.Input[str] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param pulumi.Input[bool] no_happy_eyeballs: Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param pulumi.Input[bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param pulumi.Input[str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param pulumi.Input[str] proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param pulumi.Input[int] proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param pulumi.Input[str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param pulumi.Input[str] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param pulumi.Input[str] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        TunnelConfigConfigOriginRequestArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access=access,
            bastion_mode=bastion_mode,
            ca_pool=ca_pool,
            connect_timeout=connect_timeout,
            disable_chunked_encoding=disable_chunked_encoding,
            http2_origin=http2_origin,
            http_host_header=http_host_header,
            ip_rules=ip_rules,
            keep_alive_connections=keep_alive_connections,
            keep_alive_timeout=keep_alive_timeout,
            no_happy_eyeballs=no_happy_eyeballs,
            no_tls_verify=no_tls_verify,
            origin_server_name=origin_server_name,
            proxy_address=proxy_address,
            proxy_port=proxy_port,
            proxy_type=proxy_type,
            tcp_keep_alive=tcp_keep_alive,
            tls_timeout=tls_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access: Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']] = None,
             bastion_mode: Optional[pulumi.Input[bool]] = None,
             ca_pool: Optional[pulumi.Input[str]] = None,
             connect_timeout: Optional[pulumi.Input[str]] = None,
             disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
             http2_origin: Optional[pulumi.Input[bool]] = None,
             http_host_header: Optional[pulumi.Input[str]] = None,
             ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]]] = None,
             keep_alive_connections: Optional[pulumi.Input[int]] = None,
             keep_alive_timeout: Optional[pulumi.Input[str]] = None,
             no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
             no_tls_verify: Optional[pulumi.Input[bool]] = None,
             origin_server_name: Optional[pulumi.Input[str]] = None,
             proxy_address: Optional[pulumi.Input[str]] = None,
             proxy_port: Optional[pulumi.Input[int]] = None,
             proxy_type: Optional[pulumi.Input[str]] = None,
             tcp_keep_alive: Optional[pulumi.Input[str]] = None,
             tls_timeout: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access is not None:
            _setter("access", access)
        if bastion_mode is not None:
            _setter("bastion_mode", bastion_mode)
        if ca_pool is not None:
            _setter("ca_pool", ca_pool)
        if connect_timeout is not None:
            _setter("connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            _setter("disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            _setter("http2_origin", http2_origin)
        if http_host_header is not None:
            _setter("http_host_header", http_host_header)
        if ip_rules is not None:
            _setter("ip_rules", ip_rules)
        if keep_alive_connections is not None:
            _setter("keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            _setter("keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            _setter("no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            _setter("no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            _setter("origin_server_name", origin_server_name)
        if proxy_address is not None:
            _setter("proxy_address", proxy_address)
        if proxy_port is not None:
            _setter("proxy_port", proxy_port)
        if proxy_type is not None:
            _setter("proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            _setter("tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            _setter("tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']]:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @bastion_mode.setter
    def bastion_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bastion_mode", value)

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_pool", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_origin", value)

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_host_header", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]]]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigOriginRequestIpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_server_name", value)

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @proxy_address.setter
    def proxy_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_address", value)

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[pulumi.Input[int]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @proxy_port.setter
    def proxy_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "proxy_port", value)

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_type", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_timeout", value)


@pulumi.input_type
class TunnelConfigConfigOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 team_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aud_tags: Audience tags of the access rule.
        :param pulumi.Input[bool] required: Whether the access rule is required.
        :param pulumi.Input[str] team_name: Name of the team to which the access rule applies.
        """
        TunnelConfigConfigOriginRequestAccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aud_tags=aud_tags,
            required=required,
            team_name=team_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aud_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             required: Optional[pulumi.Input[bool]] = None,
             team_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aud_tags is not None:
            _setter("aud_tags", aud_tags)
        if required is not None:
            _setter("required", required)
        if team_name is not None:
            _setter("team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aud_tags", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)


@pulumi.input_type
class TunnelConfigConfigOriginRequestIpRuleArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow: Whether to allow the IP prefix.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: Ports to use within the IP rule.
        :param pulumi.Input[str] prefix: IP rule prefix.
        """
        TunnelConfigConfigOriginRequestIpRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            ports=ports,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional[pulumi.Input[bool]] = None,
             ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow is not None:
            _setter("allow", allow)
        if ports is not None:
            _setter("ports", ports)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class TunnelConfigConfigWarpRoutingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether WARP routing is enabled.
        """
        TunnelConfigConfigWarpRoutingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether WARP routing is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class UserAgentBlockingRuleConfigurationArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target: The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        :param pulumi.Input[str] value: The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
        UserAgentBlockingRuleConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        _setter("value", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WaitingRoomAdditionalRouteArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The additional host name for which the waiting room to be applied on (no wildcards).
        :param pulumi.Input[str] path: The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
        WaitingRoomAdditionalRouteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: pulumi.Input[str],
             path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("host", host)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The additional host name for which the waiting room to be applied on (no wildcards).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class WaitingRoomRulesRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 expression: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        :param pulumi.Input[str] expression: Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        :param pulumi.Input[str] description: Brief summary of the waiting room rule and its intended use.
        :param pulumi.Input[str] id: Unique rule identifier.
        :param pulumi.Input[str] status: Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        :param pulumi.Input[str] version: Version of the waiting room rule.
        """
        WaitingRoomRulesRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            expression=expression,
            description=description,
            id=id,
            status=status,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: pulumi.Input[str],
             expression: pulumi.Input[str],
             description: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("expression", expression)
        if description is not None:
            _setter("description", description)
        if id is not None:
            _setter("id", id)
        if status is not None:
            _setter("status", status)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Brief summary of the waiting room rule and its intended use.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the waiting room rule.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class WorkerScriptAnalyticsEngineBindingArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset: The name of the Analytics Engine dataset to write to.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        WorkerScriptAnalyticsEngineBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dataset=dataset,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dataset: pulumi.Input[str],
             name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dataset", dataset)
        _setter("name", name)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input[str]:
        """
        The name of the Analytics Engine dataset to write to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WorkerScriptKvNamespaceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] namespace_id: ID of the KV namespace you want to use.
        """
        WorkerScriptKvNamespaceBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            namespace_id=namespace_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             namespace_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("namespace_id", namespace_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> pulumi.Input[str]:
        """
        ID of the KV namespace you want to use.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_id", value)


@pulumi.input_type
class WorkerScriptPlainTextBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] text: The plain text you want to store.
        """
        WorkerScriptPlainTextBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             text: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("text", text)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The plain text you want to store.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


@pulumi.input_type
class WorkerScriptQueueBindingArgs:
    def __init__(__self__, *,
                 binding: pulumi.Input[str],
                 queue: pulumi.Input[str]):
        """
        :param pulumi.Input[str] binding: The name of the global variable for the binding in your Worker code.
        :param pulumi.Input[str] queue: Name of the queue you want to use.
        """
        WorkerScriptQueueBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            binding=binding,
            queue=queue,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             binding: pulumi.Input[str],
             queue: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("binding", binding)
        _setter("queue", queue)

    @property
    @pulumi.getter
    def binding(self) -> pulumi.Input[str]:
        """
        The name of the global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @binding.setter
    def binding(self, value: pulumi.Input[str]):
        pulumi.set(self, "binding", value)

    @property
    @pulumi.getter
    def queue(self) -> pulumi.Input[str]:
        """
        Name of the queue you want to use.
        """
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue", value)


@pulumi.input_type
class WorkerScriptR2BucketBindingArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket_name: The name of the Bucket to bind to.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        WorkerScriptR2BucketBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: pulumi.Input[str],
             name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket_name", bucket_name)
        _setter("name", name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the Bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WorkerScriptSecretTextBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] text: The secret text you want to store.
        """
        WorkerScriptSecretTextBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             text: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("text", text)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The secret text you want to store.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


@pulumi.input_type
class WorkerScriptServiceBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        :param pulumi.Input[str] service: The name of the Worker to bind to.
        :param pulumi.Input[str] environment: The name of the Worker environment to bind to.
        """
        WorkerScriptServiceBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            service=service,
            environment=environment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             service: pulumi.Input[str],
             environment: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("service", service)
        if environment is not None:
            _setter("environment", environment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)


@pulumi.input_type
class WorkerScriptWebassemblyBindingArgs:
    def __init__(__self__, *,
                 module: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] module: The base64 encoded wasm module you want to store.
        :param pulumi.Input[str] name: The global variable for the binding in your Worker code.
        """
        WorkerScriptWebassemblyBindingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            module=module,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             module: pulumi.Input[str],
             name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("module", module)
        _setter("name", name)

    @property
    @pulumi.getter
    def module(self) -> pulumi.Input[str]:
        """
        The base64 encoded wasm module you want to store.
        """
        return pulumi.get(self, "module")

    @module.setter
    def module(self, value: pulumi.Input[str]):
        pulumi.set(self, "module", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ZoneLockdownConfigurationArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target: The request property to target. Available values: `ip`, `ip_range`.
        :param pulumi.Input[str] value: The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
        ZoneLockdownConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        _setter("value", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The request property to target. Available values: `ip`, `ip_range`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ZoneSettingsOverrideInitialSettingArgs:
    def __init__(__self__, *,
                 always_online: Optional[pulumi.Input[str]] = None,
                 always_use_https: Optional[pulumi.Input[str]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
                 binary_ast: Optional[pulumi.Input[str]] = None,
                 brotli: Optional[pulumi.Input[str]] = None,
                 browser_cache_ttl: Optional[pulumi.Input[int]] = None,
                 browser_check: Optional[pulumi.Input[str]] = None,
                 cache_level: Optional[pulumi.Input[str]] = None,
                 challenge_ttl: Optional[pulumi.Input[int]] = None,
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cname_flattening: Optional[pulumi.Input[str]] = None,
                 development_mode: Optional[pulumi.Input[str]] = None,
                 early_hints: Optional[pulumi.Input[str]] = None,
                 email_obfuscation: Optional[pulumi.Input[str]] = None,
                 filter_logs_to_cloudflare: Optional[pulumi.Input[str]] = None,
                 h2_prioritization: Optional[pulumi.Input[str]] = None,
                 hotlink_protection: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[str]] = None,
                 http3: Optional[pulumi.Input[str]] = None,
                 image_resizing: Optional[pulumi.Input[str]] = None,
                 ip_geolocation: Optional[pulumi.Input[str]] = None,
                 ipv6: Optional[pulumi.Input[str]] = None,
                 log_to_cloudflare: Optional[pulumi.Input[str]] = None,
                 max_upload: Optional[pulumi.Input[int]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 minify: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMinifyArgs']] = None,
                 mirage: Optional[pulumi.Input[str]] = None,
                 mobile_redirect: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMobileRedirectArgs']] = None,
                 opportunistic_encryption: Optional[pulumi.Input[str]] = None,
                 opportunistic_onion: Optional[pulumi.Input[str]] = None,
                 orange_to_orange: Optional[pulumi.Input[str]] = None,
                 origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
                 origin_max_http_version: Optional[pulumi.Input[str]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 prefetch_preload: Optional[pulumi.Input[str]] = None,
                 privacy_pass: Optional[pulumi.Input[str]] = None,
                 proxy_read_timeout: Optional[pulumi.Input[str]] = None,
                 pseudo_ipv4: Optional[pulumi.Input[str]] = None,
                 response_buffering: Optional[pulumi.Input[str]] = None,
                 rocket_loader: Optional[pulumi.Input[str]] = None,
                 security_header: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingSecurityHeaderArgs']] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 server_side_exclude: Optional[pulumi.Input[str]] = None,
                 sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 tls12_only: Optional[pulumi.Input[str]] = None,
                 tls13: Optional[pulumi.Input[str]] = None,
                 tls_client_auth: Optional[pulumi.Input[str]] = None,
                 true_client_ip_header: Optional[pulumi.Input[str]] = None,
                 universal_ssl: Optional[pulumi.Input[str]] = None,
                 visitor_ip: Optional[pulumi.Input[str]] = None,
                 waf: Optional[pulumi.Input[str]] = None,
                 webp: Optional[pulumi.Input[str]] = None,
                 websockets: Optional[pulumi.Input[str]] = None,
                 zero_rtt: Optional[pulumi.Input[str]] = None):
        ZoneSettingsOverrideInitialSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            always_online=always_online,
            always_use_https=always_use_https,
            automatic_https_rewrites=automatic_https_rewrites,
            binary_ast=binary_ast,
            brotli=brotli,
            browser_cache_ttl=browser_cache_ttl,
            browser_check=browser_check,
            cache_level=cache_level,
            challenge_ttl=challenge_ttl,
            ciphers=ciphers,
            cname_flattening=cname_flattening,
            development_mode=development_mode,
            early_hints=early_hints,
            email_obfuscation=email_obfuscation,
            filter_logs_to_cloudflare=filter_logs_to_cloudflare,
            h2_prioritization=h2_prioritization,
            hotlink_protection=hotlink_protection,
            http2=http2,
            http3=http3,
            image_resizing=image_resizing,
            ip_geolocation=ip_geolocation,
            ipv6=ipv6,
            log_to_cloudflare=log_to_cloudflare,
            max_upload=max_upload,
            min_tls_version=min_tls_version,
            minify=minify,
            mirage=mirage,
            mobile_redirect=mobile_redirect,
            opportunistic_encryption=opportunistic_encryption,
            opportunistic_onion=opportunistic_onion,
            orange_to_orange=orange_to_orange,
            origin_error_page_pass_thru=origin_error_page_pass_thru,
            origin_max_http_version=origin_max_http_version,
            polish=polish,
            prefetch_preload=prefetch_preload,
            privacy_pass=privacy_pass,
            proxy_read_timeout=proxy_read_timeout,
            pseudo_ipv4=pseudo_ipv4,
            response_buffering=response_buffering,
            rocket_loader=rocket_loader,
            security_header=security_header,
            security_level=security_level,
            server_side_exclude=server_side_exclude,
            sort_query_string_for_cache=sort_query_string_for_cache,
            ssl=ssl,
            tls12_only=tls12_only,
            tls13=tls13,
            tls_client_auth=tls_client_auth,
            true_client_ip_header=true_client_ip_header,
            universal_ssl=universal_ssl,
            visitor_ip=visitor_ip,
            waf=waf,
            webp=webp,
            websockets=websockets,
            zero_rtt=zero_rtt,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             always_online: Optional[pulumi.Input[str]] = None,
             always_use_https: Optional[pulumi.Input[str]] = None,
             automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
             binary_ast: Optional[pulumi.Input[str]] = None,
             brotli: Optional[pulumi.Input[str]] = None,
             browser_cache_ttl: Optional[pulumi.Input[int]] = None,
             browser_check: Optional[pulumi.Input[str]] = None,
             cache_level: Optional[pulumi.Input[str]] = None,
             challenge_ttl: Optional[pulumi.Input[int]] = None,
             ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cname_flattening: Optional[pulumi.Input[str]] = None,
             development_mode: Optional[pulumi.Input[str]] = None,
             early_hints: Optional[pulumi.Input[str]] = None,
             email_obfuscation: Optional[pulumi.Input[str]] = None,
             filter_logs_to_cloudflare: Optional[pulumi.Input[str]] = None,
             h2_prioritization: Optional[pulumi.Input[str]] = None,
             hotlink_protection: Optional[pulumi.Input[str]] = None,
             http2: Optional[pulumi.Input[str]] = None,
             http3: Optional[pulumi.Input[str]] = None,
             image_resizing: Optional[pulumi.Input[str]] = None,
             ip_geolocation: Optional[pulumi.Input[str]] = None,
             ipv6: Optional[pulumi.Input[str]] = None,
             log_to_cloudflare: Optional[pulumi.Input[str]] = None,
             max_upload: Optional[pulumi.Input[int]] = None,
             min_tls_version: Optional[pulumi.Input[str]] = None,
             minify: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMinifyArgs']] = None,
             mirage: Optional[pulumi.Input[str]] = None,
             mobile_redirect: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMobileRedirectArgs']] = None,
             opportunistic_encryption: Optional[pulumi.Input[str]] = None,
             opportunistic_onion: Optional[pulumi.Input[str]] = None,
             orange_to_orange: Optional[pulumi.Input[str]] = None,
             origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
             origin_max_http_version: Optional[pulumi.Input[str]] = None,
             polish: Optional[pulumi.Input[str]] = None,
             prefetch_preload: Optional[pulumi.Input[str]] = None,
             privacy_pass: Optional[pulumi.Input[str]] = None,
             proxy_read_timeout: Optional[pulumi.Input[str]] = None,
             pseudo_ipv4: Optional[pulumi.Input[str]] = None,
             response_buffering: Optional[pulumi.Input[str]] = None,
             rocket_loader: Optional[pulumi.Input[str]] = None,
             security_header: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingSecurityHeaderArgs']] = None,
             security_level: Optional[pulumi.Input[str]] = None,
             server_side_exclude: Optional[pulumi.Input[str]] = None,
             sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
             ssl: Optional[pulumi.Input[str]] = None,
             tls12_only: Optional[pulumi.Input[str]] = None,
             tls13: Optional[pulumi.Input[str]] = None,
             tls_client_auth: Optional[pulumi.Input[str]] = None,
             true_client_ip_header: Optional[pulumi.Input[str]] = None,
             universal_ssl: Optional[pulumi.Input[str]] = None,
             visitor_ip: Optional[pulumi.Input[str]] = None,
             waf: Optional[pulumi.Input[str]] = None,
             webp: Optional[pulumi.Input[str]] = None,
             websockets: Optional[pulumi.Input[str]] = None,
             zero_rtt: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if always_online is not None:
            _setter("always_online", always_online)
        if always_use_https is not None:
            _setter("always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            _setter("automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            _setter("binary_ast", binary_ast)
        if brotli is not None:
            _setter("brotli", brotli)
        if browser_cache_ttl is not None:
            _setter("browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            _setter("browser_check", browser_check)
        if cache_level is not None:
            _setter("cache_level", cache_level)
        if challenge_ttl is not None:
            _setter("challenge_ttl", challenge_ttl)
        if ciphers is not None:
            _setter("ciphers", ciphers)
        if cname_flattening is not None:
            _setter("cname_flattening", cname_flattening)
        if development_mode is not None:
            _setter("development_mode", development_mode)
        if early_hints is not None:
            _setter("early_hints", early_hints)
        if email_obfuscation is not None:
            _setter("email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            _setter("filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if h2_prioritization is not None:
            _setter("h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            _setter("hotlink_protection", hotlink_protection)
        if http2 is not None:
            _setter("http2", http2)
        if http3 is not None:
            _setter("http3", http3)
        if image_resizing is not None:
            _setter("image_resizing", image_resizing)
        if ip_geolocation is not None:
            _setter("ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            _setter("ipv6", ipv6)
        if log_to_cloudflare is not None:
            _setter("log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            _setter("max_upload", max_upload)
        if min_tls_version is not None:
            _setter("min_tls_version", min_tls_version)
        if minify is not None:
            _setter("minify", minify)
        if mirage is not None:
            _setter("mirage", mirage)
        if mobile_redirect is not None:
            _setter("mobile_redirect", mobile_redirect)
        if opportunistic_encryption is not None:
            _setter("opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            _setter("opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            _setter("orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            _setter("origin_error_page_pass_thru", origin_error_page_pass_thru)
        if origin_max_http_version is not None:
            _setter("origin_max_http_version", origin_max_http_version)
        if polish is not None:
            _setter("polish", polish)
        if prefetch_preload is not None:
            _setter("prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            _setter("privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            _setter("proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            _setter("pseudo_ipv4", pseudo_ipv4)
        if response_buffering is not None:
            _setter("response_buffering", response_buffering)
        if rocket_loader is not None:
            _setter("rocket_loader", rocket_loader)
        if security_header is not None:
            _setter("security_header", security_header)
        if security_level is not None:
            _setter("security_level", security_level)
        if server_side_exclude is not None:
            _setter("server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            _setter("sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            _setter("ssl", ssl)
        if tls12_only is not None:
            warnings.warn("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""", DeprecationWarning)
            pulumi.log.warn("""tls12_only is deprecated: tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")
        if tls12_only is not None:
            _setter("tls12_only", tls12_only)
        if tls13 is not None:
            _setter("tls13", tls13)
        if tls_client_auth is not None:
            _setter("tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            _setter("true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            _setter("universal_ssl", universal_ssl)
        if visitor_ip is not None:
            _setter("visitor_ip", visitor_ip)
        if waf is not None:
            _setter("waf", waf)
        if webp is not None:
            _setter("webp", webp)
        if websockets is not None:
            _setter("websockets", websockets)
        if zero_rtt is not None:
            _setter("zero_rtt", zero_rtt)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "always_online")

    @always_online.setter
    def always_online(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "always_online", value)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "always_use_https")

    @always_use_https.setter
    def always_use_https(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "always_use_https", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "binary_ast")

    @binary_ast.setter
    def binary_ast(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "binary_ast", value)

    @property
    @pulumi.getter
    def brotli(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "brotli")

    @brotli.setter
    def brotli(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "brotli", value)

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "browser_cache_ttl")

    @browser_cache_ttl.setter
    def browser_cache_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "browser_cache_ttl", value)

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "browser_check")

    @browser_check.setter
    def browser_check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_check", value)

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cache_level")

    @cache_level.setter
    def cache_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_level", value)

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "challenge_ttl")

    @challenge_ttl.setter
    def challenge_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "challenge_ttl", value)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ciphers", value)

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_flattening")

    @cname_flattening.setter
    def cname_flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_flattening", value)

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "development_mode")

    @development_mode.setter
    def development_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "development_mode", value)

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "early_hints")

    @early_hints.setter
    def early_hints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "early_hints", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @filter_logs_to_cloudflare.setter
    def filter_logs_to_cloudflare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_logs_to_cloudflare", value)

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "h2_prioritization")

    @h2_prioritization.setter
    def h2_prioritization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h2_prioritization", value)

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hotlink_protection")

    @hotlink_protection.setter
    def hotlink_protection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hotlink_protection", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter
    def http3(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http3")

    @http3.setter
    def http3(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http3", value)

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_resizing")

    @image_resizing.setter
    def image_resizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_resizing", value)

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_geolocation")

    @ip_geolocation.setter
    def ip_geolocation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_geolocation", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_to_cloudflare")

    @log_to_cloudflare.setter
    def log_to_cloudflare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_to_cloudflare", value)

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_upload")

    @max_upload.setter
    def max_upload(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_upload", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter
    def minify(self) -> Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMinifyArgs']]:
        return pulumi.get(self, "minify")

    @minify.setter
    def minify(self, value: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMinifyArgs']]):
        pulumi.set(self, "minify", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="mobileRedirect")
    def mobile_redirect(self) -> Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMobileRedirectArgs']]:
        return pulumi.get(self, "mobile_redirect")

    @mobile_redirect.setter
    def mobile_redirect(self, value: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingMobileRedirectArgs']]):
        pulumi.set(self, "mobile_redirect", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opportunistic_onion")

    @opportunistic_onion.setter
    def opportunistic_onion(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_onion", value)

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "orange_to_orange")

    @orange_to_orange.setter
    def orange_to_orange(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "orange_to_orange", value)

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @origin_error_page_pass_thru.setter
    def origin_error_page_pass_thru(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_error_page_pass_thru", value)

    @property
    @pulumi.getter(name="originMaxHttpVersion")
    def origin_max_http_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "origin_max_http_version")

    @origin_max_http_version.setter
    def origin_max_http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_max_http_version", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefetch_preload")

    @prefetch_preload.setter
    def prefetch_preload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefetch_preload", value)

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "privacy_pass")

    @privacy_pass.setter
    def privacy_pass(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "privacy_pass", value)

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proxy_read_timeout")

    @proxy_read_timeout.setter
    def proxy_read_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_read_timeout", value)

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pseudo_ipv4")

    @pseudo_ipv4.setter
    def pseudo_ipv4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pseudo_ipv4", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingSecurityHeaderArgs']]:
        return pulumi.get(self, "security_header")

    @security_header.setter
    def security_header(self, value: Optional[pulumi.Input['ZoneSettingsOverrideInitialSettingSecurityHeaderArgs']]):
        pulumi.set(self, "security_header", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_side_exclude")

    @server_side_exclude.setter
    def server_side_exclude(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_side_exclude", value)

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @sort_query_string_for_cache.setter
    def sort_query_string_for_cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_query_string_for_cache", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="tls12Only")
    def tls12_only(self) -> Optional[pulumi.Input[str]]:
        warnings.warn("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""", DeprecationWarning)
        pulumi.log.warn("""tls12_only is deprecated: tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")

        return pulumi.get(self, "tls12_only")

    @tls12_only.setter
    def tls12_only(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls12_only", value)

    @property
    @pulumi.getter
    def tls13(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls13")

    @tls13.setter
    def tls13(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls13", value)

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls_client_auth")

    @tls_client_auth.setter
    def tls_client_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_auth", value)

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "true_client_ip_header")

    @true_client_ip_header.setter
    def true_client_ip_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "true_client_ip_header", value)

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "universal_ssl")

    @universal_ssl.setter
    def universal_ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "universal_ssl", value)

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visitor_ip")

    @visitor_ip.setter
    def visitor_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visitor_ip", value)

    @property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf", value)

    @property
    @pulumi.getter
    def webp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "webp")

    @webp.setter
    def webp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webp", value)

    @property
    @pulumi.getter
    def websockets(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "websockets")

    @websockets.setter
    def websockets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "websockets", value)

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zero_rtt")

    @zero_rtt.setter
    def zero_rtt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_rtt", value)


@pulumi.input_type
class ZoneSettingsOverrideInitialSettingMinifyArgs:
    def __init__(__self__, *,
                 css: pulumi.Input[str],
                 html: pulumi.Input[str],
                 js: pulumi.Input[str]):
        ZoneSettingsOverrideInitialSettingMinifyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            css=css,
            html=html,
            js=js,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             css: pulumi.Input[str],
             html: pulumi.Input[str],
             js: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("css", css)
        _setter("html", html)
        _setter("js", js)

    @property
    @pulumi.getter
    def css(self) -> pulumi.Input[str]:
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: pulumi.Input[str]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> pulumi.Input[str]:
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: pulumi.Input[str]):
        pulumi.set(self, "js", value)


@pulumi.input_type
class ZoneSettingsOverrideInitialSettingMobileRedirectArgs:
    def __init__(__self__, *,
                 mobile_subdomain: pulumi.Input[str],
                 status: pulumi.Input[str],
                 strip_uri: pulumi.Input[bool]):
        ZoneSettingsOverrideInitialSettingMobileRedirectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mobile_subdomain=mobile_subdomain,
            status=status,
            strip_uri=strip_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mobile_subdomain: pulumi.Input[str],
             status: pulumi.Input[str],
             strip_uri: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mobile_subdomain", mobile_subdomain)
        _setter("status", status)
        _setter("strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mobile_subdomain")

    @mobile_subdomain.setter
    def mobile_subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "mobile_subdomain", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "strip_uri")

    @strip_uri.setter
    def strip_uri(self, value: pulumi.Input[bool]):
        pulumi.set(self, "strip_uri", value)


@pulumi.input_type
class ZoneSettingsOverrideInitialSettingSecurityHeaderArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 include_subdomains: Optional[pulumi.Input[bool]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 nosniff: Optional[pulumi.Input[bool]] = None,
                 preload: Optional[pulumi.Input[bool]] = None):
        ZoneSettingsOverrideInitialSettingSecurityHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            include_subdomains=include_subdomains,
            max_age=max_age,
            nosniff=nosniff,
            preload=preload,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             include_subdomains: Optional[pulumi.Input[bool]] = None,
             max_age: Optional[pulumi.Input[int]] = None,
             nosniff: Optional[pulumi.Input[bool]] = None,
             preload: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if include_subdomains is not None:
            _setter("include_subdomains", include_subdomains)
        if max_age is not None:
            _setter("max_age", max_age)
        if nosniff is not None:
            _setter("nosniff", nosniff)
        if preload is not None:
            _setter("preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nosniff")

    @nosniff.setter
    def nosniff(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nosniff", value)

    @property
    @pulumi.getter
    def preload(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preload")

    @preload.setter
    def preload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preload", value)


@pulumi.input_type
class ZoneSettingsOverrideSettingsArgs:
    def __init__(__self__, *,
                 always_online: Optional[pulumi.Input[str]] = None,
                 always_use_https: Optional[pulumi.Input[str]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
                 binary_ast: Optional[pulumi.Input[str]] = None,
                 brotli: Optional[pulumi.Input[str]] = None,
                 browser_cache_ttl: Optional[pulumi.Input[int]] = None,
                 browser_check: Optional[pulumi.Input[str]] = None,
                 cache_level: Optional[pulumi.Input[str]] = None,
                 challenge_ttl: Optional[pulumi.Input[int]] = None,
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cname_flattening: Optional[pulumi.Input[str]] = None,
                 development_mode: Optional[pulumi.Input[str]] = None,
                 early_hints: Optional[pulumi.Input[str]] = None,
                 email_obfuscation: Optional[pulumi.Input[str]] = None,
                 filter_logs_to_cloudflare: Optional[pulumi.Input[str]] = None,
                 h2_prioritization: Optional[pulumi.Input[str]] = None,
                 hotlink_protection: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[str]] = None,
                 http3: Optional[pulumi.Input[str]] = None,
                 image_resizing: Optional[pulumi.Input[str]] = None,
                 ip_geolocation: Optional[pulumi.Input[str]] = None,
                 ipv6: Optional[pulumi.Input[str]] = None,
                 log_to_cloudflare: Optional[pulumi.Input[str]] = None,
                 max_upload: Optional[pulumi.Input[int]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 minify: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMinifyArgs']] = None,
                 mirage: Optional[pulumi.Input[str]] = None,
                 mobile_redirect: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMobileRedirectArgs']] = None,
                 opportunistic_encryption: Optional[pulumi.Input[str]] = None,
                 opportunistic_onion: Optional[pulumi.Input[str]] = None,
                 orange_to_orange: Optional[pulumi.Input[str]] = None,
                 origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
                 origin_max_http_version: Optional[pulumi.Input[str]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 prefetch_preload: Optional[pulumi.Input[str]] = None,
                 privacy_pass: Optional[pulumi.Input[str]] = None,
                 proxy_read_timeout: Optional[pulumi.Input[str]] = None,
                 pseudo_ipv4: Optional[pulumi.Input[str]] = None,
                 response_buffering: Optional[pulumi.Input[str]] = None,
                 rocket_loader: Optional[pulumi.Input[str]] = None,
                 security_header: Optional[pulumi.Input['ZoneSettingsOverrideSettingsSecurityHeaderArgs']] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 server_side_exclude: Optional[pulumi.Input[str]] = None,
                 sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 tls12_only: Optional[pulumi.Input[str]] = None,
                 tls13: Optional[pulumi.Input[str]] = None,
                 tls_client_auth: Optional[pulumi.Input[str]] = None,
                 true_client_ip_header: Optional[pulumi.Input[str]] = None,
                 universal_ssl: Optional[pulumi.Input[str]] = None,
                 visitor_ip: Optional[pulumi.Input[str]] = None,
                 waf: Optional[pulumi.Input[str]] = None,
                 webp: Optional[pulumi.Input[str]] = None,
                 websockets: Optional[pulumi.Input[str]] = None,
                 zero_rtt: Optional[pulumi.Input[str]] = None):
        ZoneSettingsOverrideSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            always_online=always_online,
            always_use_https=always_use_https,
            automatic_https_rewrites=automatic_https_rewrites,
            binary_ast=binary_ast,
            brotli=brotli,
            browser_cache_ttl=browser_cache_ttl,
            browser_check=browser_check,
            cache_level=cache_level,
            challenge_ttl=challenge_ttl,
            ciphers=ciphers,
            cname_flattening=cname_flattening,
            development_mode=development_mode,
            early_hints=early_hints,
            email_obfuscation=email_obfuscation,
            filter_logs_to_cloudflare=filter_logs_to_cloudflare,
            h2_prioritization=h2_prioritization,
            hotlink_protection=hotlink_protection,
            http2=http2,
            http3=http3,
            image_resizing=image_resizing,
            ip_geolocation=ip_geolocation,
            ipv6=ipv6,
            log_to_cloudflare=log_to_cloudflare,
            max_upload=max_upload,
            min_tls_version=min_tls_version,
            minify=minify,
            mirage=mirage,
            mobile_redirect=mobile_redirect,
            opportunistic_encryption=opportunistic_encryption,
            opportunistic_onion=opportunistic_onion,
            orange_to_orange=orange_to_orange,
            origin_error_page_pass_thru=origin_error_page_pass_thru,
            origin_max_http_version=origin_max_http_version,
            polish=polish,
            prefetch_preload=prefetch_preload,
            privacy_pass=privacy_pass,
            proxy_read_timeout=proxy_read_timeout,
            pseudo_ipv4=pseudo_ipv4,
            response_buffering=response_buffering,
            rocket_loader=rocket_loader,
            security_header=security_header,
            security_level=security_level,
            server_side_exclude=server_side_exclude,
            sort_query_string_for_cache=sort_query_string_for_cache,
            ssl=ssl,
            tls12_only=tls12_only,
            tls13=tls13,
            tls_client_auth=tls_client_auth,
            true_client_ip_header=true_client_ip_header,
            universal_ssl=universal_ssl,
            visitor_ip=visitor_ip,
            waf=waf,
            webp=webp,
            websockets=websockets,
            zero_rtt=zero_rtt,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             always_online: Optional[pulumi.Input[str]] = None,
             always_use_https: Optional[pulumi.Input[str]] = None,
             automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
             binary_ast: Optional[pulumi.Input[str]] = None,
             brotli: Optional[pulumi.Input[str]] = None,
             browser_cache_ttl: Optional[pulumi.Input[int]] = None,
             browser_check: Optional[pulumi.Input[str]] = None,
             cache_level: Optional[pulumi.Input[str]] = None,
             challenge_ttl: Optional[pulumi.Input[int]] = None,
             ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cname_flattening: Optional[pulumi.Input[str]] = None,
             development_mode: Optional[pulumi.Input[str]] = None,
             early_hints: Optional[pulumi.Input[str]] = None,
             email_obfuscation: Optional[pulumi.Input[str]] = None,
             filter_logs_to_cloudflare: Optional[pulumi.Input[str]] = None,
             h2_prioritization: Optional[pulumi.Input[str]] = None,
             hotlink_protection: Optional[pulumi.Input[str]] = None,
             http2: Optional[pulumi.Input[str]] = None,
             http3: Optional[pulumi.Input[str]] = None,
             image_resizing: Optional[pulumi.Input[str]] = None,
             ip_geolocation: Optional[pulumi.Input[str]] = None,
             ipv6: Optional[pulumi.Input[str]] = None,
             log_to_cloudflare: Optional[pulumi.Input[str]] = None,
             max_upload: Optional[pulumi.Input[int]] = None,
             min_tls_version: Optional[pulumi.Input[str]] = None,
             minify: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMinifyArgs']] = None,
             mirage: Optional[pulumi.Input[str]] = None,
             mobile_redirect: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMobileRedirectArgs']] = None,
             opportunistic_encryption: Optional[pulumi.Input[str]] = None,
             opportunistic_onion: Optional[pulumi.Input[str]] = None,
             orange_to_orange: Optional[pulumi.Input[str]] = None,
             origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
             origin_max_http_version: Optional[pulumi.Input[str]] = None,
             polish: Optional[pulumi.Input[str]] = None,
             prefetch_preload: Optional[pulumi.Input[str]] = None,
             privacy_pass: Optional[pulumi.Input[str]] = None,
             proxy_read_timeout: Optional[pulumi.Input[str]] = None,
             pseudo_ipv4: Optional[pulumi.Input[str]] = None,
             response_buffering: Optional[pulumi.Input[str]] = None,
             rocket_loader: Optional[pulumi.Input[str]] = None,
             security_header: Optional[pulumi.Input['ZoneSettingsOverrideSettingsSecurityHeaderArgs']] = None,
             security_level: Optional[pulumi.Input[str]] = None,
             server_side_exclude: Optional[pulumi.Input[str]] = None,
             sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
             ssl: Optional[pulumi.Input[str]] = None,
             tls12_only: Optional[pulumi.Input[str]] = None,
             tls13: Optional[pulumi.Input[str]] = None,
             tls_client_auth: Optional[pulumi.Input[str]] = None,
             true_client_ip_header: Optional[pulumi.Input[str]] = None,
             universal_ssl: Optional[pulumi.Input[str]] = None,
             visitor_ip: Optional[pulumi.Input[str]] = None,
             waf: Optional[pulumi.Input[str]] = None,
             webp: Optional[pulumi.Input[str]] = None,
             websockets: Optional[pulumi.Input[str]] = None,
             zero_rtt: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if always_online is not None:
            _setter("always_online", always_online)
        if always_use_https is not None:
            _setter("always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            _setter("automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            _setter("binary_ast", binary_ast)
        if brotli is not None:
            _setter("brotli", brotli)
        if browser_cache_ttl is not None:
            _setter("browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            _setter("browser_check", browser_check)
        if cache_level is not None:
            _setter("cache_level", cache_level)
        if challenge_ttl is not None:
            _setter("challenge_ttl", challenge_ttl)
        if ciphers is not None:
            _setter("ciphers", ciphers)
        if cname_flattening is not None:
            _setter("cname_flattening", cname_flattening)
        if development_mode is not None:
            _setter("development_mode", development_mode)
        if early_hints is not None:
            _setter("early_hints", early_hints)
        if email_obfuscation is not None:
            _setter("email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            _setter("filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if h2_prioritization is not None:
            _setter("h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            _setter("hotlink_protection", hotlink_protection)
        if http2 is not None:
            _setter("http2", http2)
        if http3 is not None:
            _setter("http3", http3)
        if image_resizing is not None:
            _setter("image_resizing", image_resizing)
        if ip_geolocation is not None:
            _setter("ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            _setter("ipv6", ipv6)
        if log_to_cloudflare is not None:
            _setter("log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            _setter("max_upload", max_upload)
        if min_tls_version is not None:
            _setter("min_tls_version", min_tls_version)
        if minify is not None:
            _setter("minify", minify)
        if mirage is not None:
            _setter("mirage", mirage)
        if mobile_redirect is not None:
            _setter("mobile_redirect", mobile_redirect)
        if opportunistic_encryption is not None:
            _setter("opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            _setter("opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            _setter("orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            _setter("origin_error_page_pass_thru", origin_error_page_pass_thru)
        if origin_max_http_version is not None:
            _setter("origin_max_http_version", origin_max_http_version)
        if polish is not None:
            _setter("polish", polish)
        if prefetch_preload is not None:
            _setter("prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            _setter("privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            _setter("proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            _setter("pseudo_ipv4", pseudo_ipv4)
        if response_buffering is not None:
            _setter("response_buffering", response_buffering)
        if rocket_loader is not None:
            _setter("rocket_loader", rocket_loader)
        if security_header is not None:
            _setter("security_header", security_header)
        if security_level is not None:
            _setter("security_level", security_level)
        if server_side_exclude is not None:
            _setter("server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            _setter("sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            _setter("ssl", ssl)
        if tls12_only is not None:
            warnings.warn("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""", DeprecationWarning)
            pulumi.log.warn("""tls12_only is deprecated: tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")
        if tls12_only is not None:
            _setter("tls12_only", tls12_only)
        if tls13 is not None:
            _setter("tls13", tls13)
        if tls_client_auth is not None:
            _setter("tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            _setter("true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            _setter("universal_ssl", universal_ssl)
        if visitor_ip is not None:
            _setter("visitor_ip", visitor_ip)
        if waf is not None:
            _setter("waf", waf)
        if webp is not None:
            _setter("webp", webp)
        if websockets is not None:
            _setter("websockets", websockets)
        if zero_rtt is not None:
            _setter("zero_rtt", zero_rtt)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "always_online")

    @always_online.setter
    def always_online(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "always_online", value)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "always_use_https")

    @always_use_https.setter
    def always_use_https(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "always_use_https", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "binary_ast")

    @binary_ast.setter
    def binary_ast(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "binary_ast", value)

    @property
    @pulumi.getter
    def brotli(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "brotli")

    @brotli.setter
    def brotli(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "brotli", value)

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "browser_cache_ttl")

    @browser_cache_ttl.setter
    def browser_cache_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "browser_cache_ttl", value)

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "browser_check")

    @browser_check.setter
    def browser_check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_check", value)

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cache_level")

    @cache_level.setter
    def cache_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_level", value)

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "challenge_ttl")

    @challenge_ttl.setter
    def challenge_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "challenge_ttl", value)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ciphers", value)

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_flattening")

    @cname_flattening.setter
    def cname_flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_flattening", value)

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "development_mode")

    @development_mode.setter
    def development_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "development_mode", value)

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "early_hints")

    @early_hints.setter
    def early_hints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "early_hints", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @filter_logs_to_cloudflare.setter
    def filter_logs_to_cloudflare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_logs_to_cloudflare", value)

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "h2_prioritization")

    @h2_prioritization.setter
    def h2_prioritization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h2_prioritization", value)

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hotlink_protection")

    @hotlink_protection.setter
    def hotlink_protection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hotlink_protection", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter
    def http3(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http3")

    @http3.setter
    def http3(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http3", value)

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_resizing")

    @image_resizing.setter
    def image_resizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_resizing", value)

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_geolocation")

    @ip_geolocation.setter
    def ip_geolocation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_geolocation", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_to_cloudflare")

    @log_to_cloudflare.setter
    def log_to_cloudflare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_to_cloudflare", value)

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_upload")

    @max_upload.setter
    def max_upload(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_upload", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter
    def minify(self) -> Optional[pulumi.Input['ZoneSettingsOverrideSettingsMinifyArgs']]:
        return pulumi.get(self, "minify")

    @minify.setter
    def minify(self, value: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMinifyArgs']]):
        pulumi.set(self, "minify", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="mobileRedirect")
    def mobile_redirect(self) -> Optional[pulumi.Input['ZoneSettingsOverrideSettingsMobileRedirectArgs']]:
        return pulumi.get(self, "mobile_redirect")

    @mobile_redirect.setter
    def mobile_redirect(self, value: Optional[pulumi.Input['ZoneSettingsOverrideSettingsMobileRedirectArgs']]):
        pulumi.set(self, "mobile_redirect", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opportunistic_onion")

    @opportunistic_onion.setter
    def opportunistic_onion(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_onion", value)

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "orange_to_orange")

    @orange_to_orange.setter
    def orange_to_orange(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "orange_to_orange", value)

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @origin_error_page_pass_thru.setter
    def origin_error_page_pass_thru(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_error_page_pass_thru", value)

    @property
    @pulumi.getter(name="originMaxHttpVersion")
    def origin_max_http_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "origin_max_http_version")

    @origin_max_http_version.setter
    def origin_max_http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_max_http_version", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefetch_preload")

    @prefetch_preload.setter
    def prefetch_preload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefetch_preload", value)

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "privacy_pass")

    @privacy_pass.setter
    def privacy_pass(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "privacy_pass", value)

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proxy_read_timeout")

    @proxy_read_timeout.setter
    def proxy_read_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_read_timeout", value)

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pseudo_ipv4")

    @pseudo_ipv4.setter
    def pseudo_ipv4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pseudo_ipv4", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional[pulumi.Input['ZoneSettingsOverrideSettingsSecurityHeaderArgs']]:
        return pulumi.get(self, "security_header")

    @security_header.setter
    def security_header(self, value: Optional[pulumi.Input['ZoneSettingsOverrideSettingsSecurityHeaderArgs']]):
        pulumi.set(self, "security_header", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_side_exclude")

    @server_side_exclude.setter
    def server_side_exclude(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_side_exclude", value)

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @sort_query_string_for_cache.setter
    def sort_query_string_for_cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_query_string_for_cache", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="tls12Only")
    def tls12_only(self) -> Optional[pulumi.Input[str]]:
        warnings.warn("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""", DeprecationWarning)
        pulumi.log.warn("""tls12_only is deprecated: tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")

        return pulumi.get(self, "tls12_only")

    @tls12_only.setter
    def tls12_only(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls12_only", value)

    @property
    @pulumi.getter
    def tls13(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls13")

    @tls13.setter
    def tls13(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls13", value)

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tls_client_auth")

    @tls_client_auth.setter
    def tls_client_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_client_auth", value)

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "true_client_ip_header")

    @true_client_ip_header.setter
    def true_client_ip_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "true_client_ip_header", value)

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "universal_ssl")

    @universal_ssl.setter
    def universal_ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "universal_ssl", value)

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visitor_ip")

    @visitor_ip.setter
    def visitor_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visitor_ip", value)

    @property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf", value)

    @property
    @pulumi.getter
    def webp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "webp")

    @webp.setter
    def webp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webp", value)

    @property
    @pulumi.getter
    def websockets(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "websockets")

    @websockets.setter
    def websockets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "websockets", value)

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zero_rtt")

    @zero_rtt.setter
    def zero_rtt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_rtt", value)


@pulumi.input_type
class ZoneSettingsOverrideSettingsMinifyArgs:
    def __init__(__self__, *,
                 css: pulumi.Input[str],
                 html: pulumi.Input[str],
                 js: pulumi.Input[str]):
        ZoneSettingsOverrideSettingsMinifyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            css=css,
            html=html,
            js=js,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             css: pulumi.Input[str],
             html: pulumi.Input[str],
             js: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("css", css)
        _setter("html", html)
        _setter("js", js)

    @property
    @pulumi.getter
    def css(self) -> pulumi.Input[str]:
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: pulumi.Input[str]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> pulumi.Input[str]:
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: pulumi.Input[str]):
        pulumi.set(self, "js", value)


@pulumi.input_type
class ZoneSettingsOverrideSettingsMobileRedirectArgs:
    def __init__(__self__, *,
                 mobile_subdomain: pulumi.Input[str],
                 status: pulumi.Input[str],
                 strip_uri: pulumi.Input[bool]):
        ZoneSettingsOverrideSettingsMobileRedirectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mobile_subdomain=mobile_subdomain,
            status=status,
            strip_uri=strip_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mobile_subdomain: pulumi.Input[str],
             status: pulumi.Input[str],
             strip_uri: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mobile_subdomain", mobile_subdomain)
        _setter("status", status)
        _setter("strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mobile_subdomain")

    @mobile_subdomain.setter
    def mobile_subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "mobile_subdomain", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "strip_uri")

    @strip_uri.setter
    def strip_uri(self, value: pulumi.Input[bool]):
        pulumi.set(self, "strip_uri", value)


@pulumi.input_type
class ZoneSettingsOverrideSettingsSecurityHeaderArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 include_subdomains: Optional[pulumi.Input[bool]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 nosniff: Optional[pulumi.Input[bool]] = None,
                 preload: Optional[pulumi.Input[bool]] = None):
        ZoneSettingsOverrideSettingsSecurityHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            include_subdomains=include_subdomains,
            max_age=max_age,
            nosniff=nosniff,
            preload=preload,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             include_subdomains: Optional[pulumi.Input[bool]] = None,
             max_age: Optional[pulumi.Input[int]] = None,
             nosniff: Optional[pulumi.Input[bool]] = None,
             preload: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if include_subdomains is not None:
            _setter("include_subdomains", include_subdomains)
        if max_age is not None:
            _setter("max_age", max_age)
        if nosniff is not None:
            _setter("nosniff", nosniff)
        if preload is not None:
            _setter("preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nosniff")

    @nosniff.setter
    def nosniff(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nosniff", value)

    @property
    @pulumi.getter
    def preload(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preload")

    @preload.setter
    def preload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preload", value)


@pulumi.input_type
class GetLoadBalancerPoolsFilterArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: A regular expression matching the name of the Load Balancer pool to lookup.
        """
        GetLoadBalancerPoolsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A regular expression matching the name of the Load Balancer pool to lookup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetLoadBalancerPoolsPoolArgs:
    def __init__(__self__, *,
                 check_regions: Sequence[str],
                 created_on: str,
                 description: str,
                 enabled: bool,
                 id: str,
                 latitude: float,
                 load_sheddings: Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs'],
                 longitude: float,
                 minimum_origins: int,
                 modified_on: str,
                 monitor: str,
                 name: str,
                 notification_email: str,
                 origins: Sequence['GetLoadBalancerPoolsPoolOriginArgs']):
        """
        :param Sequence[str] check_regions: List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        :param str created_on: The RFC3339 timestamp of when the load balancer was created.
        :param str description: Brief description of the Load Balancer Pool intention.
        :param bool enabled: Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        :param str id: ID for this load balancer pool.
        :param float latitude: Latitude this pool is physically located at; used for proximity steering.
        :param Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs'] load_sheddings: Setting for controlling load shedding for this pool.
        :param float longitude: Longitude this pool is physically located at; used for proximity steering.
        :param int minimum_origins: Minimum number of origins that must be healthy for this pool to serve traffic.
        :param str modified_on: The RFC3339 timestamp of when the load balancer was last modified.
        :param str monitor: ID of the Monitor to use for health checking origins within this pool.
        :param str name: Short name (tag) for the pool.
        :param str notification_email: Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        :param Sequence['GetLoadBalancerPoolsPoolOriginArgs'] origins: The list of origins within this pool.
        """
        GetLoadBalancerPoolsPoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check_regions=check_regions,
            created_on=created_on,
            description=description,
            enabled=enabled,
            id=id,
            latitude=latitude,
            load_sheddings=load_sheddings,
            longitude=longitude,
            minimum_origins=minimum_origins,
            modified_on=modified_on,
            monitor=monitor,
            name=name,
            notification_email=notification_email,
            origins=origins,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check_regions: Sequence[str],
             created_on: str,
             description: str,
             enabled: bool,
             id: str,
             latitude: float,
             load_sheddings: Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs'],
             longitude: float,
             minimum_origins: int,
             modified_on: str,
             monitor: str,
             name: str,
             notification_email: str,
             origins: Sequence['GetLoadBalancerPoolsPoolOriginArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("check_regions", check_regions)
        _setter("created_on", created_on)
        _setter("description", description)
        _setter("enabled", enabled)
        _setter("id", id)
        _setter("latitude", latitude)
        _setter("load_sheddings", load_sheddings)
        _setter("longitude", longitude)
        _setter("minimum_origins", minimum_origins)
        _setter("modified_on", modified_on)
        _setter("monitor", monitor)
        _setter("name", name)
        _setter("notification_email", notification_email)
        _setter("origins", origins)

    @property
    @pulumi.getter(name="checkRegions")
    def check_regions(self) -> Sequence[str]:
        """
        List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        """
        return pulumi.get(self, "check_regions")

    @check_regions.setter
    def check_regions(self, value: Sequence[str]):
        pulumi.set(self, "check_regions", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The RFC3339 timestamp of when the load balancer was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: str):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Brief description of the Load Balancer Pool intention.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID for this load balancer pool.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def latitude(self) -> float:
        """
        Latitude this pool is physically located at; used for proximity steering.
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: float):
        pulumi.set(self, "latitude", value)

    @property
    @pulumi.getter(name="loadSheddings")
    def load_sheddings(self) -> Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs']:
        """
        Setting for controlling load shedding for this pool.
        """
        return pulumi.get(self, "load_sheddings")

    @load_sheddings.setter
    def load_sheddings(self, value: Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs']):
        pulumi.set(self, "load_sheddings", value)

    @property
    @pulumi.getter
    def longitude(self) -> float:
        """
        Longitude this pool is physically located at; used for proximity steering.
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: float):
        pulumi.set(self, "longitude", value)

    @property
    @pulumi.getter(name="minimumOrigins")
    def minimum_origins(self) -> int:
        """
        Minimum number of origins that must be healthy for this pool to serve traffic.
        """
        return pulumi.get(self, "minimum_origins")

    @minimum_origins.setter
    def minimum_origins(self, value: int):
        pulumi.set(self, "minimum_origins", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The RFC3339 timestamp of when the load balancer was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: str):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def monitor(self) -> str:
        """
        ID of the Monitor to use for health checking origins within this pool.
        """
        return pulumi.get(self, "monitor")

    @monitor.setter
    def monitor(self, value: str):
        pulumi.set(self, "monitor", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Short name (tag) for the pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="notificationEmail")
    def notification_email(self) -> str:
        """
        Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        """
        return pulumi.get(self, "notification_email")

    @notification_email.setter
    def notification_email(self, value: str):
        pulumi.set(self, "notification_email", value)

    @property
    @pulumi.getter
    def origins(self) -> Sequence['GetLoadBalancerPoolsPoolOriginArgs']:
        """
        The list of origins within this pool.
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: Sequence['GetLoadBalancerPoolsPoolOriginArgs']):
        pulumi.set(self, "origins", value)


@pulumi.input_type
class GetLoadBalancerPoolsPoolLoadSheddingArgs:
    def __init__(__self__, *,
                 default_percent: Optional[float] = None,
                 default_policy: Optional[str] = None,
                 session_percent: Optional[float] = None,
                 session_policy: Optional[str] = None):
        GetLoadBalancerPoolsPoolLoadSheddingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_percent=default_percent,
            default_policy=default_policy,
            session_percent=session_percent,
            session_policy=session_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_percent: Optional[float] = None,
             default_policy: Optional[str] = None,
             session_percent: Optional[float] = None,
             session_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_percent is not None:
            _setter("default_percent", default_percent)
        if default_policy is not None:
            _setter("default_policy", default_policy)
        if session_percent is not None:
            _setter("session_percent", session_percent)
        if session_policy is not None:
            _setter("session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[float]:
        return pulumi.get(self, "default_percent")

    @default_percent.setter
    def default_percent(self, value: Optional[float]):
        pulumi.set(self, "default_percent", value)

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[str]:
        return pulumi.get(self, "default_policy")

    @default_policy.setter
    def default_policy(self, value: Optional[str]):
        pulumi.set(self, "default_policy", value)

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[float]:
        return pulumi.get(self, "session_percent")

    @session_percent.setter
    def session_percent(self, value: Optional[float]):
        pulumi.set(self, "session_percent", value)

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[str]:
        return pulumi.get(self, "session_policy")

    @session_policy.setter
    def session_policy(self, value: Optional[str]):
        pulumi.set(self, "session_policy", value)


@pulumi.input_type
class GetLoadBalancerPoolsPoolOriginArgs:
    def __init__(__self__, *,
                 address: str,
                 name: str,
                 enabled: Optional[bool] = None,
                 headers: Optional[Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs']] = None,
                 weight: Optional[float] = None):
        """
        :param str name: A regular expression matching the name of the Load Balancer pool to lookup.
        :param bool enabled: Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        """
        GetLoadBalancerPoolsPoolOriginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            name=name,
            enabled=enabled,
            headers=headers,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: str,
             name: str,
             enabled: Optional[bool] = None,
             headers: Optional[Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs']] = None,
             weight: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("address", address)
        _setter("name", name)
        if enabled is not None:
            _setter("enabled", enabled)
        if headers is not None:
            _setter("headers", headers)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: str):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A regular expression matching the name of the Load Balancer pool to lookup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[float]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class GetLoadBalancerPoolsPoolOriginHeaderArgs:
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        GetLoadBalancerPoolsPoolOriginHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            header=header,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             header: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("header", header)
        _setter("values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: str):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetRulesetsFilterArgs:
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 phase: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: The ID of the Ruleset to target.
        :param str kind: Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        :param str name: Name of the ruleset.
        :param str phase: Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        :param str version: Version of the ruleset to filter on.
        """
        GetRulesetsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            kind=kind,
            name=name,
            phase=phase,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             kind: Optional[str] = None,
             name: Optional[str] = None,
             phase: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if kind is not None:
            _setter("kind", kind)
        if name is not None:
            _setter("name", name)
        if phase is not None:
            _setter("phase", phase)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Ruleset to target.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[str]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the ruleset to filter on.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class GetZonesFilterArgs:
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 lookup_type: Optional[str] = None,
                 match: Optional[str] = None,
                 name: Optional[str] = None,
                 paused: Optional[bool] = None,
                 status: Optional[str] = None):
        """
        :param str account_id: The account identifier to target for the resource.
        :param str lookup_type: The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        :param str match: A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        :param str name: A string value to search for.
        :param bool paused: Paused status of the zone to lookup. Defaults to `false`.
        :param str status: Status of the zone to lookup.
        """
        GetZonesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            lookup_type=lookup_type,
            match=match,
            name=name,
            paused=paused,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: Optional[str] = None,
             lookup_type: Optional[str] = None,
             match: Optional[str] = None,
             name: Optional[str] = None,
             paused: Optional[bool] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if account_id is not None:
            _setter("account_id", account_id)
        if lookup_type is not None:
            _setter("lookup_type", lookup_type)
        if match is not None:
            _setter("match", match)
        if name is not None:
            _setter("name", name)
        if paused is not None:
            _setter("paused", paused)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The account identifier to target for the resource.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="lookupType")
    def lookup_type(self) -> Optional[str]:
        """
        The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        """
        return pulumi.get(self, "lookup_type")

    @lookup_type.setter
    def lookup_type(self, value: Optional[str]):
        pulumi.set(self, "lookup_type", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[str]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A string value to search for.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        Paused status of the zone to lookup. Defaults to `false`.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[bool]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the zone to lookup.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[str]):
        pulumi.set(self, "status", value)


