# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['TeamsRuleArgs', 'TeamsRule']

@pulumi.input_type
class TeamsRuleArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[_builtins.str],
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 device_posture: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 expiration: Optional[pulumi.Input['TeamsRuleExpirationArgs']] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 identity: Optional[pulumi.Input[_builtins.str]] = None,
                 precedence: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_settings: Optional[pulumi.Input['TeamsRuleRuleSettingsArgs']] = None,
                 schedule: Optional[pulumi.Input['TeamsRuleScheduleArgs']] = None,
                 traffic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a TeamsRule resource.
        :param pulumi.Input[_builtins.str] action: Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
               Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect".
        :param pulumi.Input[_builtins.str] name: Specify the rule name.
        :param pulumi.Input[_builtins.str] description: Specify the rule description.
        :param pulumi.Input[_builtins.bool] enabled: Specify whether the rule is enabled.
        :param pulumi.Input['TeamsRuleExpirationArgs'] expiration: Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] filters: Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        :param pulumi.Input['TeamsRuleScheduleArgs'] schedule: Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if rule_settings is not None:
            pulumi.set(__self__, "rule_settings", rule_settings)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if traffic is not None:
            pulumi.set(__self__, "traffic", traffic)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
        Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specify the rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify the rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specify whether the rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['TeamsRuleExpirationArgs']]:
        """
        Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['TeamsRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity", value)

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "precedence")

    @precedence.setter
    def precedence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "precedence", value)

    @_builtins.property
    @pulumi.getter(name="ruleSettings")
    def rule_settings(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsArgs']]:
        return pulumi.get(self, "rule_settings")

    @rule_settings.setter
    def rule_settings(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsArgs']]):
        pulumi.set(self, "rule_settings", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['TeamsRuleScheduleArgs']]:
        """
        Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['TeamsRuleScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @_builtins.property
    @pulumi.getter
    def traffic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "traffic")

    @traffic.setter
    def traffic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic", value)


@pulumi.input_type
class _TeamsRuleState:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 device_posture: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 expiration: Optional[pulumi.Input['TeamsRuleExpirationArgs']] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 identity: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 precedence: Optional[pulumi.Input[_builtins.int]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 rule_settings: Optional[pulumi.Input['TeamsRuleRuleSettingsArgs']] = None,
                 schedule: Optional[pulumi.Input['TeamsRuleScheduleArgs']] = None,
                 sharable: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_account: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None,
                 warning_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering TeamsRule resources.
        :param pulumi.Input[_builtins.str] action: Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
               Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect".
        :param pulumi.Input[_builtins.str] deleted_at: Indicate the date of deletion, if any.
        :param pulumi.Input[_builtins.str] description: Specify the rule description.
        :param pulumi.Input[_builtins.bool] enabled: Specify whether the rule is enabled.
        :param pulumi.Input['TeamsRuleExpirationArgs'] expiration: Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] filters: Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        :param pulumi.Input[_builtins.str] name: Specify the rule name.
        :param pulumi.Input[_builtins.bool] read_only: Indicate that this rule is shared via the Orgs API and read only.
        :param pulumi.Input['TeamsRuleScheduleArgs'] schedule: Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules.
        :param pulumi.Input[_builtins.bool] sharable: Indicate that this rule is sharable via the Orgs API.
        :param pulumi.Input[_builtins.str] source_account: Provide the account tag of the account that created the rule.
        :param pulumi.Input[_builtins.int] version: Indicate the version number of the rule(read-only).
        :param pulumi.Input[_builtins.str] warning_status: Indicate a warning for a misconfigured rule, if any.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if rule_settings is not None:
            pulumi.set(__self__, "rule_settings", rule_settings)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if sharable is not None:
            pulumi.set(__self__, "sharable", sharable)
        if source_account is not None:
            pulumi.set(__self__, "source_account", source_account)
        if traffic is not None:
            pulumi.set(__self__, "traffic", traffic)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if warning_status is not None:
            pulumi.set(__self__, "warning_status", warning_status)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
        Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicate the date of deletion, if any.
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify the rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specify whether the rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['TeamsRuleExpirationArgs']]:
        """
        Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['TeamsRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify the rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "precedence")

    @precedence.setter
    def precedence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "precedence", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate that this rule is shared via the Orgs API and read only.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="ruleSettings")
    def rule_settings(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsArgs']]:
        return pulumi.get(self, "rule_settings")

    @rule_settings.setter
    def rule_settings(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsArgs']]):
        pulumi.set(self, "rule_settings", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['TeamsRuleScheduleArgs']]:
        """
        Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['TeamsRuleScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @_builtins.property
    @pulumi.getter
    def sharable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate that this rule is sharable via the Orgs API.
        """
        return pulumi.get(self, "sharable")

    @sharable.setter
    def sharable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sharable", value)

    @_builtins.property
    @pulumi.getter(name="sourceAccount")
    def source_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provide the account tag of the account that created the rule.
        """
        return pulumi.get(self, "source_account")

    @source_account.setter
    def source_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_account", value)

    @_builtins.property
    @pulumi.getter
    def traffic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "traffic")

    @traffic.setter
    def traffic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicate the version number of the rule(read-only).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="warningStatus")
    def warning_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicate a warning for a misconfigured rule, if any.
        """
        return pulumi.get(self, "warning_status")

    @warning_status.setter
    def warning_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warning_status", value)


warnings.warn("""cloudflare.index/teamsrule.TeamsRule has been deprecated in favor of cloudflare.index/zerotrustgatewaypolicy.ZeroTrustGatewayPolicy""", DeprecationWarning)


@pulumi.type_token("cloudflare:index/teamsRule:TeamsRule")
class TeamsRule(pulumi.CustomResource):
    warnings.warn("""cloudflare.index/teamsrule.TeamsRule has been deprecated in favor of cloudflare.index/zerotrustgatewaypolicy.ZeroTrustGatewayPolicy""", DeprecationWarning)

    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 device_posture: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 expiration: Optional[pulumi.Input[Union['TeamsRuleExpirationArgs', 'TeamsRuleExpirationArgsDict']]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 identity: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 precedence: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_settings: Optional[pulumi.Input[Union['TeamsRuleRuleSettingsArgs', 'TeamsRuleRuleSettingsArgsDict']]] = None,
                 schedule: Optional[pulumi.Input[Union['TeamsRuleScheduleArgs', 'TeamsRuleScheduleArgsDict']]] = None,
                 traffic: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_cloudflare as cloudflare

        example_zero_trust_gateway_policy = cloudflare.ZeroTrustGatewayPolicy("example_zero_trust_gateway_policy",
            account_id="699d98642c564d2e855e9661899b7252",
            action="allow",
            name="block bad websites",
            description="Block bad websites based on their host name.",
            device_posture="any(device_posture.checks.passed[*] in {\\"1308749e-fcfb-4ebc-b051-fe022b632644\\"})",
            enabled=True,
            expiration={
                "expires_at": "2014-01-01T05:20:20Z",
                "duration": 10,
            },
            filters=["http"],
            identity="any(identity.groups.name[*] in {\\"finance\\"})",
            precedence=0,
            rule_settings={
                "add_headers": {
                    "My-Next-Header": [
                        "foo",
                        "bar",
                    ],
                    "X-Custom-Header-Name": ["somecustomvalue"],
                },
                "allow_child_bypass": False,
                "audit_ssh": {
                    "command_logging": False,
                },
                "biso_admin_controls": {
                    "copy": "remote_only",
                    "dcp": True,
                    "dd": True,
                    "dk": True,
                    "download": "enabled",
                    "dp": False,
                    "du": True,
                    "keyboard": "enabled",
                    "paste": "enabled",
                    "printing": "enabled",
                    "upload": "enabled",
                    "version": "v1",
                },
                "block_page": {
                    "target_uri": "https://example.com",
                    "include_context": True,
                },
                "block_page_enabled": True,
                "block_reason": "This website is a security risk",
                "bypass_parent_rule": False,
                "check_session": {
                    "duration": "300s",
                    "enforce": True,
                },
                "dns_resolvers": {
                    "ipv4s": [{
                        "ip": "2.2.2.2",
                        "port": 5053,
                        "route_through_private_network": True,
                        "vnet_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                    }],
                    "ipv6s": [{
                        "ip": "2001:DB8::",
                        "port": 5053,
                        "route_through_private_network": True,
                        "vnet_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                    }],
                },
                "egress": {
                    "ipv4": "192.0.2.2",
                    "ipv4_fallback": "192.0.2.3",
                    "ipv6": "2001:DB8::/64",
                },
                "forensic_copy": {
                    "enabled": True,
                },
                "ignore_cname_category_matches": True,
                "insecure_disable_dnssec_validation": False,
                "ip_categories": True,
                "ip_indicator_feeds": True,
                "l4override": {
                    "ip": "1.1.1.1",
                    "port": 0,
                },
                "notification_settings": {
                    "enabled": True,
                    "include_context": True,
                    "msg": "msg",
                    "support_url": "support_url",
                },
                "override_host": "example.com",
                "override_ips": [
                    "1.1.1.1",
                    "2.2.2.2",
                ],
                "payload_log": {
                    "enabled": True,
                },
                "quarantine": {
                    "file_types": ["exe"],
                },
                "redirect": {
                    "target_uri": "https://example.com",
                    "include_context": True,
                    "preserve_path_and_query": True,
                },
                "resolve_dns_internally": {
                    "fallback": "none",
                    "view_id": "view_id",
                },
                "resolve_dns_through_cloudflare": True,
                "untrusted_cert": {
                    "action": "error",
                },
            },
            schedule={
                "fri": "08:00-12:30,13:30-17:00",
                "mon": "08:00-12:30,13:30-17:00",
                "sat": "08:00-12:30,13:30-17:00",
                "sun": "08:00-12:30,13:30-17:00",
                "thu": "08:00-12:30,13:30-17:00",
                "time_zone": "America/New York",
                "tue": "08:00-12:30,13:30-17:00",
                "wed": "08:00-12:30,13:30-17:00",
            },
            traffic="http.request.uri matches \\".*a/partial/uri.*\\" and http.request.host in $01302951-49f9-47c9-a400-0297e60b6a10")
        ```

        ## Import

        ```sh
        $ pulumi import cloudflare:index/teamsRule:TeamsRule example '<account_id>/<rule_id>'
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] action: Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
               Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect".
        :param pulumi.Input[_builtins.str] description: Specify the rule description.
        :param pulumi.Input[_builtins.bool] enabled: Specify whether the rule is enabled.
        :param pulumi.Input[Union['TeamsRuleExpirationArgs', 'TeamsRuleExpirationArgsDict']] expiration: Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] filters: Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        :param pulumi.Input[_builtins.str] name: Specify the rule name.
        :param pulumi.Input[Union['TeamsRuleScheduleArgs', 'TeamsRuleScheduleArgsDict']] schedule: Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: TeamsRuleArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_cloudflare as cloudflare

        example_zero_trust_gateway_policy = cloudflare.ZeroTrustGatewayPolicy("example_zero_trust_gateway_policy",
            account_id="699d98642c564d2e855e9661899b7252",
            action="allow",
            name="block bad websites",
            description="Block bad websites based on their host name.",
            device_posture="any(device_posture.checks.passed[*] in {\\"1308749e-fcfb-4ebc-b051-fe022b632644\\"})",
            enabled=True,
            expiration={
                "expires_at": "2014-01-01T05:20:20Z",
                "duration": 10,
            },
            filters=["http"],
            identity="any(identity.groups.name[*] in {\\"finance\\"})",
            precedence=0,
            rule_settings={
                "add_headers": {
                    "My-Next-Header": [
                        "foo",
                        "bar",
                    ],
                    "X-Custom-Header-Name": ["somecustomvalue"],
                },
                "allow_child_bypass": False,
                "audit_ssh": {
                    "command_logging": False,
                },
                "biso_admin_controls": {
                    "copy": "remote_only",
                    "dcp": True,
                    "dd": True,
                    "dk": True,
                    "download": "enabled",
                    "dp": False,
                    "du": True,
                    "keyboard": "enabled",
                    "paste": "enabled",
                    "printing": "enabled",
                    "upload": "enabled",
                    "version": "v1",
                },
                "block_page": {
                    "target_uri": "https://example.com",
                    "include_context": True,
                },
                "block_page_enabled": True,
                "block_reason": "This website is a security risk",
                "bypass_parent_rule": False,
                "check_session": {
                    "duration": "300s",
                    "enforce": True,
                },
                "dns_resolvers": {
                    "ipv4s": [{
                        "ip": "2.2.2.2",
                        "port": 5053,
                        "route_through_private_network": True,
                        "vnet_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                    }],
                    "ipv6s": [{
                        "ip": "2001:DB8::",
                        "port": 5053,
                        "route_through_private_network": True,
                        "vnet_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                    }],
                },
                "egress": {
                    "ipv4": "192.0.2.2",
                    "ipv4_fallback": "192.0.2.3",
                    "ipv6": "2001:DB8::/64",
                },
                "forensic_copy": {
                    "enabled": True,
                },
                "ignore_cname_category_matches": True,
                "insecure_disable_dnssec_validation": False,
                "ip_categories": True,
                "ip_indicator_feeds": True,
                "l4override": {
                    "ip": "1.1.1.1",
                    "port": 0,
                },
                "notification_settings": {
                    "enabled": True,
                    "include_context": True,
                    "msg": "msg",
                    "support_url": "support_url",
                },
                "override_host": "example.com",
                "override_ips": [
                    "1.1.1.1",
                    "2.2.2.2",
                ],
                "payload_log": {
                    "enabled": True,
                },
                "quarantine": {
                    "file_types": ["exe"],
                },
                "redirect": {
                    "target_uri": "https://example.com",
                    "include_context": True,
                    "preserve_path_and_query": True,
                },
                "resolve_dns_internally": {
                    "fallback": "none",
                    "view_id": "view_id",
                },
                "resolve_dns_through_cloudflare": True,
                "untrusted_cert": {
                    "action": "error",
                },
            },
            schedule={
                "fri": "08:00-12:30,13:30-17:00",
                "mon": "08:00-12:30,13:30-17:00",
                "sat": "08:00-12:30,13:30-17:00",
                "sun": "08:00-12:30,13:30-17:00",
                "thu": "08:00-12:30,13:30-17:00",
                "time_zone": "America/New York",
                "tue": "08:00-12:30,13:30-17:00",
                "wed": "08:00-12:30,13:30-17:00",
            },
            traffic="http.request.uri matches \\".*a/partial/uri.*\\" and http.request.host in $01302951-49f9-47c9-a400-0297e60b6a10")
        ```

        ## Import

        ```sh
        $ pulumi import cloudflare:index/teamsRule:TeamsRule example '<account_id>/<rule_id>'
        ```

        :param str resource_name: The name of the resource.
        :param TeamsRuleArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(TeamsRuleArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 device_posture: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 expiration: Optional[pulumi.Input[Union['TeamsRuleExpirationArgs', 'TeamsRuleExpirationArgsDict']]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 identity: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 precedence: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_settings: Optional[pulumi.Input[Union['TeamsRuleRuleSettingsArgs', 'TeamsRuleRuleSettingsArgsDict']]] = None,
                 schedule: Optional[pulumi.Input[Union['TeamsRuleScheduleArgs', 'TeamsRuleScheduleArgsDict']]] = None,
                 traffic: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        pulumi.log.warn("""TeamsRule is deprecated: cloudflare.index/teamsrule.TeamsRule has been deprecated in favor of cloudflare.index/zerotrustgatewaypolicy.ZeroTrustGatewayPolicy""")
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = TeamsRuleArgs.__new__(TeamsRuleArgs)

            if account_id is None and not opts.urn:
                raise TypeError("Missing required property 'account_id'")
            __props__.__dict__["account_id"] = account_id
            if action is None and not opts.urn:
                raise TypeError("Missing required property 'action'")
            __props__.__dict__["action"] = action
            __props__.__dict__["description"] = description
            __props__.__dict__["device_posture"] = device_posture
            __props__.__dict__["enabled"] = enabled
            __props__.__dict__["expiration"] = expiration
            __props__.__dict__["filters"] = filters
            __props__.__dict__["identity"] = identity
            if name is None and not opts.urn:
                raise TypeError("Missing required property 'name'")
            __props__.__dict__["name"] = name
            __props__.__dict__["precedence"] = precedence
            __props__.__dict__["rule_settings"] = rule_settings
            __props__.__dict__["schedule"] = schedule
            __props__.__dict__["traffic"] = traffic
            __props__.__dict__["created_at"] = None
            __props__.__dict__["deleted_at"] = None
            __props__.__dict__["read_only"] = None
            __props__.__dict__["sharable"] = None
            __props__.__dict__["source_account"] = None
            __props__.__dict__["updated_at"] = None
            __props__.__dict__["version"] = None
            __props__.__dict__["warning_status"] = None
        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="cloudflare:index/teamsRule:TeamsRule")])
        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
        super(TeamsRule, __self__).__init__(
            'cloudflare:index/teamsRule:TeamsRule',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            account_id: Optional[pulumi.Input[_builtins.str]] = None,
            action: Optional[pulumi.Input[_builtins.str]] = None,
            created_at: Optional[pulumi.Input[_builtins.str]] = None,
            deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            device_posture: Optional[pulumi.Input[_builtins.str]] = None,
            enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            expiration: Optional[pulumi.Input[Union['TeamsRuleExpirationArgs', 'TeamsRuleExpirationArgsDict']]] = None,
            filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            identity: Optional[pulumi.Input[_builtins.str]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            precedence: Optional[pulumi.Input[_builtins.int]] = None,
            read_only: Optional[pulumi.Input[_builtins.bool]] = None,
            rule_settings: Optional[pulumi.Input[Union['TeamsRuleRuleSettingsArgs', 'TeamsRuleRuleSettingsArgsDict']]] = None,
            schedule: Optional[pulumi.Input[Union['TeamsRuleScheduleArgs', 'TeamsRuleScheduleArgsDict']]] = None,
            sharable: Optional[pulumi.Input[_builtins.bool]] = None,
            source_account: Optional[pulumi.Input[_builtins.str]] = None,
            traffic: Optional[pulumi.Input[_builtins.str]] = None,
            updated_at: Optional[pulumi.Input[_builtins.str]] = None,
            version: Optional[pulumi.Input[_builtins.int]] = None,
            warning_status: Optional[pulumi.Input[_builtins.str]] = None) -> 'TeamsRule':
        """
        Get an existing TeamsRule resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] action: Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
               Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect".
        :param pulumi.Input[_builtins.str] deleted_at: Indicate the date of deletion, if any.
        :param pulumi.Input[_builtins.str] description: Specify the rule description.
        :param pulumi.Input[_builtins.bool] enabled: Specify whether the rule is enabled.
        :param pulumi.Input[Union['TeamsRuleExpirationArgs', 'TeamsRuleExpirationArgsDict']] expiration: Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] filters: Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        :param pulumi.Input[_builtins.str] name: Specify the rule name.
        :param pulumi.Input[_builtins.bool] read_only: Indicate that this rule is shared via the Orgs API and read only.
        :param pulumi.Input[Union['TeamsRuleScheduleArgs', 'TeamsRuleScheduleArgsDict']] schedule: Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules.
        :param pulumi.Input[_builtins.bool] sharable: Indicate that this rule is sharable via the Orgs API.
        :param pulumi.Input[_builtins.str] source_account: Provide the account tag of the account that created the rule.
        :param pulumi.Input[_builtins.int] version: Indicate the version number of the rule(read-only).
        :param pulumi.Input[_builtins.str] warning_status: Indicate a warning for a misconfigured rule, if any.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _TeamsRuleState.__new__(_TeamsRuleState)

        __props__.__dict__["account_id"] = account_id
        __props__.__dict__["action"] = action
        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["deleted_at"] = deleted_at
        __props__.__dict__["description"] = description
        __props__.__dict__["device_posture"] = device_posture
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["expiration"] = expiration
        __props__.__dict__["filters"] = filters
        __props__.__dict__["identity"] = identity
        __props__.__dict__["name"] = name
        __props__.__dict__["precedence"] = precedence
        __props__.__dict__["read_only"] = read_only
        __props__.__dict__["rule_settings"] = rule_settings
        __props__.__dict__["schedule"] = schedule
        __props__.__dict__["sharable"] = sharable
        __props__.__dict__["source_account"] = source_account
        __props__.__dict__["traffic"] = traffic
        __props__.__dict__["updated_at"] = updated_at
        __props__.__dict__["version"] = version
        __props__.__dict__["warning_status"] = warning_status
        return TeamsRule(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Output[_builtins.str]:
        """
        Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
        Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect".
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> pulumi.Output[_builtins.str]:
        """
        Indicate the date of deletion, if any.
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Specify the rule description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "device_posture")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[_builtins.bool]:
        """
        Specify whether the rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> pulumi.Output['outputs.TeamsRuleExpiration']:
        """
        Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        Specify the rule name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> pulumi.Output[_builtins.int]:
        return pulumi.get(self, "precedence")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> pulumi.Output[_builtins.bool]:
        """
        Indicate that this rule is shared via the Orgs API and read only.
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter(name="ruleSettings")
    def rule_settings(self) -> pulumi.Output['outputs.TeamsRuleRuleSettings']:
        return pulumi.get(self, "rule_settings")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> pulumi.Output['outputs.TeamsRuleSchedule']:
        """
        Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules.
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter
    def sharable(self) -> pulumi.Output[_builtins.bool]:
        """
        Indicate that this rule is sharable via the Orgs API.
        """
        return pulumi.get(self, "sharable")

    @_builtins.property
    @pulumi.getter(name="sourceAccount")
    def source_account(self) -> pulumi.Output[_builtins.str]:
        """
        Provide the account tag of the account that created the rule.
        """
        return pulumi.get(self, "source_account")

    @_builtins.property
    @pulumi.getter
    def traffic(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "traffic")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Output[_builtins.int]:
        """
        Indicate the version number of the rule(read-only).
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="warningStatus")
    def warning_status(self) -> pulumi.Output[_builtins.str]:
        """
        Indicate a warning for a misconfigured rule, if any.
        """
        return pulumi.get(self, "warning_status")

