# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AccessRuleConfiguration',
    'AccessRuleScope',
    'AccountMemberPolicy',
    'AccountMemberPolicyPermissionGroup',
    'AccountMemberPolicyResourceGroup',
    'AccountMemberUser',
    'AccountSettings',
    'AccountSubscriptionRatePlan',
    'AccountTokenCondition',
    'AccountTokenConditionRequestIp',
    'AccountTokenPolicy',
    'AccountTokenPolicyPermissionGroup',
    'AccountTokenPolicyPermissionGroupMeta',
    'AccountUnit',
    'AddressMapMembership',
    'ApiShieldAuthIdCharacteristic',
    'ApiShieldError',
    'ApiShieldMessage',
    'ApiShieldOperationFeatures',
    'ApiShieldOperationFeaturesApiRouting',
    'ApiShieldOperationFeaturesConfidenceIntervals',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99',
    'ApiShieldOperationFeaturesParameterSchemas',
    'ApiShieldOperationFeaturesParameterSchemasParameterSchemas',
    'ApiShieldOperationFeaturesSchemaInfo',
    'ApiShieldOperationFeaturesSchemaInfoActiveSchema',
    'ApiShieldOperationFeaturesThresholds',
    'ApiShieldSchemaSchema',
    'ApiShieldSchemaUploadDetails',
    'ApiShieldSchemaUploadDetailsWarning',
    'ApiTokenCondition',
    'ApiTokenConditionRequestIp',
    'ApiTokenPolicy',
    'ApiTokenPolicyPermissionGroup',
    'ApiTokenPolicyPermissionGroupMeta',
    'AuthenticatedOriginPullsConfig',
    'BotManagementStaleZoneConfiguration',
<<<<<<< HEAD
=======
    'CloudConnectorRulesParameters',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'CloudConnectorRulesRule',
    'CloudConnectorRulesRuleParameters',
    'ContentScanningExpressionBody',
    'CustomHostnameOwnershipVerification',
    'CustomHostnameOwnershipVerificationHttp',
    'CustomHostnameSsl',
<<<<<<< HEAD
=======
    'CustomHostnameSslCustomCertBundle',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'CustomHostnameSslSettings',
    'CustomSslGeoRestrictions',
    'CustomSslKeylessServer',
    'CustomSslKeylessServerTunnel',
    'DnsFirewallAttackMitigation',
    'DnsRecordData',
    'DnsRecordSettings',
<<<<<<< HEAD
=======
    'DnsSettingsZoneDefaults',
    'DnsSettingsZoneDefaultsInternalDns',
    'DnsSettingsZoneDefaultsNameservers',
    'DnsSettingsZoneDefaultsSoa',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'EmailRoutingCatchAllAction',
    'EmailRoutingCatchAllMatcher',
    'EmailRoutingDnsError',
    'EmailRoutingDnsMessage',
    'EmailRoutingDnsResult',
    'EmailRoutingDnsResultError',
    'EmailRoutingDnsResultErrorMissing',
    'EmailRoutingDnsResultInfo',
    'EmailRoutingDnsResultRecord',
    'EmailRoutingRuleAction',
    'EmailRoutingRuleMatcher',
    'EmailSecurityTrustedDomainsBody',
    'FirewallRuleAction',
    'FirewallRuleActionResponse',
    'FirewallRuleFilter',
    'HealthcheckHttpConfig',
    'HealthcheckTcpConfig',
    'HyperdriveConfigCaching',
    'HyperdriveConfigOrigin',
    'ImageVariantOptions',
    'ImageVariantVariant',
    'ImageVariantVariantOptions',
    'KeylessCertificateTunnel',
    'ListItemHostname',
    'ListItemRedirect',
    'LoadBalancerAdaptiveRouting',
    'LoadBalancerLocationStrategy',
    'LoadBalancerPoolLoadShedding',
    'LoadBalancerPoolNotificationFilter',
    'LoadBalancerPoolNotificationFilterOrigin',
    'LoadBalancerPoolNotificationFilterPool',
    'LoadBalancerPoolOrigin',
    'LoadBalancerPoolOriginHeader',
    'LoadBalancerPoolOriginSteering',
    'LoadBalancerRandomSteering',
    'LoadBalancerRule',
    'LoadBalancerRuleFixedResponse',
    'LoadBalancerRuleOverrides',
    'LoadBalancerRuleOverridesAdaptiveRouting',
    'LoadBalancerRuleOverridesLocationStrategy',
    'LoadBalancerRuleOverridesRandomSteering',
    'LoadBalancerRuleOverridesSessionAffinityAttributes',
    'LoadBalancerSessionAffinityAttributes',
    'LogpushJobOutputOptions',
    'MagicNetworkMonitoringConfigurationWarpDevice',
    'MagicTransitConnectorDevice',
    'MagicTransitSiteAclLan1',
    'MagicTransitSiteAclLan2',
    'MagicTransitSiteLanNat',
    'MagicTransitSiteLanRoutedSubnet',
    'MagicTransitSiteLanRoutedSubnetNat',
    'MagicTransitSiteLanStaticAddressing',
    'MagicTransitSiteLanStaticAddressingDhcpRelay',
    'MagicTransitSiteLanStaticAddressingDhcpServer',
    'MagicTransitSiteLocation',
    'MagicTransitSiteWanStaticAddressing',
    'MagicWanGreTunnelGreTunnel',
    'MagicWanGreTunnelGreTunnelHealthCheck',
    'MagicWanGreTunnelGreTunnelHealthCheckTarget',
    'MagicWanGreTunnelHealthCheck',
    'MagicWanGreTunnelHealthCheckTarget',
    'MagicWanGreTunnelModifiedGreTunnel',
    'MagicWanGreTunnelModifiedGreTunnelHealthCheck',
    'MagicWanGreTunnelModifiedGreTunnelHealthCheckTarget',
    'MagicWanIpsecTunnelHealthCheck',
    'MagicWanIpsecTunnelHealthCheckTarget',
    'MagicWanIpsecTunnelIpsecTunnel',
    'MagicWanIpsecTunnelIpsecTunnelHealthCheck',
    'MagicWanIpsecTunnelIpsecTunnelHealthCheckTarget',
    'MagicWanIpsecTunnelIpsecTunnelPskMetadata',
    'MagicWanIpsecTunnelModifiedIpsecTunnel',
    'MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheck',
    'MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTarget',
    'MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata',
    'MagicWanStaticRouteModifiedRoute',
    'MagicWanStaticRouteModifiedRouteScope',
    'MagicWanStaticRouteRoute',
    'MagicWanStaticRouteRouteScope',
    'MagicWanStaticRouteScope',
    'ManagedTransformsManagedRequestHeader',
    'ManagedTransformsManagedResponseHeader',
    'NotificationPolicyFilters',
    'NotificationPolicyMechanisms',
    'NotificationPolicyMechanismsEmail',
    'NotificationPolicyMechanismsPagerduty',
    'NotificationPolicyMechanismsWebhook',
    'ObservatoryScheduledTestSchedule',
    'ObservatoryScheduledTestTest',
    'ObservatoryScheduledTestTestDesktopReport',
    'ObservatoryScheduledTestTestDesktopReportError',
    'ObservatoryScheduledTestTestMobileReport',
    'ObservatoryScheduledTestTestMobileReportError',
    'ObservatoryScheduledTestTestRegion',
    'PageRuleActions',
    'PageRuleActionsCacheKeyFields',
    'PageRuleActionsCacheKeyFieldsCookie',
    'PageRuleActionsCacheKeyFieldsHeader',
    'PageRuleActionsCacheKeyFieldsHost',
    'PageRuleActionsCacheKeyFieldsQueryString',
    'PageRuleActionsCacheKeyFieldsUser',
    'PageRuleActionsForwardingUrl',
    'PagesDomainValidationData',
    'PagesDomainVerificationData',
    'PagesProjectBuildConfig',
    'PagesProjectCanonicalDeployment',
    'PagesProjectCanonicalDeploymentBuildConfig',
    'PagesProjectCanonicalDeploymentDeploymentTrigger',
    'PagesProjectCanonicalDeploymentDeploymentTriggerMetadata',
    'PagesProjectCanonicalDeploymentEnvVars',
    'PagesProjectCanonicalDeploymentLatestStage',
    'PagesProjectCanonicalDeploymentSource',
    'PagesProjectCanonicalDeploymentSourceConfig',
    'PagesProjectCanonicalDeploymentStage',
    'PagesProjectDeploymentConfigs',
    'PagesProjectDeploymentConfigsPreview',
    'PagesProjectDeploymentConfigsPreviewAiBindings',
    'PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets',
    'PagesProjectDeploymentConfigsPreviewBrowsers',
    'PagesProjectDeploymentConfigsPreviewD1Databases',
    'PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces',
    'PagesProjectDeploymentConfigsPreviewEnvVars',
    'PagesProjectDeploymentConfigsPreviewHyperdriveBindings',
    'PagesProjectDeploymentConfigsPreviewKvNamespaces',
    'PagesProjectDeploymentConfigsPreviewMtlsCertificates',
    'PagesProjectDeploymentConfigsPreviewPlacement',
    'PagesProjectDeploymentConfigsPreviewQueueProducers',
    'PagesProjectDeploymentConfigsPreviewR2Buckets',
    'PagesProjectDeploymentConfigsPreviewServices',
    'PagesProjectDeploymentConfigsPreviewVectorizeBindings',
    'PagesProjectDeploymentConfigsProduction',
    'PagesProjectDeploymentConfigsProductionAiBindings',
    'PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets',
    'PagesProjectDeploymentConfigsProductionBrowsers',
    'PagesProjectDeploymentConfigsProductionD1Databases',
    'PagesProjectDeploymentConfigsProductionDurableObjectNamespaces',
    'PagesProjectDeploymentConfigsProductionEnvVars',
    'PagesProjectDeploymentConfigsProductionHyperdriveBindings',
    'PagesProjectDeploymentConfigsProductionKvNamespaces',
    'PagesProjectDeploymentConfigsProductionMtlsCertificates',
    'PagesProjectDeploymentConfigsProductionPlacement',
    'PagesProjectDeploymentConfigsProductionQueueProducers',
    'PagesProjectDeploymentConfigsProductionR2Buckets',
    'PagesProjectDeploymentConfigsProductionServices',
    'PagesProjectDeploymentConfigsProductionVectorizeBindings',
    'PagesProjectLatestDeployment',
    'PagesProjectLatestDeploymentBuildConfig',
    'PagesProjectLatestDeploymentDeploymentTrigger',
    'PagesProjectLatestDeploymentDeploymentTriggerMetadata',
    'PagesProjectLatestDeploymentEnvVars',
    'PagesProjectLatestDeploymentLatestStage',
    'PagesProjectLatestDeploymentSource',
    'PagesProjectLatestDeploymentSourceConfig',
    'PagesProjectLatestDeploymentStage',
    'PagesProjectSource',
    'PagesProjectSourceConfig',
    'QueueConsumer',
    'QueueConsumerSettings',
    'QueueProducer',
    'QueueSettings',
<<<<<<< HEAD
=======
    'R2BucketCorsRule',
    'R2BucketCorsRuleAllowed',
    'R2BucketEventNotificationQueue',
    'R2BucketEventNotificationQueueRule',
    'R2BucketEventNotificationRule',
    'R2BucketLifecycleRule',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransition',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition',
    'R2BucketLifecycleRuleConditions',
    'R2BucketLifecycleRuleDeleteObjectsTransition',
    'R2BucketLifecycleRuleDeleteObjectsTransitionCondition',
    'R2BucketLifecycleRuleStorageClassTransition',
    'R2BucketLifecycleRuleStorageClassTransitionCondition',
    'R2BucketLockRule',
    'R2BucketLockRuleCondition',
    'R2BucketSippyDestination',
    'R2BucketSippySource',
    'R2CustomDomainStatus',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'RateLimitAction',
    'RateLimitActionResponse',
    'RateLimitBypass',
    'RateLimitMatch',
    'RateLimitMatchHeader',
    'RateLimitMatchRequest',
    'RateLimitMatchResponse',
    'RecordData',
    'RecordSettings',
    'RulesetRule',
    'RulesetRuleActionParameters',
    'RulesetRuleActionParametersAlgorithm',
    'RulesetRuleActionParametersAutominify',
    'RulesetRuleActionParametersBrowserTtl',
    'RulesetRuleActionParametersCacheKey',
    'RulesetRuleActionParametersCacheKeyCustomKey',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookie',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeader',
    'RulesetRuleActionParametersCacheKeyCustomKeyHost',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryString',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude',
    'RulesetRuleActionParametersCacheKeyCustomKeyUser',
    'RulesetRuleActionParametersCacheReserve',
    'RulesetRuleActionParametersCookieField',
    'RulesetRuleActionParametersEdgeTtl',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtl',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange',
    'RulesetRuleActionParametersFromList',
    'RulesetRuleActionParametersFromValue',
    'RulesetRuleActionParametersFromValueTargetUrl',
    'RulesetRuleActionParametersHeaders',
    'RulesetRuleActionParametersMatchedData',
    'RulesetRuleActionParametersOrigin',
    'RulesetRuleActionParametersOverrides',
    'RulesetRuleActionParametersOverridesCategory',
    'RulesetRuleActionParametersOverridesRule',
    'RulesetRuleActionParametersRequestField',
    'RulesetRuleActionParametersResponse',
    'RulesetRuleActionParametersResponseField',
    'RulesetRuleActionParametersServeStale',
    'RulesetRuleActionParametersSni',
    'RulesetRuleActionParametersUri',
    'RulesetRuleActionParametersUriPath',
    'RulesetRuleActionParametersUriQuery',
    'RulesetRuleExposedCredentialCheck',
    'RulesetRuleLogging',
    'RulesetRuleRatelimit',
    'SnippetRulesRule',
    'SnippetsMetadata',
    'SpectrumApplicationDns',
    'SpectrumApplicationEdgeIps',
    'SpectrumApplicationOriginDns',
    'StreamInput',
    'StreamLiveInputRecording',
    'StreamLiveInputRtmps',
    'StreamLiveInputRtmpsPlayback',
    'StreamLiveInputSrt',
    'StreamLiveInputSrtPlayback',
    'StreamLiveInputWebRtc',
    'StreamLiveInputWebRtcPlayback',
    'StreamPlayback',
    'StreamStatus',
    'StreamWatermark',
    'UserAgentBlockingRuleConfiguration',
    'WaitingRoomAdditionalRoute',
    'WaitingRoomCookieAttributes',
    'WaitingRoomRulesRule',
    'WebAnalyticsSiteRule',
    'WebAnalyticsSiteRuleset',
    'WorkersCronTriggerSchedule',
    'WorkersDeploymentAnnotations',
    'WorkersDeploymentDeployment',
    'WorkersDeploymentDeploymentAnnotations',
    'WorkersDeploymentDeploymentVersion',
    'WorkersDeploymentVersion',
<<<<<<< HEAD
=======
    'WorkersRouteError',
    'WorkersRouteMessage',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'WorkersScriptAssets',
    'WorkersScriptAssetsConfig',
    'WorkersScriptBinding',
    'WorkersScriptBindingOutbound',
    'WorkersScriptBindingOutboundWorker',
    'WorkersScriptMigrations',
    'WorkersScriptMigrationsRenamedClass',
    'WorkersScriptMigrationsStep',
    'WorkersScriptMigrationsStepRenamedClass',
    'WorkersScriptMigrationsStepTransferredClass',
    'WorkersScriptMigrationsTransferredClass',
    'WorkersScriptObservability',
    'WorkersScriptPlacement',
    'WorkersScriptTailConsumer',
    'ZeroTrustAccessApplicationCorsHeaders',
    'ZeroTrustAccessApplicationDestination',
    'ZeroTrustAccessApplicationFooterLink',
    'ZeroTrustAccessApplicationLandingPageDesign',
    'ZeroTrustAccessApplicationPolicy',
    'ZeroTrustAccessApplicationPolicyConnectionRules',
    'ZeroTrustAccessApplicationPolicyConnectionRulesSsh',
    'ZeroTrustAccessApplicationPolicyExclude',
    'ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken',
    'ZeroTrustAccessApplicationPolicyExcludeAuthContext',
    'ZeroTrustAccessApplicationPolicyExcludeAuthMethod',
    'ZeroTrustAccessApplicationPolicyExcludeAzureAd',
    'ZeroTrustAccessApplicationPolicyExcludeCertificate',
    'ZeroTrustAccessApplicationPolicyExcludeCommonName',
    'ZeroTrustAccessApplicationPolicyExcludeDevicePosture',
    'ZeroTrustAccessApplicationPolicyExcludeEmail',
    'ZeroTrustAccessApplicationPolicyExcludeEmailDomain',
    'ZeroTrustAccessApplicationPolicyExcludeEmailList',
    'ZeroTrustAccessApplicationPolicyExcludeEveryone',
    'ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation',
    'ZeroTrustAccessApplicationPolicyExcludeGeo',
    'ZeroTrustAccessApplicationPolicyExcludeGithubOrganization',
    'ZeroTrustAccessApplicationPolicyExcludeGroup',
    'ZeroTrustAccessApplicationPolicyExcludeGsuite',
    'ZeroTrustAccessApplicationPolicyExcludeIp',
    'ZeroTrustAccessApplicationPolicyExcludeIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessApplicationPolicyExcludeLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessApplicationPolicyExcludeOkta',
    'ZeroTrustAccessApplicationPolicyExcludeSaml',
    'ZeroTrustAccessApplicationPolicyExcludeServiceToken',
    'ZeroTrustAccessApplicationPolicyInclude',
    'ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken',
    'ZeroTrustAccessApplicationPolicyIncludeAuthContext',
    'ZeroTrustAccessApplicationPolicyIncludeAuthMethod',
    'ZeroTrustAccessApplicationPolicyIncludeAzureAd',
    'ZeroTrustAccessApplicationPolicyIncludeCertificate',
    'ZeroTrustAccessApplicationPolicyIncludeCommonName',
    'ZeroTrustAccessApplicationPolicyIncludeDevicePosture',
    'ZeroTrustAccessApplicationPolicyIncludeEmail',
    'ZeroTrustAccessApplicationPolicyIncludeEmailDomain',
    'ZeroTrustAccessApplicationPolicyIncludeEmailList',
    'ZeroTrustAccessApplicationPolicyIncludeEveryone',
    'ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation',
    'ZeroTrustAccessApplicationPolicyIncludeGeo',
    'ZeroTrustAccessApplicationPolicyIncludeGithubOrganization',
    'ZeroTrustAccessApplicationPolicyIncludeGroup',
    'ZeroTrustAccessApplicationPolicyIncludeGsuite',
    'ZeroTrustAccessApplicationPolicyIncludeIp',
    'ZeroTrustAccessApplicationPolicyIncludeIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessApplicationPolicyIncludeLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessApplicationPolicyIncludeOkta',
    'ZeroTrustAccessApplicationPolicyIncludeSaml',
    'ZeroTrustAccessApplicationPolicyIncludeServiceToken',
    'ZeroTrustAccessApplicationPolicyRequire',
    'ZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken',
    'ZeroTrustAccessApplicationPolicyRequireAuthContext',
    'ZeroTrustAccessApplicationPolicyRequireAuthMethod',
    'ZeroTrustAccessApplicationPolicyRequireAzureAd',
    'ZeroTrustAccessApplicationPolicyRequireCertificate',
    'ZeroTrustAccessApplicationPolicyRequireCommonName',
    'ZeroTrustAccessApplicationPolicyRequireDevicePosture',
    'ZeroTrustAccessApplicationPolicyRequireEmail',
    'ZeroTrustAccessApplicationPolicyRequireEmailDomain',
    'ZeroTrustAccessApplicationPolicyRequireEmailList',
    'ZeroTrustAccessApplicationPolicyRequireEveryone',
    'ZeroTrustAccessApplicationPolicyRequireExternalEvaluation',
    'ZeroTrustAccessApplicationPolicyRequireGeo',
    'ZeroTrustAccessApplicationPolicyRequireGithubOrganization',
    'ZeroTrustAccessApplicationPolicyRequireGroup',
    'ZeroTrustAccessApplicationPolicyRequireGsuite',
    'ZeroTrustAccessApplicationPolicyRequireIp',
    'ZeroTrustAccessApplicationPolicyRequireIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessApplicationPolicyRequireLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessApplicationPolicyRequireOkta',
    'ZeroTrustAccessApplicationPolicyRequireSaml',
    'ZeroTrustAccessApplicationPolicyRequireServiceToken',
    'ZeroTrustAccessApplicationSaasApp',
    'ZeroTrustAccessApplicationSaasAppCustomAttribute',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSource',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp',
    'ZeroTrustAccessApplicationSaasAppCustomClaim',
    'ZeroTrustAccessApplicationSaasAppCustomClaimSource',
    'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions',
    'ZeroTrustAccessApplicationSaasAppRefreshTokenOptions',
    'ZeroTrustAccessApplicationScimConfig',
    'ZeroTrustAccessApplicationScimConfigAuthentication',
    'ZeroTrustAccessApplicationScimConfigMapping',
    'ZeroTrustAccessApplicationScimConfigMappingOperations',
    'ZeroTrustAccessApplicationTargetCriteria',
    'ZeroTrustAccessGroupExclude',
    'ZeroTrustAccessGroupExcludeAnyValidServiceToken',
    'ZeroTrustAccessGroupExcludeAuthContext',
    'ZeroTrustAccessGroupExcludeAuthMethod',
    'ZeroTrustAccessGroupExcludeAzureAd',
    'ZeroTrustAccessGroupExcludeCertificate',
    'ZeroTrustAccessGroupExcludeCommonName',
    'ZeroTrustAccessGroupExcludeDevicePosture',
    'ZeroTrustAccessGroupExcludeEmail',
    'ZeroTrustAccessGroupExcludeEmailDomain',
    'ZeroTrustAccessGroupExcludeEmailList',
    'ZeroTrustAccessGroupExcludeEveryone',
    'ZeroTrustAccessGroupExcludeExternalEvaluation',
    'ZeroTrustAccessGroupExcludeGeo',
    'ZeroTrustAccessGroupExcludeGithubOrganization',
    'ZeroTrustAccessGroupExcludeGroup',
    'ZeroTrustAccessGroupExcludeGsuite',
    'ZeroTrustAccessGroupExcludeIp',
    'ZeroTrustAccessGroupExcludeIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessGroupExcludeLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessGroupExcludeOkta',
    'ZeroTrustAccessGroupExcludeSaml',
    'ZeroTrustAccessGroupExcludeServiceToken',
    'ZeroTrustAccessGroupInclude',
    'ZeroTrustAccessGroupIncludeAnyValidServiceToken',
    'ZeroTrustAccessGroupIncludeAuthContext',
    'ZeroTrustAccessGroupIncludeAuthMethod',
    'ZeroTrustAccessGroupIncludeAzureAd',
    'ZeroTrustAccessGroupIncludeCertificate',
    'ZeroTrustAccessGroupIncludeCommonName',
    'ZeroTrustAccessGroupIncludeDevicePosture',
    'ZeroTrustAccessGroupIncludeEmail',
    'ZeroTrustAccessGroupIncludeEmailDomain',
    'ZeroTrustAccessGroupIncludeEmailList',
    'ZeroTrustAccessGroupIncludeEveryone',
    'ZeroTrustAccessGroupIncludeExternalEvaluation',
    'ZeroTrustAccessGroupIncludeGeo',
    'ZeroTrustAccessGroupIncludeGithubOrganization',
    'ZeroTrustAccessGroupIncludeGroup',
    'ZeroTrustAccessGroupIncludeGsuite',
    'ZeroTrustAccessGroupIncludeIp',
    'ZeroTrustAccessGroupIncludeIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessGroupIncludeLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessGroupIncludeOkta',
    'ZeroTrustAccessGroupIncludeSaml',
    'ZeroTrustAccessGroupIncludeServiceToken',
    'ZeroTrustAccessGroupRequire',
    'ZeroTrustAccessGroupRequireAnyValidServiceToken',
    'ZeroTrustAccessGroupRequireAuthContext',
    'ZeroTrustAccessGroupRequireAuthMethod',
    'ZeroTrustAccessGroupRequireAzureAd',
    'ZeroTrustAccessGroupRequireCertificate',
    'ZeroTrustAccessGroupRequireCommonName',
    'ZeroTrustAccessGroupRequireDevicePosture',
    'ZeroTrustAccessGroupRequireEmail',
    'ZeroTrustAccessGroupRequireEmailDomain',
    'ZeroTrustAccessGroupRequireEmailList',
    'ZeroTrustAccessGroupRequireEveryone',
    'ZeroTrustAccessGroupRequireExternalEvaluation',
    'ZeroTrustAccessGroupRequireGeo',
    'ZeroTrustAccessGroupRequireGithubOrganization',
    'ZeroTrustAccessGroupRequireGroup',
    'ZeroTrustAccessGroupRequireGsuite',
    'ZeroTrustAccessGroupRequireIp',
    'ZeroTrustAccessGroupRequireIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessGroupRequireLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessGroupRequireOkta',
    'ZeroTrustAccessGroupRequireSaml',
    'ZeroTrustAccessGroupRequireServiceToken',
    'ZeroTrustAccessIdentityProviderConfig',
    'ZeroTrustAccessIdentityProviderConfigHeaderAttribute',
    'ZeroTrustAccessIdentityProviderScimConfig',
    'ZeroTrustAccessInfrastructureTargetIp',
    'ZeroTrustAccessInfrastructureTargetIpIpv4',
    'ZeroTrustAccessInfrastructureTargetIpIpv6',
    'ZeroTrustAccessMtlsHostnameSettingsSetting',
    'ZeroTrustAccessPolicyApprovalGroup',
    'ZeroTrustAccessPolicyExclude',
    'ZeroTrustAccessPolicyExcludeAnyValidServiceToken',
    'ZeroTrustAccessPolicyExcludeAuthContext',
    'ZeroTrustAccessPolicyExcludeAuthMethod',
    'ZeroTrustAccessPolicyExcludeAzureAd',
    'ZeroTrustAccessPolicyExcludeCertificate',
    'ZeroTrustAccessPolicyExcludeCommonName',
    'ZeroTrustAccessPolicyExcludeDevicePosture',
    'ZeroTrustAccessPolicyExcludeEmail',
    'ZeroTrustAccessPolicyExcludeEmailDomain',
    'ZeroTrustAccessPolicyExcludeEmailList',
    'ZeroTrustAccessPolicyExcludeEveryone',
    'ZeroTrustAccessPolicyExcludeExternalEvaluation',
    'ZeroTrustAccessPolicyExcludeGeo',
    'ZeroTrustAccessPolicyExcludeGithubOrganization',
    'ZeroTrustAccessPolicyExcludeGroup',
    'ZeroTrustAccessPolicyExcludeGsuite',
    'ZeroTrustAccessPolicyExcludeIp',
    'ZeroTrustAccessPolicyExcludeIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessPolicyExcludeLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessPolicyExcludeOkta',
    'ZeroTrustAccessPolicyExcludeSaml',
    'ZeroTrustAccessPolicyExcludeServiceToken',
    'ZeroTrustAccessPolicyInclude',
    'ZeroTrustAccessPolicyIncludeAnyValidServiceToken',
    'ZeroTrustAccessPolicyIncludeAuthContext',
    'ZeroTrustAccessPolicyIncludeAuthMethod',
    'ZeroTrustAccessPolicyIncludeAzureAd',
    'ZeroTrustAccessPolicyIncludeCertificate',
    'ZeroTrustAccessPolicyIncludeCommonName',
    'ZeroTrustAccessPolicyIncludeDevicePosture',
    'ZeroTrustAccessPolicyIncludeEmail',
    'ZeroTrustAccessPolicyIncludeEmailDomain',
    'ZeroTrustAccessPolicyIncludeEmailList',
    'ZeroTrustAccessPolicyIncludeEveryone',
    'ZeroTrustAccessPolicyIncludeExternalEvaluation',
    'ZeroTrustAccessPolicyIncludeGeo',
    'ZeroTrustAccessPolicyIncludeGithubOrganization',
    'ZeroTrustAccessPolicyIncludeGroup',
    'ZeroTrustAccessPolicyIncludeGsuite',
    'ZeroTrustAccessPolicyIncludeIp',
    'ZeroTrustAccessPolicyIncludeIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessPolicyIncludeLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessPolicyIncludeOkta',
    'ZeroTrustAccessPolicyIncludeSaml',
    'ZeroTrustAccessPolicyIncludeServiceToken',
    'ZeroTrustAccessPolicyRequire',
    'ZeroTrustAccessPolicyRequireAnyValidServiceToken',
    'ZeroTrustAccessPolicyRequireAuthContext',
    'ZeroTrustAccessPolicyRequireAuthMethod',
    'ZeroTrustAccessPolicyRequireAzureAd',
    'ZeroTrustAccessPolicyRequireCertificate',
    'ZeroTrustAccessPolicyRequireCommonName',
    'ZeroTrustAccessPolicyRequireDevicePosture',
    'ZeroTrustAccessPolicyRequireEmail',
    'ZeroTrustAccessPolicyRequireEmailDomain',
    'ZeroTrustAccessPolicyRequireEmailList',
    'ZeroTrustAccessPolicyRequireEveryone',
    'ZeroTrustAccessPolicyRequireExternalEvaluation',
    'ZeroTrustAccessPolicyRequireGeo',
    'ZeroTrustAccessPolicyRequireGithubOrganization',
    'ZeroTrustAccessPolicyRequireGroup',
    'ZeroTrustAccessPolicyRequireGsuite',
    'ZeroTrustAccessPolicyRequireIp',
    'ZeroTrustAccessPolicyRequireIpList',
<<<<<<< HEAD
=======
    'ZeroTrustAccessPolicyRequireLoginMethod',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustAccessPolicyRequireOkta',
    'ZeroTrustAccessPolicyRequireSaml',
    'ZeroTrustAccessPolicyRequireServiceToken',
    'ZeroTrustDeviceCustomProfileExclude',
    'ZeroTrustDeviceCustomProfileFallbackDomain',
    'ZeroTrustDeviceCustomProfileInclude',
    'ZeroTrustDeviceCustomProfileLocalDomainFallbackDomain',
    'ZeroTrustDeviceCustomProfileServiceModeV2',
    'ZeroTrustDeviceCustomProfileTargetTest',
    'ZeroTrustDeviceDefaultProfileExclude',
    'ZeroTrustDeviceDefaultProfileFallbackDomain',
    'ZeroTrustDeviceDefaultProfileInclude',
    'ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomain',
    'ZeroTrustDeviceDefaultProfileServiceModeV2',
    'ZeroTrustDeviceManagedNetworksConfig',
    'ZeroTrustDevicePostureIntegrationConfig',
    'ZeroTrustDevicePostureRuleInput',
    'ZeroTrustDevicePostureRuleInputLocations',
    'ZeroTrustDevicePostureRuleMatch',
    'ZeroTrustDexTestData',
    'ZeroTrustDexTestTargetPolicy',
    'ZeroTrustDlpCustomProfileContextAwareness',
    'ZeroTrustDlpCustomProfileContextAwarenessSkip',
    'ZeroTrustDlpCustomProfileEntry',
    'ZeroTrustDlpCustomProfileEntryPattern',
    'ZeroTrustDlpCustomProfileProfile',
    'ZeroTrustDlpCustomProfileProfileContextAwareness',
    'ZeroTrustDlpCustomProfileProfileContextAwarenessSkip',
    'ZeroTrustDlpCustomProfileProfileEntry',
    'ZeroTrustDlpCustomProfileProfileEntryPattern',
    'ZeroTrustDlpCustomProfileProfileSharedEntry',
    'ZeroTrustDlpCustomProfileSharedEntry',
    'ZeroTrustDlpDatasetColumn',
    'ZeroTrustDlpDatasetDataset',
    'ZeroTrustDlpDatasetDatasetColumn',
    'ZeroTrustDlpDatasetDatasetUpload',
    'ZeroTrustDlpDatasetUpload',
    'ZeroTrustDlpEntryConfidence',
    'ZeroTrustDlpEntryPattern',
    'ZeroTrustDlpPredefinedProfileContextAwareness',
    'ZeroTrustDlpPredefinedProfileContextAwarenessSkip',
    'ZeroTrustDlpPredefinedProfileEntry',
    'ZeroTrustDnsLocationEndpoints',
    'ZeroTrustDnsLocationEndpointsDoh',
    'ZeroTrustDnsLocationEndpointsDohNetwork',
    'ZeroTrustDnsLocationEndpointsDot',
    'ZeroTrustDnsLocationEndpointsDotNetwork',
    'ZeroTrustDnsLocationEndpointsIpv4',
    'ZeroTrustDnsLocationEndpointsIpv6',
    'ZeroTrustDnsLocationEndpointsIpv6Network',
    'ZeroTrustDnsLocationNetwork',
<<<<<<< HEAD
=======
    'ZeroTrustGatewayLoggingSettingsByRuleType',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'ZeroTrustGatewayPolicyExpiration',
    'ZeroTrustGatewayPolicyRuleSettings',
    'ZeroTrustGatewayPolicyRuleSettingsAuditSsh',
    'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls',
    'ZeroTrustGatewayPolicyRuleSettingsCheckSession',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolvers',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6',
    'ZeroTrustGatewayPolicyRuleSettingsEgress',
    'ZeroTrustGatewayPolicyRuleSettingsL4override',
    'ZeroTrustGatewayPolicyRuleSettingsNotificationSettings',
    'ZeroTrustGatewayPolicyRuleSettingsPayloadLog',
    'ZeroTrustGatewayPolicyRuleSettingsQuarantine',
    'ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally',
    'ZeroTrustGatewayPolicyRuleSettingsUntrustedCert',
    'ZeroTrustGatewayPolicySchedule',
    'ZeroTrustGatewaySettingsSettings',
    'ZeroTrustGatewaySettingsSettingsActivityLog',
    'ZeroTrustGatewaySettingsSettingsAntivirus',
    'ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings',
    'ZeroTrustGatewaySettingsSettingsBlockPage',
    'ZeroTrustGatewaySettingsSettingsBodyScanning',
    'ZeroTrustGatewaySettingsSettingsBrowserIsolation',
    'ZeroTrustGatewaySettingsSettingsCertificate',
    'ZeroTrustGatewaySettingsSettingsCustomCertificate',
    'ZeroTrustGatewaySettingsSettingsExtendedEmailMatching',
    'ZeroTrustGatewaySettingsSettingsFips',
    'ZeroTrustGatewaySettingsSettingsProtocolDetection',
    'ZeroTrustGatewaySettingsSettingsSandbox',
    'ZeroTrustGatewaySettingsSettingsTlsDecrypt',
    'ZeroTrustListItem',
    'ZeroTrustOrganizationCustomPages',
    'ZeroTrustOrganizationLoginDesign',
    'ZeroTrustRiskBehaviorBehaviors',
    'ZeroTrustTunnelCloudflaredConfigConfig',
    'ZeroTrustTunnelCloudflaredConfigConfigIngress',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequest',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess',
    'ZeroTrustTunnelCloudflaredConfigConfigWarpRouting',
    'ZeroTrustTunnelCloudflaredConnection',
    'ZoneAccount',
    'ZoneCacheVariantsValue',
    'ZoneLockdownConfiguration',
    'ZoneMeta',
    'ZoneOwner',
    'ZoneSubscriptionRatePlan',
    'GetAccessRuleConfigurationResult',
    'GetAccessRuleFilterResult',
    'GetAccessRuleFilterConfigurationResult',
    'GetAccessRuleScopeResult',
    'GetAccessRulesConfigurationResult',
    'GetAccessRulesResultResult',
    'GetAccessRulesResultConfigurationResult',
    'GetAccessRulesResultScopeResult',
    'GetAccountFilterResult',
    'GetAccountMemberFilterResult',
    'GetAccountMemberPolicyResult',
    'GetAccountMemberPolicyPermissionGroupResult',
    'GetAccountMemberPolicyPermissionGroupMetaResult',
    'GetAccountMemberPolicyResourceGroupResult',
    'GetAccountMemberPolicyResourceGroupMetaResult',
    'GetAccountMemberPolicyResourceGroupScopeResult',
    'GetAccountMemberPolicyResourceGroupScopeObjectResult',
    'GetAccountMemberRoleResult',
    'GetAccountMemberRolePermissionsResult',
    'GetAccountMemberRolePermissionsAnalyticsResult',
    'GetAccountMemberRolePermissionsBillingResult',
    'GetAccountMemberRolePermissionsCachePurgeResult',
    'GetAccountMemberRolePermissionsDnsResult',
    'GetAccountMemberRolePermissionsDnsRecordsResult',
    'GetAccountMemberRolePermissionsLbResult',
    'GetAccountMemberRolePermissionsLogsResult',
    'GetAccountMemberRolePermissionsOrganizationResult',
    'GetAccountMemberRolePermissionsSslResult',
    'GetAccountMemberRolePermissionsWafResult',
    'GetAccountMemberRolePermissionsZoneSettingsResult',
    'GetAccountMemberRolePermissionsZonesResult',
    'GetAccountMemberUserResult',
    'GetAccountMembersResultResult',
    'GetAccountMembersResultPolicyResult',
    'GetAccountMembersResultPolicyPermissionGroupResult',
    'GetAccountMembersResultPolicyPermissionGroupMetaResult',
    'GetAccountMembersResultPolicyResourceGroupResult',
    'GetAccountMembersResultPolicyResourceGroupMetaResult',
    'GetAccountMembersResultPolicyResourceGroupScopeResult',
    'GetAccountMembersResultPolicyResourceGroupScopeObjectResult',
    'GetAccountMembersResultRoleResult',
    'GetAccountMembersResultRolePermissionsResult',
    'GetAccountMembersResultRolePermissionsAnalyticsResult',
    'GetAccountMembersResultRolePermissionsBillingResult',
    'GetAccountMembersResultRolePermissionsCachePurgeResult',
    'GetAccountMembersResultRolePermissionsDnsResult',
    'GetAccountMembersResultRolePermissionsDnsRecordsResult',
    'GetAccountMembersResultRolePermissionsLbResult',
    'GetAccountMembersResultRolePermissionsLogsResult',
    'GetAccountMembersResultRolePermissionsOrganizationResult',
    'GetAccountMembersResultRolePermissionsSslResult',
    'GetAccountMembersResultRolePermissionsWafResult',
    'GetAccountMembersResultRolePermissionsZoneSettingsResult',
    'GetAccountMembersResultRolePermissionsZonesResult',
    'GetAccountMembersResultUserResult',
    'GetAccountRolePermissionsResult',
    'GetAccountRolePermissionsAnalyticsResult',
    'GetAccountRolePermissionsBillingResult',
    'GetAccountRolePermissionsCachePurgeResult',
    'GetAccountRolePermissionsDnsResult',
    'GetAccountRolePermissionsDnsRecordsResult',
    'GetAccountRolePermissionsLbResult',
    'GetAccountRolePermissionsLogsResult',
    'GetAccountRolePermissionsOrganizationResult',
    'GetAccountRolePermissionsSslResult',
    'GetAccountRolePermissionsWafResult',
    'GetAccountRolePermissionsZoneSettingsResult',
    'GetAccountRolePermissionsZonesResult',
    'GetAccountRolesResultResult',
    'GetAccountRolesResultPermissionsResult',
    'GetAccountRolesResultPermissionsAnalyticsResult',
    'GetAccountRolesResultPermissionsBillingResult',
    'GetAccountRolesResultPermissionsCachePurgeResult',
    'GetAccountRolesResultPermissionsDnsResult',
    'GetAccountRolesResultPermissionsDnsRecordsResult',
    'GetAccountRolesResultPermissionsLbResult',
    'GetAccountRolesResultPermissionsLogsResult',
    'GetAccountRolesResultPermissionsOrganizationResult',
    'GetAccountRolesResultPermissionsSslResult',
    'GetAccountRolesResultPermissionsWafResult',
    'GetAccountRolesResultPermissionsZoneSettingsResult',
    'GetAccountRolesResultPermissionsZonesResult',
    'GetAccountSettingsResult',
<<<<<<< HEAD
=======
    'GetAccountSubscriptionRatePlanResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetAccountTokenConditionResult',
    'GetAccountTokenConditionRequestIpResult',
    'GetAccountTokenFilterResult',
    'GetAccountTokenPolicyResult',
    'GetAccountTokenPolicyPermissionGroupResult',
    'GetAccountTokenPolicyPermissionGroupMetaResult',
    'GetAccountTokensResultResult',
    'GetAccountTokensResultConditionResult',
    'GetAccountTokensResultConditionRequestIpResult',
    'GetAccountTokensResultPolicyResult',
    'GetAccountTokensResultPolicyPermissionGroupResult',
    'GetAccountTokensResultPolicyPermissionGroupMetaResult',
    'GetAccountsResultResult',
    'GetAccountsResultSettingsResult',
    'GetAddressMapIpResult',
    'GetAddressMapMembershipResult',
    'GetAddressMapsResultResult',
    'GetApiShieldAuthIdCharacteristicResult',
    'GetApiShieldDiscoveryOperationsResultResult',
    'GetApiShieldDiscoveryOperationsResultFeaturesResult',
    'GetApiShieldDiscoveryOperationsResultFeaturesTrafficStatsResult',
    'GetApiShieldOperationFeaturesResult',
    'GetApiShieldOperationFeaturesApiRoutingResult',
    'GetApiShieldOperationFeaturesConfidenceIntervalsResult',
    'GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdResult',
    'GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsResult',
    'GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Result',
    'GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Result',
    'GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Result',
    'GetApiShieldOperationFeaturesParameterSchemasResult',
    'GetApiShieldOperationFeaturesParameterSchemasParameterSchemasResult',
    'GetApiShieldOperationFeaturesSchemaInfoResult',
    'GetApiShieldOperationFeaturesSchemaInfoActiveSchemaResult',
    'GetApiShieldOperationFeaturesThresholdsResult',
    'GetApiShieldOperationFilterResult',
    'GetApiShieldOperationsResultResult',
    'GetApiShieldOperationsResultFeaturesResult',
    'GetApiShieldOperationsResultFeaturesApiRoutingResult',
    'GetApiShieldOperationsResultFeaturesConfidenceIntervalsResult',
    'GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdResult',
    'GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsResult',
    'GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Result',
    'GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Result',
    'GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Result',
    'GetApiShieldOperationsResultFeaturesParameterSchemasResult',
    'GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemasResult',
    'GetApiShieldOperationsResultFeaturesSchemaInfoResult',
    'GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchemaResult',
    'GetApiShieldOperationsResultFeaturesThresholdsResult',
    'GetApiShieldSchemasResultResult',
    'GetApiTokenConditionResult',
    'GetApiTokenConditionRequestIpResult',
    'GetApiTokenFilterResult',
    'GetApiTokenPermissionsGroupsListResultResult',
    'GetApiTokenPolicyResult',
    'GetApiTokenPolicyPermissionGroupResult',
    'GetApiTokenPolicyPermissionGroupMetaResult',
    'GetApiTokensResultResult',
    'GetApiTokensResultConditionResult',
    'GetApiTokensResultConditionRequestIpResult',
    'GetApiTokensResultPolicyResult',
    'GetApiTokensResultPolicyPermissionGroupResult',
    'GetApiTokensResultPolicyPermissionGroupMetaResult',
    'GetAuthenticatedOriginPullsCertificatesResultResult',
    'GetBotManagementStaleZoneConfigurationResult',
    'GetByoIpPrefixesResultResult',
    'GetCallsSfuAppsResultResult',
    'GetCallsTurnAppsResultResult',
    'GetCertificatePacksResultResult',
    'GetCloudConnectorRulesListResultResult',
    'GetCloudConnectorRulesListResultParametersResult',
    'GetCloudforceOneRequestsResultResult',
    'GetContentScanningExpressionsResultResult',
    'GetCustomHostnameFilterResult',
    'GetCustomHostnameOwnershipVerificationResult',
    'GetCustomHostnameOwnershipVerificationHttpResult',
    'GetCustomHostnameSslResult',
    'GetCustomHostnameSslSettingsResult',
    'GetCustomHostnameSslValidationErrorResult',
    'GetCustomHostnameSslValidationRecordResult',
    'GetCustomHostnamesResultResult',
    'GetCustomHostnamesResultOwnershipVerificationResult',
    'GetCustomHostnamesResultOwnershipVerificationHttpResult',
    'GetCustomHostnamesResultSslResult',
    'GetCustomHostnamesResultSslSettingsResult',
    'GetCustomHostnamesResultSslValidationErrorResult',
    'GetCustomHostnamesResultSslValidationRecordResult',
    'GetCustomSslFilterResult',
    'GetCustomSslGeoRestrictionsResult',
    'GetCustomSslKeylessServerResult',
    'GetCustomSslKeylessServerTunnelResult',
    'GetCustomSslsResultResult',
    'GetCustomSslsResultGeoRestrictionsResult',
    'GetCustomSslsResultKeylessServerResult',
    'GetCustomSslsResultKeylessServerTunnelResult',
    'GetD1DatabaseFilterResult',
    'GetD1DatabasesResultResult',
    'GetDnsFirewallAttackMitigationResult',
    'GetDnsFirewallsResultResult',
    'GetDnsFirewallsResultAttackMitigationResult',
    'GetDnsRecordDataResult',
    'GetDnsRecordFilterResult',
    'GetDnsRecordFilterCommentResult',
    'GetDnsRecordFilterContentResult',
    'GetDnsRecordFilterNameResult',
    'GetDnsRecordFilterTagResult',
    'GetDnsRecordSettingsResult',
    'GetDnsRecordsCommentResult',
    'GetDnsRecordsContentResult',
    'GetDnsRecordsNameResult',
    'GetDnsRecordsResultResult',
    'GetDnsRecordsResultDataResult',
    'GetDnsRecordsResultSettingsResult',
    'GetDnsRecordsTagResult',
<<<<<<< HEAD
=======
    'GetDnsSettingsInternalViewFilterResult',
    'GetDnsSettingsInternalViewFilterNameResult',
    'GetDnsSettingsInternalViewsNameResult',
    'GetDnsSettingsInternalViewsResultResult',
    'GetDnsSettingsZoneDefaultsResult',
    'GetDnsSettingsZoneDefaultsInternalDnsResult',
    'GetDnsSettingsZoneDefaultsNameserversResult',
    'GetDnsSettingsZoneDefaultsSoaResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetDnsZoneTransfersAclsResultResult',
    'GetDnsZoneTransfersPeersResultResult',
    'GetDnsZoneTransfersTsigsResultResult',
    'GetEmailRoutingAddressFilterResult',
    'GetEmailRoutingAddressesResultResult',
    'GetEmailRoutingCatchAllActionResult',
    'GetEmailRoutingCatchAllMatcherResult',
    'GetEmailRoutingDnsErrorResult',
    'GetEmailRoutingDnsMessageResult',
    'GetEmailRoutingDnsResultResult',
    'GetEmailRoutingDnsResultErrorResult',
    'GetEmailRoutingDnsResultErrorMissingResult',
    'GetEmailRoutingDnsResultInfoResult',
    'GetEmailRoutingDnsResultRecordResult',
    'GetEmailRoutingRuleActionResult',
    'GetEmailRoutingRuleFilterResult',
    'GetEmailRoutingRuleMatcherResult',
    'GetEmailRoutingRulesResultResult',
    'GetEmailRoutingRulesResultActionResult',
    'GetEmailRoutingRulesResultMatcherResult',
    'GetEmailSecurityBlockSenderFilterResult',
    'GetEmailSecurityBlockSendersResultResult',
    'GetEmailSecurityImpersonationRegistriesResultResult',
    'GetEmailSecurityImpersonationRegistryFilterResult',
    'GetEmailSecurityTrustedDomainsFilterResult',
    'GetEmailSecurityTrustedDomainsListResultResult',
<<<<<<< HEAD
    'GetFiltersResultResult',
    'GetFirewallRuleFilterResult',
=======
    'GetFilterFilterResult',
    'GetFiltersResultResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetFirewallRulesResultResult',
    'GetFirewallRulesResultFilterResult',
    'GetHealthcheckHttpConfigResult',
    'GetHealthcheckTcpConfigResult',
    'GetHealthchecksResultResult',
    'GetHealthchecksResultHttpConfigResult',
    'GetHealthchecksResultTcpConfigResult',
    'GetHyperdriveConfigCachingResult',
    'GetHyperdriveConfigOriginResult',
    'GetHyperdriveConfigsResultResult',
    'GetHyperdriveConfigsResultCachingResult',
    'GetHyperdriveConfigsResultOriginResult',
    'GetImageVariantVariantResult',
    'GetImageVariantVariantOptionsResult',
    'GetImagesResultResult',
    'GetImagesResultImageResult',
    'GetKeylessCertificateTunnelResult',
    'GetKeylessCertificatesResultResult',
    'GetKeylessCertificatesResultTunnelResult',
    'GetLeakedCredentialCheckRulesResultResult',
    'GetListItemHostnameResult',
    'GetListItemRedirectResult',
    'GetListItemsResultResult',
    'GetListItemsResultHostnameResult',
    'GetListItemsResultRedirectResult',
    'GetListsResultResult',
    'GetLoadBalancerAdaptiveRoutingResult',
    'GetLoadBalancerLocationStrategyResult',
    'GetLoadBalancerMonitorsResultResult',
    'GetLoadBalancerPoolFilterResult',
    'GetLoadBalancerPoolLoadSheddingResult',
    'GetLoadBalancerPoolNotificationFilterResult',
    'GetLoadBalancerPoolNotificationFilterOriginResult',
    'GetLoadBalancerPoolNotificationFilterPoolResult',
    'GetLoadBalancerPoolOriginResult',
    'GetLoadBalancerPoolOriginHeaderResult',
    'GetLoadBalancerPoolOriginSteeringResult',
    'GetLoadBalancerPoolsResultResult',
    'GetLoadBalancerPoolsResultLoadSheddingResult',
    'GetLoadBalancerPoolsResultNotificationFilterResult',
    'GetLoadBalancerPoolsResultNotificationFilterOriginResult',
    'GetLoadBalancerPoolsResultNotificationFilterPoolResult',
    'GetLoadBalancerPoolsResultOriginResult',
    'GetLoadBalancerPoolsResultOriginHeaderResult',
    'GetLoadBalancerPoolsResultOriginSteeringResult',
    'GetLoadBalancerRandomSteeringResult',
    'GetLoadBalancerRuleResult',
    'GetLoadBalancerRuleFixedResponseResult',
    'GetLoadBalancerRuleOverridesResult',
    'GetLoadBalancerRuleOverridesAdaptiveRoutingResult',
    'GetLoadBalancerRuleOverridesLocationStrategyResult',
    'GetLoadBalancerRuleOverridesRandomSteeringResult',
    'GetLoadBalancerRuleOverridesSessionAffinityAttributesResult',
    'GetLoadBalancerSessionAffinityAttributesResult',
    'GetLoadBalancersResultResult',
    'GetLoadBalancersResultAdaptiveRoutingResult',
    'GetLoadBalancersResultLocationStrategyResult',
    'GetLoadBalancersResultRandomSteeringResult',
    'GetLoadBalancersResultRuleResult',
    'GetLoadBalancersResultRuleFixedResponseResult',
    'GetLoadBalancersResultRuleOverridesResult',
    'GetLoadBalancersResultRuleOverridesAdaptiveRoutingResult',
    'GetLoadBalancersResultRuleOverridesLocationStrategyResult',
    'GetLoadBalancersResultRuleOverridesRandomSteeringResult',
    'GetLoadBalancersResultRuleOverridesSessionAffinityAttributesResult',
    'GetLoadBalancersResultSessionAffinityAttributesResult',
<<<<<<< HEAD
=======
    'GetLogpushDatasetJobOutputOptionsResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetLogpushJobOutputOptionsResult',
    'GetLogpushJobsResultResult',
    'GetLogpushJobsResultOutputOptionsResult',
    'GetMagicNetworkMonitoringConfigurationWarpDeviceResult',
    'GetMagicNetworkMonitoringRulesResultResult',
    'GetMagicTransitConnectorDeviceResult',
    'GetMagicTransitConnectorsResultResult',
    'GetMagicTransitConnectorsResultDeviceResult',
    'GetMagicTransitSiteAclLan1Result',
    'GetMagicTransitSiteAclLan2Result',
    'GetMagicTransitSiteAclsResultResult',
    'GetMagicTransitSiteAclsResultLan1Result',
    'GetMagicTransitSiteAclsResultLan2Result',
    'GetMagicTransitSiteFilterResult',
    'GetMagicTransitSiteLanNatResult',
    'GetMagicTransitSiteLanRoutedSubnetResult',
    'GetMagicTransitSiteLanRoutedSubnetNatResult',
    'GetMagicTransitSiteLanStaticAddressingResult',
    'GetMagicTransitSiteLanStaticAddressingDhcpRelayResult',
    'GetMagicTransitSiteLanStaticAddressingDhcpServerResult',
    'GetMagicTransitSiteLansResultResult',
    'GetMagicTransitSiteLansResultNatResult',
    'GetMagicTransitSiteLansResultRoutedSubnetResult',
    'GetMagicTransitSiteLansResultRoutedSubnetNatResult',
    'GetMagicTransitSiteLansResultStaticAddressingResult',
    'GetMagicTransitSiteLansResultStaticAddressingDhcpRelayResult',
    'GetMagicTransitSiteLansResultStaticAddressingDhcpServerResult',
    'GetMagicTransitSiteLocationResult',
    'GetMagicTransitSiteWanStaticAddressingResult',
    'GetMagicTransitSiteWansResultResult',
    'GetMagicTransitSiteWansResultStaticAddressingResult',
    'GetMagicTransitSitesResultResult',
    'GetMagicTransitSitesResultLocationResult',
    'GetMagicWanGreTunnelGreTunnelResult',
    'GetMagicWanGreTunnelGreTunnelHealthCheckResult',
    'GetMagicWanGreTunnelGreTunnelHealthCheckTargetResult',
    'GetMagicWanIpsecTunnelIpsecTunnelResult',
    'GetMagicWanIpsecTunnelIpsecTunnelHealthCheckResult',
    'GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTargetResult',
    'GetMagicWanIpsecTunnelIpsecTunnelPskMetadataResult',
    'GetMagicWanStaticRouteRouteResult',
    'GetMagicWanStaticRouteRouteScopeResult',
    'GetManagedTransformsManagedRequestHeaderResult',
    'GetManagedTransformsManagedResponseHeaderResult',
    'GetMtlsCertificatesResultResult',
    'GetNotificationPoliciesResultResult',
    'GetNotificationPoliciesResultFiltersResult',
    'GetNotificationPoliciesResultMechanismsResult',
    'GetNotificationPoliciesResultMechanismsEmailResult',
    'GetNotificationPoliciesResultMechanismsPagerdutyResult',
    'GetNotificationPoliciesResultMechanismsWebhookResult',
    'GetNotificationPolicyFiltersResult',
    'GetNotificationPolicyMechanismsResult',
    'GetNotificationPolicyMechanismsEmailResult',
    'GetNotificationPolicyMechanismsPagerdutyResult',
    'GetNotificationPolicyMechanismsWebhookResult',
    'GetNotificationPolicyWebhooksListResultResult',
    'GetOriginCaCertificateFilterResult',
    'GetOriginCaCertificatesResultResult',
    'GetPageShieldConnectionsListResultResult',
    'GetPageShieldCookiesListResultResult',
    'GetPageShieldPoliciesResultResult',
    'GetPageShieldScriptsListResultResult',
    'GetPageShieldScriptsVersionResult',
    'GetPagesDomainValidationDataResult',
    'GetPagesDomainVerificationDataResult',
    'GetPagesDomainsResultResult',
    'GetPagesDomainsResultValidationDataResult',
    'GetPagesDomainsResultVerificationDataResult',
    'GetPagesProjectBuildConfigResult',
    'GetPagesProjectCanonicalDeploymentResult',
    'GetPagesProjectCanonicalDeploymentBuildConfigResult',
    'GetPagesProjectCanonicalDeploymentDeploymentTriggerResult',
    'GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadataResult',
    'GetPagesProjectCanonicalDeploymentEnvVarsResult',
    'GetPagesProjectCanonicalDeploymentLatestStageResult',
    'GetPagesProjectCanonicalDeploymentSourceResult',
    'GetPagesProjectCanonicalDeploymentSourceConfigResult',
    'GetPagesProjectCanonicalDeploymentStageResult',
    'GetPagesProjectDeploymentConfigsResult',
    'GetPagesProjectDeploymentConfigsPreviewResult',
    'GetPagesProjectDeploymentConfigsPreviewAiBindingsResult',
    'GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsResult',
    'GetPagesProjectDeploymentConfigsPreviewBrowsersResult',
    'GetPagesProjectDeploymentConfigsPreviewD1DatabasesResult',
    'GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespacesResult',
    'GetPagesProjectDeploymentConfigsPreviewEnvVarsResult',
    'GetPagesProjectDeploymentConfigsPreviewHyperdriveBindingsResult',
    'GetPagesProjectDeploymentConfigsPreviewKvNamespacesResult',
    'GetPagesProjectDeploymentConfigsPreviewMtlsCertificatesResult',
    'GetPagesProjectDeploymentConfigsPreviewPlacementResult',
    'GetPagesProjectDeploymentConfigsPreviewQueueProducersResult',
    'GetPagesProjectDeploymentConfigsPreviewR2BucketsResult',
    'GetPagesProjectDeploymentConfigsPreviewServicesResult',
    'GetPagesProjectDeploymentConfigsPreviewVectorizeBindingsResult',
    'GetPagesProjectDeploymentConfigsProductionResult',
    'GetPagesProjectDeploymentConfigsProductionAiBindingsResult',
    'GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsResult',
    'GetPagesProjectDeploymentConfigsProductionBrowsersResult',
    'GetPagesProjectDeploymentConfigsProductionD1DatabasesResult',
    'GetPagesProjectDeploymentConfigsProductionDurableObjectNamespacesResult',
    'GetPagesProjectDeploymentConfigsProductionEnvVarsResult',
    'GetPagesProjectDeploymentConfigsProductionHyperdriveBindingsResult',
    'GetPagesProjectDeploymentConfigsProductionKvNamespacesResult',
    'GetPagesProjectDeploymentConfigsProductionMtlsCertificatesResult',
    'GetPagesProjectDeploymentConfigsProductionPlacementResult',
    'GetPagesProjectDeploymentConfigsProductionQueueProducersResult',
    'GetPagesProjectDeploymentConfigsProductionR2BucketsResult',
    'GetPagesProjectDeploymentConfigsProductionServicesResult',
    'GetPagesProjectDeploymentConfigsProductionVectorizeBindingsResult',
    'GetPagesProjectLatestDeploymentResult',
    'GetPagesProjectLatestDeploymentBuildConfigResult',
    'GetPagesProjectLatestDeploymentDeploymentTriggerResult',
    'GetPagesProjectLatestDeploymentDeploymentTriggerMetadataResult',
    'GetPagesProjectLatestDeploymentEnvVarsResult',
    'GetPagesProjectLatestDeploymentLatestStageResult',
    'GetPagesProjectLatestDeploymentSourceResult',
    'GetPagesProjectLatestDeploymentSourceConfigResult',
    'GetPagesProjectLatestDeploymentStageResult',
    'GetPagesProjectSourceResult',
    'GetPagesProjectSourceConfigResult',
    'GetPagesProjectsResultResult',
    'GetPagesProjectsResultBuildConfigResult',
    'GetPagesProjectsResultDeploymentTriggerResult',
    'GetPagesProjectsResultDeploymentTriggerMetadataResult',
    'GetPagesProjectsResultEnvVarsResult',
    'GetPagesProjectsResultLatestStageResult',
    'GetPagesProjectsResultSourceResult',
    'GetPagesProjectsResultSourceConfigResult',
    'GetPagesProjectsResultStageResult',
    'GetPermissionGroupMetaResult',
    'GetPermissionGroupsResultResult',
<<<<<<< HEAD
=======
    'GetPermissionGroupsResultMetaResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetQueueConsumerResult',
    'GetQueueConsumerSettingsResult',
    'GetQueueProducerResult',
    'GetQueueSettingsResult',
    'GetQueuesResultResult',
    'GetQueuesResultConsumerResult',
    'GetQueuesResultConsumerSettingsResult',
    'GetQueuesResultProducerResult',
    'GetQueuesResultSettingsResult',
<<<<<<< HEAD
=======
    'GetR2BucketCorsRuleResult',
    'GetR2BucketCorsRuleAllowedResult',
    'GetR2BucketEventNotificationQueueResult',
    'GetR2BucketEventNotificationQueueRuleResult',
    'GetR2BucketLifecycleRuleResult',
    'GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionResult',
    'GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionResult',
    'GetR2BucketLifecycleRuleConditionsResult',
    'GetR2BucketLifecycleRuleDeleteObjectsTransitionResult',
    'GetR2BucketLifecycleRuleDeleteObjectsTransitionConditionResult',
    'GetR2BucketLifecycleRuleStorageClassTransitionResult',
    'GetR2BucketLifecycleRuleStorageClassTransitionConditionResult',
    'GetR2BucketLockRuleResult',
    'GetR2BucketLockRuleConditionResult',
    'GetR2BucketSippyDestinationResult',
    'GetR2BucketSippySourceResult',
    'GetR2CustomDomainStatusResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetRateLimitActionResult',
    'GetRateLimitActionResponseResult',
    'GetRateLimitBypassResult',
    'GetRateLimitMatchResult',
    'GetRateLimitMatchHeaderResult',
    'GetRateLimitMatchRequestResult',
    'GetRateLimitMatchResponseResult',
    'GetRateLimitsResultResult',
    'GetRateLimitsResultActionResult',
    'GetRateLimitsResultActionResponseResult',
    'GetRateLimitsResultBypassResult',
    'GetRateLimitsResultMatchResult',
    'GetRateLimitsResultMatchHeaderResult',
    'GetRateLimitsResultMatchRequestResult',
    'GetRateLimitsResultMatchResponseResult',
    'GetRegionalHostnamesResultResult',
    'GetRegistrarDomainsResultResult',
    'GetRegistrarDomainsResultRegistrantContactResult',
    'GetRegistrarDomainsResultTransferInResult',
    'GetResourceGroupMetaResult',
    'GetResourceGroupScopeResult',
    'GetResourceGroupScopeObjectResult',
    'GetResourceGroupsResultResult',
<<<<<<< HEAD
=======
    'GetResourceGroupsResultMetaResult',
    'GetResourceGroupsResultScopeResult',
    'GetResourceGroupsResultScopeObjectResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetRulesetRuleResult',
    'GetRulesetRuleActionParametersResult',
    'GetRulesetRuleActionParametersAlgorithmResult',
    'GetRulesetRuleActionParametersAutominifyResult',
    'GetRulesetRuleActionParametersBrowserTtlResult',
    'GetRulesetRuleActionParametersCacheKeyResult',
    'GetRulesetRuleActionParametersCacheKeyCustomKeyResult',
    'GetRulesetRuleActionParametersCacheKeyCustomKeyCookieResult',
    'GetRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult',
    'GetRulesetRuleActionParametersCacheKeyCustomKeyHostResult',
    'GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult',
    'GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeResult',
    'GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeResult',
    'GetRulesetRuleActionParametersCacheKeyCustomKeyUserResult',
    'GetRulesetRuleActionParametersCacheReserveResult',
    'GetRulesetRuleActionParametersCookieFieldResult',
    'GetRulesetRuleActionParametersEdgeTtlResult',
    'GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult',
    'GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult',
    'GetRulesetRuleActionParametersFromListResult',
    'GetRulesetRuleActionParametersFromValueResult',
    'GetRulesetRuleActionParametersFromValueTargetUrlResult',
    'GetRulesetRuleActionParametersHeadersResult',
    'GetRulesetRuleActionParametersMatchedDataResult',
    'GetRulesetRuleActionParametersOriginResult',
    'GetRulesetRuleActionParametersOverridesResult',
    'GetRulesetRuleActionParametersOverridesCategoryResult',
    'GetRulesetRuleActionParametersOverridesRuleResult',
    'GetRulesetRuleActionParametersRequestFieldResult',
    'GetRulesetRuleActionParametersResponseResult',
    'GetRulesetRuleActionParametersResponseFieldResult',
    'GetRulesetRuleActionParametersServeStaleResult',
    'GetRulesetRuleActionParametersSniResult',
    'GetRulesetRuleActionParametersUriResult',
    'GetRulesetRuleActionParametersUriPathResult',
    'GetRulesetRuleActionParametersUriQueryResult',
    'GetRulesetRuleExposedCredentialCheckResult',
    'GetRulesetRuleLoggingResult',
    'GetRulesetRuleRatelimitResult',
    'GetRulesetsResultResult',
    'GetSnippetRulesListResultResult',
    'GetSnippetsListResultResult',
    'GetSpectrumApplicationDnsResult',
    'GetSpectrumApplicationEdgeIpsResult',
    'GetSpectrumApplicationOriginDnsResult',
    'GetSpectrumApplicationsResultResult',
    'GetStreamInputResult',
    'GetStreamLiveInputRecordingResult',
    'GetStreamLiveInputRtmpsResult',
    'GetStreamLiveInputRtmpsPlaybackResult',
    'GetStreamLiveInputSrtResult',
    'GetStreamLiveInputSrtPlaybackResult',
    'GetStreamLiveInputWebRtcResult',
    'GetStreamLiveInputWebRtcPlaybackResult',
    'GetStreamPlaybackResult',
    'GetStreamStatusResult',
    'GetStreamWatermarkResult',
    'GetStreamWatermarksResultResult',
    'GetStreamsResultResult',
    'GetStreamsResultInputResult',
    'GetStreamsResultPlaybackResult',
    'GetStreamsResultStatusResult',
    'GetStreamsResultWatermarkResult',
    'GetTurnstileWidgetFilterResult',
    'GetTurnstileWidgetsResultResult',
    'GetUserAgentBlockingRulesResultResult',
    'GetUserAgentBlockingRulesResultConfigurationResult',
    'GetWaitingRoomAdditionalRouteResult',
    'GetWaitingRoomCookieAttributesResult',
    'GetWaitingRoomEventsResultResult',
    'GetWaitingRoomsResultResult',
    'GetWaitingRoomsResultAdditionalRouteResult',
    'GetWaitingRoomsResultCookieAttributesResult',
    'GetWeb3HostnamesResultResult',
    'GetWebAnalyticsSiteFilterResult',
    'GetWebAnalyticsSiteRuleResult',
    'GetWebAnalyticsSiteRulesetResult',
    'GetWebAnalyticsSitesResultResult',
    'GetWebAnalyticsSitesResultRuleResult',
    'GetWebAnalyticsSitesResultRulesetResult',
    'GetWorkersCronTriggerScheduleResult',
    'GetWorkersCustomDomainFilterResult',
    'GetWorkersCustomDomainsResultResult',
    'GetWorkersDeploymentDeploymentResult',
    'GetWorkersDeploymentDeploymentAnnotationsResult',
    'GetWorkersDeploymentDeploymentVersionResult',
    'GetWorkersForPlatformsDispatchNamespacesResultResult',
    'GetWorkersKvNamespaceFilterResult',
    'GetWorkersKvNamespacesResultResult',
<<<<<<< HEAD
=======
    'GetWorkersRoutesResultResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetWorkersScriptsResultResult',
    'GetWorkersScriptsResultPlacementResult',
    'GetWorkersScriptsResultTailConsumerResult',
    'GetWorkersSecretsResultResult',
    'GetZeroTrustAccessApplicationCorsHeadersResult',
    'GetZeroTrustAccessApplicationDestinationResult',
    'GetZeroTrustAccessApplicationFilterResult',
    'GetZeroTrustAccessApplicationFooterLinkResult',
    'GetZeroTrustAccessApplicationLandingPageDesignResult',
    'GetZeroTrustAccessApplicationPolicyResult',
    'GetZeroTrustAccessApplicationPolicyApprovalGroupResult',
    'GetZeroTrustAccessApplicationPolicyConnectionRulesResult',
    'GetZeroTrustAccessApplicationPolicyConnectionRulesSshResult',
    'GetZeroTrustAccessApplicationPolicyExcludeResult',
    'GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessApplicationPolicyExcludeAuthContextResult',
    'GetZeroTrustAccessApplicationPolicyExcludeAuthMethodResult',
    'GetZeroTrustAccessApplicationPolicyExcludeAzureAdResult',
    'GetZeroTrustAccessApplicationPolicyExcludeCertificateResult',
    'GetZeroTrustAccessApplicationPolicyExcludeCommonNameResult',
    'GetZeroTrustAccessApplicationPolicyExcludeDevicePostureResult',
    'GetZeroTrustAccessApplicationPolicyExcludeEmailResult',
    'GetZeroTrustAccessApplicationPolicyExcludeEmailDomainResult',
    'GetZeroTrustAccessApplicationPolicyExcludeEmailListResult',
    'GetZeroTrustAccessApplicationPolicyExcludeEveryoneResult',
    'GetZeroTrustAccessApplicationPolicyExcludeExternalEvaluationResult',
    'GetZeroTrustAccessApplicationPolicyExcludeGeoResult',
    'GetZeroTrustAccessApplicationPolicyExcludeGithubOrganizationResult',
    'GetZeroTrustAccessApplicationPolicyExcludeGroupResult',
    'GetZeroTrustAccessApplicationPolicyExcludeGsuiteResult',
    'GetZeroTrustAccessApplicationPolicyExcludeIpResult',
    'GetZeroTrustAccessApplicationPolicyExcludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessApplicationPolicyExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessApplicationPolicyExcludeOktaResult',
    'GetZeroTrustAccessApplicationPolicyExcludeSamlResult',
    'GetZeroTrustAccessApplicationPolicyExcludeServiceTokenResult',
    'GetZeroTrustAccessApplicationPolicyIncludeResult',
    'GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessApplicationPolicyIncludeAuthContextResult',
    'GetZeroTrustAccessApplicationPolicyIncludeAuthMethodResult',
    'GetZeroTrustAccessApplicationPolicyIncludeAzureAdResult',
    'GetZeroTrustAccessApplicationPolicyIncludeCertificateResult',
    'GetZeroTrustAccessApplicationPolicyIncludeCommonNameResult',
    'GetZeroTrustAccessApplicationPolicyIncludeDevicePostureResult',
    'GetZeroTrustAccessApplicationPolicyIncludeEmailResult',
    'GetZeroTrustAccessApplicationPolicyIncludeEmailDomainResult',
    'GetZeroTrustAccessApplicationPolicyIncludeEmailListResult',
    'GetZeroTrustAccessApplicationPolicyIncludeEveryoneResult',
    'GetZeroTrustAccessApplicationPolicyIncludeExternalEvaluationResult',
    'GetZeroTrustAccessApplicationPolicyIncludeGeoResult',
    'GetZeroTrustAccessApplicationPolicyIncludeGithubOrganizationResult',
    'GetZeroTrustAccessApplicationPolicyIncludeGroupResult',
    'GetZeroTrustAccessApplicationPolicyIncludeGsuiteResult',
    'GetZeroTrustAccessApplicationPolicyIncludeIpResult',
    'GetZeroTrustAccessApplicationPolicyIncludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessApplicationPolicyIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessApplicationPolicyIncludeOktaResult',
    'GetZeroTrustAccessApplicationPolicyIncludeSamlResult',
    'GetZeroTrustAccessApplicationPolicyIncludeServiceTokenResult',
    'GetZeroTrustAccessApplicationPolicyRequireResult',
    'GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenResult',
    'GetZeroTrustAccessApplicationPolicyRequireAuthContextResult',
    'GetZeroTrustAccessApplicationPolicyRequireAuthMethodResult',
    'GetZeroTrustAccessApplicationPolicyRequireAzureAdResult',
    'GetZeroTrustAccessApplicationPolicyRequireCertificateResult',
    'GetZeroTrustAccessApplicationPolicyRequireCommonNameResult',
    'GetZeroTrustAccessApplicationPolicyRequireDevicePostureResult',
    'GetZeroTrustAccessApplicationPolicyRequireEmailResult',
    'GetZeroTrustAccessApplicationPolicyRequireEmailDomainResult',
    'GetZeroTrustAccessApplicationPolicyRequireEmailListResult',
    'GetZeroTrustAccessApplicationPolicyRequireEveryoneResult',
    'GetZeroTrustAccessApplicationPolicyRequireExternalEvaluationResult',
    'GetZeroTrustAccessApplicationPolicyRequireGeoResult',
    'GetZeroTrustAccessApplicationPolicyRequireGithubOrganizationResult',
    'GetZeroTrustAccessApplicationPolicyRequireGroupResult',
    'GetZeroTrustAccessApplicationPolicyRequireGsuiteResult',
    'GetZeroTrustAccessApplicationPolicyRequireIpResult',
    'GetZeroTrustAccessApplicationPolicyRequireIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessApplicationPolicyRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessApplicationPolicyRequireOktaResult',
    'GetZeroTrustAccessApplicationPolicyRequireSamlResult',
    'GetZeroTrustAccessApplicationPolicyRequireServiceTokenResult',
    'GetZeroTrustAccessApplicationSaasAppResult',
    'GetZeroTrustAccessApplicationSaasAppCustomAttributeResult',
    'GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessApplicationSaasAppCustomClaimResult',
    'GetZeroTrustAccessApplicationSaasAppCustomClaimSourceResult',
    'GetZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsResult',
    'GetZeroTrustAccessApplicationSaasAppRefreshTokenOptionsResult',
    'GetZeroTrustAccessApplicationScimConfigResult',
    'GetZeroTrustAccessApplicationScimConfigAuthenticationResult',
    'GetZeroTrustAccessApplicationScimConfigMappingResult',
    'GetZeroTrustAccessApplicationScimConfigMappingOperationsResult',
    'GetZeroTrustAccessApplicationTargetCriteriaResult',
    'GetZeroTrustAccessApplicationsResultResult',
    'GetZeroTrustAccessApplicationsResultCorsHeadersResult',
    'GetZeroTrustAccessApplicationsResultDestinationResult',
    'GetZeroTrustAccessApplicationsResultFooterLinkResult',
    'GetZeroTrustAccessApplicationsResultLandingPageDesignResult',
    'GetZeroTrustAccessApplicationsResultPolicyResult',
    'GetZeroTrustAccessApplicationsResultPolicyApprovalGroupResult',
    'GetZeroTrustAccessApplicationsResultPolicyConnectionRulesResult',
    'GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSshResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeAuthContextResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeAuthMethodResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeAzureAdResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeCertificateResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeCommonNameResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeDevicePostureResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeEmailResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeEmailDomainResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeEmailListResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeEveryoneResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeExternalEvaluationResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeGeoResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeGithubOrganizationResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeGroupResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeGsuiteResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeIpResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessApplicationsResultPolicyExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessApplicationsResultPolicyExcludeOktaResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeSamlResult',
    'GetZeroTrustAccessApplicationsResultPolicyExcludeServiceTokenResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeAuthContextResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeAuthMethodResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeAzureAdResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeCertificateResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeCommonNameResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeDevicePostureResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeEmailResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeEmailDomainResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeEmailListResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeEveryoneResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeExternalEvaluationResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeGeoResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeGithubOrganizationResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeGroupResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeGsuiteResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeIpResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessApplicationsResultPolicyIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessApplicationsResultPolicyIncludeOktaResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeSamlResult',
    'GetZeroTrustAccessApplicationsResultPolicyIncludeServiceTokenResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceTokenResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireAuthContextResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireAuthMethodResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireAzureAdResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireCertificateResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireCommonNameResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireDevicePostureResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireEmailResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireEmailDomainResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireEmailListResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireEveryoneResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireExternalEvaluationResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireGeoResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireGithubOrganizationResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireGroupResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireGsuiteResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireIpResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessApplicationsResultPolicyRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessApplicationsResultPolicyRequireOktaResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireSamlResult',
    'GetZeroTrustAccessApplicationsResultPolicyRequireServiceTokenResult',
    'GetZeroTrustAccessApplicationsResultSaasAppResult',
    'GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeResult',
    'GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdpResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessApplicationsResultSaasAppCustomClaimResult',
    'GetZeroTrustAccessApplicationsResultSaasAppCustomClaimSourceResult',
    'GetZeroTrustAccessApplicationsResultSaasAppHybridAndImplicitOptionsResult',
    'GetZeroTrustAccessApplicationsResultSaasAppRefreshTokenOptionsResult',
    'GetZeroTrustAccessApplicationsResultScimConfigResult',
    'GetZeroTrustAccessApplicationsResultScimConfigAuthenticationResult',
    'GetZeroTrustAccessApplicationsResultScimConfigMappingResult',
    'GetZeroTrustAccessApplicationsResultScimConfigMappingOperationsResult',
    'GetZeroTrustAccessApplicationsResultTargetCriteriaResult',
    'GetZeroTrustAccessCustomPagesResultResult',
    'GetZeroTrustAccessGroupExcludeResult',
    'GetZeroTrustAccessGroupExcludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessGroupExcludeAuthContextResult',
    'GetZeroTrustAccessGroupExcludeAuthMethodResult',
    'GetZeroTrustAccessGroupExcludeAzureAdResult',
    'GetZeroTrustAccessGroupExcludeCertificateResult',
    'GetZeroTrustAccessGroupExcludeCommonNameResult',
    'GetZeroTrustAccessGroupExcludeDevicePostureResult',
    'GetZeroTrustAccessGroupExcludeEmailResult',
    'GetZeroTrustAccessGroupExcludeEmailDomainResult',
    'GetZeroTrustAccessGroupExcludeEmailListResult',
    'GetZeroTrustAccessGroupExcludeEveryoneResult',
    'GetZeroTrustAccessGroupExcludeExternalEvaluationResult',
    'GetZeroTrustAccessGroupExcludeGeoResult',
    'GetZeroTrustAccessGroupExcludeGithubOrganizationResult',
    'GetZeroTrustAccessGroupExcludeGroupResult',
    'GetZeroTrustAccessGroupExcludeGsuiteResult',
    'GetZeroTrustAccessGroupExcludeIpResult',
    'GetZeroTrustAccessGroupExcludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessGroupExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessGroupExcludeOktaResult',
    'GetZeroTrustAccessGroupExcludeSamlResult',
    'GetZeroTrustAccessGroupExcludeServiceTokenResult',
    'GetZeroTrustAccessGroupFilterResult',
    'GetZeroTrustAccessGroupIncludeResult',
    'GetZeroTrustAccessGroupIncludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessGroupIncludeAuthContextResult',
    'GetZeroTrustAccessGroupIncludeAuthMethodResult',
    'GetZeroTrustAccessGroupIncludeAzureAdResult',
    'GetZeroTrustAccessGroupIncludeCertificateResult',
    'GetZeroTrustAccessGroupIncludeCommonNameResult',
    'GetZeroTrustAccessGroupIncludeDevicePostureResult',
    'GetZeroTrustAccessGroupIncludeEmailResult',
    'GetZeroTrustAccessGroupIncludeEmailDomainResult',
    'GetZeroTrustAccessGroupIncludeEmailListResult',
    'GetZeroTrustAccessGroupIncludeEveryoneResult',
    'GetZeroTrustAccessGroupIncludeExternalEvaluationResult',
    'GetZeroTrustAccessGroupIncludeGeoResult',
    'GetZeroTrustAccessGroupIncludeGithubOrganizationResult',
    'GetZeroTrustAccessGroupIncludeGroupResult',
    'GetZeroTrustAccessGroupIncludeGsuiteResult',
    'GetZeroTrustAccessGroupIncludeIpResult',
    'GetZeroTrustAccessGroupIncludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessGroupIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessGroupIncludeOktaResult',
    'GetZeroTrustAccessGroupIncludeSamlResult',
    'GetZeroTrustAccessGroupIncludeServiceTokenResult',
    'GetZeroTrustAccessGroupIsDefaultResult',
    'GetZeroTrustAccessGroupIsDefaultAnyValidServiceTokenResult',
    'GetZeroTrustAccessGroupIsDefaultAuthContextResult',
    'GetZeroTrustAccessGroupIsDefaultAuthMethodResult',
    'GetZeroTrustAccessGroupIsDefaultAzureAdResult',
    'GetZeroTrustAccessGroupIsDefaultCertificateResult',
    'GetZeroTrustAccessGroupIsDefaultCommonNameResult',
    'GetZeroTrustAccessGroupIsDefaultDevicePostureResult',
    'GetZeroTrustAccessGroupIsDefaultEmailResult',
    'GetZeroTrustAccessGroupIsDefaultEmailDomainResult',
    'GetZeroTrustAccessGroupIsDefaultEmailListResult',
    'GetZeroTrustAccessGroupIsDefaultEveryoneResult',
    'GetZeroTrustAccessGroupIsDefaultExternalEvaluationResult',
    'GetZeroTrustAccessGroupIsDefaultGeoResult',
    'GetZeroTrustAccessGroupIsDefaultGithubOrganizationResult',
    'GetZeroTrustAccessGroupIsDefaultGroupResult',
    'GetZeroTrustAccessGroupIsDefaultGsuiteResult',
    'GetZeroTrustAccessGroupIsDefaultIpResult',
    'GetZeroTrustAccessGroupIsDefaultIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessGroupIsDefaultLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessGroupIsDefaultOktaResult',
    'GetZeroTrustAccessGroupIsDefaultSamlResult',
    'GetZeroTrustAccessGroupIsDefaultServiceTokenResult',
    'GetZeroTrustAccessGroupRequireResult',
    'GetZeroTrustAccessGroupRequireAnyValidServiceTokenResult',
    'GetZeroTrustAccessGroupRequireAuthContextResult',
    'GetZeroTrustAccessGroupRequireAuthMethodResult',
    'GetZeroTrustAccessGroupRequireAzureAdResult',
    'GetZeroTrustAccessGroupRequireCertificateResult',
    'GetZeroTrustAccessGroupRequireCommonNameResult',
    'GetZeroTrustAccessGroupRequireDevicePostureResult',
    'GetZeroTrustAccessGroupRequireEmailResult',
    'GetZeroTrustAccessGroupRequireEmailDomainResult',
    'GetZeroTrustAccessGroupRequireEmailListResult',
    'GetZeroTrustAccessGroupRequireEveryoneResult',
    'GetZeroTrustAccessGroupRequireExternalEvaluationResult',
    'GetZeroTrustAccessGroupRequireGeoResult',
    'GetZeroTrustAccessGroupRequireGithubOrganizationResult',
    'GetZeroTrustAccessGroupRequireGroupResult',
    'GetZeroTrustAccessGroupRequireGsuiteResult',
    'GetZeroTrustAccessGroupRequireIpResult',
    'GetZeroTrustAccessGroupRequireIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessGroupRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessGroupRequireOktaResult',
    'GetZeroTrustAccessGroupRequireSamlResult',
    'GetZeroTrustAccessGroupRequireServiceTokenResult',
    'GetZeroTrustAccessGroupsResultResult',
    'GetZeroTrustAccessGroupsResultExcludeResult',
    'GetZeroTrustAccessGroupsResultExcludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessGroupsResultExcludeAuthContextResult',
    'GetZeroTrustAccessGroupsResultExcludeAuthMethodResult',
    'GetZeroTrustAccessGroupsResultExcludeAzureAdResult',
    'GetZeroTrustAccessGroupsResultExcludeCertificateResult',
    'GetZeroTrustAccessGroupsResultExcludeCommonNameResult',
    'GetZeroTrustAccessGroupsResultExcludeDevicePostureResult',
    'GetZeroTrustAccessGroupsResultExcludeEmailResult',
    'GetZeroTrustAccessGroupsResultExcludeEmailDomainResult',
    'GetZeroTrustAccessGroupsResultExcludeEmailListResult',
    'GetZeroTrustAccessGroupsResultExcludeEveryoneResult',
    'GetZeroTrustAccessGroupsResultExcludeExternalEvaluationResult',
    'GetZeroTrustAccessGroupsResultExcludeGeoResult',
    'GetZeroTrustAccessGroupsResultExcludeGithubOrganizationResult',
    'GetZeroTrustAccessGroupsResultExcludeGroupResult',
    'GetZeroTrustAccessGroupsResultExcludeGsuiteResult',
    'GetZeroTrustAccessGroupsResultExcludeIpResult',
    'GetZeroTrustAccessGroupsResultExcludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessGroupsResultExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessGroupsResultExcludeOktaResult',
    'GetZeroTrustAccessGroupsResultExcludeSamlResult',
    'GetZeroTrustAccessGroupsResultExcludeServiceTokenResult',
    'GetZeroTrustAccessGroupsResultIncludeResult',
    'GetZeroTrustAccessGroupsResultIncludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessGroupsResultIncludeAuthContextResult',
    'GetZeroTrustAccessGroupsResultIncludeAuthMethodResult',
    'GetZeroTrustAccessGroupsResultIncludeAzureAdResult',
    'GetZeroTrustAccessGroupsResultIncludeCertificateResult',
    'GetZeroTrustAccessGroupsResultIncludeCommonNameResult',
    'GetZeroTrustAccessGroupsResultIncludeDevicePostureResult',
    'GetZeroTrustAccessGroupsResultIncludeEmailResult',
    'GetZeroTrustAccessGroupsResultIncludeEmailDomainResult',
    'GetZeroTrustAccessGroupsResultIncludeEmailListResult',
    'GetZeroTrustAccessGroupsResultIncludeEveryoneResult',
    'GetZeroTrustAccessGroupsResultIncludeExternalEvaluationResult',
    'GetZeroTrustAccessGroupsResultIncludeGeoResult',
    'GetZeroTrustAccessGroupsResultIncludeGithubOrganizationResult',
    'GetZeroTrustAccessGroupsResultIncludeGroupResult',
    'GetZeroTrustAccessGroupsResultIncludeGsuiteResult',
    'GetZeroTrustAccessGroupsResultIncludeIpResult',
    'GetZeroTrustAccessGroupsResultIncludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessGroupsResultIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessGroupsResultIncludeOktaResult',
    'GetZeroTrustAccessGroupsResultIncludeSamlResult',
    'GetZeroTrustAccessGroupsResultIncludeServiceTokenResult',
    'GetZeroTrustAccessGroupsResultIsDefaultResult',
    'GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceTokenResult',
    'GetZeroTrustAccessGroupsResultIsDefaultAuthContextResult',
    'GetZeroTrustAccessGroupsResultIsDefaultAuthMethodResult',
    'GetZeroTrustAccessGroupsResultIsDefaultAzureAdResult',
    'GetZeroTrustAccessGroupsResultIsDefaultCertificateResult',
    'GetZeroTrustAccessGroupsResultIsDefaultCommonNameResult',
    'GetZeroTrustAccessGroupsResultIsDefaultDevicePostureResult',
    'GetZeroTrustAccessGroupsResultIsDefaultEmailResult',
    'GetZeroTrustAccessGroupsResultIsDefaultEmailDomainResult',
    'GetZeroTrustAccessGroupsResultIsDefaultEmailListResult',
    'GetZeroTrustAccessGroupsResultIsDefaultEveryoneResult',
    'GetZeroTrustAccessGroupsResultIsDefaultExternalEvaluationResult',
    'GetZeroTrustAccessGroupsResultIsDefaultGeoResult',
    'GetZeroTrustAccessGroupsResultIsDefaultGithubOrganizationResult',
    'GetZeroTrustAccessGroupsResultIsDefaultGroupResult',
    'GetZeroTrustAccessGroupsResultIsDefaultGsuiteResult',
    'GetZeroTrustAccessGroupsResultIsDefaultIpResult',
    'GetZeroTrustAccessGroupsResultIsDefaultIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessGroupsResultIsDefaultLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessGroupsResultIsDefaultOktaResult',
    'GetZeroTrustAccessGroupsResultIsDefaultSamlResult',
    'GetZeroTrustAccessGroupsResultIsDefaultServiceTokenResult',
    'GetZeroTrustAccessGroupsResultRequireResult',
    'GetZeroTrustAccessGroupsResultRequireAnyValidServiceTokenResult',
    'GetZeroTrustAccessGroupsResultRequireAuthContextResult',
    'GetZeroTrustAccessGroupsResultRequireAuthMethodResult',
    'GetZeroTrustAccessGroupsResultRequireAzureAdResult',
    'GetZeroTrustAccessGroupsResultRequireCertificateResult',
    'GetZeroTrustAccessGroupsResultRequireCommonNameResult',
    'GetZeroTrustAccessGroupsResultRequireDevicePostureResult',
    'GetZeroTrustAccessGroupsResultRequireEmailResult',
    'GetZeroTrustAccessGroupsResultRequireEmailDomainResult',
    'GetZeroTrustAccessGroupsResultRequireEmailListResult',
    'GetZeroTrustAccessGroupsResultRequireEveryoneResult',
    'GetZeroTrustAccessGroupsResultRequireExternalEvaluationResult',
    'GetZeroTrustAccessGroupsResultRequireGeoResult',
    'GetZeroTrustAccessGroupsResultRequireGithubOrganizationResult',
    'GetZeroTrustAccessGroupsResultRequireGroupResult',
    'GetZeroTrustAccessGroupsResultRequireGsuiteResult',
    'GetZeroTrustAccessGroupsResultRequireIpResult',
    'GetZeroTrustAccessGroupsResultRequireIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessGroupsResultRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessGroupsResultRequireOktaResult',
    'GetZeroTrustAccessGroupsResultRequireSamlResult',
    'GetZeroTrustAccessGroupsResultRequireServiceTokenResult',
    'GetZeroTrustAccessIdentityProviderConfigResult',
    'GetZeroTrustAccessIdentityProviderConfigHeaderAttributeResult',
    'GetZeroTrustAccessIdentityProviderFilterResult',
    'GetZeroTrustAccessIdentityProviderScimConfigResult',
    'GetZeroTrustAccessIdentityProvidersResultResult',
    'GetZeroTrustAccessIdentityProvidersResultConfigResult',
    'GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttributeResult',
    'GetZeroTrustAccessIdentityProvidersResultScimConfigResult',
    'GetZeroTrustAccessInfrastructureTargetFilterResult',
    'GetZeroTrustAccessInfrastructureTargetIpResult',
    'GetZeroTrustAccessInfrastructureTargetIpIpv4Result',
    'GetZeroTrustAccessInfrastructureTargetIpIpv6Result',
    'GetZeroTrustAccessInfrastructureTargetsResultResult',
    'GetZeroTrustAccessInfrastructureTargetsResultIpResult',
    'GetZeroTrustAccessInfrastructureTargetsResultIpIpv4Result',
    'GetZeroTrustAccessInfrastructureTargetsResultIpIpv6Result',
    'GetZeroTrustAccessMtlsCertificatesResultResult',
    'GetZeroTrustAccessPoliciesResultResult',
    'GetZeroTrustAccessPoliciesResultApprovalGroupResult',
    'GetZeroTrustAccessPoliciesResultExcludeResult',
    'GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessPoliciesResultExcludeAuthContextResult',
    'GetZeroTrustAccessPoliciesResultExcludeAuthMethodResult',
    'GetZeroTrustAccessPoliciesResultExcludeAzureAdResult',
    'GetZeroTrustAccessPoliciesResultExcludeCertificateResult',
    'GetZeroTrustAccessPoliciesResultExcludeCommonNameResult',
    'GetZeroTrustAccessPoliciesResultExcludeDevicePostureResult',
    'GetZeroTrustAccessPoliciesResultExcludeEmailResult',
    'GetZeroTrustAccessPoliciesResultExcludeEmailDomainResult',
    'GetZeroTrustAccessPoliciesResultExcludeEmailListResult',
    'GetZeroTrustAccessPoliciesResultExcludeEveryoneResult',
    'GetZeroTrustAccessPoliciesResultExcludeExternalEvaluationResult',
    'GetZeroTrustAccessPoliciesResultExcludeGeoResult',
    'GetZeroTrustAccessPoliciesResultExcludeGithubOrganizationResult',
    'GetZeroTrustAccessPoliciesResultExcludeGroupResult',
    'GetZeroTrustAccessPoliciesResultExcludeGsuiteResult',
    'GetZeroTrustAccessPoliciesResultExcludeIpResult',
    'GetZeroTrustAccessPoliciesResultExcludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessPoliciesResultExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessPoliciesResultExcludeOktaResult',
    'GetZeroTrustAccessPoliciesResultExcludeSamlResult',
    'GetZeroTrustAccessPoliciesResultExcludeServiceTokenResult',
    'GetZeroTrustAccessPoliciesResultIncludeResult',
    'GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessPoliciesResultIncludeAuthContextResult',
    'GetZeroTrustAccessPoliciesResultIncludeAuthMethodResult',
    'GetZeroTrustAccessPoliciesResultIncludeAzureAdResult',
    'GetZeroTrustAccessPoliciesResultIncludeCertificateResult',
    'GetZeroTrustAccessPoliciesResultIncludeCommonNameResult',
    'GetZeroTrustAccessPoliciesResultIncludeDevicePostureResult',
    'GetZeroTrustAccessPoliciesResultIncludeEmailResult',
    'GetZeroTrustAccessPoliciesResultIncludeEmailDomainResult',
    'GetZeroTrustAccessPoliciesResultIncludeEmailListResult',
    'GetZeroTrustAccessPoliciesResultIncludeEveryoneResult',
    'GetZeroTrustAccessPoliciesResultIncludeExternalEvaluationResult',
    'GetZeroTrustAccessPoliciesResultIncludeGeoResult',
    'GetZeroTrustAccessPoliciesResultIncludeGithubOrganizationResult',
    'GetZeroTrustAccessPoliciesResultIncludeGroupResult',
    'GetZeroTrustAccessPoliciesResultIncludeGsuiteResult',
    'GetZeroTrustAccessPoliciesResultIncludeIpResult',
    'GetZeroTrustAccessPoliciesResultIncludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessPoliciesResultIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessPoliciesResultIncludeOktaResult',
    'GetZeroTrustAccessPoliciesResultIncludeSamlResult',
    'GetZeroTrustAccessPoliciesResultIncludeServiceTokenResult',
    'GetZeroTrustAccessPoliciesResultRequireResult',
    'GetZeroTrustAccessPoliciesResultRequireAnyValidServiceTokenResult',
    'GetZeroTrustAccessPoliciesResultRequireAuthContextResult',
    'GetZeroTrustAccessPoliciesResultRequireAuthMethodResult',
    'GetZeroTrustAccessPoliciesResultRequireAzureAdResult',
    'GetZeroTrustAccessPoliciesResultRequireCertificateResult',
    'GetZeroTrustAccessPoliciesResultRequireCommonNameResult',
    'GetZeroTrustAccessPoliciesResultRequireDevicePostureResult',
    'GetZeroTrustAccessPoliciesResultRequireEmailResult',
    'GetZeroTrustAccessPoliciesResultRequireEmailDomainResult',
    'GetZeroTrustAccessPoliciesResultRequireEmailListResult',
    'GetZeroTrustAccessPoliciesResultRequireEveryoneResult',
    'GetZeroTrustAccessPoliciesResultRequireExternalEvaluationResult',
    'GetZeroTrustAccessPoliciesResultRequireGeoResult',
    'GetZeroTrustAccessPoliciesResultRequireGithubOrganizationResult',
    'GetZeroTrustAccessPoliciesResultRequireGroupResult',
    'GetZeroTrustAccessPoliciesResultRequireGsuiteResult',
    'GetZeroTrustAccessPoliciesResultRequireIpResult',
    'GetZeroTrustAccessPoliciesResultRequireIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessPoliciesResultRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessPoliciesResultRequireOktaResult',
    'GetZeroTrustAccessPoliciesResultRequireSamlResult',
    'GetZeroTrustAccessPoliciesResultRequireServiceTokenResult',
    'GetZeroTrustAccessPolicyApprovalGroupResult',
    'GetZeroTrustAccessPolicyExcludeResult',
    'GetZeroTrustAccessPolicyExcludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessPolicyExcludeAuthContextResult',
    'GetZeroTrustAccessPolicyExcludeAuthMethodResult',
    'GetZeroTrustAccessPolicyExcludeAzureAdResult',
    'GetZeroTrustAccessPolicyExcludeCertificateResult',
    'GetZeroTrustAccessPolicyExcludeCommonNameResult',
    'GetZeroTrustAccessPolicyExcludeDevicePostureResult',
    'GetZeroTrustAccessPolicyExcludeEmailResult',
    'GetZeroTrustAccessPolicyExcludeEmailDomainResult',
    'GetZeroTrustAccessPolicyExcludeEmailListResult',
    'GetZeroTrustAccessPolicyExcludeEveryoneResult',
    'GetZeroTrustAccessPolicyExcludeExternalEvaluationResult',
    'GetZeroTrustAccessPolicyExcludeGeoResult',
    'GetZeroTrustAccessPolicyExcludeGithubOrganizationResult',
    'GetZeroTrustAccessPolicyExcludeGroupResult',
    'GetZeroTrustAccessPolicyExcludeGsuiteResult',
    'GetZeroTrustAccessPolicyExcludeIpResult',
    'GetZeroTrustAccessPolicyExcludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessPolicyExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessPolicyExcludeOktaResult',
    'GetZeroTrustAccessPolicyExcludeSamlResult',
    'GetZeroTrustAccessPolicyExcludeServiceTokenResult',
    'GetZeroTrustAccessPolicyIncludeResult',
    'GetZeroTrustAccessPolicyIncludeAnyValidServiceTokenResult',
    'GetZeroTrustAccessPolicyIncludeAuthContextResult',
    'GetZeroTrustAccessPolicyIncludeAuthMethodResult',
    'GetZeroTrustAccessPolicyIncludeAzureAdResult',
    'GetZeroTrustAccessPolicyIncludeCertificateResult',
    'GetZeroTrustAccessPolicyIncludeCommonNameResult',
    'GetZeroTrustAccessPolicyIncludeDevicePostureResult',
    'GetZeroTrustAccessPolicyIncludeEmailResult',
    'GetZeroTrustAccessPolicyIncludeEmailDomainResult',
    'GetZeroTrustAccessPolicyIncludeEmailListResult',
    'GetZeroTrustAccessPolicyIncludeEveryoneResult',
    'GetZeroTrustAccessPolicyIncludeExternalEvaluationResult',
    'GetZeroTrustAccessPolicyIncludeGeoResult',
    'GetZeroTrustAccessPolicyIncludeGithubOrganizationResult',
    'GetZeroTrustAccessPolicyIncludeGroupResult',
    'GetZeroTrustAccessPolicyIncludeGsuiteResult',
    'GetZeroTrustAccessPolicyIncludeIpResult',
    'GetZeroTrustAccessPolicyIncludeIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessPolicyIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessPolicyIncludeOktaResult',
    'GetZeroTrustAccessPolicyIncludeSamlResult',
    'GetZeroTrustAccessPolicyIncludeServiceTokenResult',
    'GetZeroTrustAccessPolicyRequireResult',
    'GetZeroTrustAccessPolicyRequireAnyValidServiceTokenResult',
    'GetZeroTrustAccessPolicyRequireAuthContextResult',
    'GetZeroTrustAccessPolicyRequireAuthMethodResult',
    'GetZeroTrustAccessPolicyRequireAzureAdResult',
    'GetZeroTrustAccessPolicyRequireCertificateResult',
    'GetZeroTrustAccessPolicyRequireCommonNameResult',
    'GetZeroTrustAccessPolicyRequireDevicePostureResult',
    'GetZeroTrustAccessPolicyRequireEmailResult',
    'GetZeroTrustAccessPolicyRequireEmailDomainResult',
    'GetZeroTrustAccessPolicyRequireEmailListResult',
    'GetZeroTrustAccessPolicyRequireEveryoneResult',
    'GetZeroTrustAccessPolicyRequireExternalEvaluationResult',
    'GetZeroTrustAccessPolicyRequireGeoResult',
    'GetZeroTrustAccessPolicyRequireGithubOrganizationResult',
    'GetZeroTrustAccessPolicyRequireGroupResult',
    'GetZeroTrustAccessPolicyRequireGsuiteResult',
    'GetZeroTrustAccessPolicyRequireIpResult',
    'GetZeroTrustAccessPolicyRequireIpListResult',
<<<<<<< HEAD
=======
    'GetZeroTrustAccessPolicyRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustAccessPolicyRequireOktaResult',
    'GetZeroTrustAccessPolicyRequireSamlResult',
    'GetZeroTrustAccessPolicyRequireServiceTokenResult',
    'GetZeroTrustAccessServiceTokenFilterResult',
    'GetZeroTrustAccessServiceTokensResultResult',
    'GetZeroTrustAccessShortLivedCertificatesResultResult',
    'GetZeroTrustAccessTagsResultResult',
    'GetZeroTrustDeviceCustomProfileExcludeResult',
    'GetZeroTrustDeviceCustomProfileFallbackDomainResult',
    'GetZeroTrustDeviceCustomProfileIncludeResult',
    'GetZeroTrustDeviceCustomProfileServiceModeV2Result',
    'GetZeroTrustDeviceCustomProfileTargetTestResult',
    'GetZeroTrustDeviceCustomProfilesResultResult',
    'GetZeroTrustDeviceCustomProfilesResultExcludeResult',
    'GetZeroTrustDeviceCustomProfilesResultFallbackDomainResult',
    'GetZeroTrustDeviceCustomProfilesResultIncludeResult',
    'GetZeroTrustDeviceCustomProfilesResultServiceModeV2Result',
    'GetZeroTrustDeviceCustomProfilesResultTargetTestResult',
    'GetZeroTrustDeviceDefaultProfileExcludeResult',
    'GetZeroTrustDeviceDefaultProfileFallbackDomainResult',
    'GetZeroTrustDeviceDefaultProfileIncludeResult',
    'GetZeroTrustDeviceDefaultProfileServiceModeV2Result',
    'GetZeroTrustDeviceManagedNetworksConfigResult',
    'GetZeroTrustDeviceManagedNetworksListResultResult',
    'GetZeroTrustDeviceManagedNetworksListResultConfigResult',
    'GetZeroTrustDevicePostureIntegrationConfigResult',
    'GetZeroTrustDevicePostureIntegrationsResultResult',
    'GetZeroTrustDevicePostureIntegrationsResultConfigResult',
    'GetZeroTrustDevicePostureRuleInputResult',
    'GetZeroTrustDevicePostureRuleInputLocationsResult',
    'GetZeroTrustDevicePostureRuleMatchResult',
    'GetZeroTrustDevicePostureRulesResultResult',
    'GetZeroTrustDevicePostureRulesResultInputResult',
    'GetZeroTrustDevicePostureRulesResultInputLocationsResult',
    'GetZeroTrustDevicePostureRulesResultMatchResult',
    'GetZeroTrustDexTestDataResult',
    'GetZeroTrustDexTestTargetPolicyResult',
    'GetZeroTrustDexTestsResultResult',
    'GetZeroTrustDexTestsResultDataResult',
    'GetZeroTrustDexTestsResultTargetPolicyResult',
    'GetZeroTrustDlpCustomProfileContextAwarenessResult',
    'GetZeroTrustDlpCustomProfileContextAwarenessSkipResult',
    'GetZeroTrustDlpCustomProfileEntryResult',
    'GetZeroTrustDlpCustomProfileEntryConfidenceResult',
    'GetZeroTrustDlpCustomProfileEntryPatternResult',
    'GetZeroTrustDlpDatasetColumnResult',
    'GetZeroTrustDlpDatasetUploadResult',
    'GetZeroTrustDlpDatasetsResultResult',
    'GetZeroTrustDlpDatasetsResultColumnResult',
    'GetZeroTrustDlpDatasetsResultUploadResult',
    'GetZeroTrustDlpEntriesResultResult',
    'GetZeroTrustDlpEntriesResultConfidenceResult',
    'GetZeroTrustDlpEntriesResultPatternResult',
    'GetZeroTrustDlpEntryConfidenceResult',
    'GetZeroTrustDlpEntryPatternResult',
    'GetZeroTrustDlpPredefinedProfileContextAwarenessResult',
    'GetZeroTrustDlpPredefinedProfileContextAwarenessSkipResult',
    'GetZeroTrustDlpPredefinedProfileEntryResult',
    'GetZeroTrustDlpPredefinedProfileEntryConfidenceResult',
    'GetZeroTrustDlpPredefinedProfileEntryPatternResult',
    'GetZeroTrustDnsLocationEndpointsResult',
    'GetZeroTrustDnsLocationEndpointsDohResult',
    'GetZeroTrustDnsLocationEndpointsDohNetworkResult',
    'GetZeroTrustDnsLocationEndpointsDotResult',
    'GetZeroTrustDnsLocationEndpointsDotNetworkResult',
    'GetZeroTrustDnsLocationEndpointsIpv4Result',
    'GetZeroTrustDnsLocationEndpointsIpv6Result',
    'GetZeroTrustDnsLocationEndpointsIpv6NetworkResult',
    'GetZeroTrustDnsLocationNetworkResult',
    'GetZeroTrustDnsLocationsResultResult',
    'GetZeroTrustDnsLocationsResultEndpointsResult',
    'GetZeroTrustDnsLocationsResultEndpointsDohResult',
    'GetZeroTrustDnsLocationsResultEndpointsDohNetworkResult',
    'GetZeroTrustDnsLocationsResultEndpointsDotResult',
    'GetZeroTrustDnsLocationsResultEndpointsDotNetworkResult',
    'GetZeroTrustDnsLocationsResultEndpointsIpv4Result',
    'GetZeroTrustDnsLocationsResultEndpointsIpv6Result',
    'GetZeroTrustDnsLocationsResultEndpointsIpv6NetworkResult',
    'GetZeroTrustDnsLocationsResultNetworkResult',
    'GetZeroTrustGatewayAppTypesListResultResult',
    'GetZeroTrustGatewayCategoriesListResultResult',
    'GetZeroTrustGatewayCategoriesListResultSubcategoryResult',
    'GetZeroTrustGatewayCertificatesResultResult',
<<<<<<< HEAD
=======
    'GetZeroTrustGatewayLoggingSettingsByRuleTypeResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    'GetZeroTrustGatewayPoliciesResultResult',
    'GetZeroTrustGatewayPoliciesResultExpirationResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSshResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControlsResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSessionResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv4Result',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv6Result',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsEgressResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsL4overrideResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettingsResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLogResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantineResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternallyResult',
    'GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCertResult',
    'GetZeroTrustGatewayPoliciesResultScheduleResult',
    'GetZeroTrustGatewayPolicyExpirationResult',
    'GetZeroTrustGatewayPolicyRuleSettingsResult',
    'GetZeroTrustGatewayPolicyRuleSettingsAuditSshResult',
    'GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsResult',
    'GetZeroTrustGatewayPolicyRuleSettingsCheckSessionResult',
    'GetZeroTrustGatewayPolicyRuleSettingsDnsResolversResult',
    'GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Result',
    'GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Result',
    'GetZeroTrustGatewayPolicyRuleSettingsEgressResult',
    'GetZeroTrustGatewayPolicyRuleSettingsL4overrideResult',
    'GetZeroTrustGatewayPolicyRuleSettingsNotificationSettingsResult',
    'GetZeroTrustGatewayPolicyRuleSettingsPayloadLogResult',
    'GetZeroTrustGatewayPolicyRuleSettingsQuarantineResult',
    'GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyResult',
    'GetZeroTrustGatewayPolicyRuleSettingsUntrustedCertResult',
    'GetZeroTrustGatewayPolicyScheduleResult',
    'GetZeroTrustGatewaySettingsSettingsResult',
    'GetZeroTrustGatewaySettingsSettingsActivityLogResult',
    'GetZeroTrustGatewaySettingsSettingsAntivirusResult',
    'GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsResult',
    'GetZeroTrustGatewaySettingsSettingsBlockPageResult',
    'GetZeroTrustGatewaySettingsSettingsBodyScanningResult',
    'GetZeroTrustGatewaySettingsSettingsBrowserIsolationResult',
    'GetZeroTrustGatewaySettingsSettingsCertificateResult',
    'GetZeroTrustGatewaySettingsSettingsCustomCertificateResult',
    'GetZeroTrustGatewaySettingsSettingsExtendedEmailMatchingResult',
    'GetZeroTrustGatewaySettingsSettingsFipsResult',
    'GetZeroTrustGatewaySettingsSettingsProtocolDetectionResult',
    'GetZeroTrustGatewaySettingsSettingsSandboxResult',
    'GetZeroTrustGatewaySettingsSettingsTlsDecryptResult',
    'GetZeroTrustListFilterResult',
    'GetZeroTrustListsResultResult',
    'GetZeroTrustOrganizationCustomPagesResult',
    'GetZeroTrustOrganizationLoginDesignResult',
    'GetZeroTrustRiskBehaviorBehaviorsResult',
    'GetZeroTrustRiskScoringIntegrationsResultResult',
    'GetZeroTrustTunnelCloudflaredConfigConfigResult',
    'GetZeroTrustTunnelCloudflaredConfigConfigIngressResult',
    'GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestResult',
    'GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessResult',
    'GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestResult',
    'GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessResult',
    'GetZeroTrustTunnelCloudflaredConfigConfigWarpRoutingResult',
    'GetZeroTrustTunnelCloudflaredConnectionResult',
    'GetZeroTrustTunnelCloudflaredFilterResult',
    'GetZeroTrustTunnelCloudflaredRouteFilterResult',
    'GetZeroTrustTunnelCloudflaredRoutesResultResult',
    'GetZeroTrustTunnelCloudflaredVirtualNetworkFilterResult',
    'GetZeroTrustTunnelCloudflaredVirtualNetworksResultResult',
    'GetZeroTrustTunnelCloudflaredsResultResult',
    'GetZeroTrustTunnelCloudflaredsResultConnectionResult',
    'GetZoneAccountResult',
    'GetZoneFilterResult',
    'GetZoneFilterAccountResult',
    'GetZoneLockdownConfigurationResult',
    'GetZoneLockdownFilterResult',
    'GetZoneLockdownsResultResult',
    'GetZoneLockdownsResultConfigurationResult',
    'GetZoneMetaResult',
    'GetZoneOwnerResult',
    'GetZonesAccountResult',
    'GetZonesResultResult',
    'GetZonesResultAccountResult',
    'GetZonesResultMetaResult',
    'GetZonesResultOwnerResult',
]

@pulumi.output_type
class AccessRuleConfiguration(dict):
    def __init__(__self__, *,
                 target: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str target: The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        :param str value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AccessRuleScope(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str email: The contact email address of the user.
        :param str id: Identifier
        :param str type: The scope of the rule.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The scope of the rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AccountMemberPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionGroups":
            suggest = "permission_groups"
        elif key == "resourceGroups":
            suggest = "resource_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountMemberPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountMemberPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountMemberPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 permission_groups: Sequence['outputs.AccountMemberPolicyPermissionGroup'],
                 resource_groups: Sequence['outputs.AccountMemberPolicyResourceGroup'],
                 id: Optional[str] = None):
        """
        :param str access: Allow or deny operations against the resources.
        :param Sequence['AccountMemberPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Sequence['AccountMemberPolicyResourceGroupArgs'] resource_groups: A list of resource groups that the policy applies to.
        :param str id: Policy identifier.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resource_groups", resource_groups)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.AccountMemberPolicyPermissionGroup']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Sequence['outputs.AccountMemberPolicyResourceGroup']:
        """
        A list of resource groups that the policy applies to.
        """
        return pulumi.get(self, "resource_groups")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AccountMemberPolicyPermissionGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Identifier of the group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AccountMemberPolicyResourceGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Identifier of the group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AccountMemberUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "twoFactorAuthenticationEnabled":
            suggest = "two_factor_authentication_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountMemberUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountMemberUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountMemberUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[str] = None,
                 first_name: Optional[str] = None,
                 id: Optional[str] = None,
                 last_name: Optional[str] = None,
                 two_factor_authentication_enabled: Optional[bool] = None):
        """
        :param str email: The contact email address of the user.
        :param str first_name: User's first name
        :param str id: Identifier
        :param str last_name: User's last name
        :param bool two_factor_authentication_enabled: Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if two_factor_authentication_enabled is not None:
            pulumi.set(__self__, "two_factor_authentication_enabled", two_factor_authentication_enabled)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        User's first name
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        User's last name
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="twoFactorAuthenticationEnabled")
    def two_factor_authentication_enabled(self) -> Optional[bool]:
        """
        Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        return pulumi.get(self, "two_factor_authentication_enabled")


@pulumi.output_type
class AccountSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abuseContactEmail":
            suggest = "abuse_contact_email"
        elif key == "defaultNameservers":
            suggest = "default_nameservers"
        elif key == "enforceTwofactor":
            suggest = "enforce_twofactor"
        elif key == "useAccountCustomNsByDefault":
            suggest = "use_account_custom_ns_by_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 abuse_contact_email: Optional[str] = None,
                 default_nameservers: Optional[str] = None,
                 enforce_twofactor: Optional[bool] = None,
                 use_account_custom_ns_by_default: Optional[bool] = None):
        """
        :param str abuse_contact_email: Sets an abuse contact email to notify for abuse reports.
        :param str default_nameservers: Specifies the default nameservers to be used for new zones added to this account.
        :param bool enforce_twofactor: Indicates whether membership in this account requires that
               Two-Factor Authentication is enabled
        :param bool use_account_custom_ns_by_default: Indicates whether new zones should use the account-level custom
               nameservers by default.
               
               Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
        if abuse_contact_email is not None:
            pulumi.set(__self__, "abuse_contact_email", abuse_contact_email)
        if default_nameservers is not None:
            pulumi.set(__self__, "default_nameservers", default_nameservers)
        if enforce_twofactor is not None:
            pulumi.set(__self__, "enforce_twofactor", enforce_twofactor)
        if use_account_custom_ns_by_default is not None:
            pulumi.set(__self__, "use_account_custom_ns_by_default", use_account_custom_ns_by_default)

    @property
    @pulumi.getter(name="abuseContactEmail")
    def abuse_contact_email(self) -> Optional[str]:
        """
        Sets an abuse contact email to notify for abuse reports.
        """
        return pulumi.get(self, "abuse_contact_email")

    @property
    @pulumi.getter(name="defaultNameservers")
    def default_nameservers(self) -> Optional[str]:
        """
        Specifies the default nameservers to be used for new zones added to this account.
        """
        return pulumi.get(self, "default_nameservers")

    @property
    @pulumi.getter(name="enforceTwofactor")
    def enforce_twofactor(self) -> Optional[bool]:
        """
        Indicates whether membership in this account requires that
        Two-Factor Authentication is enabled
        """
        return pulumi.get(self, "enforce_twofactor")

    @property
    @pulumi.getter(name="useAccountCustomNsByDefault")
    def use_account_custom_ns_by_default(self) -> Optional[bool]:
        """
        Indicates whether new zones should use the account-level custom
        nameservers by default.

        Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
        return pulumi.get(self, "use_account_custom_ns_by_default")


@pulumi.output_type
class AccountSubscriptionRatePlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externallyManaged":
            suggest = "externally_managed"
        elif key == "isContract":
            suggest = "is_contract"
        elif key == "publicName":
            suggest = "public_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSubscriptionRatePlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSubscriptionRatePlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSubscriptionRatePlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency: Optional[str] = None,
                 externally_managed: Optional[bool] = None,
                 id: Optional[str] = None,
                 is_contract: Optional[bool] = None,
                 public_name: Optional[str] = None,
                 scope: Optional[str] = None,
                 sets: Optional[Sequence[str]] = None):
        """
        :param str currency: The currency applied to the rate plan subscription.
        :param bool externally_managed: Whether this rate plan is managed externally from Cloudflare.
        :param str id: The ID of the rate plan.
        :param bool is_contract: Whether a rate plan is enterprise-based (or newly adopted term contract).
        :param str public_name: The full name of the rate plan.
        :param str scope: The scope that this rate plan applies to.
        :param Sequence[str] sets: The list of sets this rate plan applies to.
        """
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if externally_managed is not None:
            pulumi.set(__self__, "externally_managed", externally_managed)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_contract is not None:
            pulumi.set(__self__, "is_contract", is_contract)
        if public_name is not None:
            pulumi.set(__self__, "public_name", public_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sets is not None:
            pulumi.set(__self__, "sets", sets)

    @property
    @pulumi.getter
    def currency(self) -> Optional[str]:
        """
        The currency applied to the rate plan subscription.
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="externallyManaged")
    def externally_managed(self) -> Optional[bool]:
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        return pulumi.get(self, "externally_managed")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the rate plan.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isContract")
    def is_contract(self) -> Optional[bool]:
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        return pulumi.get(self, "is_contract")

    @property
    @pulumi.getter(name="publicName")
    def public_name(self) -> Optional[str]:
        """
        The full name of the rate plan.
        """
        return pulumi.get(self, "public_name")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope that this rate plan applies to.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def sets(self) -> Optional[Sequence[str]]:
        """
        The list of sets this rate plan applies to.
        """
        return pulumi.get(self, "sets")


@pulumi.output_type
class AccountTokenCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestIp":
            suggest = "request_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountTokenCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountTokenCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountTokenCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_ip: Optional['outputs.AccountTokenConditionRequestIp'] = None):
        """
        :param 'AccountTokenConditionRequestIpArgs' request_ip: Client IP restrictions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional['outputs.AccountTokenConditionRequestIp']:
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class AccountTokenConditionRequestIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notIns":
            suggest = "not_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountTokenConditionRequestIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountTokenConditionRequestIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountTokenConditionRequestIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ins: Optional[Sequence[str]] = None,
                 not_ins: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ins: List of IPv4/IPv6 CIDR addresses.
        :param Sequence[str] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[Sequence[str]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[Sequence[str]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class AccountTokenPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionGroups":
            suggest = "permission_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountTokenPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountTokenPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountTokenPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: str,
                 permission_groups: Sequence['outputs.AccountTokenPolicyPermissionGroup'],
                 resources: Mapping[str, str],
                 id: Optional[str] = None):
        """
        :param str effect: Allow or deny operations against the resources.
        :param Sequence['AccountTokenPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Mapping[str, str] resources: A list of resource names that the policy applies to.
        :param str id: Policy identifier.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.AccountTokenPolicyPermissionGroup']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, str]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AccountTokenPolicyPermissionGroup(dict):
    def __init__(__self__, *,
<<<<<<< HEAD
                 id: Optional[str] = None,
=======
                 id: str,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 meta: Optional['outputs.AccountTokenPolicyPermissionGroupMeta'] = None,
                 name: Optional[str] = None):
        """
        :param str id: Identifier of the group.
        :param 'AccountTokenPolicyPermissionGroupMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
<<<<<<< HEAD
        if id is not None:
            pulumi.set(__self__, "id", id)
=======
        pulumi.set(__self__, "id", id)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if meta is not None:
            pulumi.set(__self__, "meta", meta)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
<<<<<<< HEAD
    def id(self) -> Optional[str]:
=======
    def id(self) -> str:
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> Optional['outputs.AccountTokenPolicyPermissionGroupMeta']:
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AccountTokenPolicyPermissionGroupMeta(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AccountUnit(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: Tenant unit ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Tenant unit ID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AddressMapMembership(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canDelete":
            suggest = "can_delete"
        elif key == "createdAt":
            suggest = "created_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddressMapMembership. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddressMapMembership.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddressMapMembership.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_delete: Optional[bool] = None,
                 created_at: Optional[str] = None,
                 identifier: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        :param bool can_delete: Controls whether the membership can be deleted via the API or not.
        :param str identifier: The identifier for the membership (eg. a zone or account tag).
        :param str kind: The type of the membership.
        """
        if can_delete is not None:
            pulumi.set(__self__, "can_delete", can_delete)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> Optional[bool]:
        """
        Controls whether the membership can be deleted via the API or not.
        """
        return pulumi.get(self, "can_delete")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        The identifier for the membership (eg. a zone or account tag).
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        The type of the membership.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class ApiShieldAuthIdCharacteristic(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: The name of the characteristic field, i.e., the header or cookie name.
        :param str type: The type of characteristic.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the characteristic field, i.e., the header or cookie name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of characteristic.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApiShieldError(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 message: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class ApiShieldMessage(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 message: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class ApiShieldOperationFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiRouting":
            suggest = "api_routing"
        elif key == "confidenceIntervals":
            suggest = "confidence_intervals"
        elif key == "parameterSchemas":
            suggest = "parameter_schemas"
        elif key == "schemaInfo":
            suggest = "schema_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldOperationFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldOperationFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldOperationFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_routing: Optional['outputs.ApiShieldOperationFeaturesApiRouting'] = None,
                 confidence_intervals: Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervals'] = None,
                 parameter_schemas: Optional['outputs.ApiShieldOperationFeaturesParameterSchemas'] = None,
                 schema_info: Optional['outputs.ApiShieldOperationFeaturesSchemaInfo'] = None,
                 thresholds: Optional['outputs.ApiShieldOperationFeaturesThresholds'] = None):
        """
        :param 'ApiShieldOperationFeaturesApiRoutingArgs' api_routing: API Routing settings on endpoint.
        """
        if api_routing is not None:
            pulumi.set(__self__, "api_routing", api_routing)
        if confidence_intervals is not None:
            pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        if parameter_schemas is not None:
            pulumi.set(__self__, "parameter_schemas", parameter_schemas)
        if schema_info is not None:
            pulumi.set(__self__, "schema_info", schema_info)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter(name="apiRouting")
    def api_routing(self) -> Optional['outputs.ApiShieldOperationFeaturesApiRouting']:
        """
        API Routing settings on endpoint.
        """
        return pulumi.get(self, "api_routing")

    @property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervals']:
        return pulumi.get(self, "confidence_intervals")

    @property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> Optional['outputs.ApiShieldOperationFeaturesParameterSchemas']:
        return pulumi.get(self, "parameter_schemas")

    @property
    @pulumi.getter(name="schemaInfo")
    def schema_info(self) -> Optional['outputs.ApiShieldOperationFeaturesSchemaInfo']:
        return pulumi.get(self, "schema_info")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ApiShieldOperationFeaturesThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ApiShieldOperationFeaturesApiRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastUpdated":
            suggest = "last_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldOperationFeaturesApiRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldOperationFeaturesApiRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldOperationFeaturesApiRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_updated: Optional[str] = None,
                 route: Optional[str] = None):
        """
        :param str route: Target route.
        """
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        """
        Target route.
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class ApiShieldOperationFeaturesConfidenceIntervals(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastUpdated":
            suggest = "last_updated"
        elif key == "suggestedThreshold":
            suggest = "suggested_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldOperationFeaturesConfidenceIntervals. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldOperationFeaturesConfidenceIntervals.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldOperationFeaturesConfidenceIntervals.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_updated: Optional[str] = None,
                 suggested_threshold: Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold'] = None):
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if suggested_threshold is not None:
            pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold']:
        return pulumi.get(self, "suggested_threshold")


@pulumi.output_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidenceIntervals":
            suggest = "confidence_intervals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidence_intervals: Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals'] = None,
                 mean: Optional[float] = None):
        """
        :param float mean: Suggested threshold.
        """
        if confidence_intervals is not None:
            pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        if mean is not None:
            pulumi.set(__self__, "mean", mean)

    @property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals']:
        return pulumi.get(self, "confidence_intervals")

    @property
    @pulumi.getter
    def mean(self) -> Optional[float]:
        """
        Suggested threshold.
        """
        return pulumi.get(self, "mean")


@pulumi.output_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals(dict):
    def __init__(__self__, *,
                 p90: Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90'] = None,
                 p95: Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95'] = None,
                 p99: Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99'] = None):
        """
        :param 'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args' p90: Upper and lower bound for percentile estimate
        :param 'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args' p95: Upper and lower bound for percentile estimate
        :param 'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args' p99: Upper and lower bound for percentile estimate
        """
        if p90 is not None:
            pulumi.set(__self__, "p90", p90)
        if p95 is not None:
            pulumi.set(__self__, "p95", p95)
        if p99 is not None:
            pulumi.set(__self__, "p99", p99)

    @property
    @pulumi.getter
    def p90(self) -> Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90']:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p90")

    @property
    @pulumi.getter
    def p95(self) -> Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95']:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p95")

    @property
    @pulumi.getter
    def p99(self) -> Optional['outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99']:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p99")


@pulumi.output_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90(dict):
    def __init__(__self__, *,
                 lower: Optional[float] = None,
                 upper: Optional[float] = None):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> Optional[float]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> Optional[float]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95(dict):
    def __init__(__self__, *,
                 lower: Optional[float] = None,
                 upper: Optional[float] = None):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> Optional[float]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> Optional[float]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99(dict):
    def __init__(__self__, *,
                 lower: Optional[float] = None,
                 upper: Optional[float] = None):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> Optional[float]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> Optional[float]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class ApiShieldOperationFeaturesParameterSchemas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastUpdated":
            suggest = "last_updated"
        elif key == "parameterSchemas":
            suggest = "parameter_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldOperationFeaturesParameterSchemas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldOperationFeaturesParameterSchemas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldOperationFeaturesParameterSchemas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_updated: Optional[str] = None,
                 parameter_schemas: Optional['outputs.ApiShieldOperationFeaturesParameterSchemasParameterSchemas'] = None):
        """
        :param 'ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs' parameter_schemas: An operation schema object containing a response.
        """
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if parameter_schemas is not None:
            pulumi.set(__self__, "parameter_schemas", parameter_schemas)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> Optional['outputs.ApiShieldOperationFeaturesParameterSchemasParameterSchemas']:
        """
        An operation schema object containing a response.
        """
        return pulumi.get(self, "parameter_schemas")


@pulumi.output_type
class ApiShieldOperationFeaturesParameterSchemasParameterSchemas(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[str]] = None,
                 responses: Optional[str] = None):
        """
        :param Sequence[str] parameters: An array containing the learned parameter schemas.
        :param str responses: An empty response object. This field is required to yield a valid operation schema.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        An array containing the learned parameter schemas.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def responses(self) -> Optional[str]:
        """
        An empty response object. This field is required to yield a valid operation schema.
        """
        return pulumi.get(self, "responses")


@pulumi.output_type
class ApiShieldOperationFeaturesSchemaInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeSchema":
            suggest = "active_schema"
        elif key == "learnedAvailable":
            suggest = "learned_available"
        elif key == "mitigationAction":
            suggest = "mitigation_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldOperationFeaturesSchemaInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldOperationFeaturesSchemaInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldOperationFeaturesSchemaInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_schema: Optional['outputs.ApiShieldOperationFeaturesSchemaInfoActiveSchema'] = None,
                 learned_available: Optional[bool] = None,
                 mitigation_action: Optional[str] = None):
        """
        :param 'ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs' active_schema: Schema active on endpoint.
        :param bool learned_available: True if a Cloudflare-provided learned schema is available for this endpoint.
        :param str mitigation_action: Action taken on requests failing validation.
        """
        if active_schema is not None:
            pulumi.set(__self__, "active_schema", active_schema)
        if learned_available is not None:
            pulumi.set(__self__, "learned_available", learned_available)
        if mitigation_action is not None:
            pulumi.set(__self__, "mitigation_action", mitigation_action)

    @property
    @pulumi.getter(name="activeSchema")
    def active_schema(self) -> Optional['outputs.ApiShieldOperationFeaturesSchemaInfoActiveSchema']:
        """
        Schema active on endpoint.
        """
        return pulumi.get(self, "active_schema")

    @property
    @pulumi.getter(name="learnedAvailable")
    def learned_available(self) -> Optional[bool]:
        """
        True if a Cloudflare-provided learned schema is available for this endpoint.
        """
        return pulumi.get(self, "learned_available")

    @property
    @pulumi.getter(name="mitigationAction")
    def mitigation_action(self) -> Optional[str]:
        """
        Action taken on requests failing validation.
        """
        return pulumi.get(self, "mitigation_action")


@pulumi.output_type
class ApiShieldOperationFeaturesSchemaInfoActiveSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "isLearned":
            suggest = "is_learned"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldOperationFeaturesSchemaInfoActiveSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldOperationFeaturesSchemaInfoActiveSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldOperationFeaturesSchemaInfoActiveSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 id: Optional[str] = None,
                 is_learned: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str id: UUID
        :param bool is_learned: True if schema is Cloudflare-provided.
        :param str name: Schema file name.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_learned is not None:
            pulumi.set(__self__, "is_learned", is_learned)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isLearned")
    def is_learned(self) -> Optional[bool]:
        """
        True if schema is Cloudflare-provided.
        """
        return pulumi.get(self, "is_learned")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Schema file name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ApiShieldOperationFeaturesThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authIdTokens":
            suggest = "auth_id_tokens"
        elif key == "dataPoints":
            suggest = "data_points"
        elif key == "lastUpdated":
            suggest = "last_updated"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "suggestedThreshold":
            suggest = "suggested_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldOperationFeaturesThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldOperationFeaturesThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldOperationFeaturesThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_id_tokens: Optional[int] = None,
                 data_points: Optional[int] = None,
                 last_updated: Optional[str] = None,
                 p50: Optional[int] = None,
                 p90: Optional[int] = None,
                 p99: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 requests: Optional[int] = None,
                 suggested_threshold: Optional[int] = None):
        """
        :param int auth_id_tokens: The total number of auth-ids seen across this calculation.
        :param int data_points: The number of data points used for the threshold suggestion calculation.
        :param int p50: The p50 quantile of requests (in period_seconds).
        :param int p90: The p90 quantile of requests (in period_seconds).
        :param int p99: The p99 quantile of requests (in period_seconds).
        :param int period_seconds: The period over which this threshold is suggested.
        :param int requests: The estimated number of requests covered by these calculations.
        :param int suggested_threshold: The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        if auth_id_tokens is not None:
            pulumi.set(__self__, "auth_id_tokens", auth_id_tokens)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if p50 is not None:
            pulumi.set(__self__, "p50", p50)
        if p90 is not None:
            pulumi.set(__self__, "p90", p90)
        if p99 is not None:
            pulumi.set(__self__, "p99", p99)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if suggested_threshold is not None:
            pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @property
    @pulumi.getter(name="authIdTokens")
    def auth_id_tokens(self) -> Optional[int]:
        """
        The total number of auth-ids seen across this calculation.
        """
        return pulumi.get(self, "auth_id_tokens")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[int]:
        """
        The number of data points used for the threshold suggestion calculation.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def p50(self) -> Optional[int]:
        """
        The p50 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p50")

    @property
    @pulumi.getter
    def p90(self) -> Optional[int]:
        """
        The p90 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p90")

    @property
    @pulumi.getter
    def p99(self) -> Optional[int]:
        """
        The p99 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p99")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        The period over which this threshold is suggested.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter
    def requests(self) -> Optional[int]:
        """
        The estimated number of requests covered by these calculations.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> Optional[int]:
        """
        The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        return pulumi.get(self, "suggested_threshold")


@pulumi.output_type
class ApiShieldSchemaSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "schemaId":
            suggest = "schema_id"
        elif key == "validationEnabled":
            suggest = "validation_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiShieldSchemaSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiShieldSchemaSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiShieldSchemaSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 schema_id: Optional[str] = None,
                 source: Optional[str] = None,
                 validation_enabled: Optional[bool] = None):
        """
        :param str kind: Kind of schema
        :param str name: Name of the schema
        :param str schema_id: UUID
        :param str source: Source of the schema
        :param bool validation_enabled: Flag whether schema is enabled for validation.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if validation_enabled is not None:
            pulumi.set(__self__, "validation_enabled", validation_enabled)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of schema
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[str]:
        """
        UUID
        """
        return pulumi.get(self, "schema_id")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Source of the schema
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="validationEnabled")
    def validation_enabled(self) -> Optional[bool]:
        """
        Flag whether schema is enabled for validation.
        """
        return pulumi.get(self, "validation_enabled")


@pulumi.output_type
class ApiShieldSchemaUploadDetails(dict):
    def __init__(__self__, *,
                 warnings: Optional[Sequence['outputs.ApiShieldSchemaUploadDetailsWarning']] = None):
        """
        :param Sequence['ApiShieldSchemaUploadDetailsWarningArgs'] warnings: Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
        """
        if warnings is not None:
            pulumi.set(__self__, "warnings", warnings)

    @property
    @pulumi.getter
    def warnings(self) -> Optional[Sequence['outputs.ApiShieldSchemaUploadDetailsWarning']]:
        """
        Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
        """
        return pulumi.get(self, "warnings")


@pulumi.output_type
class ApiShieldSchemaUploadDetailsWarning(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 locations: Optional[Sequence[str]] = None,
                 message: Optional[str] = None):
        """
        :param int code: Code that identifies the event that occurred.
        :param Sequence[str] locations: JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
        :param str message: Diagnostic message that describes the event.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        Code that identifies the event that occurred.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        """
        JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Diagnostic message that describes the event.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ApiTokenCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestIp":
            suggest = "request_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_ip: Optional['outputs.ApiTokenConditionRequestIp'] = None):
        """
        :param 'ApiTokenConditionRequestIpArgs' request_ip: Client IP restrictions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional['outputs.ApiTokenConditionRequestIp']:
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class ApiTokenConditionRequestIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notIns":
            suggest = "not_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenConditionRequestIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenConditionRequestIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenConditionRequestIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ins: Optional[Sequence[str]] = None,
                 not_ins: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ins: List of IPv4/IPv6 CIDR addresses.
        :param Sequence[str] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[Sequence[str]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[Sequence[str]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class ApiTokenPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionGroups":
            suggest = "permission_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: str,
                 permission_groups: Sequence['outputs.ApiTokenPolicyPermissionGroup'],
                 resources: Mapping[str, str],
                 id: Optional[str] = None):
        """
        :param str effect: Allow or deny operations against the resources.
        :param Sequence['ApiTokenPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Mapping[str, str] resources: A list of resource names that the policy applies to.
        :param str id: Policy identifier.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.ApiTokenPolicyPermissionGroup']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, str]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApiTokenPolicyPermissionGroup(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: Optional['outputs.ApiTokenPolicyPermissionGroupMeta'] = None,
                 name: Optional[str] = None):
        """
        :param str id: Identifier of the group.
        :param 'ApiTokenPolicyPermissionGroupMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        if meta is not None:
            pulumi.set(__self__, "meta", meta)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> Optional['outputs.ApiTokenPolicyPermissionGroupMeta']:
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ApiTokenPolicyPermissionGroupMeta(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AuthenticatedOriginPullsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certId":
            suggest = "cert_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthenticatedOriginPullsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthenticatedOriginPullsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthenticatedOriginPullsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 hostname: Optional[str] = None):
        """
        :param str cert_id: Certificate identifier tag.
        :param bool enabled: Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
        :param str hostname: The hostname on the origin for which the client certificate uploaded will be used.
        """
        if cert_id is not None:
            pulumi.set(__self__, "cert_id", cert_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="certId")
    def cert_id(self) -> Optional[str]:
        """
        Certificate identifier tag.
        """
        return pulumi.get(self, "cert_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The hostname on the origin for which the client certificate uploaded will be used.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class BotManagementStaleZoneConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fightMode":
            suggest = "fight_mode"
        elif key == "optimizeWordpress":
            suggest = "optimize_wordpress"
        elif key == "sbfmDefinitelyAutomated":
            suggest = "sbfm_definitely_automated"
        elif key == "sbfmLikelyAutomated":
            suggest = "sbfm_likely_automated"
        elif key == "sbfmStaticResourceProtection":
            suggest = "sbfm_static_resource_protection"
        elif key == "sbfmVerifiedBots":
            suggest = "sbfm_verified_bots"
        elif key == "suppressSessionScore":
            suggest = "suppress_session_score"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BotManagementStaleZoneConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BotManagementStaleZoneConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BotManagementStaleZoneConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fight_mode: Optional[bool] = None,
                 optimize_wordpress: Optional[bool] = None,
                 sbfm_definitely_automated: Optional[str] = None,
                 sbfm_likely_automated: Optional[str] = None,
                 sbfm_static_resource_protection: Optional[str] = None,
                 sbfm_verified_bots: Optional[str] = None,
                 suppress_session_score: Optional[bool] = None):
        """
        :param bool fight_mode: Indicates that the zone's Bot Fight Mode is turned on.
        :param bool optimize_wordpress: Indicates that the zone's wordpress optimization for SBFM is turned on.
        :param str sbfm_definitely_automated: Indicates that the zone's definitely automated requests are being blocked or challenged.
        :param str sbfm_likely_automated: Indicates that the zone's likely automated requests are being blocked or challenged.
        :param str sbfm_static_resource_protection: Indicates that the zone's static resource protection is turned on.
        :param str sbfm_verified_bots: Indicates that the zone's verified bot requests are being blocked.
        :param bool suppress_session_score: Indicates that the zone's session score tracking is disabled.
        """
        if fight_mode is not None:
            pulumi.set(__self__, "fight_mode", fight_mode)
        if optimize_wordpress is not None:
            pulumi.set(__self__, "optimize_wordpress", optimize_wordpress)
        if sbfm_definitely_automated is not None:
            pulumi.set(__self__, "sbfm_definitely_automated", sbfm_definitely_automated)
        if sbfm_likely_automated is not None:
            pulumi.set(__self__, "sbfm_likely_automated", sbfm_likely_automated)
        if sbfm_static_resource_protection is not None:
            pulumi.set(__self__, "sbfm_static_resource_protection", sbfm_static_resource_protection)
        if sbfm_verified_bots is not None:
            pulumi.set(__self__, "sbfm_verified_bots", sbfm_verified_bots)
        if suppress_session_score is not None:
            pulumi.set(__self__, "suppress_session_score", suppress_session_score)

    @property
    @pulumi.getter(name="fightMode")
    def fight_mode(self) -> Optional[bool]:
        """
        Indicates that the zone's Bot Fight Mode is turned on.
        """
        return pulumi.get(self, "fight_mode")

    @property
    @pulumi.getter(name="optimizeWordpress")
    def optimize_wordpress(self) -> Optional[bool]:
        """
        Indicates that the zone's wordpress optimization for SBFM is turned on.
        """
        return pulumi.get(self, "optimize_wordpress")

    @property
    @pulumi.getter(name="sbfmDefinitelyAutomated")
    def sbfm_definitely_automated(self) -> Optional[str]:
        """
        Indicates that the zone's definitely automated requests are being blocked or challenged.
        """
        return pulumi.get(self, "sbfm_definitely_automated")

    @property
    @pulumi.getter(name="sbfmLikelyAutomated")
    def sbfm_likely_automated(self) -> Optional[str]:
        """
        Indicates that the zone's likely automated requests are being blocked or challenged.
        """
        return pulumi.get(self, "sbfm_likely_automated")

    @property
    @pulumi.getter(name="sbfmStaticResourceProtection")
    def sbfm_static_resource_protection(self) -> Optional[str]:
        """
        Indicates that the zone's static resource protection is turned on.
        """
        return pulumi.get(self, "sbfm_static_resource_protection")

    @property
    @pulumi.getter(name="sbfmVerifiedBots")
    def sbfm_verified_bots(self) -> Optional[str]:
        """
        Indicates that the zone's verified bot requests are being blocked.
        """
        return pulumi.get(self, "sbfm_verified_bots")

    @property
    @pulumi.getter(name="suppressSessionScore")
    def suppress_session_score(self) -> Optional[bool]:
        """
        Indicates that the zone's session score tracking is disabled.
        """
        return pulumi.get(self, "suppress_session_score")


@pulumi.output_type
<<<<<<< HEAD
=======
class CloudConnectorRulesParameters(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None):
        """
        :param str host: Host to perform Cloud Connection to
        """
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host to perform Cloud Connection to
        """
        return pulumi.get(self, "host")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class CloudConnectorRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudConnectorRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudConnectorRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudConnectorRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[str] = None,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 expression: Optional[str] = None,
                 id: Optional[str] = None,
                 parameters: Optional['outputs.CloudConnectorRulesRuleParameters'] = None):
        """
        :param str cloud_provider: Cloud Provider type
        :param 'CloudConnectorRulesRuleParametersArgs' parameters: Parameters of Cloud Connector Rule
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Cloud Provider type
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def parameters(self) -> Optional['outputs.CloudConnectorRulesRuleParameters']:
        """
        Parameters of Cloud Connector Rule
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class CloudConnectorRulesRuleParameters(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None):
        """
        :param str host: Host to perform Cloud Connection to
        """
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host to perform Cloud Connection to
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class ContentScanningExpressionBody(dict):
    def __init__(__self__, *,
                 payload: str):
        """
        :param str payload: Ruleset expression to use in matching content objects
        """
        pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        Ruleset expression to use in matching content objects
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class CustomHostnameOwnershipVerification(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: DNS Name for record.
        :param str type: DNS Record type.
        :param str value: Content for the record.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        DNS Name for record.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        DNS Record type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Content for the record.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomHostnameOwnershipVerificationHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpBody":
            suggest = "http_body"
        elif key == "httpUrl":
            suggest = "http_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameOwnershipVerificationHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameOwnershipVerificationHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameOwnershipVerificationHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_body: Optional[str] = None,
                 http_url: Optional[str] = None):
        """
        :param str http_body: Token to be served.
        :param str http_url: The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[str]:
        """
        Token to be served.
        """
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[str]:
        """
        The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        return pulumi.get(self, "http_url")


@pulumi.output_type
class CustomHostnameSsl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bundleMethod":
            suggest = "bundle_method"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "cloudflareBranding":
            suggest = "cloudflare_branding"
<<<<<<< HEAD
=======
        elif key == "customCertBundles":
            suggest = "custom_cert_bundles"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "customCertificate":
            suggest = "custom_certificate"
        elif key == "customKey":
            suggest = "custom_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSsl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSsl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSsl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundle_method: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 cloudflare_branding: Optional[bool] = None,
<<<<<<< HEAD
=======
                 custom_cert_bundles: Optional[Sequence['outputs.CustomHostnameSslCustomCertBundle']] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 custom_certificate: Optional[str] = None,
                 custom_key: Optional[str] = None,
                 method: Optional[str] = None,
                 settings: Optional['outputs.CustomHostnameSslSettings'] = None,
                 type: Optional[str] = None,
                 wildcard: Optional[bool] = None):
        """
        :param str bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        :param str certificate_authority: The Certificate Authority that will issue the certificate
        :param bool cloudflare_branding: Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
<<<<<<< HEAD
=======
        :param Sequence['CustomHostnameSslCustomCertBundleArgs'] custom_cert_bundles: Array of custom certificate and key pairs (1 or 2 pairs allowed)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        :param str custom_certificate: If a custom uploaded certificate is used.
        :param str custom_key: The key for a custom uploaded certificate.
        :param str method: Domain control validation (DCV) method used for this hostname.
        :param 'CustomHostnameSslSettingsArgs' settings: SSL specific settings.
        :param str type: Level of validation to be used for this hostname. Domain validation (dv) must be used.
        :param bool wildcard: Indicates whether the certificate covers a wildcard.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cloudflare_branding is not None:
            pulumi.set(__self__, "cloudflare_branding", cloudflare_branding)
<<<<<<< HEAD
=======
        if custom_cert_bundles is not None:
            pulumi.set(__self__, "custom_cert_bundles", custom_cert_bundles)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[str]:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The Certificate Authority that will issue the certificate
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="cloudflareBranding")
    def cloudflare_branding(self) -> Optional[bool]:
        """
        Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        """
        return pulumi.get(self, "cloudflare_branding")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="customCertBundles")
    def custom_cert_bundles(self) -> Optional[Sequence['outputs.CustomHostnameSslCustomCertBundle']]:
        """
        Array of custom certificate and key pairs (1 or 2 pairs allowed)
        """
        return pulumi.get(self, "custom_cert_bundles")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[str]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[str]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Domain control validation (DCV) method used for this hostname.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.CustomHostnameSslSettings']:
        """
        SSL specific settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Level of validation to be used for this hostname. Domain validation (dv) must be used.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[bool]:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")


@pulumi.output_type
<<<<<<< HEAD
=======
class CustomHostnameSslCustomCertBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customCertificate":
            suggest = "custom_certificate"
        elif key == "customKey":
            suggest = "custom_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSslCustomCertBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSslCustomCertBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSslCustomCertBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_certificate: str,
                 custom_key: str):
        """
        :param str custom_certificate: If a custom uploaded certificate is used.
        :param str custom_key: The key for a custom uploaded certificate.
        """
        pulumi.set(__self__, "custom_certificate", custom_certificate)
        pulumi.set(__self__, "custom_key", custom_key)

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> str:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> str:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class CustomHostnameSslSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earlyHints":
            suggest = "early_hints"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSslSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSslSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSslSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ciphers: Optional[Sequence[str]] = None,
                 early_hints: Optional[str] = None,
                 http2: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 tls13: Optional[str] = None):
        """
        :param Sequence[str] ciphers: An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        :param str early_hints: Whether or not Early Hints is enabled.
        :param str http2: Whether or not HTTP2 is enabled.
        :param str min_tls_version: The minimum TLS version supported.
        :param str tls13: Whether or not TLS 1.3 is enabled.
        """
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[str]]:
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[str]:
        """
        Whether or not Early Hints is enabled.
        """
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter
    def http2(self) -> Optional[str]:
        """
        Whether or not HTTP2 is enabled.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum TLS version supported.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[str]:
        """
        Whether or not TLS 1.3 is enabled.
        """
        return pulumi.get(self, "tls13")


@pulumi.output_type
class CustomSslGeoRestrictions(dict):
    def __init__(__self__, *,
                 label: Optional[str] = None):
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")


@pulumi.output_type
class CustomSslKeylessServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdOn":
            suggest = "created_on"
        elif key == "modifiedOn":
            suggest = "modified_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomSslKeylessServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomSslKeylessServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomSslKeylessServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_on: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 host: Optional[str] = None,
                 id: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 name: Optional[str] = None,
                 permissions: Optional[Sequence[str]] = None,
                 port: Optional[float] = None,
                 status: Optional[str] = None,
                 tunnel: Optional['outputs.CustomSslKeylessServerTunnel'] = None):
        """
        :param str created_on: When the Keyless SSL was created.
        :param bool enabled: Whether or not the Keyless SSL is on or off.
        :param str host: The keyless SSL name.
        :param str id: Keyless certificate identifier tag.
        :param str modified_on: When the Keyless SSL was last modified.
        :param str name: The keyless SSL name.
        :param Sequence[str] permissions: Available permissions for the Keyless SSL for the current user requesting the item.
        :param float port: The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        :param str status: Status of the Keyless SSL.
        :param 'CustomSslKeylessServerTunnelArgs' tunnel: Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        When the Keyless SSL was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not the Keyless SSL is on or off.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Keyless certificate identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        When the Keyless SSL was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[str]]:
        """
        Available permissions for the Keyless SSL for the current user requesting the item.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the Keyless SSL.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tunnel(self) -> Optional['outputs.CustomSslKeylessServerTunnel']:
        """
        Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        return pulumi.get(self, "tunnel")


@pulumi.output_type
class CustomSslKeylessServerTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomSslKeylessServerTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomSslKeylessServerTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomSslKeylessServerTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip: Optional[str] = None,
                 vnet_id: Optional[str] = None):
        """
        :param str private_ip: Private IP of the Key Server Host
        :param str vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[str]:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class DnsFirewallAttackMitigation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onlyWhenUpstreamUnhealthy":
            suggest = "only_when_upstream_unhealthy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsFirewallAttackMitigation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsFirewallAttackMitigation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsFirewallAttackMitigation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 only_when_upstream_unhealthy: Optional[bool] = None):
        """
        :param bool enabled: When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        :param bool only_when_upstream_unhealthy: Only mitigate attacks when upstream servers seem unhealthy
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if only_when_upstream_unhealthy is not None:
            pulumi.set(__self__, "only_when_upstream_unhealthy", only_when_upstream_unhealthy)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="onlyWhenUpstreamUnhealthy")
    def only_when_upstream_unhealthy(self) -> Optional[bool]:
        """
        Only mitigate attacks when upstream servers seem unhealthy
        """
        return pulumi.get(self, "only_when_upstream_unhealthy")


@pulumi.output_type
class DnsRecordData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "digestType":
            suggest = "digest_type"
        elif key == "keyTag":
            suggest = "key_tag"
        elif key == "latDegrees":
            suggest = "lat_degrees"
        elif key == "latDirection":
            suggest = "lat_direction"
        elif key == "latMinutes":
            suggest = "lat_minutes"
        elif key == "latSeconds":
            suggest = "lat_seconds"
        elif key == "longDegrees":
            suggest = "long_degrees"
        elif key == "longDirection":
            suggest = "long_direction"
        elif key == "longMinutes":
            suggest = "long_minutes"
        elif key == "longSeconds":
            suggest = "long_seconds"
        elif key == "matchingType":
            suggest = "matching_type"
        elif key == "precisionHorz":
            suggest = "precision_horz"
        elif key == "precisionVert":
            suggest = "precision_vert"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsRecordData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsRecordData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsRecordData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[float] = None,
                 altitude: Optional[float] = None,
                 certificate: Optional[str] = None,
                 digest: Optional[str] = None,
                 digest_type: Optional[float] = None,
                 fingerprint: Optional[str] = None,
<<<<<<< HEAD
                 flags: Optional[Any] = None,
=======
                 flags: Optional[float] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 key_tag: Optional[float] = None,
                 lat_degrees: Optional[float] = None,
                 lat_direction: Optional[str] = None,
                 lat_minutes: Optional[float] = None,
                 lat_seconds: Optional[float] = None,
                 long_degrees: Optional[float] = None,
                 long_direction: Optional[str] = None,
                 long_minutes: Optional[float] = None,
                 long_seconds: Optional[float] = None,
                 matching_type: Optional[float] = None,
                 order: Optional[float] = None,
                 port: Optional[float] = None,
                 precision_horz: Optional[float] = None,
                 precision_vert: Optional[float] = None,
                 preference: Optional[float] = None,
                 priority: Optional[float] = None,
                 protocol: Optional[float] = None,
                 public_key: Optional[str] = None,
                 regex: Optional[str] = None,
                 replacement: Optional[str] = None,
                 selector: Optional[float] = None,
                 service: Optional[str] = None,
                 size: Optional[float] = None,
                 tag: Optional[str] = None,
                 target: Optional[str] = None,
                 type: Optional[float] = None,
                 usage: Optional[float] = None,
                 value: Optional[str] = None,
                 weight: Optional[float] = None):
        """
        :param float algorithm: Algorithm.
        :param float altitude: Altitude of location in meters.
        :param str certificate: Certificate.
        :param str digest: Digest.
        :param float digest_type: Digest Type.
        :param str fingerprint: fingerprint.
<<<<<<< HEAD
        :param Any flags: Flags for the CAA record.
=======
        :param float flags: Flags for the CAA record.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        :param float key_tag: Key Tag.
        :param float lat_degrees: Degrees of latitude.
        :param str lat_direction: Latitude direction.
        :param float lat_minutes: Minutes of latitude.
        :param float lat_seconds: Seconds of latitude.
        :param float long_degrees: Degrees of longitude.
        :param str long_direction: Longitude direction.
        :param float long_minutes: Minutes of longitude.
        :param float long_seconds: Seconds of longitude.
        :param float matching_type: Matching Type.
        :param float order: Order.
        :param float port: The port of the service.
        :param float precision_horz: Horizontal precision of location.
        :param float precision_vert: Vertical precision of location.
        :param float preference: Preference.
        :param float priority: priority.
        :param float protocol: Protocol.
        :param str public_key: Public Key.
        :param str regex: Regex.
        :param str replacement: Replacement.
        :param float selector: Selector.
        :param str service: Service.
        :param float size: Size of location in meters.
        :param str tag: Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        :param str target: target.
        :param float type: Type.
        :param float usage: Usage.
        :param str value: Value of the record. This field's semantics depend on the chosen tag.
        :param float weight: The record weight.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[float]:
        """
        Algorithm.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def altitude(self) -> Optional[float]:
        """
        Altitude of location in meters.
        """
        return pulumi.get(self, "altitude")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        """
        Digest.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[float]:
        """
        Digest Type.
        """
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        """
        fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
<<<<<<< HEAD
    def flags(self) -> Optional[Any]:
=======
    def flags(self) -> Optional[float]:
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        """
        Flags for the CAA record.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[float]:
        """
        Key Tag.
        """
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[float]:
        """
        Degrees of latitude.
        """
        return pulumi.get(self, "lat_degrees")

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[str]:
        """
        Latitude direction.
        """
        return pulumi.get(self, "lat_direction")

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[float]:
        """
        Minutes of latitude.
        """
        return pulumi.get(self, "lat_minutes")

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[float]:
        """
        Seconds of latitude.
        """
        return pulumi.get(self, "lat_seconds")

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[float]:
        """
        Degrees of longitude.
        """
        return pulumi.get(self, "long_degrees")

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[str]:
        """
        Longitude direction.
        """
        return pulumi.get(self, "long_direction")

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[float]:
        """
        Minutes of longitude.
        """
        return pulumi.get(self, "long_minutes")

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[float]:
        """
        Seconds of longitude.
        """
        return pulumi.get(self, "long_seconds")

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[float]:
        """
        Matching Type.
        """
        return pulumi.get(self, "matching_type")

    @property
    @pulumi.getter
    def order(self) -> Optional[float]:
        """
        Order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[float]:
        """
        Horizontal precision of location.
        """
        return pulumi.get(self, "precision_horz")

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[float]:
        """
        Vertical precision of location.
        """
        return pulumi.get(self, "precision_vert")

    @property
    @pulumi.getter
    def preference(self) -> Optional[float]:
        """
        Preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[float]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        Regex.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        """
        Replacement.
        """
        return pulumi.get(self, "replacement")

    @property
    @pulumi.getter
    def selector(self) -> Optional[float]:
        """
        Selector.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def size(self) -> Optional[float]:
        """
        Size of location in meters.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        target.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[float]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> Optional[float]:
        """
        Usage.
        """
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        The record weight.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class DnsRecordSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flattenCname":
            suggest = "flatten_cname"
        elif key == "ipv4Only":
            suggest = "ipv4_only"
        elif key == "ipv6Only":
            suggest = "ipv6_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsRecordSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsRecordSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsRecordSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flatten_cname: Optional[bool] = None,
                 ipv4_only: Optional[bool] = None,
                 ipv6_only: Optional[bool] = None):
        """
        :param bool flatten_cname: If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        :param bool ipv4_only: When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        :param bool ipv6_only: When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        if flatten_cname is not None:
            pulumi.set(__self__, "flatten_cname", flatten_cname)
        if ipv4_only is not None:
            pulumi.set(__self__, "ipv4_only", ipv4_only)
        if ipv6_only is not None:
            pulumi.set(__self__, "ipv6_only", ipv6_only)

    @property
    @pulumi.getter(name="flattenCname")
    def flatten_cname(self) -> Optional[bool]:
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        return pulumi.get(self, "flatten_cname")

    @property
    @pulumi.getter(name="ipv4Only")
    def ipv4_only(self) -> Optional[bool]:
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv4_only")

    @property
    @pulumi.getter(name="ipv6Only")
    def ipv6_only(self) -> Optional[bool]:
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv6_only")
<<<<<<< HEAD
=======


@pulumi.output_type
class DnsSettingsZoneDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flattenAllCnames":
            suggest = "flatten_all_cnames"
        elif key == "foundationDns":
            suggest = "foundation_dns"
        elif key == "internalDns":
            suggest = "internal_dns"
        elif key == "multiProvider":
            suggest = "multi_provider"
        elif key == "nsTtl":
            suggest = "ns_ttl"
        elif key == "secondaryOverrides":
            suggest = "secondary_overrides"
        elif key == "zoneMode":
            suggest = "zone_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsSettingsZoneDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsSettingsZoneDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsSettingsZoneDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flatten_all_cnames: Optional[bool] = None,
                 foundation_dns: Optional[bool] = None,
                 internal_dns: Optional['outputs.DnsSettingsZoneDefaultsInternalDns'] = None,
                 multi_provider: Optional[bool] = None,
                 nameservers: Optional['outputs.DnsSettingsZoneDefaultsNameservers'] = None,
                 ns_ttl: Optional[float] = None,
                 secondary_overrides: Optional[bool] = None,
                 soa: Optional['outputs.DnsSettingsZoneDefaultsSoa'] = None,
                 zone_mode: Optional[str] = None):
        """
        :param bool flatten_all_cnames: Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        :param bool foundation_dns: Whether to enable Foundation DNS Advanced Nameservers on the zone.
        :param 'DnsSettingsZoneDefaultsInternalDnsArgs' internal_dns: Settings for this internal zone.
        :param bool multi_provider: Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        :param 'DnsSettingsZoneDefaultsNameserversArgs' nameservers: Settings determining the nameservers through which the zone should be available.
        :param float ns_ttl: The time to live (TTL) of the zone's nameserver (NS) records.
        :param bool secondary_overrides: Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        :param 'DnsSettingsZoneDefaultsSoaArgs' soa: Components of the zone's SOA record.
        :param str zone_mode: Whether the zone mode is a regular or CDN/DNS only zone.
        """
        if flatten_all_cnames is not None:
            pulumi.set(__self__, "flatten_all_cnames", flatten_all_cnames)
        if foundation_dns is not None:
            pulumi.set(__self__, "foundation_dns", foundation_dns)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if multi_provider is not None:
            pulumi.set(__self__, "multi_provider", multi_provider)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if ns_ttl is not None:
            pulumi.set(__self__, "ns_ttl", ns_ttl)
        if secondary_overrides is not None:
            pulumi.set(__self__, "secondary_overrides", secondary_overrides)
        if soa is not None:
            pulumi.set(__self__, "soa", soa)
        if zone_mode is not None:
            pulumi.set(__self__, "zone_mode", zone_mode)

    @property
    @pulumi.getter(name="flattenAllCnames")
    def flatten_all_cnames(self) -> Optional[bool]:
        """
        Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        """
        return pulumi.get(self, "flatten_all_cnames")

    @property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> Optional[bool]:
        """
        Whether to enable Foundation DNS Advanced Nameservers on the zone.
        """
        return pulumi.get(self, "foundation_dns")

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional['outputs.DnsSettingsZoneDefaultsInternalDns']:
        """
        Settings for this internal zone.
        """
        return pulumi.get(self, "internal_dns")

    @property
    @pulumi.getter(name="multiProvider")
    def multi_provider(self) -> Optional[bool]:
        """
        Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        """
        return pulumi.get(self, "multi_provider")

    @property
    @pulumi.getter
    def nameservers(self) -> Optional['outputs.DnsSettingsZoneDefaultsNameservers']:
        """
        Settings determining the nameservers through which the zone should be available.
        """
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter(name="nsTtl")
    def ns_ttl(self) -> Optional[float]:
        """
        The time to live (TTL) of the zone's nameserver (NS) records.
        """
        return pulumi.get(self, "ns_ttl")

    @property
    @pulumi.getter(name="secondaryOverrides")
    def secondary_overrides(self) -> Optional[bool]:
        """
        Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        """
        return pulumi.get(self, "secondary_overrides")

    @property
    @pulumi.getter
    def soa(self) -> Optional['outputs.DnsSettingsZoneDefaultsSoa']:
        """
        Components of the zone's SOA record.
        """
        return pulumi.get(self, "soa")

    @property
    @pulumi.getter(name="zoneMode")
    def zone_mode(self) -> Optional[str]:
        """
        Whether the zone mode is a regular or CDN/DNS only zone.
        """
        return pulumi.get(self, "zone_mode")


@pulumi.output_type
class DnsSettingsZoneDefaultsInternalDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceZoneId":
            suggest = "reference_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsSettingsZoneDefaultsInternalDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsSettingsZoneDefaultsInternalDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsSettingsZoneDefaultsInternalDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_zone_id: Optional[str] = None):
        """
        :param str reference_zone_id: The ID of the zone to fallback to.
        """
        if reference_zone_id is not None:
            pulumi.set(__self__, "reference_zone_id", reference_zone_id)

    @property
    @pulumi.getter(name="referenceZoneId")
    def reference_zone_id(self) -> Optional[str]:
        """
        The ID of the zone to fallback to.
        """
        return pulumi.get(self, "reference_zone_id")


@pulumi.output_type
class DnsSettingsZoneDefaultsNameservers(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Nameserver type
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Nameserver type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DnsSettingsZoneDefaultsSoa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minTtl":
            suggest = "min_ttl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsSettingsZoneDefaultsSoa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsSettingsZoneDefaultsSoa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsSettingsZoneDefaultsSoa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expire: float,
                 min_ttl: float,
                 mname: str,
                 refresh: float,
                 retry: float,
                 rname: str,
                 ttl: float):
        """
        :param float expire: Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        :param float min_ttl: The time to live (TTL) for negative caching of records within the zone.
        :param str mname: The primary nameserver, which may be used for outbound zone transfers.
        :param float refresh: Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        :param float retry: Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        :param str rname: The email address of the zone administrator, with the first label representing the local part of the email address.
        :param float ttl: The time to live (TTL) of the SOA record itself.
        """
        pulumi.set(__self__, "expire", expire)
        pulumi.set(__self__, "min_ttl", min_ttl)
        pulumi.set(__self__, "mname", mname)
        pulumi.set(__self__, "refresh", refresh)
        pulumi.set(__self__, "retry", retry)
        pulumi.set(__self__, "rname", rname)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def expire(self) -> float:
        """
        Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        """
        return pulumi.get(self, "expire")

    @property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> float:
        """
        The time to live (TTL) for negative caching of records within the zone.
        """
        return pulumi.get(self, "min_ttl")

    @property
    @pulumi.getter
    def mname(self) -> str:
        """
        The primary nameserver, which may be used for outbound zone transfers.
        """
        return pulumi.get(self, "mname")

    @property
    @pulumi.getter
    def refresh(self) -> float:
        """
        Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        """
        return pulumi.get(self, "refresh")

    @property
    @pulumi.getter
    def retry(self) -> float:
        """
        Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        """
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def rname(self) -> str:
        """
        The email address of the zone administrator, with the first label representing the local part of the email address.
        """
        return pulumi.get(self, "rname")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        The time to live (TTL) of the SOA record itself.
        """
        return pulumi.get(self, "ttl")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580


@pulumi.output_type
class EmailRoutingCatchAllAction(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: Type of action for catch-all rule.
        """
        pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of action for catch-all rule.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class EmailRoutingCatchAllMatcher(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Type of matcher. Default is 'all'.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of matcher. Default is 'all'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EmailRoutingDnsError(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 message: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class EmailRoutingDnsMessage(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 message: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class EmailRoutingDnsResult(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 errors: Optional[Sequence['outputs.EmailRoutingDnsResultError']] = None,
                 name: Optional[str] = None,
                 priority: Optional[float] = None,
                 records: Optional[Sequence['outputs.EmailRoutingDnsResultRecord']] = None,
                 ttl: Optional[float] = None,
                 type: Optional[str] = None):
        """
        :param str content: DNS record content.
        :param str name: DNS record name (or @ for the zone apex).
        :param float priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param float ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param str type: DNS record type.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.EmailRoutingDnsResultError']]:
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def records(self) -> Optional[Sequence['outputs.EmailRoutingDnsResultRecord']]:
        return pulumi.get(self, "records")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[float]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EmailRoutingDnsResultError(dict):
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 missing: Optional['outputs.EmailRoutingDnsResultErrorMissing'] = None):
        """
        :param 'EmailRoutingDnsResultErrorMissingArgs' missing: List of records needed to enable an Email Routing zone.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if missing is not None:
            pulumi.set(__self__, "missing", missing)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def missing(self) -> Optional['outputs.EmailRoutingDnsResultErrorMissing']:
        """
        List of records needed to enable an Email Routing zone.
        """
        return pulumi.get(self, "missing")


@pulumi.output_type
class EmailRoutingDnsResultErrorMissing(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[float] = None,
                 ttl: Optional[float] = None,
                 type: Optional[str] = None):
        """
        :param str content: DNS record content.
        :param str name: DNS record name (or @ for the zone apex).
        :param float priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param float ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param str type: DNS record type.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[float]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EmailRoutingDnsResultInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perPage":
            suggest = "per_page"
        elif key == "totalCount":
            suggest = "total_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmailRoutingDnsResultInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmailRoutingDnsResultInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmailRoutingDnsResultInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[float] = None,
                 page: Optional[float] = None,
                 per_page: Optional[float] = None,
                 total_count: Optional[float] = None):
        """
        :param float count: Total number of results for the requested service
        :param float page: Current page within paginated list of results
        :param float per_page: Number of results per page of results
        :param float total_count: Total results available without any search parameters
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if page is not None:
            pulumi.set(__self__, "page", page)
        if per_page is not None:
            pulumi.set(__self__, "per_page", per_page)
        if total_count is not None:
            pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter
    def count(self) -> Optional[float]:
        """
        Total number of results for the requested service
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def page(self) -> Optional[float]:
        """
        Current page within paginated list of results
        """
        return pulumi.get(self, "page")

    @property
    @pulumi.getter(name="perPage")
    def per_page(self) -> Optional[float]:
        """
        Number of results per page of results
        """
        return pulumi.get(self, "per_page")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> Optional[float]:
        """
        Total results available without any search parameters
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class EmailRoutingDnsResultRecord(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[float] = None,
                 ttl: Optional[float] = None,
                 type: Optional[str] = None):
        """
        :param str content: DNS record content.
        :param str name: DNS record name (or @ for the zone apex).
        :param float priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param float ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param str type: DNS record type.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[float]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EmailRoutingRuleAction(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Type of supported action.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of supported action.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class EmailRoutingRuleMatcher(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str,
                 value: str):
        """
        :param str field: Field for type matcher.
        :param str type: Type of matcher.
        :param str value: Value for matcher.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Field for type matcher.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of matcher.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for matcher.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EmailSecurityTrustedDomainsBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRecent":
            suggest = "is_recent"
        elif key == "isRegex":
            suggest = "is_regex"
        elif key == "isSimilarity":
            suggest = "is_similarity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmailSecurityTrustedDomainsBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmailSecurityTrustedDomainsBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmailSecurityTrustedDomainsBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_recent: bool,
                 is_regex: bool,
                 is_similarity: bool,
                 pattern: str,
                 comments: Optional[str] = None):
        """
        :param bool is_recent: Select to prevent recently registered domains from triggering a
               Suspicious or Malicious disposition.
        :param bool is_similarity: Select for partner or other approved domains that have similar
               spelling to your connected domains. Prevents listed domains from
               triggering a Spoof disposition.
        """
        pulumi.set(__self__, "is_recent", is_recent)
        pulumi.set(__self__, "is_regex", is_regex)
        pulumi.set(__self__, "is_similarity", is_similarity)
        pulumi.set(__self__, "pattern", pattern)
        if comments is not None:
            pulumi.set(__self__, "comments", comments)

    @property
    @pulumi.getter(name="isRecent")
    def is_recent(self) -> bool:
        """
        Select to prevent recently registered domains from triggering a
        Suspicious or Malicious disposition.
        """
        return pulumi.get(self, "is_recent")

    @property
    @pulumi.getter(name="isRegex")
    def is_regex(self) -> bool:
        return pulumi.get(self, "is_regex")

    @property
    @pulumi.getter(name="isSimilarity")
    def is_similarity(self) -> bool:
        """
        Select for partner or other approved domains that have similar
        spelling to your connected domains. Prevents listed domains from
        triggering a Spoof disposition.
        """
        return pulumi.get(self, "is_similarity")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def comments(self) -> Optional[str]:
        return pulumi.get(self, "comments")


@pulumi.output_type
class FirewallRuleAction(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 response: Optional['outputs.FirewallRuleActionResponse'] = None,
                 timeout: Optional[float] = None):
        """
        :param str mode: The action to perform.
        :param 'FirewallRuleActionResponseArgs' response: A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
               Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        :param float timeout: The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
               Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The action to perform.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.FirewallRuleActionResponse']:
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[float]:
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class FirewallRuleActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallRuleActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallRuleActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallRuleActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 content_type: Optional[str] = None):
        """
        :param str body: The response body to return. The value must conform to the configured content type.
        :param str content_type: The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The response body to return. The value must conform to the configured content type.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        return pulumi.get(self, "content_type")


@pulumi.output_type
class FirewallRuleFilter(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 expression: Optional[str] = None,
                 id: Optional[str] = None,
                 paused: Optional[bool] = None,
                 ref: Optional[str] = None):
        """
        :param str description: An informative summary of the filter.
        :param str expression: The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        :param str id: The unique identifier of the filter.
        :param bool paused: When true, indicates that the filter is currently paused.
        :param str ref: A short reference tag. Allows you to select related filters.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An informative summary of the filter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        A short reference tag. Allows you to select related filters.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class HealthcheckHttpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "expectedBody":
            suggest = "expected_body"
        elif key == "expectedCodes":
            suggest = "expected_codes"
        elif key == "followRedirects":
            suggest = "follow_redirects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthcheckHttpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthcheckHttpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthcheckHttpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_insecure: Optional[bool] = None,
                 expected_body: Optional[str] = None,
                 expected_codes: Optional[Sequence[str]] = None,
                 follow_redirects: Optional[bool] = None,
                 header: Optional[Mapping[str, Sequence[str]]] = None,
                 method: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param bool allow_insecure: Do not validate the certificate when the health check uses HTTPS.
        :param str expected_body: A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        :param Sequence[str] expected_codes: The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        :param bool follow_redirects: Follow redirects if the origin returns a 3xx status code.
        :param Mapping[str, Sequence[str]] header: The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        :param str method: The HTTP method to use for the health check.
        :param str path: The endpoint path to health check against.
        :param int port: Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if expected_body is not None:
            pulumi.set(__self__, "expected_body", expected_body)
        if expected_codes is not None:
            pulumi.set(__self__, "expected_codes", expected_codes)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        """
        Do not validate the certificate when the health check uses HTTPS.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="expectedBody")
    def expected_body(self) -> Optional[str]:
        """
        A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        """
        return pulumi.get(self, "expected_body")

    @property
    @pulumi.getter(name="expectedCodes")
    def expected_codes(self) -> Optional[Sequence[str]]:
        """
        The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        """
        return pulumi.get(self, "expected_codes")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        Follow redirects if the origin returns a 3xx status code.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def header(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method to use for the health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The endpoint path to health check against.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class HealthcheckTcpConfig(dict):
    def __init__(__self__, *,
                 method: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str method: The TCP connection method to use for the health check.
        :param int port: Port number to connect to for the health check. Defaults to 80.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The TCP connection method to use for the health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number to connect to for the health check. Defaults to 80.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class HyperdriveConfigCaching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"
        elif key == "staleWhileRevalidate":
            suggest = "stale_while_revalidate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HyperdriveConfigCaching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HyperdriveConfigCaching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HyperdriveConfigCaching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[bool] = None,
                 max_age: Optional[int] = None,
                 stale_while_revalidate: Optional[int] = None):
        """
        :param bool disabled: When set to true, disables the caching of SQL responses. (Default: false)
        :param int max_age: When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        :param int stale_while_revalidate: When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if stale_while_revalidate is not None:
            pulumi.set(__self__, "stale_while_revalidate", stale_while_revalidate)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        When set to true, disables the caching of SQL responses. (Default: false)
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="staleWhileRevalidate")
    def stale_while_revalidate(self) -> Optional[int]:
        """
        When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
        return pulumi.get(self, "stale_while_revalidate")


@pulumi.output_type
class HyperdriveConfigOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessClientId":
            suggest = "access_client_id"
        elif key == "accessClientSecret":
            suggest = "access_client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HyperdriveConfigOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HyperdriveConfigOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HyperdriveConfigOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 password: str,
                 scheme: str,
                 user: str,
                 access_client_id: Optional[str] = None,
                 access_client_secret: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str database: The name of your origin database.
        :param str host: The host (hostname or IP) of your origin database.
        :param str password: The password required to access your origin database. This value is write-only and never returned by the API.
        :param str scheme: Specifies the URL scheme used to connect to your origin database.
        :param str user: The user of your origin database.
        :param str access_client_id: The Client ID of the Access token to use when connecting to the origin database.
        :param str access_client_secret: The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        :param int port: The port (default: 5432 for Postgres) of your origin database.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "user", user)
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of your origin database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host (hostname or IP) of your origin database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password required to access your origin database. This value is write-only and never returned by the API.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        Specifies the URL scheme used to connect to your origin database.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The user of your origin database.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[str]:
        """
        The Client ID of the Access token to use when connecting to the origin database.
        """
        return pulumi.get(self, "access_client_id")

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[str]:
        """
        The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        """
        return pulumi.get(self, "access_client_secret")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port (default: 5432 for Postgres) of your origin database.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ImageVariantOptions(dict):
    def __init__(__self__, *,
                 fit: str,
                 height: float,
                 metadata: str,
                 width: float):
        """
        :param str fit: The fit property describes how the width and height dimensions should be interpreted.
        :param float height: Maximum height in image pixels.
        :param str metadata: What EXIF data should be preserved in the output image.
        :param float width: Maximum width in image pixels.
        """
        pulumi.set(__self__, "fit", fit)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def fit(self) -> str:
        """
        The fit property describes how the width and height dimensions should be interpreted.
        """
        return pulumi.get(self, "fit")

    @property
    @pulumi.getter
    def height(self) -> float:
        """
        Maximum height in image pixels.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        What EXIF data should be preserved in the output image.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def width(self) -> float:
        """
        Maximum width in image pixels.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class ImageVariantVariant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "neverRequireSignedUrls":
            suggest = "never_require_signed_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageVariantVariant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageVariantVariant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageVariantVariant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 never_require_signed_urls: Optional[bool] = None,
                 options: Optional['outputs.ImageVariantVariantOptions'] = None):
        """
        :param bool never_require_signed_urls: Indicates whether the variant can access an image without a signature, regardless of image access control.
        :param 'ImageVariantVariantOptionsArgs' options: Allows you to define image resizing sizes for different use cases.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if never_require_signed_urls is not None:
            pulumi.set(__self__, "never_require_signed_urls", never_require_signed_urls)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="neverRequireSignedUrls")
    def never_require_signed_urls(self) -> Optional[bool]:
        """
        Indicates whether the variant can access an image without a signature, regardless of image access control.
        """
        return pulumi.get(self, "never_require_signed_urls")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.ImageVariantVariantOptions']:
        """
        Allows you to define image resizing sizes for different use cases.
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class ImageVariantVariantOptions(dict):
    def __init__(__self__, *,
                 fit: Optional[str] = None,
                 height: Optional[float] = None,
                 metadata: Optional[str] = None,
                 width: Optional[float] = None):
        """
        :param str fit: The fit property describes how the width and height dimensions should be interpreted.
        :param float height: Maximum height in image pixels.
        :param str metadata: What EXIF data should be preserved in the output image.
        :param float width: Maximum width in image pixels.
        """
        if fit is not None:
            pulumi.set(__self__, "fit", fit)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def fit(self) -> Optional[str]:
        """
        The fit property describes how the width and height dimensions should be interpreted.
        """
        return pulumi.get(self, "fit")

    @property
    @pulumi.getter
    def height(self) -> Optional[float]:
        """
        Maximum height in image pixels.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        What EXIF data should be preserved in the output image.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def width(self) -> Optional[float]:
        """
        Maximum width in image pixels.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class KeylessCertificateTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeylessCertificateTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeylessCertificateTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeylessCertificateTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip: str,
                 vnet_id: str):
        """
        :param str private_ip: Private IP of the Key Server Host
        :param str vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class ListItemHostname(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlHostname":
            suggest = "url_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemHostname. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemHostname.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemHostname.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_hostname: str):
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> str:
        return pulumi.get(self, "url_hostname")


@pulumi.output_type
class ListItemRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceUrl":
            suggest = "source_url"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "preservePathSuffix":
            suggest = "preserve_path_suffix"
        elif key == "preserveQueryString":
            suggest = "preserve_query_string"
        elif key == "statusCode":
            suggest = "status_code"
        elif key == "subpathMatching":
            suggest = "subpath_matching"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_url: str,
                 target_url: str,
                 include_subdomains: Optional[bool] = None,
                 preserve_path_suffix: Optional[bool] = None,
                 preserve_query_string: Optional[bool] = None,
                 status_code: Optional[int] = None,
                 subpath_matching: Optional[bool] = None):
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> str:
        return pulumi.get(self, "source_url")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[bool]:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[bool]:
        return pulumi.get(self, "preserve_path_suffix")

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[bool]:
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[bool]:
        return pulumi.get(self, "subpath_matching")


@pulumi.output_type
class LoadBalancerAdaptiveRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverAcrossPools":
            suggest = "failover_across_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerAdaptiveRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerAdaptiveRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerAdaptiveRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_across_pools: Optional[bool] = None):
        """
        :param bool failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[bool]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class LoadBalancerLocationStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferEcs":
            suggest = "prefer_ecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerLocationStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerLocationStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerLocationStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 prefer_ecs: Optional[str] = None):
        """
        :param str mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param str prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[str]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class LoadBalancerPoolLoadShedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPercent":
            suggest = "default_percent"
        elif key == "defaultPolicy":
            suggest = "default_policy"
        elif key == "sessionPercent":
            suggest = "session_percent"
        elif key == "sessionPolicy":
            suggest = "session_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPoolLoadShedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPoolLoadShedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPoolLoadShedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_percent: Optional[float] = None,
                 default_policy: Optional[str] = None,
                 session_percent: Optional[float] = None,
                 session_policy: Optional[str] = None):
        """
        :param float default_percent: The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        :param str default_policy: The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        :param float session_percent: The percent of existing sessions to shed from the pool, according to the session policy.
        :param str session_policy: Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[float]:
        """
        The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        """
        return pulumi.get(self, "default_percent")

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[str]:
        """
        The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        """
        return pulumi.get(self, "default_policy")

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[float]:
        """
        The percent of existing sessions to shed from the pool, according to the session policy.
        """
        return pulumi.get(self, "session_percent")

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[str]:
        """
        Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
        return pulumi.get(self, "session_policy")


@pulumi.output_type
class LoadBalancerPoolNotificationFilter(dict):
    def __init__(__self__, *,
                 origin: Optional['outputs.LoadBalancerPoolNotificationFilterOrigin'] = None,
                 pool: Optional['outputs.LoadBalancerPoolNotificationFilterPool'] = None):
        """
        :param 'LoadBalancerPoolNotificationFilterOriginArgs' origin: Filter options for a particular resource type (pool or origin). Use null to reset.
        :param 'LoadBalancerPoolNotificationFilterPoolArgs' pool: Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)

    @property
    @pulumi.getter
    def origin(self) -> Optional['outputs.LoadBalancerPoolNotificationFilterOrigin']:
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def pool(self) -> Optional['outputs.LoadBalancerPoolNotificationFilterPool']:
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "pool")


@pulumi.output_type
class LoadBalancerPoolNotificationFilterOrigin(dict):
    def __init__(__self__, *,
                 disable: Optional[bool] = None,
                 healthy: Optional[bool] = None):
        """
        :param bool disable: If set true, disable notifications for this type of resource (pool or origin).
        :param bool healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if healthy is not None:
            pulumi.set(__self__, "healthy", healthy)

    @property
    @pulumi.getter
    def disable(self) -> Optional[bool]:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def healthy(self) -> Optional[bool]:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")


@pulumi.output_type
class LoadBalancerPoolNotificationFilterPool(dict):
    def __init__(__self__, *,
                 disable: Optional[bool] = None,
                 healthy: Optional[bool] = None):
        """
        :param bool disable: If set true, disable notifications for this type of resource (pool or origin).
        :param bool healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if healthy is not None:
            pulumi.set(__self__, "healthy", healthy)

    @property
    @pulumi.getter
    def disable(self) -> Optional[bool]:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def healthy(self) -> Optional[bool]:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")


@pulumi.output_type
class LoadBalancerPoolOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disabledAt":
            suggest = "disabled_at"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPoolOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPoolOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPoolOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 disabled_at: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 header: Optional['outputs.LoadBalancerPoolOriginHeader'] = None,
                 name: Optional[str] = None,
                 virtual_network_id: Optional[str] = None,
                 weight: Optional[float] = None):
        """
        :param str address: The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        :param str disabled_at: This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        :param bool enabled: Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        :param 'LoadBalancerPoolOriginHeaderArgs' header: The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        :param str name: A human-identifiable name for the origin.
        :param str virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param float weight: The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if disabled_at is not None:
            pulumi.set(__self__, "disabled_at", disabled_at)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="disabledAt")
    def disabled_at(self) -> Optional[str]:
        """
        This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        """
        return pulumi.get(self, "disabled_at")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.LoadBalancerPoolOriginHeader']:
        """
        The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class LoadBalancerPoolOriginHeader(dict):
    def __init__(__self__, *,
                 hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] hosts: The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        return pulumi.get(self, "hosts")


@pulumi.output_type
class LoadBalancerPoolOriginSteering(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None):
        """
        :param str policy: The type of origin steering policy to use.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        The type of origin steering policy to use.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class LoadBalancerRandomSteering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultWeight":
            suggest = "default_weight"
        elif key == "poolWeights":
            suggest = "pool_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRandomSteering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRandomSteering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRandomSteering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_weight: Optional[float] = None,
                 pool_weights: Optional[Mapping[str, float]] = None):
        """
        :param float default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param Mapping[str, float] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[float]:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[Mapping[str, float]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class LoadBalancerRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedResponse":
            suggest = "fixed_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 fixed_response: Optional['outputs.LoadBalancerRuleFixedResponse'] = None,
                 name: Optional[str] = None,
                 overrides: Optional['outputs.LoadBalancerRuleOverrides'] = None,
                 priority: Optional[int] = None,
                 terminates: Optional[bool] = None):
        """
        :param str condition: The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        :param bool disabled: Disable this specific rule. It will no longer be evaluated by this load balancer.
        :param 'LoadBalancerRuleFixedResponseArgs' fixed_response: A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        :param str name: Name of this rule. Only used for human readability.
        :param 'LoadBalancerRuleOverridesArgs' overrides: A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        :param int priority: The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        :param bool terminates: If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if terminates is not None:
            pulumi.set(__self__, "terminates", terminates)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Disable this specific rule. It will no longer be evaluated by this load balancer.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional['outputs.LoadBalancerRuleFixedResponse']:
        """
        A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        """
        return pulumi.get(self, "fixed_response")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of this rule. Only used for human readability.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.LoadBalancerRuleOverrides']:
        """
        A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def terminates(self) -> Optional[bool]:
        """
        If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        return pulumi.get(self, "terminates")


@pulumi.output_type
class LoadBalancerRuleFixedResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleFixedResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleFixedResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleFixedResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[str] = None,
                 location: Optional[str] = None,
                 message_body: Optional[str] = None,
                 status_code: Optional[int] = None):
        """
        :param str content_type: The http 'Content-Type' header to include in the response.
        :param str location: The http 'Location' header to include in the response.
        :param str message_body: Text to include as the http body.
        :param int status_code: The http status code to respond with.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        The http 'Content-Type' header to include in the response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The http 'Location' header to include in the response.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[str]:
        """
        Text to include as the http body.
        """
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        The http status code to respond with.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class LoadBalancerRuleOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveRouting":
            suggest = "adaptive_routing"
        elif key == "countryPools":
            suggest = "country_pools"
        elif key == "defaultPools":
            suggest = "default_pools"
        elif key == "fallbackPool":
            suggest = "fallback_pool"
        elif key == "locationStrategy":
            suggest = "location_strategy"
        elif key == "popPools":
            suggest = "pop_pools"
        elif key == "randomSteering":
            suggest = "random_steering"
        elif key == "regionPools":
            suggest = "region_pools"
        elif key == "sessionAffinity":
            suggest = "session_affinity"
        elif key == "sessionAffinityAttributes":
            suggest = "session_affinity_attributes"
        elif key == "sessionAffinityTtl":
            suggest = "session_affinity_ttl"
        elif key == "steeringPolicy":
            suggest = "steering_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_routing: Optional['outputs.LoadBalancerRuleOverridesAdaptiveRouting'] = None,
                 country_pools: Optional[Mapping[str, Sequence[str]]] = None,
                 default_pools: Optional[Sequence[str]] = None,
                 fallback_pool: Optional[str] = None,
                 location_strategy: Optional['outputs.LoadBalancerRuleOverridesLocationStrategy'] = None,
                 pop_pools: Optional[Mapping[str, Sequence[str]]] = None,
                 random_steering: Optional['outputs.LoadBalancerRuleOverridesRandomSteering'] = None,
                 region_pools: Optional[Mapping[str, Sequence[str]]] = None,
                 session_affinity: Optional[str] = None,
                 session_affinity_attributes: Optional['outputs.LoadBalancerRuleOverridesSessionAffinityAttributes'] = None,
                 session_affinity_ttl: Optional[float] = None,
                 steering_policy: Optional[str] = None,
                 ttl: Optional[float] = None):
        """
        :param 'LoadBalancerRuleOverridesAdaptiveRoutingArgs' adaptive_routing: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        :param Mapping[str, Sequence[str]] country_pools: A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        :param Sequence[str] default_pools: A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        :param str fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param 'LoadBalancerRuleOverridesLocationStrategyArgs' location_strategy: Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        :param Mapping[str, Sequence[str]] pop_pools: (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        :param 'LoadBalancerRuleOverridesRandomSteeringArgs' random_steering: Configures pool weights.
        :param Mapping[str, Sequence[str]] region_pools: A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        :param str session_affinity: Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        :param 'LoadBalancerRuleOverridesSessionAffinityAttributesArgs' session_affinity_attributes: Configures attributes for session affinity.
        :param float session_affinity_ttl: Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        :param str steering_policy: Steering Policy for this load balancer.
        :param float ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        if adaptive_routing is not None:
            pulumi.set(__self__, "adaptive_routing", adaptive_routing)
        if country_pools is not None:
            pulumi.set(__self__, "country_pools", country_pools)
        if default_pools is not None:
            pulumi.set(__self__, "default_pools", default_pools)
        if fallback_pool is not None:
            pulumi.set(__self__, "fallback_pool", fallback_pool)
        if location_strategy is not None:
            pulumi.set(__self__, "location_strategy", location_strategy)
        if pop_pools is not None:
            pulumi.set(__self__, "pop_pools", pop_pools)
        if random_steering is not None:
            pulumi.set(__self__, "random_steering", random_steering)
        if region_pools is not None:
            pulumi.set(__self__, "region_pools", region_pools)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_affinity_attributes is not None:
            pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        if session_affinity_ttl is not None:
            pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        if steering_policy is not None:
            pulumi.set(__self__, "steering_policy", steering_policy)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRouting")
    def adaptive_routing(self) -> Optional['outputs.LoadBalancerRuleOverridesAdaptiveRouting']:
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        """
        return pulumi.get(self, "adaptive_routing")

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        """
        return pulumi.get(self, "country_pools")

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Optional[Sequence[str]]:
        """
        A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        """
        return pulumi.get(self, "default_pools")

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> Optional[str]:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @property
    @pulumi.getter(name="locationStrategy")
    def location_strategy(self) -> Optional['outputs.LoadBalancerRuleOverridesLocationStrategy']:
        """
        Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        """
        return pulumi.get(self, "location_strategy")

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        """
        return pulumi.get(self, "pop_pools")

    @property
    @pulumi.getter(name="randomSteering")
    def random_steering(self) -> Optional['outputs.LoadBalancerRuleOverridesRandomSteering']:
        """
        Configures pool weights.
        """
        return pulumi.get(self, "random_steering")

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        """
        return pulumi.get(self, "region_pools")

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[str]:
        """
        Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        """
        return pulumi.get(self, "session_affinity")

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> Optional['outputs.LoadBalancerRuleOverridesSessionAffinityAttributes']:
        """
        Configures attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> Optional[float]:
        """
        Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        """
        return pulumi.get(self, "session_affinity_ttl")

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> Optional[str]:
        """
        Steering Policy for this load balancer.
        """
        return pulumi.get(self, "steering_policy")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[float]:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class LoadBalancerRuleOverridesAdaptiveRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverAcrossPools":
            suggest = "failover_across_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverridesAdaptiveRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverridesAdaptiveRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverridesAdaptiveRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_across_pools: Optional[bool] = None):
        """
        :param bool failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[bool]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class LoadBalancerRuleOverridesLocationStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferEcs":
            suggest = "prefer_ecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverridesLocationStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverridesLocationStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverridesLocationStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 prefer_ecs: Optional[str] = None):
        """
        :param str mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param str prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[str]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class LoadBalancerRuleOverridesRandomSteering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultWeight":
            suggest = "default_weight"
        elif key == "poolWeights":
            suggest = "pool_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverridesRandomSteering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverridesRandomSteering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverridesRandomSteering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_weight: Optional[float] = None,
                 pool_weights: Optional[Mapping[str, float]] = None):
        """
        :param float default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param Mapping[str, float] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[float]:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[Mapping[str, float]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class LoadBalancerRuleOverridesSessionAffinityAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainDuration":
            suggest = "drain_duration"
        elif key == "requireAllHeaders":
            suggest = "require_all_headers"
        elif key == "zeroDowntimeFailover":
            suggest = "zero_downtime_failover"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverridesSessionAffinityAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverridesSessionAffinityAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverridesSessionAffinityAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_duration: Optional[float] = None,
                 headers: Optional[Sequence[str]] = None,
                 require_all_headers: Optional[bool] = None,
                 samesite: Optional[str] = None,
                 secure: Optional[str] = None,
                 zero_downtime_failover: Optional[str] = None):
        """
        :param float drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param Sequence[str] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param bool require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        :param str samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        :param str secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        :param str zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[float]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[bool]:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> Optional[str]:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> Optional[str]:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[str]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class LoadBalancerSessionAffinityAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainDuration":
            suggest = "drain_duration"
        elif key == "requireAllHeaders":
            suggest = "require_all_headers"
        elif key == "zeroDowntimeFailover":
            suggest = "zero_downtime_failover"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerSessionAffinityAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerSessionAffinityAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerSessionAffinityAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_duration: Optional[float] = None,
                 headers: Optional[Sequence[str]] = None,
                 require_all_headers: Optional[bool] = None,
                 samesite: Optional[str] = None,
                 secure: Optional[str] = None,
                 zero_downtime_failover: Optional[str] = None):
        """
        :param float drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param Sequence[str] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param bool require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        :param str samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        :param str secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        :param str zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[float]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[bool]:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> Optional[str]:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> Optional[str]:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[str]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class LogpushJobOutputOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchPrefix":
            suggest = "batch_prefix"
        elif key == "batchSuffix":
            suggest = "batch_suffix"
        elif key == "fieldDelimiter":
            suggest = "field_delimiter"
        elif key == "fieldNames":
            suggest = "field_names"
        elif key == "outputType":
            suggest = "output_type"
        elif key == "recordDelimiter":
            suggest = "record_delimiter"
        elif key == "recordPrefix":
            suggest = "record_prefix"
        elif key == "recordSuffix":
            suggest = "record_suffix"
        elif key == "recordTemplate":
            suggest = "record_template"
        elif key == "sampleRate":
            suggest = "sample_rate"
        elif key == "timestampFormat":
            suggest = "timestamp_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogpushJobOutputOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogpushJobOutputOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogpushJobOutputOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_prefix: Optional[str] = None,
                 batch_suffix: Optional[str] = None,
                 cve20214428: Optional[bool] = None,
                 field_delimiter: Optional[str] = None,
                 field_names: Optional[Sequence[str]] = None,
                 output_type: Optional[str] = None,
                 record_delimiter: Optional[str] = None,
                 record_prefix: Optional[str] = None,
                 record_suffix: Optional[str] = None,
                 record_template: Optional[str] = None,
                 sample_rate: Optional[float] = None,
                 timestamp_format: Optional[str] = None):
        """
        :param str batch_prefix: String to be prepended before each batch.
        :param str batch_suffix: String to be appended after each batch.
        :param bool cve20214428: If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        :param str field_delimiter: String to join fields. This field be ignored when `record_template` is set.
        :param Sequence[str] field_names: List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        :param str output_type: Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        :param str record_delimiter: String to be inserted in-between the records as separator.
        :param str record_prefix: String to be prepended before each record.
        :param str record_suffix: String to be appended after each record.
        :param str record_template: String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        :param float sample_rate: Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        :param str timestamp_format: String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        if batch_prefix is not None:
            pulumi.set(__self__, "batch_prefix", batch_prefix)
        if batch_suffix is not None:
            pulumi.set(__self__, "batch_suffix", batch_suffix)
        if cve20214428 is not None:
            pulumi.set(__self__, "cve20214428", cve20214428)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)
        if output_type is not None:
            pulumi.set(__self__, "output_type", output_type)
        if record_delimiter is not None:
            pulumi.set(__self__, "record_delimiter", record_delimiter)
        if record_prefix is not None:
            pulumi.set(__self__, "record_prefix", record_prefix)
        if record_suffix is not None:
            pulumi.set(__self__, "record_suffix", record_suffix)
        if record_template is not None:
            pulumi.set(__self__, "record_template", record_template)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter(name="batchPrefix")
    def batch_prefix(self) -> Optional[str]:
        """
        String to be prepended before each batch.
        """
        return pulumi.get(self, "batch_prefix")

    @property
    @pulumi.getter(name="batchSuffix")
    def batch_suffix(self) -> Optional[str]:
        """
        String to be appended after each batch.
        """
        return pulumi.get(self, "batch_suffix")

    @property
    @pulumi.getter
    def cve20214428(self) -> Optional[bool]:
        """
        If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        """
        return pulumi.get(self, "cve20214428")

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[str]:
        """
        String to join fields. This field be ignored when `record_template` is set.
        """
        return pulumi.get(self, "field_delimiter")

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[Sequence[str]]:
        """
        List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        """
        return pulumi.get(self, "field_names")

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> Optional[str]:
        """
        Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        """
        return pulumi.get(self, "output_type")

    @property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> Optional[str]:
        """
        String to be inserted in-between the records as separator.
        """
        return pulumi.get(self, "record_delimiter")

    @property
    @pulumi.getter(name="recordPrefix")
    def record_prefix(self) -> Optional[str]:
        """
        String to be prepended before each record.
        """
        return pulumi.get(self, "record_prefix")

    @property
    @pulumi.getter(name="recordSuffix")
    def record_suffix(self) -> Optional[str]:
        """
        String to be appended after each record.
        """
        return pulumi.get(self, "record_suffix")

    @property
    @pulumi.getter(name="recordTemplate")
    def record_template(self) -> Optional[str]:
        """
        String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        """
        return pulumi.get(self, "record_template")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[str]:
        """
        String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        return pulumi.get(self, "timestamp_format")


@pulumi.output_type
class MagicNetworkMonitoringConfigurationWarpDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routerIp":
            suggest = "router_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicNetworkMonitoringConfigurationWarpDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicNetworkMonitoringConfigurationWarpDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicNetworkMonitoringConfigurationWarpDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 router_ip: str):
        """
        :param str id: Unique identifier for the warp device.
        :param str name: Name of the warp device.
        :param str router_ip: IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "router_ip", router_ip)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the warp device.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the warp device.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="routerIp")
    def router_ip(self) -> str:
        """
        IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
        return pulumi.get(self, "router_ip")


@pulumi.output_type
class MagicTransitConnectorDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitConnectorDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitConnectorDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitConnectorDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 serial_number: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")


@pulumi.output_type
class MagicTransitSiteAclLan1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lanId":
            suggest = "lan_id"
        elif key == "lanName":
            suggest = "lan_name"
        elif key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteAclLan1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteAclLan1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteAclLan1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lan_id: str,
                 lan_name: Optional[str] = None,
                 port_ranges: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[int]] = None,
                 subnets: Optional[Sequence[str]] = None):
        """
        :param str lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param str lan_name: The name of the LAN based on the provided lan_id.
        :param Sequence[str] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param Sequence[int] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param Sequence[str] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        if lan_name is not None:
            pulumi.set(__self__, "lan_name", lan_name)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> Optional[str]:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence[str]]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class MagicTransitSiteAclLan2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lanId":
            suggest = "lan_id"
        elif key == "lanName":
            suggest = "lan_name"
        elif key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteAclLan2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteAclLan2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteAclLan2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lan_id: str,
                 lan_name: Optional[str] = None,
                 port_ranges: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[int]] = None,
                 subnets: Optional[Sequence[str]] = None):
        """
        :param str lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param str lan_name: The name of the LAN based on the provided lan_id.
        :param Sequence[str] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param Sequence[int] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param Sequence[str] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        if lan_name is not None:
            pulumi.set(__self__, "lan_name", lan_name)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> Optional[str]:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence[str]]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class MagicTransitSiteLanNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticPrefix":
            suggest = "static_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteLanNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteLanNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteLanNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_prefix: Optional[str] = None):
        """
        :param str static_prefix: A valid CIDR notation representing an IP range.
        """
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class MagicTransitSiteLanRoutedSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHop":
            suggest = "next_hop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteLanRoutedSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteLanRoutedSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteLanRoutedSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_hop: str,
                 prefix: str,
                 nat: Optional['outputs.MagicTransitSiteLanRoutedSubnetNat'] = None):
        """
        :param str next_hop: A valid IPv4 address.
        :param str prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def nat(self) -> Optional['outputs.MagicTransitSiteLanRoutedSubnetNat']:
        return pulumi.get(self, "nat")


@pulumi.output_type
class MagicTransitSiteLanRoutedSubnetNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticPrefix":
            suggest = "static_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteLanRoutedSubnetNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteLanRoutedSubnetNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteLanRoutedSubnetNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_prefix: Optional[str] = None):
        """
        :param str static_prefix: A valid CIDR notation representing an IP range.
        """
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class MagicTransitSiteLanStaticAddressing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhcpRelay":
            suggest = "dhcp_relay"
        elif key == "dhcpServer":
            suggest = "dhcp_server"
        elif key == "secondaryAddress":
            suggest = "secondary_address"
        elif key == "virtualAddress":
            suggest = "virtual_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteLanStaticAddressing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteLanStaticAddressing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteLanStaticAddressing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 dhcp_relay: Optional['outputs.MagicTransitSiteLanStaticAddressingDhcpRelay'] = None,
                 dhcp_server: Optional['outputs.MagicTransitSiteLanStaticAddressingDhcpServer'] = None,
                 secondary_address: Optional[str] = None,
                 virtual_address: Optional[str] = None):
        """
        :param str address: A valid CIDR notation representing an IP range.
        :param str secondary_address: A valid CIDR notation representing an IP range.
        :param str virtual_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        if dhcp_relay is not None:
            pulumi.set(__self__, "dhcp_relay", dhcp_relay)
        if dhcp_server is not None:
            pulumi.set(__self__, "dhcp_server", dhcp_server)
        if secondary_address is not None:
            pulumi.set(__self__, "secondary_address", secondary_address)
        if virtual_address is not None:
            pulumi.set(__self__, "virtual_address", virtual_address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="dhcpRelay")
    def dhcp_relay(self) -> Optional['outputs.MagicTransitSiteLanStaticAddressingDhcpRelay']:
        return pulumi.get(self, "dhcp_relay")

    @property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> Optional['outputs.MagicTransitSiteLanStaticAddressingDhcpServer']:
        return pulumi.get(self, "dhcp_server")

    @property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> Optional[str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")

    @property
    @pulumi.getter(name="virtualAddress")
    def virtual_address(self) -> Optional[str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "virtual_address")


@pulumi.output_type
class MagicTransitSiteLanStaticAddressingDhcpRelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddresses":
            suggest = "server_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteLanStaticAddressingDhcpRelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteLanStaticAddressingDhcpRelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteLanStaticAddressingDhcpRelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_addresses: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] server_addresses: List of DHCP server IPs.
        """
        if server_addresses is not None:
            pulumi.set(__self__, "server_addresses", server_addresses)

    @property
    @pulumi.getter(name="serverAddresses")
    def server_addresses(self) -> Optional[Sequence[str]]:
        """
        List of DHCP server IPs.
        """
        return pulumi.get(self, "server_addresses")


@pulumi.output_type
class MagicTransitSiteLanStaticAddressingDhcpServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhcpPoolEnd":
            suggest = "dhcp_pool_end"
        elif key == "dhcpPoolStart":
            suggest = "dhcp_pool_start"
        elif key == "dnsServer":
            suggest = "dns_server"
<<<<<<< HEAD
=======
        elif key == "dnsServers":
            suggest = "dns_servers"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteLanStaticAddressingDhcpServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteLanStaticAddressingDhcpServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteLanStaticAddressingDhcpServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dhcp_pool_end: Optional[str] = None,
                 dhcp_pool_start: Optional[str] = None,
                 dns_server: Optional[str] = None,
<<<<<<< HEAD
=======
                 dns_servers: Optional[Sequence[str]] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 reservations: Optional[Mapping[str, str]] = None):
        """
        :param str dhcp_pool_end: A valid IPv4 address.
        :param str dhcp_pool_start: A valid IPv4 address.
        :param str dns_server: A valid IPv4 address.
        :param Mapping[str, str] reservations: Mapping of MAC addresses to IP addresses
        """
        if dhcp_pool_end is not None:
            pulumi.set(__self__, "dhcp_pool_end", dhcp_pool_end)
        if dhcp_pool_start is not None:
            pulumi.set(__self__, "dhcp_pool_start", dhcp_pool_start)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
<<<<<<< HEAD
=======
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if reservations is not None:
            pulumi.set(__self__, "reservations", reservations)

    @property
    @pulumi.getter(name="dhcpPoolEnd")
    def dhcp_pool_end(self) -> Optional[str]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_end")

    @property
    @pulumi.getter(name="dhcpPoolStart")
    def dhcp_pool_start(self) -> Optional[str]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_start")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[str]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dns_server")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_servers")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def reservations(self) -> Optional[Mapping[str, str]]:
        """
        Mapping of MAC addresses to IP addresses
        """
        return pulumi.get(self, "reservations")


@pulumi.output_type
class MagicTransitSiteLocation(dict):
    def __init__(__self__, *,
                 lat: Optional[str] = None,
                 lon: Optional[str] = None):
        """
        :param str lat: Latitude
        :param str lon: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lon is not None:
            pulumi.set(__self__, "lon", lon)

    @property
    @pulumi.getter
    def lat(self) -> Optional[str]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[str]:
        """
        Longitude
        """
        return pulumi.get(self, "lon")


@pulumi.output_type
class MagicTransitSiteWanStaticAddressing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayAddress":
            suggest = "gateway_address"
        elif key == "secondaryAddress":
            suggest = "secondary_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicTransitSiteWanStaticAddressing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicTransitSiteWanStaticAddressing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicTransitSiteWanStaticAddressing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 gateway_address: str,
                 secondary_address: Optional[str] = None):
        """
        :param str address: A valid CIDR notation representing an IP range.
        :param str gateway_address: A valid IPv4 address.
        :param str secondary_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "gateway_address", gateway_address)
        if secondary_address is not None:
            pulumi.set(__self__, "secondary_address", secondary_address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="gatewayAddress")
    def gateway_address(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "gateway_address")

    @property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> Optional[str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")


@pulumi.output_type
class MagicWanGreTunnelGreTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudflareGreEndpoint":
            suggest = "cloudflare_gre_endpoint"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "customerGreEndpoint":
            suggest = "customer_gre_endpoint"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "interfaceAddress":
            suggest = "interface_address"
        elif key == "modifiedOn":
            suggest = "modified_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanGreTunnelGreTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanGreTunnelGreTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanGreTunnelGreTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudflare_gre_endpoint: Optional[str] = None,
                 created_on: Optional[str] = None,
                 customer_gre_endpoint: Optional[str] = None,
                 description: Optional[str] = None,
                 health_check: Optional['outputs.MagicWanGreTunnelGreTunnelHealthCheck'] = None,
                 id: Optional[str] = None,
                 interface_address: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 mtu: Optional[int] = None,
                 name: Optional[str] = None,
                 ttl: Optional[int] = None):
        """
        :param str cloudflare_gre_endpoint: The IP address assigned to the Cloudflare side of the GRE tunnel.
        :param str created_on: The date and time the tunnel was created.
        :param str customer_gre_endpoint: The IP address assigned to the customer side of the GRE tunnel.
        :param str description: An optional description of the GRE tunnel.
        :param str id: Tunnel identifier tag.
        :param str interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        :param str modified_on: The date and time the tunnel was last modified.
        :param int mtu: Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        :param str name: The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        :param int ttl: Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        if cloudflare_gre_endpoint is not None:
            pulumi.set(__self__, "cloudflare_gre_endpoint", cloudflare_gre_endpoint)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if customer_gre_endpoint is not None:
            pulumi.set(__self__, "customer_gre_endpoint", customer_gre_endpoint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="cloudflareGreEndpoint")
    def cloudflare_gre_endpoint(self) -> Optional[str]:
        """
        The IP address assigned to the Cloudflare side of the GRE tunnel.
        """
        return pulumi.get(self, "cloudflare_gre_endpoint")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="customerGreEndpoint")
    def customer_gre_endpoint(self) -> Optional[str]:
        """
        The IP address assigned to the customer side of the GRE tunnel.
        """
        return pulumi.get(self, "customer_gre_endpoint")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the GRE tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.MagicWanGreTunnelGreTunnelHealthCheck']:
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[str]:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class MagicWanGreTunnelGreTunnelHealthCheck(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 rate: Optional[str] = None,
                 target: Optional['outputs.MagicWanGreTunnelGreTunnelHealthCheckTarget'] = None,
                 type: Optional[str] = None):
        """
        :param str direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param bool enabled: Determines whether to run healthchecks for a tunnel.
        :param str rate: How frequent the health check is run. The default value is `mid`.
        :param 'MagicWanGreTunnelGreTunnelHealthCheckTargetArgs' target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param str type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rate(self) -> Optional[str]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.MagicWanGreTunnelGreTunnelHealthCheckTarget']:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MagicWanGreTunnelGreTunnelHealthCheckTarget(dict):
    def __init__(__self__, *,
                 effective: Optional[str] = None,
                 saved: Optional[str] = None):
        """
        :param str effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param str saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[str]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @property
    @pulumi.getter
    def saved(self) -> Optional[str]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")


@pulumi.output_type
class MagicWanGreTunnelHealthCheck(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 rate: Optional[str] = None,
                 target: Optional['outputs.MagicWanGreTunnelHealthCheckTarget'] = None,
                 type: Optional[str] = None):
        """
        :param str direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param bool enabled: Determines whether to run healthchecks for a tunnel.
        :param str rate: How frequent the health check is run. The default value is `mid`.
        :param 'MagicWanGreTunnelHealthCheckTargetArgs' target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param str type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rate(self) -> Optional[str]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.MagicWanGreTunnelHealthCheckTarget']:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MagicWanGreTunnelHealthCheckTarget(dict):
    def __init__(__self__, *,
                 effective: Optional[str] = None,
                 saved: Optional[str] = None):
        """
        :param str effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param str saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[str]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @property
    @pulumi.getter
    def saved(self) -> Optional[str]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")


@pulumi.output_type
class MagicWanGreTunnelModifiedGreTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudflareGreEndpoint":
            suggest = "cloudflare_gre_endpoint"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "customerGreEndpoint":
            suggest = "customer_gre_endpoint"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "interfaceAddress":
            suggest = "interface_address"
        elif key == "modifiedOn":
            suggest = "modified_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanGreTunnelModifiedGreTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanGreTunnelModifiedGreTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanGreTunnelModifiedGreTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudflare_gre_endpoint: Optional[str] = None,
                 created_on: Optional[str] = None,
                 customer_gre_endpoint: Optional[str] = None,
                 description: Optional[str] = None,
                 health_check: Optional['outputs.MagicWanGreTunnelModifiedGreTunnelHealthCheck'] = None,
                 id: Optional[str] = None,
                 interface_address: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 mtu: Optional[int] = None,
                 name: Optional[str] = None,
                 ttl: Optional[int] = None):
        """
        :param str cloudflare_gre_endpoint: The IP address assigned to the Cloudflare side of the GRE tunnel.
        :param str created_on: The date and time the tunnel was created.
        :param str customer_gre_endpoint: The IP address assigned to the customer side of the GRE tunnel.
        :param str description: An optional description of the GRE tunnel.
        :param str id: Tunnel identifier tag.
        :param str interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        :param str modified_on: The date and time the tunnel was last modified.
        :param int mtu: Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        :param str name: The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        :param int ttl: Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        if cloudflare_gre_endpoint is not None:
            pulumi.set(__self__, "cloudflare_gre_endpoint", cloudflare_gre_endpoint)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if customer_gre_endpoint is not None:
            pulumi.set(__self__, "customer_gre_endpoint", customer_gre_endpoint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="cloudflareGreEndpoint")
    def cloudflare_gre_endpoint(self) -> Optional[str]:
        """
        The IP address assigned to the Cloudflare side of the GRE tunnel.
        """
        return pulumi.get(self, "cloudflare_gre_endpoint")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="customerGreEndpoint")
    def customer_gre_endpoint(self) -> Optional[str]:
        """
        The IP address assigned to the customer side of the GRE tunnel.
        """
        return pulumi.get(self, "customer_gre_endpoint")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the GRE tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.MagicWanGreTunnelModifiedGreTunnelHealthCheck']:
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[str]:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class MagicWanGreTunnelModifiedGreTunnelHealthCheck(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 rate: Optional[str] = None,
                 target: Optional['outputs.MagicWanGreTunnelModifiedGreTunnelHealthCheckTarget'] = None,
                 type: Optional[str] = None):
        """
        :param str direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param bool enabled: Determines whether to run healthchecks for a tunnel.
        :param str rate: How frequent the health check is run. The default value is `mid`.
        :param 'MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgs' target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param str type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rate(self) -> Optional[str]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.MagicWanGreTunnelModifiedGreTunnelHealthCheckTarget']:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MagicWanGreTunnelModifiedGreTunnelHealthCheckTarget(dict):
    def __init__(__self__, *,
                 effective: Optional[str] = None,
                 saved: Optional[str] = None):
        """
        :param str effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param str saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[str]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @property
    @pulumi.getter
    def saved(self) -> Optional[str]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")


@pulumi.output_type
class MagicWanIpsecTunnelHealthCheck(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 rate: Optional[str] = None,
                 target: Optional['outputs.MagicWanIpsecTunnelHealthCheckTarget'] = None,
                 type: Optional[str] = None):
        """
        :param str direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param bool enabled: Determines whether to run healthchecks for a tunnel.
        :param str rate: How frequent the health check is run. The default value is `mid`.
        :param 'MagicWanIpsecTunnelHealthCheckTargetArgs' target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param str type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rate(self) -> Optional[str]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.MagicWanIpsecTunnelHealthCheckTarget']:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MagicWanIpsecTunnelHealthCheckTarget(dict):
    def __init__(__self__, *,
                 effective: Optional[str] = None,
                 saved: Optional[str] = None):
        """
        :param str effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param str saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[str]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @property
    @pulumi.getter
    def saved(self) -> Optional[str]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")


@pulumi.output_type
class MagicWanIpsecTunnelIpsecTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowNullCipher":
            suggest = "allow_null_cipher"
        elif key == "cloudflareEndpoint":
            suggest = "cloudflare_endpoint"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "customerEndpoint":
            suggest = "customer_endpoint"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "interfaceAddress":
            suggest = "interface_address"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "pskMetadata":
            suggest = "psk_metadata"
        elif key == "replayProtection":
            suggest = "replay_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanIpsecTunnelIpsecTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanIpsecTunnelIpsecTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanIpsecTunnelIpsecTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_null_cipher: Optional[bool] = None,
                 cloudflare_endpoint: Optional[str] = None,
                 created_on: Optional[str] = None,
                 customer_endpoint: Optional[str] = None,
                 description: Optional[str] = None,
                 health_check: Optional['outputs.MagicWanIpsecTunnelIpsecTunnelHealthCheck'] = None,
                 id: Optional[str] = None,
                 interface_address: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 name: Optional[str] = None,
                 psk_metadata: Optional['outputs.MagicWanIpsecTunnelIpsecTunnelPskMetadata'] = None,
                 replay_protection: Optional[bool] = None):
        """
        :param bool allow_null_cipher: When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        :param str cloudflare_endpoint: The IP address assigned to the Cloudflare side of the IPsec tunnel.
        :param str created_on: The date and time the tunnel was created.
        :param str customer_endpoint: The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        :param str description: An optional description forthe IPsec tunnel.
        :param str id: Tunnel identifier tag.
        :param str interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        :param str modified_on: The date and time the tunnel was last modified.
        :param str name: The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        :param 'MagicWanIpsecTunnelIpsecTunnelPskMetadataArgs' psk_metadata: The PSK metadata that includes when the PSK was generated.
        :param bool replay_protection: If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        if allow_null_cipher is not None:
            pulumi.set(__self__, "allow_null_cipher", allow_null_cipher)
        if cloudflare_endpoint is not None:
            pulumi.set(__self__, "cloudflare_endpoint", cloudflare_endpoint)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if customer_endpoint is not None:
            pulumi.set(__self__, "customer_endpoint", customer_endpoint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if psk_metadata is not None:
            pulumi.set(__self__, "psk_metadata", psk_metadata)
        if replay_protection is not None:
            pulumi.set(__self__, "replay_protection", replay_protection)

    @property
    @pulumi.getter(name="allowNullCipher")
    def allow_null_cipher(self) -> Optional[bool]:
        """
        When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        """
        return pulumi.get(self, "allow_null_cipher")

    @property
    @pulumi.getter(name="cloudflareEndpoint")
    def cloudflare_endpoint(self) -> Optional[str]:
        """
        The IP address assigned to the Cloudflare side of the IPsec tunnel.
        """
        return pulumi.get(self, "cloudflare_endpoint")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="customerEndpoint")
    def customer_endpoint(self) -> Optional[str]:
        """
        The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        """
        return pulumi.get(self, "customer_endpoint")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description forthe IPsec tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.MagicWanIpsecTunnelIpsecTunnelHealthCheck']:
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[str]:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pskMetadata")
    def psk_metadata(self) -> Optional['outputs.MagicWanIpsecTunnelIpsecTunnelPskMetadata']:
        """
        The PSK metadata that includes when the PSK was generated.
        """
        return pulumi.get(self, "psk_metadata")

    @property
    @pulumi.getter(name="replayProtection")
    def replay_protection(self) -> Optional[bool]:
        """
        If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        return pulumi.get(self, "replay_protection")


@pulumi.output_type
class MagicWanIpsecTunnelIpsecTunnelHealthCheck(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 rate: Optional[str] = None,
                 target: Optional['outputs.MagicWanIpsecTunnelIpsecTunnelHealthCheckTarget'] = None,
                 type: Optional[str] = None):
        """
        :param str direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param bool enabled: Determines whether to run healthchecks for a tunnel.
        :param str rate: How frequent the health check is run. The default value is `mid`.
        :param 'MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgs' target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param str type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rate(self) -> Optional[str]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.MagicWanIpsecTunnelIpsecTunnelHealthCheckTarget']:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MagicWanIpsecTunnelIpsecTunnelHealthCheckTarget(dict):
    def __init__(__self__, *,
                 effective: Optional[str] = None,
                 saved: Optional[str] = None):
        """
        :param str effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param str saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[str]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @property
    @pulumi.getter
    def saved(self) -> Optional[str]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")


@pulumi.output_type
class MagicWanIpsecTunnelIpsecTunnelPskMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastGeneratedOn":
            suggest = "last_generated_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanIpsecTunnelIpsecTunnelPskMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanIpsecTunnelIpsecTunnelPskMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanIpsecTunnelIpsecTunnelPskMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_generated_on: Optional[str] = None):
        """
        :param str last_generated_on: The date and time the tunnel was last modified.
        """
        if last_generated_on is not None:
            pulumi.set(__self__, "last_generated_on", last_generated_on)

    @property
    @pulumi.getter(name="lastGeneratedOn")
    def last_generated_on(self) -> Optional[str]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "last_generated_on")


@pulumi.output_type
class MagicWanIpsecTunnelModifiedIpsecTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowNullCipher":
            suggest = "allow_null_cipher"
        elif key == "cloudflareEndpoint":
            suggest = "cloudflare_endpoint"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "customerEndpoint":
            suggest = "customer_endpoint"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "interfaceAddress":
            suggest = "interface_address"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "pskMetadata":
            suggest = "psk_metadata"
        elif key == "replayProtection":
            suggest = "replay_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanIpsecTunnelModifiedIpsecTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanIpsecTunnelModifiedIpsecTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanIpsecTunnelModifiedIpsecTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_null_cipher: Optional[bool] = None,
                 cloudflare_endpoint: Optional[str] = None,
                 created_on: Optional[str] = None,
                 customer_endpoint: Optional[str] = None,
                 description: Optional[str] = None,
                 health_check: Optional['outputs.MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheck'] = None,
                 id: Optional[str] = None,
                 interface_address: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 name: Optional[str] = None,
                 psk_metadata: Optional['outputs.MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata'] = None,
                 replay_protection: Optional[bool] = None):
        """
        :param bool allow_null_cipher: When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        :param str cloudflare_endpoint: The IP address assigned to the Cloudflare side of the IPsec tunnel.
        :param str created_on: The date and time the tunnel was created.
        :param str customer_endpoint: The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        :param str description: An optional description forthe IPsec tunnel.
        :param str id: Tunnel identifier tag.
        :param str interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        :param str modified_on: The date and time the tunnel was last modified.
        :param str name: The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        :param 'MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgs' psk_metadata: The PSK metadata that includes when the PSK was generated.
        :param bool replay_protection: If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        if allow_null_cipher is not None:
            pulumi.set(__self__, "allow_null_cipher", allow_null_cipher)
        if cloudflare_endpoint is not None:
            pulumi.set(__self__, "cloudflare_endpoint", cloudflare_endpoint)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if customer_endpoint is not None:
            pulumi.set(__self__, "customer_endpoint", customer_endpoint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if psk_metadata is not None:
            pulumi.set(__self__, "psk_metadata", psk_metadata)
        if replay_protection is not None:
            pulumi.set(__self__, "replay_protection", replay_protection)

    @property
    @pulumi.getter(name="allowNullCipher")
    def allow_null_cipher(self) -> Optional[bool]:
        """
        When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        """
        return pulumi.get(self, "allow_null_cipher")

    @property
    @pulumi.getter(name="cloudflareEndpoint")
    def cloudflare_endpoint(self) -> Optional[str]:
        """
        The IP address assigned to the Cloudflare side of the IPsec tunnel.
        """
        return pulumi.get(self, "cloudflare_endpoint")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="customerEndpoint")
    def customer_endpoint(self) -> Optional[str]:
        """
        The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        """
        return pulumi.get(self, "customer_endpoint")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description forthe IPsec tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheck']:
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[str]:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pskMetadata")
    def psk_metadata(self) -> Optional['outputs.MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata']:
        """
        The PSK metadata that includes when the PSK was generated.
        """
        return pulumi.get(self, "psk_metadata")

    @property
    @pulumi.getter(name="replayProtection")
    def replay_protection(self) -> Optional[bool]:
        """
        If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        return pulumi.get(self, "replay_protection")


@pulumi.output_type
class MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheck(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 rate: Optional[str] = None,
                 target: Optional['outputs.MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTarget'] = None,
                 type: Optional[str] = None):
        """
        :param str direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param bool enabled: Determines whether to run healthchecks for a tunnel.
        :param str rate: How frequent the health check is run. The default value is `mid`.
        :param 'MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgs' target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param str type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rate(self) -> Optional[str]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTarget']:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTarget(dict):
    def __init__(__self__, *,
                 effective: Optional[str] = None,
                 saved: Optional[str] = None):
        """
        :param str effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param str saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[str]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @property
    @pulumi.getter
    def saved(self) -> Optional[str]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")


@pulumi.output_type
class MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastGeneratedOn":
            suggest = "last_generated_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_generated_on: Optional[str] = None):
        """
        :param str last_generated_on: The date and time the tunnel was last modified.
        """
        if last_generated_on is not None:
            pulumi.set(__self__, "last_generated_on", last_generated_on)

    @property
    @pulumi.getter(name="lastGeneratedOn")
    def last_generated_on(self) -> Optional[str]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "last_generated_on")


@pulumi.output_type
class MagicWanStaticRouteModifiedRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdOn":
            suggest = "created_on"
        elif key == "modifiedOn":
            suggest = "modified_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanStaticRouteModifiedRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanStaticRouteModifiedRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanStaticRouteModifiedRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_on: Optional[str] = None,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 nexthop: Optional[str] = None,
                 prefix: Optional[str] = None,
                 priority: Optional[int] = None,
                 scope: Optional['outputs.MagicWanStaticRouteModifiedRouteScope'] = None,
                 weight: Optional[int] = None):
        """
        :param str created_on: When the route was created.
        :param str description: An optional human provided description of the static route.
        :param str id: Identifier
        :param str modified_on: When the route was last modified.
        :param str nexthop: The next-hop IP Address for the static route.
        :param str prefix: IP Prefix in Classless Inter-Domain Routing format.
        :param int priority: Priority of the static route.
        :param 'MagicWanStaticRouteModifiedRouteScopeArgs' scope: Used only for ECMP routes.
        :param int weight: Optional weight of the ECMP scope - if provided.
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        When the route was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional human provided description of the static route.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        When the route was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def nexthop(self) -> Optional[str]:
        """
        The next-hop IP Address for the static route.
        """
        return pulumi.get(self, "nexthop")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        IP Prefix in Classless Inter-Domain Routing format.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the static route.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.MagicWanStaticRouteModifiedRouteScope']:
        """
        Used only for ECMP routes.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Optional weight of the ECMP scope - if provided.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class MagicWanStaticRouteModifiedRouteScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coloNames":
            suggest = "colo_names"
        elif key == "coloRegions":
            suggest = "colo_regions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanStaticRouteModifiedRouteScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanStaticRouteModifiedRouteScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanStaticRouteModifiedRouteScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 colo_names: Optional[Sequence[str]] = None,
                 colo_regions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] colo_names: List of colo names for the ECMP scope.
        :param Sequence[str] colo_regions: List of colo regions for the ECMP scope.
        """
        if colo_names is not None:
            pulumi.set(__self__, "colo_names", colo_names)
        if colo_regions is not None:
            pulumi.set(__self__, "colo_regions", colo_regions)

    @property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Optional[Sequence[str]]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Optional[Sequence[str]]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")


@pulumi.output_type
class MagicWanStaticRouteRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdOn":
            suggest = "created_on"
        elif key == "modifiedOn":
            suggest = "modified_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanStaticRouteRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanStaticRouteRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanStaticRouteRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_on: Optional[str] = None,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 nexthop: Optional[str] = None,
                 prefix: Optional[str] = None,
                 priority: Optional[int] = None,
                 scope: Optional['outputs.MagicWanStaticRouteRouteScope'] = None,
                 weight: Optional[int] = None):
        """
        :param str created_on: When the route was created.
        :param str description: An optional human provided description of the static route.
        :param str id: Identifier
        :param str modified_on: When the route was last modified.
        :param str nexthop: The next-hop IP Address for the static route.
        :param str prefix: IP Prefix in Classless Inter-Domain Routing format.
        :param int priority: Priority of the static route.
        :param 'MagicWanStaticRouteRouteScopeArgs' scope: Used only for ECMP routes.
        :param int weight: Optional weight of the ECMP scope - if provided.
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        When the route was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional human provided description of the static route.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        When the route was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def nexthop(self) -> Optional[str]:
        """
        The next-hop IP Address for the static route.
        """
        return pulumi.get(self, "nexthop")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        IP Prefix in Classless Inter-Domain Routing format.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the static route.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.MagicWanStaticRouteRouteScope']:
        """
        Used only for ECMP routes.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Optional weight of the ECMP scope - if provided.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class MagicWanStaticRouteRouteScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coloNames":
            suggest = "colo_names"
        elif key == "coloRegions":
            suggest = "colo_regions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanStaticRouteRouteScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanStaticRouteRouteScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanStaticRouteRouteScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 colo_names: Optional[Sequence[str]] = None,
                 colo_regions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] colo_names: List of colo names for the ECMP scope.
        :param Sequence[str] colo_regions: List of colo regions for the ECMP scope.
        """
        if colo_names is not None:
            pulumi.set(__self__, "colo_names", colo_names)
        if colo_regions is not None:
            pulumi.set(__self__, "colo_regions", colo_regions)

    @property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Optional[Sequence[str]]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Optional[Sequence[str]]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")


@pulumi.output_type
class MagicWanStaticRouteScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coloNames":
            suggest = "colo_names"
        elif key == "coloRegions":
            suggest = "colo_regions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MagicWanStaticRouteScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MagicWanStaticRouteScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MagicWanStaticRouteScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 colo_names: Optional[Sequence[str]] = None,
                 colo_regions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] colo_names: List of colo names for the ECMP scope.
        :param Sequence[str] colo_regions: List of colo regions for the ECMP scope.
        """
        if colo_names is not None:
            pulumi.set(__self__, "colo_names", colo_names)
        if colo_regions is not None:
            pulumi.set(__self__, "colo_regions", colo_regions)

    @property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Optional[Sequence[str]]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Optional[Sequence[str]]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")


@pulumi.output_type
class ManagedTransformsManagedRequestHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conflictsWiths":
            suggest = "conflicts_withs"
        elif key == "hasConflict":
            suggest = "has_conflict"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedTransformsManagedRequestHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedTransformsManagedRequestHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedTransformsManagedRequestHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 id: str,
                 conflicts_withs: Optional[Sequence[str]] = None,
                 has_conflict: Optional[bool] = None):
        """
        :param bool enabled: Whether the Managed Transform is enabled.
        :param str id: The human-readable identifier of the Managed Transform.
        :param Sequence[str] conflicts_withs: The Managed Transforms that this Managed Transform conflicts with.
        :param bool has_conflict: Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if conflicts_withs is not None:
            pulumi.set(__self__, "conflicts_withs", conflicts_withs)
        if has_conflict is not None:
            pulumi.set(__self__, "has_conflict", has_conflict)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="conflictsWiths")
    def conflicts_withs(self) -> Optional[Sequence[str]]:
        """
        The Managed Transforms that this Managed Transform conflicts with.
        """
        return pulumi.get(self, "conflicts_withs")

    @property
    @pulumi.getter(name="hasConflict")
    def has_conflict(self) -> Optional[bool]:
        """
        Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        return pulumi.get(self, "has_conflict")


@pulumi.output_type
class ManagedTransformsManagedResponseHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conflictsWiths":
            suggest = "conflicts_withs"
        elif key == "hasConflict":
            suggest = "has_conflict"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedTransformsManagedResponseHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedTransformsManagedResponseHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedTransformsManagedResponseHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 id: str,
                 conflicts_withs: Optional[Sequence[str]] = None,
                 has_conflict: Optional[bool] = None):
        """
        :param bool enabled: Whether the Managed Transform is enabled.
        :param str id: The human-readable identifier of the Managed Transform.
        :param Sequence[str] conflicts_withs: The Managed Transforms that this Managed Transform conflicts with.
        :param bool has_conflict: Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if conflicts_withs is not None:
            pulumi.set(__self__, "conflicts_withs", conflicts_withs)
        if has_conflict is not None:
            pulumi.set(__self__, "has_conflict", has_conflict)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="conflictsWiths")
    def conflicts_withs(self) -> Optional[Sequence[str]]:
        """
        The Managed Transforms that this Managed Transform conflicts with.
        """
        return pulumi.get(self, "conflicts_withs")

    @property
    @pulumi.getter(name="hasConflict")
    def has_conflict(self) -> Optional[bool]:
        """
        Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        return pulumi.get(self, "has_conflict")


@pulumi.output_type
class NotificationPolicyFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedAsns":
            suggest = "affected_asns"
        elif key == "affectedComponents":
            suggest = "affected_components"
        elif key == "affectedLocations":
            suggest = "affected_locations"
        elif key == "airportCodes":
            suggest = "airport_codes"
        elif key == "alertTriggerPreferences":
            suggest = "alert_trigger_preferences"
        elif key == "alertTriggerPreferencesValues":
            suggest = "alert_trigger_preferences_values"
        elif key == "eventSources":
            suggest = "event_sources"
        elif key == "eventTypes":
            suggest = "event_types"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "healthCheckIds":
            suggest = "health_check_ids"
        elif key == "incidentImpacts":
            suggest = "incident_impacts"
        elif key == "inputIds":
            suggest = "input_ids"
        elif key == "insightClasses":
            suggest = "insight_classes"
        elif key == "logoTags":
            suggest = "logo_tags"
        elif key == "megabitsPerSeconds":
            suggest = "megabits_per_seconds"
        elif key == "newHealths":
            suggest = "new_healths"
        elif key == "newStatuses":
            suggest = "new_statuses"
        elif key == "packetsPerSeconds":
            suggest = "packets_per_seconds"
        elif key == "poolIds":
            suggest = "pool_ids"
        elif key == "popNames":
            suggest = "pop_names"
        elif key == "projectIds":
            suggest = "project_ids"
        elif key == "queryTags":
            suggest = "query_tags"
        elif key == "requestsPerSeconds":
            suggest = "requests_per_seconds"
        elif key == "targetHostnames":
            suggest = "target_hostnames"
        elif key == "targetIps":
            suggest = "target_ips"
        elif key == "targetZoneNames":
            suggest = "target_zone_names"
        elif key == "trafficExclusions":
            suggest = "traffic_exclusions"
        elif key == "tunnelIds":
            suggest = "tunnel_ids"
        elif key == "tunnelNames":
            suggest = "tunnel_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None,
                 affected_asns: Optional[Sequence[str]] = None,
                 affected_components: Optional[Sequence[str]] = None,
                 affected_locations: Optional[Sequence[str]] = None,
                 airport_codes: Optional[Sequence[str]] = None,
                 alert_trigger_preferences: Optional[Sequence[str]] = None,
                 alert_trigger_preferences_values: Optional[Sequence[str]] = None,
                 enableds: Optional[Sequence[str]] = None,
                 environments: Optional[Sequence[str]] = None,
                 event_sources: Optional[Sequence[str]] = None,
                 event_types: Optional[Sequence[str]] = None,
                 events: Optional[Sequence[str]] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 health_check_ids: Optional[Sequence[str]] = None,
                 incident_impacts: Optional[Sequence[str]] = None,
                 input_ids: Optional[Sequence[str]] = None,
                 insight_classes: Optional[Sequence[str]] = None,
                 limits: Optional[Sequence[str]] = None,
                 logo_tags: Optional[Sequence[str]] = None,
                 megabits_per_seconds: Optional[Sequence[str]] = None,
                 new_healths: Optional[Sequence[str]] = None,
                 new_statuses: Optional[Sequence[str]] = None,
                 packets_per_seconds: Optional[Sequence[str]] = None,
                 pool_ids: Optional[Sequence[str]] = None,
                 pop_names: Optional[Sequence[str]] = None,
                 products: Optional[Sequence[str]] = None,
                 project_ids: Optional[Sequence[str]] = None,
                 protocols: Optional[Sequence[str]] = None,
                 query_tags: Optional[Sequence[str]] = None,
                 requests_per_seconds: Optional[Sequence[str]] = None,
                 selectors: Optional[Sequence[str]] = None,
                 services: Optional[Sequence[str]] = None,
                 slos: Optional[Sequence[str]] = None,
                 statuses: Optional[Sequence[str]] = None,
                 target_hostnames: Optional[Sequence[str]] = None,
                 target_ips: Optional[Sequence[str]] = None,
                 target_zone_names: Optional[Sequence[str]] = None,
                 traffic_exclusions: Optional[Sequence[str]] = None,
                 tunnel_ids: Optional[Sequence[str]] = None,
                 tunnel_names: Optional[Sequence[str]] = None,
                 wheres: Optional[Sequence[str]] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] actions: Usage depends on specific alert type
        :param Sequence[str] affected_asns: Used for configuring radar_notification
        :param Sequence[str] affected_components: Used for configuring incident_alert
        :param Sequence[str] affected_locations: Used for configuring radar_notification
        :param Sequence[str] airport_codes: Used for configuring maintenance*event*notification
        :param Sequence[str] alert_trigger_preferences: Usage depends on specific alert type
        :param Sequence[str] alert_trigger_preferences_values: Usage depends on specific alert type
        :param Sequence[str] enableds: Used for configuring load*balancing*pool*enablement*alert
        :param Sequence[str] environments: Used for configuring pages*event*alert
        :param Sequence[str] event_sources: Used for configuring load*balancing*health_alert
        :param Sequence[str] event_types: Usage depends on specific alert type
        :param Sequence[str] events: Used for configuring pages*event*alert
        :param Sequence[str] group_bies: Usage depends on specific alert type
        :param Sequence[str] health_check_ids: Used for configuring health*check*status_notification
        :param Sequence[str] incident_impacts: Used for configuring incident_alert
        :param Sequence[str] input_ids: Used for configuring stream*live*notifications
        :param Sequence[str] insight_classes: Used for configuring security*insights*alert
        :param Sequence[str] limits: Used for configuring billing*usage*alert
        :param Sequence[str] logo_tags: Used for configuring logo*match*alert
        :param Sequence[str] megabits_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] new_healths: Used for configuring load*balancing*health_alert
        :param Sequence[str] new_statuses: Used for configuring tunnel*health*event
        :param Sequence[str] packets_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] pool_ids: Usage depends on specific alert type
        :param Sequence[str] pop_names: Usage depends on specific alert type
        :param Sequence[str] products: Used for configuring billing*usage*alert
        :param Sequence[str] project_ids: Used for configuring pages*event*alert
        :param Sequence[str] protocols: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] query_tags: Usage depends on specific alert type
        :param Sequence[str] requests_per_seconds: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] selectors: Usage depends on specific alert type
        :param Sequence[str] services: Used for configuring clickhouse*alert*fw*ent*anomaly
        :param Sequence[str] slos: Usage depends on specific alert type
        :param Sequence[str] statuses: Used for configuring health*check*status_notification
        :param Sequence[str] target_hostnames: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] target_ips: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] target_zone_names: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] traffic_exclusions: Used for configuring traffic*anomalies*alert
        :param Sequence[str] tunnel_ids: Used for configuring tunnel*health*event
        :param Sequence[str] tunnel_names: Usage depends on specific alert type
        :param Sequence[str] wheres: Usage depends on specific alert type
        :param Sequence[str] zones: Usage depends on specific alert type
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if affected_asns is not None:
            pulumi.set(__self__, "affected_asns", affected_asns)
        if affected_components is not None:
            pulumi.set(__self__, "affected_components", affected_components)
        if affected_locations is not None:
            pulumi.set(__self__, "affected_locations", affected_locations)
        if airport_codes is not None:
            pulumi.set(__self__, "airport_codes", airport_codes)
        if alert_trigger_preferences is not None:
            pulumi.set(__self__, "alert_trigger_preferences", alert_trigger_preferences)
        if alert_trigger_preferences_values is not None:
            pulumi.set(__self__, "alert_trigger_preferences_values", alert_trigger_preferences_values)
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if event_sources is not None:
            pulumi.set(__self__, "event_sources", event_sources)
        if event_types is not None:
            pulumi.set(__self__, "event_types", event_types)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if health_check_ids is not None:
            pulumi.set(__self__, "health_check_ids", health_check_ids)
        if incident_impacts is not None:
            pulumi.set(__self__, "incident_impacts", incident_impacts)
        if input_ids is not None:
            pulumi.set(__self__, "input_ids", input_ids)
        if insight_classes is not None:
            pulumi.set(__self__, "insight_classes", insight_classes)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if logo_tags is not None:
            pulumi.set(__self__, "logo_tags", logo_tags)
        if megabits_per_seconds is not None:
            pulumi.set(__self__, "megabits_per_seconds", megabits_per_seconds)
        if new_healths is not None:
            pulumi.set(__self__, "new_healths", new_healths)
        if new_statuses is not None:
            pulumi.set(__self__, "new_statuses", new_statuses)
        if packets_per_seconds is not None:
            pulumi.set(__self__, "packets_per_seconds", packets_per_seconds)
        if pool_ids is not None:
            pulumi.set(__self__, "pool_ids", pool_ids)
        if pop_names is not None:
            pulumi.set(__self__, "pop_names", pop_names)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if query_tags is not None:
            pulumi.set(__self__, "query_tags", query_tags)
        if requests_per_seconds is not None:
            pulumi.set(__self__, "requests_per_seconds", requests_per_seconds)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if slos is not None:
            pulumi.set(__self__, "slos", slos)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if target_hostnames is not None:
            pulumi.set(__self__, "target_hostnames", target_hostnames)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if target_zone_names is not None:
            pulumi.set(__self__, "target_zone_names", target_zone_names)
        if traffic_exclusions is not None:
            pulumi.set(__self__, "traffic_exclusions", traffic_exclusions)
        if tunnel_ids is not None:
            pulumi.set(__self__, "tunnel_ids", tunnel_ids)
        if tunnel_names is not None:
            pulumi.set(__self__, "tunnel_names", tunnel_names)
        if wheres is not None:
            pulumi.set(__self__, "wheres", wheres)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="affectedAsns")
    def affected_asns(self) -> Optional[Sequence[str]]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_asns")

    @property
    @pulumi.getter(name="affectedComponents")
    def affected_components(self) -> Optional[Sequence[str]]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "affected_components")

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> Optional[Sequence[str]]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="airportCodes")
    def airport_codes(self) -> Optional[Sequence[str]]:
        """
        Used for configuring maintenance*event*notification
        """
        return pulumi.get(self, "airport_codes")

    @property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @property
    @pulumi.getter(name="alertTriggerPreferencesValues")
    def alert_trigger_preferences_values(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences_values")

    @property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[str]]:
        """
        Used for configuring load*balancing*pool*enablement*alert
        """
        return pulumi.get(self, "enableds")

    @property
    @pulumi.getter
    def environments(self) -> Optional[Sequence[str]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Optional[Sequence[str]]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "event_sources")

    @property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "event_types")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence[str]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Optional[Sequence[str]]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "health_check_ids")

    @property
    @pulumi.getter(name="incidentImpacts")
    def incident_impacts(self) -> Optional[Sequence[str]]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "incident_impacts")

    @property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Optional[Sequence[str]]:
        """
        Used for configuring stream*live*notifications
        """
        return pulumi.get(self, "input_ids")

    @property
    @pulumi.getter(name="insightClasses")
    def insight_classes(self) -> Optional[Sequence[str]]:
        """
        Used for configuring security*insights*alert
        """
        return pulumi.get(self, "insight_classes")

    @property
    @pulumi.getter
    def limits(self) -> Optional[Sequence[str]]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="logoTags")
    def logo_tags(self) -> Optional[Sequence[str]]:
        """
        Used for configuring logo*match*alert
        """
        return pulumi.get(self, "logo_tags")

    @property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Optional[Sequence[str]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "megabits_per_seconds")

    @property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Optional[Sequence[str]]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "new_healths")

    @property
    @pulumi.getter(name="newStatuses")
    def new_statuses(self) -> Optional[Sequence[str]]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "new_statuses")

    @property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Optional[Sequence[str]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "packets_per_seconds")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter(name="popNames")
    def pop_names(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pop_names")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[str]]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[Sequence[str]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "project_ids")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[str]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="queryTags")
    def query_tags(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "query_tags")

    @property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Optional[Sequence[str]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "requests_per_seconds")

    @property
    @pulumi.getter
    def selectors(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "selectors")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence[str]]:
        """
        Used for configuring clickhouse*alert*fw*ent*anomaly
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def slos(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "slos")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[str]]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Optional[Sequence[str]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_hostnames")

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[Sequence[str]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "target_ips")

    @property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Optional[Sequence[str]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_zone_names")

    @property
    @pulumi.getter(name="trafficExclusions")
    def traffic_exclusions(self) -> Optional[Sequence[str]]:
        """
        Used for configuring traffic*anomalies*alert
        """
        return pulumi.get(self, "traffic_exclusions")

    @property
    @pulumi.getter(name="tunnelIds")
    def tunnel_ids(self) -> Optional[Sequence[str]]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "tunnel_ids")

    @property
    @pulumi.getter(name="tunnelNames")
    def tunnel_names(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "tunnel_names")

    @property
    @pulumi.getter
    def wheres(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "wheres")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class NotificationPolicyMechanisms(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence['outputs.NotificationPolicyMechanismsEmail']] = None,
                 pagerduties: Optional[Sequence['outputs.NotificationPolicyMechanismsPagerduty']] = None,
                 webhooks: Optional[Sequence['outputs.NotificationPolicyMechanismsWebhook']] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if pagerduties is not None:
            pulumi.set(__self__, "pagerduties", pagerduties)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence['outputs.NotificationPolicyMechanismsEmail']]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def pagerduties(self) -> Optional[Sequence['outputs.NotificationPolicyMechanismsPagerduty']]:
        return pulumi.get(self, "pagerduties")

    @property
    @pulumi.getter
    def webhooks(self) -> Optional[Sequence['outputs.NotificationPolicyMechanismsWebhook']]:
        return pulumi.get(self, "webhooks")


@pulumi.output_type
class NotificationPolicyMechanismsEmail(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: The email address
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The email address
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NotificationPolicyMechanismsPagerduty(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: UUID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NotificationPolicyMechanismsWebhook(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: UUID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ObservatoryScheduledTestSchedule(dict):
    def __init__(__self__, *,
                 frequency: Optional[str] = None,
                 region: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str frequency: The frequency of the test.
        :param str region: A test region.
        :param str url: A URL.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[str]:
        """
        The frequency of the test.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        A test region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        A URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ObservatoryScheduledTestTest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desktopReport":
            suggest = "desktop_report"
        elif key == "mobileReport":
            suggest = "mobile_report"
        elif key == "scheduleFrequency":
            suggest = "schedule_frequency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObservatoryScheduledTestTest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObservatoryScheduledTestTest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObservatoryScheduledTestTest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date: Optional[str] = None,
                 desktop_report: Optional['outputs.ObservatoryScheduledTestTestDesktopReport'] = None,
                 id: Optional[str] = None,
                 mobile_report: Optional['outputs.ObservatoryScheduledTestTestMobileReport'] = None,
                 region: Optional['outputs.ObservatoryScheduledTestTestRegion'] = None,
                 schedule_frequency: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param 'ObservatoryScheduledTestTestDesktopReportArgs' desktop_report: The Lighthouse report.
        :param str id: UUID
        :param 'ObservatoryScheduledTestTestMobileReportArgs' mobile_report: The Lighthouse report.
        :param 'ObservatoryScheduledTestTestRegionArgs' region: A test region with a label.
        :param str schedule_frequency: The frequency of the test.
        :param str url: A URL.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if desktop_report is not None:
            pulumi.set(__self__, "desktop_report", desktop_report)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mobile_report is not None:
            pulumi.set(__self__, "mobile_report", mobile_report)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if schedule_frequency is not None:
            pulumi.set(__self__, "schedule_frequency", schedule_frequency)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="desktopReport")
    def desktop_report(self) -> Optional['outputs.ObservatoryScheduledTestTestDesktopReport']:
        """
        The Lighthouse report.
        """
        return pulumi.get(self, "desktop_report")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="mobileReport")
    def mobile_report(self) -> Optional['outputs.ObservatoryScheduledTestTestMobileReport']:
        """
        The Lighthouse report.
        """
        return pulumi.get(self, "mobile_report")

    @property
    @pulumi.getter
    def region(self) -> Optional['outputs.ObservatoryScheduledTestTestRegion']:
        """
        A test region with a label.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> Optional[str]:
        """
        The frequency of the test.
        """
        return pulumi.get(self, "schedule_frequency")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        A URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ObservatoryScheduledTestTestDesktopReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"
        elif key == "jsonReportUrl":
            suggest = "json_report_url"
        elif key == "performanceScore":
            suggest = "performance_score"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObservatoryScheduledTestTestDesktopReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObservatoryScheduledTestTestDesktopReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObservatoryScheduledTestTestDesktopReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cls: Optional[float] = None,
                 device_type: Optional[str] = None,
                 error: Optional['outputs.ObservatoryScheduledTestTestDesktopReportError'] = None,
                 fcp: Optional[float] = None,
                 json_report_url: Optional[str] = None,
                 lcp: Optional[float] = None,
                 performance_score: Optional[float] = None,
                 si: Optional[float] = None,
                 state: Optional[str] = None,
                 tbt: Optional[float] = None,
                 ttfb: Optional[float] = None,
                 tti: Optional[float] = None):
        """
        :param float cls: Cumulative Layout Shift.
        :param str device_type: The type of device.
        :param float fcp: First Contentful Paint.
        :param str json_report_url: The URL to the full Lighthouse JSON report.
        :param float lcp: Largest Contentful Paint.
        :param float performance_score: The Lighthouse performance score.
        :param float si: Speed Index.
        :param str state: The state of the Lighthouse report.
        :param float tbt: Total Blocking Time.
        :param float ttfb: Time To First Byte.
        :param float tti: Time To Interactive.
        """
        if cls is not None:
            pulumi.set(__self__, "cls", cls)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if fcp is not None:
            pulumi.set(__self__, "fcp", fcp)
        if json_report_url is not None:
            pulumi.set(__self__, "json_report_url", json_report_url)
        if lcp is not None:
            pulumi.set(__self__, "lcp", lcp)
        if performance_score is not None:
            pulumi.set(__self__, "performance_score", performance_score)
        if si is not None:
            pulumi.set(__self__, "si", si)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tbt is not None:
            pulumi.set(__self__, "tbt", tbt)
        if ttfb is not None:
            pulumi.set(__self__, "ttfb", ttfb)
        if tti is not None:
            pulumi.set(__self__, "tti", tti)

    @property
    @pulumi.getter
    def cls(self) -> Optional[float]:
        """
        Cumulative Layout Shift.
        """
        return pulumi.get(self, "cls")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[str]:
        """
        The type of device.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ObservatoryScheduledTestTestDesktopReportError']:
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def fcp(self) -> Optional[float]:
        """
        First Contentful Paint.
        """
        return pulumi.get(self, "fcp")

    @property
    @pulumi.getter(name="jsonReportUrl")
    def json_report_url(self) -> Optional[str]:
        """
        The URL to the full Lighthouse JSON report.
        """
        return pulumi.get(self, "json_report_url")

    @property
    @pulumi.getter
    def lcp(self) -> Optional[float]:
        """
        Largest Contentful Paint.
        """
        return pulumi.get(self, "lcp")

    @property
    @pulumi.getter(name="performanceScore")
    def performance_score(self) -> Optional[float]:
        """
        The Lighthouse performance score.
        """
        return pulumi.get(self, "performance_score")

    @property
    @pulumi.getter
    def si(self) -> Optional[float]:
        """
        Speed Index.
        """
        return pulumi.get(self, "si")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The state of the Lighthouse report.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tbt(self) -> Optional[float]:
        """
        Total Blocking Time.
        """
        return pulumi.get(self, "tbt")

    @property
    @pulumi.getter
    def ttfb(self) -> Optional[float]:
        """
        Time To First Byte.
        """
        return pulumi.get(self, "ttfb")

    @property
    @pulumi.getter
    def tti(self) -> Optional[float]:
        """
        Time To Interactive.
        """
        return pulumi.get(self, "tti")


@pulumi.output_type
class ObservatoryScheduledTestTestDesktopReportError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "finalDisplayedUrl":
            suggest = "final_displayed_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObservatoryScheduledTestTestDesktopReportError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObservatoryScheduledTestTestDesktopReportError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObservatoryScheduledTestTestDesktopReportError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[str] = None,
                 detail: Optional[str] = None,
                 final_displayed_url: Optional[str] = None):
        """
        :param str code: The error code of the Lighthouse result.
        :param str detail: Detailed error message.
        :param str final_displayed_url: The final URL displayed to the user.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if final_displayed_url is not None:
            pulumi.set(__self__, "final_displayed_url", final_displayed_url)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The error code of the Lighthouse result.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def detail(self) -> Optional[str]:
        """
        Detailed error message.
        """
        return pulumi.get(self, "detail")

    @property
    @pulumi.getter(name="finalDisplayedUrl")
    def final_displayed_url(self) -> Optional[str]:
        """
        The final URL displayed to the user.
        """
        return pulumi.get(self, "final_displayed_url")


@pulumi.output_type
class ObservatoryScheduledTestTestMobileReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"
        elif key == "jsonReportUrl":
            suggest = "json_report_url"
        elif key == "performanceScore":
            suggest = "performance_score"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObservatoryScheduledTestTestMobileReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObservatoryScheduledTestTestMobileReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObservatoryScheduledTestTestMobileReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cls: Optional[float] = None,
                 device_type: Optional[str] = None,
                 error: Optional['outputs.ObservatoryScheduledTestTestMobileReportError'] = None,
                 fcp: Optional[float] = None,
                 json_report_url: Optional[str] = None,
                 lcp: Optional[float] = None,
                 performance_score: Optional[float] = None,
                 si: Optional[float] = None,
                 state: Optional[str] = None,
                 tbt: Optional[float] = None,
                 ttfb: Optional[float] = None,
                 tti: Optional[float] = None):
        """
        :param float cls: Cumulative Layout Shift.
        :param str device_type: The type of device.
        :param float fcp: First Contentful Paint.
        :param str json_report_url: The URL to the full Lighthouse JSON report.
        :param float lcp: Largest Contentful Paint.
        :param float performance_score: The Lighthouse performance score.
        :param float si: Speed Index.
        :param str state: The state of the Lighthouse report.
        :param float tbt: Total Blocking Time.
        :param float ttfb: Time To First Byte.
        :param float tti: Time To Interactive.
        """
        if cls is not None:
            pulumi.set(__self__, "cls", cls)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if fcp is not None:
            pulumi.set(__self__, "fcp", fcp)
        if json_report_url is not None:
            pulumi.set(__self__, "json_report_url", json_report_url)
        if lcp is not None:
            pulumi.set(__self__, "lcp", lcp)
        if performance_score is not None:
            pulumi.set(__self__, "performance_score", performance_score)
        if si is not None:
            pulumi.set(__self__, "si", si)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tbt is not None:
            pulumi.set(__self__, "tbt", tbt)
        if ttfb is not None:
            pulumi.set(__self__, "ttfb", ttfb)
        if tti is not None:
            pulumi.set(__self__, "tti", tti)

    @property
    @pulumi.getter
    def cls(self) -> Optional[float]:
        """
        Cumulative Layout Shift.
        """
        return pulumi.get(self, "cls")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[str]:
        """
        The type of device.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ObservatoryScheduledTestTestMobileReportError']:
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def fcp(self) -> Optional[float]:
        """
        First Contentful Paint.
        """
        return pulumi.get(self, "fcp")

    @property
    @pulumi.getter(name="jsonReportUrl")
    def json_report_url(self) -> Optional[str]:
        """
        The URL to the full Lighthouse JSON report.
        """
        return pulumi.get(self, "json_report_url")

    @property
    @pulumi.getter
    def lcp(self) -> Optional[float]:
        """
        Largest Contentful Paint.
        """
        return pulumi.get(self, "lcp")

    @property
    @pulumi.getter(name="performanceScore")
    def performance_score(self) -> Optional[float]:
        """
        The Lighthouse performance score.
        """
        return pulumi.get(self, "performance_score")

    @property
    @pulumi.getter
    def si(self) -> Optional[float]:
        """
        Speed Index.
        """
        return pulumi.get(self, "si")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The state of the Lighthouse report.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tbt(self) -> Optional[float]:
        """
        Total Blocking Time.
        """
        return pulumi.get(self, "tbt")

    @property
    @pulumi.getter
    def ttfb(self) -> Optional[float]:
        """
        Time To First Byte.
        """
        return pulumi.get(self, "ttfb")

    @property
    @pulumi.getter
    def tti(self) -> Optional[float]:
        """
        Time To Interactive.
        """
        return pulumi.get(self, "tti")


@pulumi.output_type
class ObservatoryScheduledTestTestMobileReportError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "finalDisplayedUrl":
            suggest = "final_displayed_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObservatoryScheduledTestTestMobileReportError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObservatoryScheduledTestTestMobileReportError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObservatoryScheduledTestTestMobileReportError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[str] = None,
                 detail: Optional[str] = None,
                 final_displayed_url: Optional[str] = None):
        """
        :param str code: The error code of the Lighthouse result.
        :param str detail: Detailed error message.
        :param str final_displayed_url: The final URL displayed to the user.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if final_displayed_url is not None:
            pulumi.set(__self__, "final_displayed_url", final_displayed_url)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The error code of the Lighthouse result.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def detail(self) -> Optional[str]:
        """
        Detailed error message.
        """
        return pulumi.get(self, "detail")

    @property
    @pulumi.getter(name="finalDisplayedUrl")
    def final_displayed_url(self) -> Optional[str]:
        """
        The final URL displayed to the user.
        """
        return pulumi.get(self, "final_displayed_url")


@pulumi.output_type
class ObservatoryScheduledTestTestRegion(dict):
    def __init__(__self__, *,
                 label: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: A test region.
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        A test region.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PageRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "bypassCacheOnCookie":
            suggest = "bypass_cache_on_cookie"
        elif key == "cacheByDeviceType":
            suggest = "cache_by_device_type"
        elif key == "cacheDeceptionArmor":
            suggest = "cache_deception_armor"
        elif key == "cacheKeyFields":
            suggest = "cache_key_fields"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "cacheOnCookie":
            suggest = "cache_on_cookie"
        elif key == "cacheTtlByStatus":
            suggest = "cache_ttl_by_status"
        elif key == "disableApps":
            suggest = "disable_apps"
        elif key == "disablePerformance":
            suggest = "disable_performance"
        elif key == "disableSecurity":
            suggest = "disable_security"
        elif key == "disableZaraz":
            suggest = "disable_zaraz"
        elif key == "edgeCacheTtl":
            suggest = "edge_cache_ttl"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "explicitCacheControl":
            suggest = "explicit_cache_control"
        elif key == "forwardingUrl":
            suggest = "forwarding_url"
        elif key == "hostHeaderOverride":
            suggest = "host_header_override"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "resolveOverride":
            suggest = "resolve_override"
        elif key == "respectStrongEtag":
            suggest = "respect_strong_etag"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_use_https: Optional[bool] = None,
                 automatic_https_rewrites: Optional[str] = None,
                 browser_cache_ttl: Optional[int] = None,
                 browser_check: Optional[str] = None,
                 bypass_cache_on_cookie: Optional[str] = None,
                 cache_by_device_type: Optional[str] = None,
                 cache_deception_armor: Optional[str] = None,
                 cache_key_fields: Optional['outputs.PageRuleActionsCacheKeyFields'] = None,
                 cache_level: Optional[str] = None,
                 cache_on_cookie: Optional[str] = None,
                 cache_ttl_by_status: Optional[Any] = None,
                 disable_apps: Optional[bool] = None,
                 disable_performance: Optional[bool] = None,
                 disable_security: Optional[bool] = None,
                 disable_zaraz: Optional[bool] = None,
                 edge_cache_ttl: Optional[int] = None,
                 email_obfuscation: Optional[str] = None,
                 explicit_cache_control: Optional[str] = None,
                 forwarding_url: Optional['outputs.PageRuleActionsForwardingUrl'] = None,
                 host_header_override: Optional[str] = None,
                 ip_geolocation: Optional[str] = None,
                 mirage: Optional[str] = None,
                 opportunistic_encryption: Optional[str] = None,
                 origin_error_page_pass_thru: Optional[str] = None,
                 polish: Optional[str] = None,
                 resolve_override: Optional[str] = None,
                 respect_strong_etag: Optional[str] = None,
                 response_buffering: Optional[str] = None,
                 rocket_loader: Optional[str] = None,
                 security_level: Optional[str] = None,
                 sort_query_string_for_cache: Optional[str] = None,
                 ssl: Optional[str] = None,
                 true_client_ip_header: Optional[str] = None,
                 waf: Optional[str] = None):
        """
        :param bool always_use_https: Boolean of whether this action is enabled. Default: false.
        :param str automatic_https_rewrites: Whether this action is `"on"` or `"off"`.
        :param int browser_cache_ttl: The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        :param str browser_check: Whether this action is `"on"` or `"off"`.
        :param str bypass_cache_on_cookie: String value of cookie name to conditionally bypass cache the page.
        :param str cache_by_device_type: Whether this action is `"on"` or `"off"`.
        :param str cache_deception_armor: Whether this action is `"on"` or `"off"`.
        :param 'PageRuleActionsCacheKeyFieldsArgs' cache_key_fields: Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        :param str cache_level: Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        :param str cache_on_cookie: String value of cookie name to conditionally cache the page.
        :param Any cache_ttl_by_status: Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        :param bool disable_apps: Boolean of whether this action is enabled. Default: false.
        :param bool disable_performance: Boolean of whether this action is enabled. Default: false.
        :param bool disable_security: Boolean of whether this action is enabled. Default: false.
        :param bool disable_zaraz: Boolean of whether this action is enabled. Default: false.
        :param int edge_cache_ttl: The Time To Live for the edge cache.
        :param str email_obfuscation: Whether this action is `"on"` or `"off"`.
        :param str explicit_cache_control: Whether origin Cache-Control action is `"on"` or `"off"`.
        :param 'PageRuleActionsForwardingUrlArgs' forwarding_url: The URL to forward to, and with what status. See below.
        :param str host_header_override: Value of the Host header to send.
        :param str ip_geolocation: Whether this action is `"on"` or `"off"`.
        :param str mirage: Whether this action is `"on"` or `"off"`.
        :param str opportunistic_encryption: Whether this action is `"on"` or `"off"`.
        :param str origin_error_page_pass_thru: Whether this action is `"on"` or `"off"`.
        :param str polish: Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        :param str resolve_override: Overridden origin server name.
        :param str respect_strong_etag: Whether this action is `"on"` or `"off"`.
        :param str response_buffering: Whether this action is `"on"` or `"off"`.
        :param str rocket_loader: Whether to set the rocket loader to `"on"`, `"off"`.
        :param str security_level: Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        :param str sort_query_string_for_cache: Whether this action is `"on"` or `"off"`.
        :param str ssl: Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        :param str true_client_ip_header: Whether this action is `"on"` or `"off"`.
        :param str waf: Whether this action is `"on"` or `"off"`.
        """
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if bypass_cache_on_cookie is not None:
            pulumi.set(__self__, "bypass_cache_on_cookie", bypass_cache_on_cookie)
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if cache_key_fields is not None:
            pulumi.set(__self__, "cache_key_fields", cache_key_fields)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if cache_on_cookie is not None:
            pulumi.set(__self__, "cache_on_cookie", cache_on_cookie)
        if cache_ttl_by_status is not None:
            pulumi.set(__self__, "cache_ttl_by_status", cache_ttl_by_status)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_performance is not None:
            pulumi.set(__self__, "disable_performance", disable_performance)
        if disable_security is not None:
            pulumi.set(__self__, "disable_security", disable_security)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_cache_ttl is not None:
            pulumi.set(__self__, "edge_cache_ttl", edge_cache_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if explicit_cache_control is not None:
            pulumi.set(__self__, "explicit_cache_control", explicit_cache_control)
        if forwarding_url is not None:
            pulumi.set(__self__, "forwarding_url", forwarding_url)
        if host_header_override is not None:
            pulumi.set(__self__, "host_header_override", host_header_override)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if resolve_override is not None:
            pulumi.set(__self__, "resolve_override", resolve_override)
        if respect_strong_etag is not None:
            pulumi.set(__self__, "respect_strong_etag", respect_strong_etag)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[int]:
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="bypassCacheOnCookie")
    def bypass_cache_on_cookie(self) -> Optional[str]:
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        return pulumi.get(self, "bypass_cache_on_cookie")

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="cacheKeyFields")
    def cache_key_fields(self) -> Optional['outputs.PageRuleActionsCacheKeyFields']:
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        return pulumi.get(self, "cache_key_fields")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[str]:
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="cacheOnCookie")
    def cache_on_cookie(self) -> Optional[str]:
        """
        String value of cookie name to conditionally cache the page.
        """
        return pulumi.get(self, "cache_on_cookie")

    @property
    @pulumi.getter(name="cacheTtlByStatus")
    def cache_ttl_by_status(self) -> Optional[Any]:
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        return pulumi.get(self, "cache_ttl_by_status")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disablePerformance")
    def disable_performance(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_performance")

    @property
    @pulumi.getter(name="disableSecurity")
    def disable_security(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_security")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeCacheTtl")
    def edge_cache_ttl(self) -> Optional[int]:
        """
        The Time To Live for the edge cache.
        """
        return pulumi.get(self, "edge_cache_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="explicitCacheControl")
    def explicit_cache_control(self) -> Optional[str]:
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "explicit_cache_control")

    @property
    @pulumi.getter(name="forwardingUrl")
    def forwarding_url(self) -> Optional['outputs.PageRuleActionsForwardingUrl']:
        """
        The URL to forward to, and with what status. See below.
        """
        return pulumi.get(self, "forwarding_url")

    @property
    @pulumi.getter(name="hostHeaderOverride")
    def host_header_override(self) -> Optional[str]:
        """
        Value of the Host header to send.
        """
        return pulumi.get(self, "host_header_override")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="resolveOverride")
    def resolve_override(self) -> Optional[str]:
        """
        Overridden origin server name.
        """
        return pulumi.get(self, "resolve_override")

    @property
    @pulumi.getter(name="respectStrongEtag")
    def respect_strong_etag(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "respect_strong_etag")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[str]:
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter
    def waf(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "waf")


@pulumi.output_type
class PageRuleActionsCacheKeyFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.PageRuleActionsCacheKeyFieldsCookie'] = None,
                 header: Optional['outputs.PageRuleActionsCacheKeyFieldsHeader'] = None,
                 host: Optional['outputs.PageRuleActionsCacheKeyFieldsHost'] = None,
                 query_string: Optional['outputs.PageRuleActionsCacheKeyFieldsQueryString'] = None,
                 user: Optional['outputs.PageRuleActionsCacheKeyFieldsUser'] = None):
        """
        :param 'PageRuleActionsCacheKeyFieldsCookieArgs' cookie: Controls what cookies go into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsHeaderArgs' header: Controls what HTTP headers go into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsHostArgs' host: Controls which Host header goes into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsQueryStringArgs' query_string: Controls which URL query string parameters go into the Cache Key.
        :param 'PageRuleActionsCacheKeyFieldsUserArgs' user: Controls which end user-related features go into the Cache Key.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsCookie']:
        """
        Controls what cookies go into Cache Key:
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsHeader']:
        """
        Controls what HTTP headers go into Cache Key:
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def host(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsHost']:
        """
        Controls which Host header goes into Cache Key:
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsQueryString']:
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsUser']:
        """
        Controls which end user-related features go into the Cache Key.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] check_presences: Check for presence of specified cookies, without including their actual values.
        :param Sequence[str] includes: Use values of specified cookies in Cache Key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        """
        Check for presence of specified cookies, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Use values of specified cookies in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] check_presences: Check for presence of specified HTTP headers, without including their actual values.
        :param Sequence[str] excludes: Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        :param Sequence[str] includes: Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsHost(dict):
    def __init__(__self__, *,
                 resolved: Optional[bool] = None):
        """
        :param bool resolved: `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[bool]:
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        return pulumi.get(self, "resolved")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsQueryString(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] excludes: Exclude these query string parameters from Cache Key.
        :param Sequence[str] includes: Only use values of specified query string parameters in Cache Key.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        Exclude these query string parameters from Cache Key.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_type: Optional[bool] = None,
                 geo: Optional[bool] = None,
                 lang: Optional[bool] = None):
        """
        :param bool device_type: `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
        :param bool geo: `true` - includes the client’s country, derived from the IP address; defaults to `false`.
        :param bool lang: `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
               
               Example:
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[bool]:
        """
        `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[bool]:
        """
        `true` - includes the client’s country, derived from the IP address; defaults to `false`.
        """
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[bool]:
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.

        Example:
        """
        return pulumi.get(self, "lang")


@pulumi.output_type
class PageRuleActionsForwardingUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsForwardingUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsForwardingUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsForwardingUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: int,
                 url: str):
        """
        :param int status_code: The status code to use for the redirection.
        :param str url: The URL to which the page rule should forward.
        """
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The status code to use for the redirection.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to which the page rule should forward.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PagesDomainValidationData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "txtName":
            suggest = "txt_name"
        elif key == "txtValue":
            suggest = "txt_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesDomainValidationData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesDomainValidationData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesDomainValidationData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[str] = None,
                 method: Optional[str] = None,
                 status: Optional[str] = None,
                 txt_name: Optional[str] = None,
                 txt_value: Optional[str] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[str]:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[str]:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class PagesDomainVerificationData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesDomainVerificationData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesDomainVerificationData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesDomainVerificationData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[str] = None,
                 status: Optional[str] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class PagesProjectBuildConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCaching":
            suggest = "build_caching"
        elif key == "buildCommand":
            suggest = "build_command"
        elif key == "destinationDir":
            suggest = "destination_dir"
        elif key == "rootDir":
            suggest = "root_dir"
        elif key == "webAnalyticsTag":
            suggest = "web_analytics_tag"
        elif key == "webAnalyticsToken":
            suggest = "web_analytics_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectBuildConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectBuildConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectBuildConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_caching: Optional[bool] = None,
                 build_command: Optional[str] = None,
                 destination_dir: Optional[str] = None,
                 root_dir: Optional[str] = None,
                 web_analytics_tag: Optional[str] = None,
                 web_analytics_token: Optional[str] = None):
        """
        :param bool build_caching: Enable build caching for the project.
        :param str build_command: Command used to build project.
        :param str destination_dir: Output directory of the build.
        :param str root_dir: Directory to run the command.
        :param str web_analytics_tag: The classifying tag for analytics.
        :param str web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[bool]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[str]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[str]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[str]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[str]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[str]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class PagesProjectCanonicalDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildConfig":
            suggest = "build_config"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "deploymentTrigger":
            suggest = "deployment_trigger"
        elif key == "envVars":
            suggest = "env_vars"
        elif key == "isSkipped":
            suggest = "is_skipped"
        elif key == "latestStage":
            suggest = "latest_stage"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "shortId":
            suggest = "short_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectCanonicalDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectCanonicalDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectCanonicalDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aliases: Optional[Sequence[str]] = None,
                 build_config: Optional['outputs.PagesProjectCanonicalDeploymentBuildConfig'] = None,
                 created_on: Optional[str] = None,
                 deployment_trigger: Optional['outputs.PagesProjectCanonicalDeploymentDeploymentTrigger'] = None,
                 env_vars: Optional[Mapping[str, 'outputs.PagesProjectCanonicalDeploymentEnvVars']] = None,
                 environment: Optional[str] = None,
                 id: Optional[str] = None,
                 is_skipped: Optional[bool] = None,
                 latest_stage: Optional['outputs.PagesProjectCanonicalDeploymentLatestStage'] = None,
                 modified_on: Optional[str] = None,
                 project_id: Optional[str] = None,
                 project_name: Optional[str] = None,
                 short_id: Optional[str] = None,
                 source: Optional['outputs.PagesProjectCanonicalDeploymentSource'] = None,
                 stages: Optional[Sequence['outputs.PagesProjectCanonicalDeploymentStage']] = None,
                 url: Optional[str] = None):
        """
        :param Sequence[str] aliases: A list of alias URLs pointing to this deployment.
        :param 'PagesProjectCanonicalDeploymentBuildConfigArgs' build_config: Configs for the project build process.
        :param str created_on: When the deployment was created.
        :param 'PagesProjectCanonicalDeploymentDeploymentTriggerArgs' deployment_trigger: Info about what caused the deployment.
        :param Mapping[str, 'PagesProjectCanonicalDeploymentEnvVarsArgs'] env_vars: A dict of env variables to build this deploy.
        :param str environment: Type of deploy.
        :param str id: Id of the deployment.
        :param bool is_skipped: If the deployment has been skipped.
        :param 'PagesProjectCanonicalDeploymentLatestStageArgs' latest_stage: The status of the deployment.
        :param str modified_on: When the deployment was last modified.
        :param str project_id: Id of the project.
        :param str project_name: Name of the project.
        :param str short_id: Short Id (8 character) of the deployment.
        :param Sequence['PagesProjectCanonicalDeploymentStageArgs'] stages: List of past stages.
        :param str url: The live URL to view this deployment.
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if build_config is not None:
            pulumi.set(__self__, "build_config", build_config)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if deployment_trigger is not None:
            pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_skipped is not None:
            pulumi.set(__self__, "is_skipped", is_skipped)
        if latest_stage is not None:
            pulumi.set(__self__, "latest_stage", latest_stage)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence[str]]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> Optional['outputs.PagesProjectCanonicalDeploymentBuildConfig']:
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> Optional['outputs.PagesProjectCanonicalDeploymentDeploymentTrigger']:
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[Mapping[str, 'outputs.PagesProjectCanonicalDeploymentEnvVars']]:
        """
        A dict of env variables to build this deploy.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Type of deploy.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> Optional[bool]:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> Optional['outputs.PagesProjectCanonicalDeploymentLatestStage']:
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[str]:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[str]:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.PagesProjectCanonicalDeploymentSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def stages(self) -> Optional[Sequence['outputs.PagesProjectCanonicalDeploymentStage']]:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PagesProjectCanonicalDeploymentBuildConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCaching":
            suggest = "build_caching"
        elif key == "buildCommand":
            suggest = "build_command"
        elif key == "destinationDir":
            suggest = "destination_dir"
        elif key == "rootDir":
            suggest = "root_dir"
        elif key == "webAnalyticsTag":
            suggest = "web_analytics_tag"
        elif key == "webAnalyticsToken":
            suggest = "web_analytics_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectCanonicalDeploymentBuildConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectCanonicalDeploymentBuildConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectCanonicalDeploymentBuildConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_caching: Optional[bool] = None,
                 build_command: Optional[str] = None,
                 destination_dir: Optional[str] = None,
                 root_dir: Optional[str] = None,
                 web_analytics_tag: Optional[str] = None,
                 web_analytics_token: Optional[str] = None):
        """
        :param bool build_caching: Enable build caching for the project.
        :param str build_command: Command used to build project.
        :param str destination_dir: Output directory of the build.
        :param str root_dir: Directory to run the command.
        :param str web_analytics_tag: The classifying tag for analytics.
        :param str web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[bool]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[str]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[str]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[str]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[str]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[str]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class PagesProjectCanonicalDeploymentDeploymentTrigger(dict):
    def __init__(__self__, *,
                 metadata: Optional['outputs.PagesProjectCanonicalDeploymentDeploymentTriggerMetadata'] = None,
                 type: Optional[str] = None):
        """
        :param 'PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs' metadata: Additional info about the trigger.
        :param str type: What caused the deployment.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.PagesProjectCanonicalDeploymentDeploymentTriggerMetadata']:
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        What caused the deployment.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectCanonicalDeploymentDeploymentTriggerMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commitHash":
            suggest = "commit_hash"
        elif key == "commitMessage":
            suggest = "commit_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectCanonicalDeploymentDeploymentTriggerMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectCanonicalDeploymentDeploymentTriggerMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectCanonicalDeploymentDeploymentTriggerMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 commit_hash: Optional[str] = None,
                 commit_message: Optional[str] = None):
        """
        :param str branch: Where the trigger happened.
        :param str commit_hash: Hash of the deployment trigger commit.
        :param str commit_message: Message of the deployment trigger commit.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_hash is not None:
            pulumi.set(__self__, "commit_hash", commit_hash)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> Optional[str]:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")


@pulumi.output_type
class PagesProjectCanonicalDeploymentEnvVars(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str type: The type of environment variable.
        :param str value: Environment variable value.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PagesProjectCanonicalDeploymentLatestStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectCanonicalDeploymentLatestStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectCanonicalDeploymentLatestStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectCanonicalDeploymentLatestStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: Optional[str] = None,
                 name: Optional[str] = None,
                 started_on: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[str]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[str]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PagesProjectCanonicalDeploymentSource(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.PagesProjectCanonicalDeploymentSourceConfig'] = None,
                 type: Optional[str] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.PagesProjectCanonicalDeploymentSourceConfig']:
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectCanonicalDeploymentSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentsEnabled":
            suggest = "deployments_enabled"
        elif key == "pathExcludes":
            suggest = "path_excludes"
        elif key == "pathIncludes":
            suggest = "path_includes"
        elif key == "prCommentsEnabled":
            suggest = "pr_comments_enabled"
        elif key == "previewBranchExcludes":
            suggest = "preview_branch_excludes"
        elif key == "previewBranchIncludes":
            suggest = "preview_branch_includes"
        elif key == "previewDeploymentSetting":
            suggest = "preview_deployment_setting"
        elif key == "productionBranch":
            suggest = "production_branch"
        elif key == "productionDeploymentsEnabled":
            suggest = "production_deployments_enabled"
        elif key == "repoName":
            suggest = "repo_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectCanonicalDeploymentSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectCanonicalDeploymentSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectCanonicalDeploymentSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployments_enabled: Optional[bool] = None,
                 owner: Optional[str] = None,
                 path_excludes: Optional[Sequence[str]] = None,
                 path_includes: Optional[Sequence[str]] = None,
                 pr_comments_enabled: Optional[bool] = None,
                 preview_branch_excludes: Optional[Sequence[str]] = None,
                 preview_branch_includes: Optional[Sequence[str]] = None,
                 preview_deployment_setting: Optional[str] = None,
                 production_branch: Optional[str] = None,
                 production_deployments_enabled: Optional[bool] = None,
                 repo_name: Optional[str] = None):
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "path_excludes")

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "path_includes")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[str]:
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[str]:
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "production_deployments_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class PagesProjectCanonicalDeploymentStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectCanonicalDeploymentStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectCanonicalDeploymentStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectCanonicalDeploymentStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: Optional[str] = None,
                 name: Optional[str] = None,
                 started_on: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[str]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[str]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PagesProjectDeploymentConfigs(dict):
    def __init__(__self__, *,
                 preview: Optional['outputs.PagesProjectDeploymentConfigsPreview'] = None,
                 production: Optional['outputs.PagesProjectDeploymentConfigsProduction'] = None):
        """
        :param 'PagesProjectDeploymentConfigsPreviewArgs' preview: Configs for preview deploys.
        :param 'PagesProjectDeploymentConfigsProductionArgs' production: Configs for production deploys.
        """
        if preview is not None:
            pulumi.set(__self__, "preview", preview)
        if production is not None:
            pulumi.set(__self__, "production", production)

    @property
    @pulumi.getter
    def preview(self) -> Optional['outputs.PagesProjectDeploymentConfigsPreview']:
        """
        Configs for preview deploys.
        """
        return pulumi.get(self, "preview")

    @property
    @pulumi.getter
    def production(self) -> Optional['outputs.PagesProjectDeploymentConfigsProduction']:
        """
        Configs for production deploys.
        """
        return pulumi.get(self, "production")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreview(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aiBindings":
            suggest = "ai_bindings"
        elif key == "analyticsEngineDatasets":
            suggest = "analytics_engine_datasets"
        elif key == "compatibilityDate":
            suggest = "compatibility_date"
        elif key == "compatibilityFlags":
            suggest = "compatibility_flags"
        elif key == "d1Databases":
            suggest = "d1_databases"
        elif key == "durableObjectNamespaces":
            suggest = "durable_object_namespaces"
        elif key == "envVars":
            suggest = "env_vars"
        elif key == "hyperdriveBindings":
            suggest = "hyperdrive_bindings"
        elif key == "kvNamespaces":
            suggest = "kv_namespaces"
        elif key == "mtlsCertificates":
            suggest = "mtls_certificates"
        elif key == "queueProducers":
            suggest = "queue_producers"
        elif key == "r2Buckets":
            suggest = "r2_buckets"
        elif key == "vectorizeBindings":
            suggest = "vectorize_bindings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsPreview. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsPreview.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsPreview.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ai_bindings: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewAiBindings']] = None,
                 analytics_engine_datasets: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets']] = None,
                 browsers: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewBrowsers']] = None,
                 compatibility_date: Optional[str] = None,
                 compatibility_flags: Optional[Sequence[str]] = None,
                 d1_databases: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewD1Databases']] = None,
                 durable_object_namespaces: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces']] = None,
                 env_vars: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewEnvVars']] = None,
                 hyperdrive_bindings: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewHyperdriveBindings']] = None,
                 kv_namespaces: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewKvNamespaces']] = None,
                 mtls_certificates: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewMtlsCertificates']] = None,
                 placement: Optional['outputs.PagesProjectDeploymentConfigsPreviewPlacement'] = None,
                 queue_producers: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewQueueProducers']] = None,
                 r2_buckets: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewR2Buckets']] = None,
                 services: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewServices']] = None,
                 vectorize_bindings: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewVectorizeBindings']] = None):
        """
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewAiBindingsArgs'] ai_bindings: Constellation bindings used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs'] analytics_engine_datasets: Analytics Engine bindings used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewBrowsersArgs'] browsers: Browser bindings used for Pages Functions.
        :param str compatibility_date: Compatibility date used for Pages Functions.
        :param Sequence[str] compatibility_flags: Compatibility flags used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewD1DatabasesArgs'] d1_databases: D1 databases used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs'] durable_object_namespaces: Durabble Object namespaces used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewEnvVarsArgs'] env_vars: Environment variables for build configs.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs'] hyperdrive_bindings: Hyperdrive bindings used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewKvNamespacesArgs'] kv_namespaces: KV namespaces used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs'] mtls_certificates: mTLS bindings used for Pages Functions.
        :param 'PagesProjectDeploymentConfigsPreviewPlacementArgs' placement: Placement setting used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewQueueProducersArgs'] queue_producers: Queue Producer bindings used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewR2BucketsArgs'] r2_buckets: R2 buckets used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewServicesArgs'] services: Services used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs'] vectorize_bindings: Vectorize bindings used for Pages Functions.
        """
        if ai_bindings is not None:
            pulumi.set(__self__, "ai_bindings", ai_bindings)
        if analytics_engine_datasets is not None:
            pulumi.set(__self__, "analytics_engine_datasets", analytics_engine_datasets)
        if browsers is not None:
            pulumi.set(__self__, "browsers", browsers)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if hyperdrive_bindings is not None:
            pulumi.set(__self__, "hyperdrive_bindings", hyperdrive_bindings)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if mtls_certificates is not None:
            pulumi.set(__self__, "mtls_certificates", mtls_certificates)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if queue_producers is not None:
            pulumi.set(__self__, "queue_producers", queue_producers)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vectorize_bindings is not None:
            pulumi.set(__self__, "vectorize_bindings", vectorize_bindings)

    @property
    @pulumi.getter(name="aiBindings")
    def ai_bindings(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewAiBindings']]:
        """
        Constellation bindings used for Pages Functions.
        """
        return pulumi.get(self, "ai_bindings")

    @property
    @pulumi.getter(name="analyticsEngineDatasets")
    def analytics_engine_datasets(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets']]:
        """
        Analytics Engine bindings used for Pages Functions.
        """
        return pulumi.get(self, "analytics_engine_datasets")

    @property
    @pulumi.getter
    def browsers(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewBrowsers']]:
        """
        Browser bindings used for Pages Functions.
        """
        return pulumi.get(self, "browsers")

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[str]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[Sequence[str]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewD1Databases']]:
        """
        D1 databases used for Pages Functions.
        """
        return pulumi.get(self, "d1_databases")

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces']]:
        """
        Durabble Object namespaces used for Pages Functions.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewEnvVars']]:
        """
        Environment variables for build configs.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter(name="hyperdriveBindings")
    def hyperdrive_bindings(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewHyperdriveBindings']]:
        """
        Hyperdrive bindings used for Pages Functions.
        """
        return pulumi.get(self, "hyperdrive_bindings")

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewKvNamespaces']]:
        """
        KV namespaces used for Pages Functions.
        """
        return pulumi.get(self, "kv_namespaces")

    @property
    @pulumi.getter(name="mtlsCertificates")
    def mtls_certificates(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewMtlsCertificates']]:
        """
        mTLS bindings used for Pages Functions.
        """
        return pulumi.get(self, "mtls_certificates")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.PagesProjectDeploymentConfigsPreviewPlacement']:
        """
        Placement setting used for Pages Functions.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="queueProducers")
    def queue_producers(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewQueueProducers']]:
        """
        Queue Producer bindings used for Pages Functions.
        """
        return pulumi.get(self, "queue_producers")

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewR2Buckets']]:
        """
        R2 buckets used for Pages Functions.
        """
        return pulumi.get(self, "r2_buckets")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewServices']]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter(name="vectorizeBindings")
    def vectorize_bindings(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsPreviewVectorizeBindings']]:
        """
        Vectorize bindings used for Pages Functions.
        """
        return pulumi.get(self, "vectorize_bindings")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewAiBindings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsPreviewAiBindings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsPreviewAiBindings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsPreviewAiBindings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: Optional[str] = None):
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets(dict):
    def __init__(__self__, *,
                 dataset: Optional[str] = None):
        """
        :param str dataset: Name of the dataset.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[str]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "dataset")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewBrowsers(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewD1Databases(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: UUID of the D1 database.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID of the D1 database.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_id: Optional[str] = None):
        """
        :param str namespace_id: ID of the Durabble Object namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[str]:
        """
        ID of the Durabble Object namespace.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewEnvVars(dict):
    def __init__(__self__, *,
                 value: str,
                 type: Optional[str] = None):
        """
        :param str value: Environment variable value.
        :param str type: The type of environment variable.
        """
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewHyperdriveBindings(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewKvNamespaces(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsPreviewKvNamespaces. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsPreviewKvNamespaces.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsPreviewKvNamespaces.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_id: Optional[str] = None):
        """
        :param str namespace_id: ID of the KV namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[str]:
        """
        ID of the KV namespace.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewMtlsCertificates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsPreviewMtlsCertificates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsPreviewMtlsCertificates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsPreviewMtlsCertificates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_id: Optional[str] = None):
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[str]:
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewPlacement(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None):
        """
        :param str mode: Placement mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Placement mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewQueueProducers(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the Queue.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Queue.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewR2Buckets(dict):
    def __init__(__self__, *,
                 jurisdiction: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str jurisdiction: Jurisdiction of the R2 bucket.
        :param str name: Name of the R2 bucket.
        """
        if jurisdiction is not None:
            pulumi.set(__self__, "jurisdiction", jurisdiction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def jurisdiction(self) -> Optional[str]:
        """
        Jurisdiction of the R2 bucket.
        """
        return pulumi.get(self, "jurisdiction")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the R2 bucket.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewServices(dict):
    def __init__(__self__, *,
                 entrypoint: Optional[str] = None,
                 environment: Optional[str] = None,
                 service: Optional[str] = None):
        """
        :param str entrypoint: The entrypoint to bind to.
        :param str environment: The Service environment.
        :param str service: The Service name.
        """
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def entrypoint(self) -> Optional[str]:
        """
        The entrypoint to bind to.
        """
        return pulumi.get(self, "entrypoint")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        The Service environment.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The Service name.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewVectorizeBindings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexName":
            suggest = "index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsPreviewVectorizeBindings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsPreviewVectorizeBindings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsPreviewVectorizeBindings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_name: Optional[str] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[str]:
        return pulumi.get(self, "index_name")


@pulumi.output_type
class PagesProjectDeploymentConfigsProduction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aiBindings":
            suggest = "ai_bindings"
        elif key == "analyticsEngineDatasets":
            suggest = "analytics_engine_datasets"
        elif key == "compatibilityDate":
            suggest = "compatibility_date"
        elif key == "compatibilityFlags":
            suggest = "compatibility_flags"
        elif key == "d1Databases":
            suggest = "d1_databases"
        elif key == "durableObjectNamespaces":
            suggest = "durable_object_namespaces"
        elif key == "envVars":
            suggest = "env_vars"
        elif key == "hyperdriveBindings":
            suggest = "hyperdrive_bindings"
        elif key == "kvNamespaces":
            suggest = "kv_namespaces"
        elif key == "mtlsCertificates":
            suggest = "mtls_certificates"
        elif key == "queueProducers":
            suggest = "queue_producers"
        elif key == "r2Buckets":
            suggest = "r2_buckets"
        elif key == "vectorizeBindings":
            suggest = "vectorize_bindings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsProduction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsProduction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsProduction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ai_bindings: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionAiBindings']] = None,
                 analytics_engine_datasets: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets']] = None,
                 browsers: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionBrowsers']] = None,
                 compatibility_date: Optional[str] = None,
                 compatibility_flags: Optional[Sequence[str]] = None,
                 d1_databases: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionD1Databases']] = None,
                 durable_object_namespaces: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionDurableObjectNamespaces']] = None,
                 env_vars: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionEnvVars']] = None,
                 hyperdrive_bindings: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionHyperdriveBindings']] = None,
                 kv_namespaces: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionKvNamespaces']] = None,
                 mtls_certificates: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionMtlsCertificates']] = None,
                 placement: Optional['outputs.PagesProjectDeploymentConfigsProductionPlacement'] = None,
                 queue_producers: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionQueueProducers']] = None,
                 r2_buckets: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionR2Buckets']] = None,
                 services: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionServices']] = None,
                 vectorize_bindings: Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionVectorizeBindings']] = None):
        """
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionAiBindingsArgs'] ai_bindings: Constellation bindings used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs'] analytics_engine_datasets: Analytics Engine bindings used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionBrowsersArgs'] browsers: Browser bindings used for Pages Functions.
        :param str compatibility_date: Compatibility date used for Pages Functions.
        :param Sequence[str] compatibility_flags: Compatibility flags used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionD1DatabasesArgs'] d1_databases: D1 databases used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs'] durable_object_namespaces: Durabble Object namespaces used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionEnvVarsArgs'] env_vars: Environment variables for build configs.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs'] hyperdrive_bindings: Hyperdrive bindings used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionKvNamespacesArgs'] kv_namespaces: KV namespaces used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs'] mtls_certificates: mTLS bindings used for Pages Functions.
        :param 'PagesProjectDeploymentConfigsProductionPlacementArgs' placement: Placement setting used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionQueueProducersArgs'] queue_producers: Queue Producer bindings used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionR2BucketsArgs'] r2_buckets: R2 buckets used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionServicesArgs'] services: Services used for Pages Functions.
        :param Mapping[str, 'PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs'] vectorize_bindings: Vectorize bindings used for Pages Functions.
        """
        if ai_bindings is not None:
            pulumi.set(__self__, "ai_bindings", ai_bindings)
        if analytics_engine_datasets is not None:
            pulumi.set(__self__, "analytics_engine_datasets", analytics_engine_datasets)
        if browsers is not None:
            pulumi.set(__self__, "browsers", browsers)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if hyperdrive_bindings is not None:
            pulumi.set(__self__, "hyperdrive_bindings", hyperdrive_bindings)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if mtls_certificates is not None:
            pulumi.set(__self__, "mtls_certificates", mtls_certificates)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if queue_producers is not None:
            pulumi.set(__self__, "queue_producers", queue_producers)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vectorize_bindings is not None:
            pulumi.set(__self__, "vectorize_bindings", vectorize_bindings)

    @property
    @pulumi.getter(name="aiBindings")
    def ai_bindings(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionAiBindings']]:
        """
        Constellation bindings used for Pages Functions.
        """
        return pulumi.get(self, "ai_bindings")

    @property
    @pulumi.getter(name="analyticsEngineDatasets")
    def analytics_engine_datasets(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets']]:
        """
        Analytics Engine bindings used for Pages Functions.
        """
        return pulumi.get(self, "analytics_engine_datasets")

    @property
    @pulumi.getter
    def browsers(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionBrowsers']]:
        """
        Browser bindings used for Pages Functions.
        """
        return pulumi.get(self, "browsers")

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[str]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[Sequence[str]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionD1Databases']]:
        """
        D1 databases used for Pages Functions.
        """
        return pulumi.get(self, "d1_databases")

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionDurableObjectNamespaces']]:
        """
        Durabble Object namespaces used for Pages Functions.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionEnvVars']]:
        """
        Environment variables for build configs.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter(name="hyperdriveBindings")
    def hyperdrive_bindings(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionHyperdriveBindings']]:
        """
        Hyperdrive bindings used for Pages Functions.
        """
        return pulumi.get(self, "hyperdrive_bindings")

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionKvNamespaces']]:
        """
        KV namespaces used for Pages Functions.
        """
        return pulumi.get(self, "kv_namespaces")

    @property
    @pulumi.getter(name="mtlsCertificates")
    def mtls_certificates(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionMtlsCertificates']]:
        """
        mTLS bindings used for Pages Functions.
        """
        return pulumi.get(self, "mtls_certificates")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.PagesProjectDeploymentConfigsProductionPlacement']:
        """
        Placement setting used for Pages Functions.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="queueProducers")
    def queue_producers(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionQueueProducers']]:
        """
        Queue Producer bindings used for Pages Functions.
        """
        return pulumi.get(self, "queue_producers")

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionR2Buckets']]:
        """
        R2 buckets used for Pages Functions.
        """
        return pulumi.get(self, "r2_buckets")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionServices']]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter(name="vectorizeBindings")
    def vectorize_bindings(self) -> Optional[Mapping[str, 'outputs.PagesProjectDeploymentConfigsProductionVectorizeBindings']]:
        """
        Vectorize bindings used for Pages Functions.
        """
        return pulumi.get(self, "vectorize_bindings")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionAiBindings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsProductionAiBindings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsProductionAiBindings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsProductionAiBindings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: Optional[str] = None):
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets(dict):
    def __init__(__self__, *,
                 dataset: Optional[str] = None):
        """
        :param str dataset: Name of the dataset.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[str]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "dataset")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionBrowsers(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionD1Databases(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: UUID of the D1 database.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID of the D1 database.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionDurableObjectNamespaces(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsProductionDurableObjectNamespaces. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsProductionDurableObjectNamespaces.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsProductionDurableObjectNamespaces.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_id: Optional[str] = None):
        """
        :param str namespace_id: ID of the Durabble Object namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[str]:
        """
        ID of the Durabble Object namespace.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionEnvVars(dict):
    def __init__(__self__, *,
                 value: str,
                 type: Optional[str] = None):
        """
        :param str value: Environment variable value.
        :param str type: The type of environment variable.
        """
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionHyperdriveBindings(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionKvNamespaces(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsProductionKvNamespaces. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsProductionKvNamespaces.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsProductionKvNamespaces.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_id: Optional[str] = None):
        """
        :param str namespace_id: ID of the KV namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[str]:
        """
        ID of the KV namespace.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionMtlsCertificates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsProductionMtlsCertificates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsProductionMtlsCertificates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsProductionMtlsCertificates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_id: Optional[str] = None):
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[str]:
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionPlacement(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None):
        """
        :param str mode: Placement mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Placement mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionQueueProducers(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the Queue.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Queue.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionR2Buckets(dict):
    def __init__(__self__, *,
                 jurisdiction: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str jurisdiction: Jurisdiction of the R2 bucket.
        :param str name: Name of the R2 bucket.
        """
        if jurisdiction is not None:
            pulumi.set(__self__, "jurisdiction", jurisdiction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def jurisdiction(self) -> Optional[str]:
        """
        Jurisdiction of the R2 bucket.
        """
        return pulumi.get(self, "jurisdiction")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the R2 bucket.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionServices(dict):
    def __init__(__self__, *,
                 entrypoint: Optional[str] = None,
                 environment: Optional[str] = None,
                 service: Optional[str] = None):
        """
        :param str entrypoint: The entrypoint to bind to.
        :param str environment: The Service environment.
        :param str service: The Service name.
        """
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def entrypoint(self) -> Optional[str]:
        """
        The entrypoint to bind to.
        """
        return pulumi.get(self, "entrypoint")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        The Service environment.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The Service name.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionVectorizeBindings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexName":
            suggest = "index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsProductionVectorizeBindings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsProductionVectorizeBindings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsProductionVectorizeBindings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_name: Optional[str] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[str]:
        return pulumi.get(self, "index_name")


@pulumi.output_type
class PagesProjectLatestDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildConfig":
            suggest = "build_config"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "deploymentTrigger":
            suggest = "deployment_trigger"
        elif key == "envVars":
            suggest = "env_vars"
        elif key == "isSkipped":
            suggest = "is_skipped"
        elif key == "latestStage":
            suggest = "latest_stage"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "shortId":
            suggest = "short_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectLatestDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectLatestDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectLatestDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aliases: Optional[Sequence[str]] = None,
                 build_config: Optional['outputs.PagesProjectLatestDeploymentBuildConfig'] = None,
                 created_on: Optional[str] = None,
                 deployment_trigger: Optional['outputs.PagesProjectLatestDeploymentDeploymentTrigger'] = None,
                 env_vars: Optional[Mapping[str, 'outputs.PagesProjectLatestDeploymentEnvVars']] = None,
                 environment: Optional[str] = None,
                 id: Optional[str] = None,
                 is_skipped: Optional[bool] = None,
                 latest_stage: Optional['outputs.PagesProjectLatestDeploymentLatestStage'] = None,
                 modified_on: Optional[str] = None,
                 project_id: Optional[str] = None,
                 project_name: Optional[str] = None,
                 short_id: Optional[str] = None,
                 source: Optional['outputs.PagesProjectLatestDeploymentSource'] = None,
                 stages: Optional[Sequence['outputs.PagesProjectLatestDeploymentStage']] = None,
                 url: Optional[str] = None):
        """
        :param Sequence[str] aliases: A list of alias URLs pointing to this deployment.
        :param 'PagesProjectLatestDeploymentBuildConfigArgs' build_config: Configs for the project build process.
        :param str created_on: When the deployment was created.
        :param 'PagesProjectLatestDeploymentDeploymentTriggerArgs' deployment_trigger: Info about what caused the deployment.
        :param Mapping[str, 'PagesProjectLatestDeploymentEnvVarsArgs'] env_vars: A dict of env variables to build this deploy.
        :param str environment: Type of deploy.
        :param str id: Id of the deployment.
        :param bool is_skipped: If the deployment has been skipped.
        :param 'PagesProjectLatestDeploymentLatestStageArgs' latest_stage: The status of the deployment.
        :param str modified_on: When the deployment was last modified.
        :param str project_id: Id of the project.
        :param str project_name: Name of the project.
        :param str short_id: Short Id (8 character) of the deployment.
        :param Sequence['PagesProjectLatestDeploymentStageArgs'] stages: List of past stages.
        :param str url: The live URL to view this deployment.
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if build_config is not None:
            pulumi.set(__self__, "build_config", build_config)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if deployment_trigger is not None:
            pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_skipped is not None:
            pulumi.set(__self__, "is_skipped", is_skipped)
        if latest_stage is not None:
            pulumi.set(__self__, "latest_stage", latest_stage)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence[str]]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> Optional['outputs.PagesProjectLatestDeploymentBuildConfig']:
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> Optional['outputs.PagesProjectLatestDeploymentDeploymentTrigger']:
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[Mapping[str, 'outputs.PagesProjectLatestDeploymentEnvVars']]:
        """
        A dict of env variables to build this deploy.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Type of deploy.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> Optional[bool]:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> Optional['outputs.PagesProjectLatestDeploymentLatestStage']:
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[str]:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[str]:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.PagesProjectLatestDeploymentSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def stages(self) -> Optional[Sequence['outputs.PagesProjectLatestDeploymentStage']]:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PagesProjectLatestDeploymentBuildConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCaching":
            suggest = "build_caching"
        elif key == "buildCommand":
            suggest = "build_command"
        elif key == "destinationDir":
            suggest = "destination_dir"
        elif key == "rootDir":
            suggest = "root_dir"
        elif key == "webAnalyticsTag":
            suggest = "web_analytics_tag"
        elif key == "webAnalyticsToken":
            suggest = "web_analytics_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectLatestDeploymentBuildConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectLatestDeploymentBuildConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectLatestDeploymentBuildConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_caching: Optional[bool] = None,
                 build_command: Optional[str] = None,
                 destination_dir: Optional[str] = None,
                 root_dir: Optional[str] = None,
                 web_analytics_tag: Optional[str] = None,
                 web_analytics_token: Optional[str] = None):
        """
        :param bool build_caching: Enable build caching for the project.
        :param str build_command: Command used to build project.
        :param str destination_dir: Output directory of the build.
        :param str root_dir: Directory to run the command.
        :param str web_analytics_tag: The classifying tag for analytics.
        :param str web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[bool]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[str]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[str]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[str]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[str]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[str]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class PagesProjectLatestDeploymentDeploymentTrigger(dict):
    def __init__(__self__, *,
                 metadata: Optional['outputs.PagesProjectLatestDeploymentDeploymentTriggerMetadata'] = None,
                 type: Optional[str] = None):
        """
        :param 'PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs' metadata: Additional info about the trigger.
        :param str type: What caused the deployment.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.PagesProjectLatestDeploymentDeploymentTriggerMetadata']:
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        What caused the deployment.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectLatestDeploymentDeploymentTriggerMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commitHash":
            suggest = "commit_hash"
        elif key == "commitMessage":
            suggest = "commit_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectLatestDeploymentDeploymentTriggerMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectLatestDeploymentDeploymentTriggerMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectLatestDeploymentDeploymentTriggerMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 commit_hash: Optional[str] = None,
                 commit_message: Optional[str] = None):
        """
        :param str branch: Where the trigger happened.
        :param str commit_hash: Hash of the deployment trigger commit.
        :param str commit_message: Message of the deployment trigger commit.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_hash is not None:
            pulumi.set(__self__, "commit_hash", commit_hash)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> Optional[str]:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")


@pulumi.output_type
class PagesProjectLatestDeploymentEnvVars(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str type: The type of environment variable.
        :param str value: Environment variable value.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PagesProjectLatestDeploymentLatestStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectLatestDeploymentLatestStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectLatestDeploymentLatestStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectLatestDeploymentLatestStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: Optional[str] = None,
                 name: Optional[str] = None,
                 started_on: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[str]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[str]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PagesProjectLatestDeploymentSource(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.PagesProjectLatestDeploymentSourceConfig'] = None,
                 type: Optional[str] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.PagesProjectLatestDeploymentSourceConfig']:
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectLatestDeploymentSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentsEnabled":
            suggest = "deployments_enabled"
        elif key == "pathExcludes":
            suggest = "path_excludes"
        elif key == "pathIncludes":
            suggest = "path_includes"
        elif key == "prCommentsEnabled":
            suggest = "pr_comments_enabled"
        elif key == "previewBranchExcludes":
            suggest = "preview_branch_excludes"
        elif key == "previewBranchIncludes":
            suggest = "preview_branch_includes"
        elif key == "previewDeploymentSetting":
            suggest = "preview_deployment_setting"
        elif key == "productionBranch":
            suggest = "production_branch"
        elif key == "productionDeploymentsEnabled":
            suggest = "production_deployments_enabled"
        elif key == "repoName":
            suggest = "repo_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectLatestDeploymentSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectLatestDeploymentSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectLatestDeploymentSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployments_enabled: Optional[bool] = None,
                 owner: Optional[str] = None,
                 path_excludes: Optional[Sequence[str]] = None,
                 path_includes: Optional[Sequence[str]] = None,
                 pr_comments_enabled: Optional[bool] = None,
                 preview_branch_excludes: Optional[Sequence[str]] = None,
                 preview_branch_includes: Optional[Sequence[str]] = None,
                 preview_deployment_setting: Optional[str] = None,
                 production_branch: Optional[str] = None,
                 production_deployments_enabled: Optional[bool] = None,
                 repo_name: Optional[str] = None):
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "path_excludes")

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "path_includes")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[str]:
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[str]:
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "production_deployments_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class PagesProjectLatestDeploymentStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectLatestDeploymentStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectLatestDeploymentStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectLatestDeploymentStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: Optional[str] = None,
                 name: Optional[str] = None,
                 started_on: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[str]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[str]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PagesProjectSource(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.PagesProjectSourceConfig'] = None,
                 type: Optional[str] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.PagesProjectSourceConfig']:
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentsEnabled":
            suggest = "deployments_enabled"
        elif key == "pathExcludes":
            suggest = "path_excludes"
        elif key == "pathIncludes":
            suggest = "path_includes"
        elif key == "prCommentsEnabled":
            suggest = "pr_comments_enabled"
        elif key == "previewBranchExcludes":
            suggest = "preview_branch_excludes"
        elif key == "previewBranchIncludes":
            suggest = "preview_branch_includes"
        elif key == "previewDeploymentSetting":
            suggest = "preview_deployment_setting"
        elif key == "productionBranch":
            suggest = "production_branch"
        elif key == "productionDeploymentsEnabled":
            suggest = "production_deployments_enabled"
        elif key == "repoName":
            suggest = "repo_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployments_enabled: Optional[bool] = None,
                 owner: Optional[str] = None,
                 path_excludes: Optional[Sequence[str]] = None,
                 path_includes: Optional[Sequence[str]] = None,
                 pr_comments_enabled: Optional[bool] = None,
                 preview_branch_excludes: Optional[Sequence[str]] = None,
                 preview_branch_includes: Optional[Sequence[str]] = None,
                 preview_deployment_setting: Optional[str] = None,
                 production_branch: Optional[str] = None,
                 production_deployments_enabled: Optional[bool] = None,
                 repo_name: Optional[str] = None):
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "path_excludes")

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "path_includes")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[str]:
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[str]:
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "production_deployments_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class QueueConsumer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerId":
            suggest = "consumer_id"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "queueId":
            suggest = "queue_id"
        elif key == "scriptName":
            suggest = "script_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueConsumer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueConsumer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueConsumer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_id: Optional[str] = None,
                 created_on: Optional[str] = None,
                 queue_id: Optional[str] = None,
                 script: Optional[str] = None,
                 script_name: Optional[str] = None,
                 settings: Optional['outputs.QueueConsumerSettings'] = None,
                 type: Optional[str] = None):
        """
        :param str consumer_id: A Resource identifier.
        :param str queue_id: A Resource identifier.
        :param str script: Name of a Worker
        :param str script_name: Name of a Worker
        """
        if consumer_id is not None:
            pulumi.set(__self__, "consumer_id", consumer_id)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if queue_id is not None:
            pulumi.set(__self__, "queue_id", queue_id)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if script_name is not None:
            pulumi.set(__self__, "script_name", script_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="consumerId")
    def consumer_id(self) -> Optional[str]:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "consumer_id")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> Optional[str]:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script")

    @property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> Optional[str]:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script_name")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.QueueConsumerSettings']:
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class QueueConsumerSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSize":
            suggest = "batch_size"
        elif key == "maxConcurrency":
            suggest = "max_concurrency"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "maxWaitTimeMs":
            suggest = "max_wait_time_ms"
        elif key == "retryDelay":
            suggest = "retry_delay"
        elif key == "visibilityTimeoutMs":
            suggest = "visibility_timeout_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueConsumerSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueConsumerSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueConsumerSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size: Optional[float] = None,
                 max_concurrency: Optional[float] = None,
                 max_retries: Optional[float] = None,
                 max_wait_time_ms: Optional[float] = None,
                 retry_delay: Optional[float] = None,
                 visibility_timeout_ms: Optional[float] = None):
        """
        :param float batch_size: The maximum number of messages to include in a batch.
        :param float max_concurrency: Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        :param float max_retries: The maximum number of retries
        :param float max_wait_time_ms: The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        :param float retry_delay: The number of seconds to delay before making the message available for another attempt.
        :param float visibility_timeout_ms: The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if max_wait_time_ms is not None:
            pulumi.set(__self__, "max_wait_time_ms", max_wait_time_ms)
        if retry_delay is not None:
            pulumi.set(__self__, "retry_delay", retry_delay)
        if visibility_timeout_ms is not None:
            pulumi.set(__self__, "visibility_timeout_ms", visibility_timeout_ms)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[float]:
        """
        The maximum number of messages to include in a batch.
        """
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[float]:
        """
        Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        """
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[float]:
        """
        The maximum number of retries
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="maxWaitTimeMs")
    def max_wait_time_ms(self) -> Optional[float]:
        """
        The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        """
        return pulumi.get(self, "max_wait_time_ms")

    @property
    @pulumi.getter(name="retryDelay")
    def retry_delay(self) -> Optional[float]:
        """
        The number of seconds to delay before making the message available for another attempt.
        """
        return pulumi.get(self, "retry_delay")

    @property
    @pulumi.getter(name="visibilityTimeoutMs")
    def visibility_timeout_ms(self) -> Optional[float]:
        """
        The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        return pulumi.get(self, "visibility_timeout_ms")


@pulumi.output_type
class QueueProducer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueProducer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueProducer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueProducer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 script: Optional[str] = None,
                 type: Optional[str] = None):
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class QueueSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryDelay":
            suggest = "delivery_delay"
        elif key == "messageRetentionPeriod":
            suggest = "message_retention_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_delay: Optional[float] = None,
                 message_retention_period: Optional[float] = None):
        """
        :param float delivery_delay: Number of seconds to delay delivery of all messages to consumers.
        :param float message_retention_period: Number of seconds after which an unconsumed message will be delayed.
        """
        if delivery_delay is not None:
            pulumi.set(__self__, "delivery_delay", delivery_delay)
        if message_retention_period is not None:
            pulumi.set(__self__, "message_retention_period", message_retention_period)

    @property
    @pulumi.getter(name="deliveryDelay")
    def delivery_delay(self) -> Optional[float]:
        """
        Number of seconds to delay delivery of all messages to consumers.
        """
        return pulumi.get(self, "delivery_delay")

    @property
    @pulumi.getter(name="messageRetentionPeriod")
    def message_retention_period(self) -> Optional[float]:
        """
        Number of seconds after which an unconsumed message will be delayed.
        """
        return pulumi.get(self, "message_retention_period")


@pulumi.output_type
<<<<<<< HEAD
=======
class R2BucketCorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAgeSeconds":
            suggest = "max_age_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketCorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketCorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketCorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed: 'outputs.R2BucketCorsRuleAllowed',
                 expose_headers: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 max_age_seconds: Optional[float] = None):
        """
        :param 'R2BucketCorsRuleAllowedArgs' allowed: Object specifying allowed origins, methods and headers for this CORS rule.
        :param Sequence[str] expose_headers: Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        :param str id: Identifier for this rule
        :param float max_age_seconds: Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
        pulumi.set(__self__, "allowed", allowed)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter
    def allowed(self) -> 'outputs.R2BucketCorsRuleAllowed':
        """
        Object specifying allowed origins, methods and headers for this CORS rule.
        """
        return pulumi.get(self, "allowed")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier for this rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[float]:
        """
        Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class R2BucketCorsRuleAllowed(dict):
    def __init__(__self__, *,
                 methods: Sequence[str],
                 origins: Sequence[str],
                 headers: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] methods: Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        :param Sequence[str] origins: Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        :param Sequence[str] headers: Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "origins", origins)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def origins(self) -> Sequence[str]:
        """
        Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        """
        return pulumi.get(self, "origins")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class R2BucketEventNotificationQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueId":
            suggest = "queue_id"
        elif key == "queueName":
            suggest = "queue_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketEventNotificationQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketEventNotificationQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketEventNotificationQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_id: Optional[str] = None,
                 queue_name: Optional[str] = None,
                 rules: Optional[Sequence['outputs.R2BucketEventNotificationQueueRule']] = None):
        """
        :param str queue_id: Queue ID
        :param str queue_name: Name of the queue
        """
        if queue_id is not None:
            pulumi.set(__self__, "queue_id", queue_id)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> Optional[str]:
        """
        Queue ID
        """
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[str]:
        """
        Name of the queue
        """
        return pulumi.get(self, "queue_name")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.R2BucketEventNotificationQueueRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class R2BucketEventNotificationQueueRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketEventNotificationQueueRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketEventNotificationQueueRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketEventNotificationQueueRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None,
                 created_at: Optional[str] = None,
                 description: Optional[str] = None,
                 prefix: Optional[str] = None,
                 rule_id: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param Sequence[str] actions: Array of R2 object actions that will trigger notifications
        :param str created_at: Timestamp when the rule was created
        :param str description: A description that can be used to identify the event notification rule after creation
        :param str prefix: Notifications will be sent only for objects with this prefix
        :param str rule_id: Rule ID
        :param str suffix: Notifications will be sent only for objects with this suffix
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Array of R2 object actions that will trigger notifications
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        Timestamp when the rule was created
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description that can be used to identify the event notification rule after creation
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Notifications will be sent only for objects with this prefix
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[str]:
        """
        Rule ID
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Notifications will be sent only for objects with this suffix
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class R2BucketEventNotificationRule(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 description: Optional[str] = None,
                 prefix: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param Sequence[str] actions: Array of R2 object actions that will trigger notifications
        :param str description: A description that can be used to identify the event notification rule after creation
        :param str prefix: Notifications will be sent only for objects with this prefix
        :param str suffix: Notifications will be sent only for objects with this suffix
        """
        pulumi.set(__self__, "actions", actions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Array of R2 object actions that will trigger notifications
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description that can be used to identify the event notification rule after creation
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Notifications will be sent only for objects with this prefix
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Notifications will be sent only for objects with this suffix
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class R2BucketLifecycleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abortMultipartUploadsTransition":
            suggest = "abort_multipart_uploads_transition"
        elif key == "deleteObjectsTransition":
            suggest = "delete_objects_transition"
        elif key == "storageClassTransitions":
            suggest = "storage_class_transitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketLifecycleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketLifecycleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketLifecycleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: 'outputs.R2BucketLifecycleRuleConditions',
                 enabled: bool,
                 id: str,
                 abort_multipart_uploads_transition: Optional['outputs.R2BucketLifecycleRuleAbortMultipartUploadsTransition'] = None,
                 delete_objects_transition: Optional['outputs.R2BucketLifecycleRuleDeleteObjectsTransition'] = None,
                 storage_class_transitions: Optional[Sequence['outputs.R2BucketLifecycleRuleStorageClassTransition']] = None):
        """
        :param 'R2BucketLifecycleRuleConditionsArgs' conditions: Conditions that apply to all transitions of this rule
        :param bool enabled: Whether or not this rule is in effect
        :param str id: Unique identifier for this rule
        :param 'R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs' abort_multipart_uploads_transition: Transition to abort ongoing multipart uploads
        :param 'R2BucketLifecycleRuleDeleteObjectsTransitionArgs' delete_objects_transition: Transition to delete objects
        :param Sequence['R2BucketLifecycleRuleStorageClassTransitionArgs'] storage_class_transitions: Transitions to change the storage class of objects
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if abort_multipart_uploads_transition is not None:
            pulumi.set(__self__, "abort_multipart_uploads_transition", abort_multipart_uploads_transition)
        if delete_objects_transition is not None:
            pulumi.set(__self__, "delete_objects_transition", delete_objects_transition)
        if storage_class_transitions is not None:
            pulumi.set(__self__, "storage_class_transitions", storage_class_transitions)

    @property
    @pulumi.getter
    def conditions(self) -> 'outputs.R2BucketLifecycleRuleConditions':
        """
        Conditions that apply to all transitions of this rule
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not this rule is in effect
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for this rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="abortMultipartUploadsTransition")
    def abort_multipart_uploads_transition(self) -> Optional['outputs.R2BucketLifecycleRuleAbortMultipartUploadsTransition']:
        """
        Transition to abort ongoing multipart uploads
        """
        return pulumi.get(self, "abort_multipart_uploads_transition")

    @property
    @pulumi.getter(name="deleteObjectsTransition")
    def delete_objects_transition(self) -> Optional['outputs.R2BucketLifecycleRuleDeleteObjectsTransition']:
        """
        Transition to delete objects
        """
        return pulumi.get(self, "delete_objects_transition")

    @property
    @pulumi.getter(name="storageClassTransitions")
    def storage_class_transitions(self) -> Optional[Sequence['outputs.R2BucketLifecycleRuleStorageClassTransition']]:
        """
        Transitions to change the storage class of objects
        """
        return pulumi.get(self, "storage_class_transitions")


@pulumi.output_type
class R2BucketLifecycleRuleAbortMultipartUploadsTransition(dict):
    def __init__(__self__, *,
                 condition: Optional['outputs.R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition'] = None):
        """
        :param 'R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs' condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional['outputs.R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition']:
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_age: int,
                 type: str):
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class R2BucketLifecycleRuleConditions(dict):
    def __init__(__self__, *,
                 prefix: str):
        """
        :param str prefix: Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class R2BucketLifecycleRuleDeleteObjectsTransition(dict):
    def __init__(__self__, *,
                 condition: Optional['outputs.R2BucketLifecycleRuleDeleteObjectsTransitionCondition'] = None):
        """
        :param 'R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs' condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional['outputs.R2BucketLifecycleRuleDeleteObjectsTransitionCondition']:
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class R2BucketLifecycleRuleDeleteObjectsTransitionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketLifecycleRuleDeleteObjectsTransitionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketLifecycleRuleDeleteObjectsTransitionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketLifecycleRuleDeleteObjectsTransitionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 date: Optional[str] = None,
                 max_age: Optional[int] = None):
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class R2BucketLifecycleRuleStorageClassTransition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketLifecycleRuleStorageClassTransition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketLifecycleRuleStorageClassTransition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketLifecycleRuleStorageClassTransition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.R2BucketLifecycleRuleStorageClassTransitionCondition',
                 storage_class: str):
        """
        :param 'R2BucketLifecycleRuleStorageClassTransitionConditionArgs' condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.R2BucketLifecycleRuleStorageClassTransitionCondition':
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class R2BucketLifecycleRuleStorageClassTransitionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketLifecycleRuleStorageClassTransitionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketLifecycleRuleStorageClassTransitionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketLifecycleRuleStorageClassTransitionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 date: Optional[str] = None,
                 max_age: Optional[int] = None):
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class R2BucketLockRule(dict):
    def __init__(__self__, *,
                 condition: 'outputs.R2BucketLockRuleCondition',
                 enabled: bool,
                 id: str,
                 prefix: Optional[str] = None):
        """
        :param 'R2BucketLockRuleConditionArgs' condition: Condition to apply a lock rule to an object for how long in seconds
        :param bool enabled: Whether or not this rule is in effect
        :param str id: Unique identifier for this rule
        :param str prefix: Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.R2BucketLockRuleCondition':
        """
        Condition to apply a lock rule to an object for how long in seconds
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not this rule is in effect
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for this rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class R2BucketLockRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAgeSeconds":
            suggest = "max_age_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketLockRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketLockRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketLockRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 date: Optional[str] = None,
                 max_age_seconds: Optional[int] = None):
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[int]:
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class R2BucketSippyDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketSippyDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketSippyDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketSippyDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[str] = None,
                 provider: Optional[str] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param str access_key_id: ID of a Cloudflare API token.
               This is the value labelled "Access Key ID" when creating an API
               token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
        :param str secret_access_key: Value of a Cloudflare API token.
               This is the value labelled "Secret Access Key" when creating an API
               token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
               
               Sippy will use this token when writing objects to R2, so it is
               best to scope this token to the bucket you're enabling Sippy for.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        ID of a Cloudflare API token.
        This is the value labelled "Access Key ID" when creating an API
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        Value of a Cloudflare API token.
        This is the value labelled "Secret Access Key" when creating an API
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).

        Sippy will use this token when writing objects to R2, so it is
        best to scope this token to the bucket you're enabling Sippy for.
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class R2BucketSippySource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in R2BucketSippySource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        R2BucketSippySource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        R2BucketSippySource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[str] = None,
                 bucket: Optional[str] = None,
                 client_email: Optional[str] = None,
                 private_key: Optional[str] = None,
                 provider: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param str access_key_id: Access Key ID of an IAM credential (ideally scoped to a single S3 bucket)
        :param str bucket: Name of the AWS S3 bucket
        :param str client_email: Client email of an IAM credential (ideally scoped to a single GCS bucket)
        :param str private_key: Private Key of an IAM credential (ideally scoped to a single GCS bucket)
        :param str region: Name of the AWS availability zone
        :param str secret_access_key: Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket)
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        Access Key ID of an IAM credential (ideally scoped to a single S3 bucket)
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        Name of the AWS S3 bucket
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        """
        Client email of an IAM credential (ideally scoped to a single GCS bucket)
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        Private Key of an IAM credential (ideally scoped to a single GCS bucket)
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Name of the AWS availability zone
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket)
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class R2CustomDomainStatus(dict):
    def __init__(__self__, *,
                 ownership: Optional[str] = None,
                 ssl: Optional[str] = None):
        """
        :param str ownership: Ownership status of the domain
        :param str ssl: SSL certificate status
        """
        if ownership is not None:
            pulumi.set(__self__, "ownership", ownership)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)

    @property
    @pulumi.getter
    def ownership(self) -> Optional[str]:
        """
        Ownership status of the domain
        """
        return pulumi.get(self, "ownership")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        SSL certificate status
        """
        return pulumi.get(self, "ssl")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class RateLimitAction(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 response: Optional['outputs.RateLimitActionResponse'] = None,
                 timeout: Optional[float] = None):
        """
        :param str mode: The action to perform.
        :param 'RateLimitActionResponseArgs' response: A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
               Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        :param float timeout: The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
               Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The action to perform.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RateLimitActionResponse']:
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[float]:
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RateLimitActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 content_type: Optional[str] = None):
        """
        :param str body: The response body to return. The value must conform to the configured content type.
        :param str content_type: The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The response body to return. The value must conform to the configured content type.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        return pulumi.get(self, "content_type")


@pulumi.output_type
class RateLimitBypass(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: The URL to bypass.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The URL to bypass.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RateLimitMatch(dict):
    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.RateLimitMatchHeader']] = None,
                 request: Optional['outputs.RateLimitMatchRequest'] = None,
                 response: Optional['outputs.RateLimitMatchResponse'] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RateLimitMatchHeader']]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.RateLimitMatchRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RateLimitMatchResponse']:
        return pulumi.get(self, "response")


@pulumi.output_type
class RateLimitMatchHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 op: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the response header to match.
        :param str op: The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        :param str value: The value of the response header, which must match exactly.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the response header to match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the response header, which must match exactly.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RateLimitMatchRequest(dict):
    def __init__(__self__, *,
                 methods: Optional[Sequence[str]] = None,
                 schemes: Optional[Sequence[str]] = None,
                 url: Optional[str] = None):
        """
        :param Sequence[str] methods: The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        :param Sequence[str] schemes: The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        :param str url: The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if schemes is not None:
            pulumi.set(__self__, "schemes", schemes)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[str]]:
        """
        The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def schemes(self) -> Optional[Sequence[str]]:
        """
        The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        """
        return pulumi.get(self, "schemes")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class RateLimitMatchResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originTraffic":
            suggest = "origin_traffic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitMatchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitMatchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitMatchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_traffic: Optional[bool] = None):
        """
        :param bool origin_traffic: When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
               Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        if origin_traffic is not None:
            pulumi.set(__self__, "origin_traffic", origin_traffic)

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> Optional[bool]:
        """
        When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
        Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        return pulumi.get(self, "origin_traffic")


@pulumi.output_type
class RecordData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "digestType":
            suggest = "digest_type"
        elif key == "keyTag":
            suggest = "key_tag"
        elif key == "latDegrees":
            suggest = "lat_degrees"
        elif key == "latDirection":
            suggest = "lat_direction"
        elif key == "latMinutes":
            suggest = "lat_minutes"
        elif key == "latSeconds":
            suggest = "lat_seconds"
        elif key == "longDegrees":
            suggest = "long_degrees"
        elif key == "longDirection":
            suggest = "long_direction"
        elif key == "longMinutes":
            suggest = "long_minutes"
        elif key == "longSeconds":
            suggest = "long_seconds"
        elif key == "matchingType":
            suggest = "matching_type"
        elif key == "precisionHorz":
            suggest = "precision_horz"
        elif key == "precisionVert":
            suggest = "precision_vert"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[float] = None,
                 altitude: Optional[float] = None,
                 certificate: Optional[str] = None,
                 digest: Optional[str] = None,
                 digest_type: Optional[float] = None,
                 fingerprint: Optional[str] = None,
<<<<<<< HEAD
                 flags: Optional[Any] = None,
=======
                 flags: Optional[float] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 key_tag: Optional[float] = None,
                 lat_degrees: Optional[float] = None,
                 lat_direction: Optional[str] = None,
                 lat_minutes: Optional[float] = None,
                 lat_seconds: Optional[float] = None,
                 long_degrees: Optional[float] = None,
                 long_direction: Optional[str] = None,
                 long_minutes: Optional[float] = None,
                 long_seconds: Optional[float] = None,
                 matching_type: Optional[float] = None,
                 order: Optional[float] = None,
                 port: Optional[float] = None,
                 precision_horz: Optional[float] = None,
                 precision_vert: Optional[float] = None,
                 preference: Optional[float] = None,
                 priority: Optional[float] = None,
                 protocol: Optional[float] = None,
                 public_key: Optional[str] = None,
                 regex: Optional[str] = None,
                 replacement: Optional[str] = None,
                 selector: Optional[float] = None,
                 service: Optional[str] = None,
                 size: Optional[float] = None,
                 tag: Optional[str] = None,
                 target: Optional[str] = None,
                 type: Optional[float] = None,
                 usage: Optional[float] = None,
                 value: Optional[str] = None,
                 weight: Optional[float] = None):
        """
        :param float algorithm: Algorithm.
        :param float altitude: Altitude of location in meters.
        :param str certificate: Certificate.
        :param str digest: Digest.
        :param float digest_type: Digest Type.
        :param str fingerprint: fingerprint.
<<<<<<< HEAD
        :param Any flags: Flags for the CAA record.
=======
        :param float flags: Flags for the CAA record.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        :param float key_tag: Key Tag.
        :param float lat_degrees: Degrees of latitude.
        :param str lat_direction: Latitude direction.
        :param float lat_minutes: Minutes of latitude.
        :param float lat_seconds: Seconds of latitude.
        :param float long_degrees: Degrees of longitude.
        :param str long_direction: Longitude direction.
        :param float long_minutes: Minutes of longitude.
        :param float long_seconds: Seconds of longitude.
        :param float matching_type: Matching Type.
        :param float order: Order.
        :param float port: The port of the service.
        :param float precision_horz: Horizontal precision of location.
        :param float precision_vert: Vertical precision of location.
        :param float preference: Preference.
        :param float priority: priority.
        :param float protocol: Protocol.
        :param str public_key: Public Key.
        :param str regex: Regex.
        :param str replacement: Replacement.
        :param float selector: Selector.
        :param str service: Service.
        :param float size: Size of location in meters.
        :param str tag: Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        :param str target: target.
        :param float type: Type.
        :param float usage: Usage.
        :param str value: Value of the record. This field's semantics depend on the chosen tag.
        :param float weight: The record weight.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[float]:
        """
        Algorithm.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def altitude(self) -> Optional[float]:
        """
        Altitude of location in meters.
        """
        return pulumi.get(self, "altitude")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        """
        Digest.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[float]:
        """
        Digest Type.
        """
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        """
        fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
<<<<<<< HEAD
    def flags(self) -> Optional[Any]:
=======
    def flags(self) -> Optional[float]:
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        """
        Flags for the CAA record.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[float]:
        """
        Key Tag.
        """
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[float]:
        """
        Degrees of latitude.
        """
        return pulumi.get(self, "lat_degrees")

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[str]:
        """
        Latitude direction.
        """
        return pulumi.get(self, "lat_direction")

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[float]:
        """
        Minutes of latitude.
        """
        return pulumi.get(self, "lat_minutes")

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[float]:
        """
        Seconds of latitude.
        """
        return pulumi.get(self, "lat_seconds")

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[float]:
        """
        Degrees of longitude.
        """
        return pulumi.get(self, "long_degrees")

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[str]:
        """
        Longitude direction.
        """
        return pulumi.get(self, "long_direction")

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[float]:
        """
        Minutes of longitude.
        """
        return pulumi.get(self, "long_minutes")

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[float]:
        """
        Seconds of longitude.
        """
        return pulumi.get(self, "long_seconds")

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[float]:
        """
        Matching Type.
        """
        return pulumi.get(self, "matching_type")

    @property
    @pulumi.getter
    def order(self) -> Optional[float]:
        """
        Order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[float]:
        """
        Horizontal precision of location.
        """
        return pulumi.get(self, "precision_horz")

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[float]:
        """
        Vertical precision of location.
        """
        return pulumi.get(self, "precision_vert")

    @property
    @pulumi.getter
    def preference(self) -> Optional[float]:
        """
        Preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[float]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        Regex.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        """
        Replacement.
        """
        return pulumi.get(self, "replacement")

    @property
    @pulumi.getter
    def selector(self) -> Optional[float]:
        """
        Selector.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def size(self) -> Optional[float]:
        """
        Size of location in meters.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        target.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[float]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> Optional[float]:
        """
        Usage.
        """
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        The record weight.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class RecordSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flattenCname":
            suggest = "flatten_cname"
        elif key == "ipv4Only":
            suggest = "ipv4_only"
        elif key == "ipv6Only":
            suggest = "ipv6_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flatten_cname: Optional[bool] = None,
                 ipv4_only: Optional[bool] = None,
                 ipv6_only: Optional[bool] = None):
        """
        :param bool flatten_cname: If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        :param bool ipv4_only: When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        :param bool ipv6_only: When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        if flatten_cname is not None:
            pulumi.set(__self__, "flatten_cname", flatten_cname)
        if ipv4_only is not None:
            pulumi.set(__self__, "ipv4_only", ipv4_only)
        if ipv6_only is not None:
            pulumi.set(__self__, "ipv6_only", ipv6_only)

    @property
    @pulumi.getter(name="flattenCname")
    def flatten_cname(self) -> Optional[bool]:
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        return pulumi.get(self, "flatten_cname")

    @property
    @pulumi.getter(name="ipv4Only")
    def ipv4_only(self) -> Optional[bool]:
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv4_only")

    @property
    @pulumi.getter(name="ipv6Only")
    def ipv6_only(self) -> Optional[bool]:
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv6_only")


@pulumi.output_type
class RulesetRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionParameters":
            suggest = "action_parameters"
        elif key == "exposedCredentialCheck":
            suggest = "exposed_credential_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 action_parameters: Optional['outputs.RulesetRuleActionParameters'] = None,
                 categories: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 exposed_credential_check: Optional['outputs.RulesetRuleExposedCredentialCheck'] = None,
                 expression: Optional[str] = None,
                 id: Optional[str] = None,
                 logging: Optional['outputs.RulesetRuleLogging'] = None,
                 ratelimit: Optional['outputs.RulesetRuleRatelimit'] = None,
                 ref: Optional[str] = None):
        """
        :param str action: The action to perform when the rule matches.
        :param 'RulesetRuleActionParametersArgs' action_parameters: The parameters configuring the rule's action.
        :param Sequence[str] categories: The categories of the rule.
        :param str description: An informative description of the rule.
        :param bool enabled: Whether the rule should be executed.
        :param 'RulesetRuleExposedCredentialCheckArgs' exposed_credential_check: Configure checks for exposed credentials.
        :param str expression: The expression defining which traffic will match the rule.
        :param str id: The unique ID of the rule.
        :param 'RulesetRuleLoggingArgs' logging: An object configuring the rule's logging behavior.
        :param 'RulesetRuleRatelimitArgs' ratelimit: An object configuring the rule's ratelimit behavior.
        :param str ref: The reference of the rule (the rule ID by default).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to perform when the rule matches.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional['outputs.RulesetRuleActionParameters']:
        """
        The parameters configuring the rule's action.
        """
        return pulumi.get(self, "action_parameters")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[str]]:
        """
        The categories of the rule.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An informative description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the rule should be executed.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional['outputs.RulesetRuleExposedCredentialCheck']:
        """
        Configure checks for exposed credentials.
        """
        return pulumi.get(self, "exposed_credential_check")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The expression defining which traffic will match the rule.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The unique ID of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.RulesetRuleLogging']:
        """
        An object configuring the rule's logging behavior.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional['outputs.RulesetRuleRatelimit']:
        """
        An object configuring the rule's ratelimit behavior.
        """
        return pulumi.get(self, "ratelimit")

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        The reference of the rule (the rule ID by default).
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class RulesetRuleActionParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalCacheablePorts":
            suggest = "additional_cacheable_ports"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "browserTtl":
            suggest = "browser_ttl"
        elif key == "cacheKey":
            suggest = "cache_key"
        elif key == "cacheReserve":
            suggest = "cache_reserve"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "cookieFields":
            suggest = "cookie_fields"
        elif key == "disableApps":
            suggest = "disable_apps"
        elif key == "disableRum":
            suggest = "disable_rum"
        elif key == "disableZaraz":
            suggest = "disable_zaraz"
        elif key == "edgeTtl":
            suggest = "edge_ttl"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "fromList":
            suggest = "from_list"
        elif key == "fromValue":
            suggest = "from_value"
        elif key == "hostHeader":
            suggest = "host_header"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "matchedData":
            suggest = "matched_data"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "originCacheControl":
            suggest = "origin_cache_control"
        elif key == "originErrorPagePassthru":
            suggest = "origin_error_page_passthru"
        elif key == "readTimeout":
            suggest = "read_timeout"
        elif key == "requestFields":
            suggest = "request_fields"
        elif key == "respectStrongEtags":
            suggest = "respect_strong_etags"
        elif key == "responseFields":
            suggest = "response_fields"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serveStale":
            suggest = "serve_stale"
        elif key == "serverSideExcludes":
            suggest = "server_side_excludes"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_cacheable_ports: Optional[Sequence[int]] = None,
                 algorithms: Optional[Sequence['outputs.RulesetRuleActionParametersAlgorithm']] = None,
                 automatic_https_rewrites: Optional[bool] = None,
                 autominify: Optional['outputs.RulesetRuleActionParametersAutominify'] = None,
                 bic: Optional[bool] = None,
                 browser_ttl: Optional['outputs.RulesetRuleActionParametersBrowserTtl'] = None,
                 cache: Optional[bool] = None,
                 cache_key: Optional['outputs.RulesetRuleActionParametersCacheKey'] = None,
                 cache_reserve: Optional['outputs.RulesetRuleActionParametersCacheReserve'] = None,
                 content: Optional[str] = None,
                 content_type: Optional[str] = None,
                 cookie_fields: Optional[Sequence['outputs.RulesetRuleActionParametersCookieField']] = None,
                 disable_apps: Optional[bool] = None,
                 disable_rum: Optional[bool] = None,
                 disable_zaraz: Optional[bool] = None,
                 edge_ttl: Optional['outputs.RulesetRuleActionParametersEdgeTtl'] = None,
                 email_obfuscation: Optional[bool] = None,
                 fonts: Optional[bool] = None,
                 from_list: Optional['outputs.RulesetRuleActionParametersFromList'] = None,
                 from_value: Optional['outputs.RulesetRuleActionParametersFromValue'] = None,
                 headers: Optional[Mapping[str, 'outputs.RulesetRuleActionParametersHeaders']] = None,
                 host_header: Optional[str] = None,
                 hotlink_protection: Optional[bool] = None,
                 id: Optional[str] = None,
                 increment: Optional[int] = None,
                 matched_data: Optional['outputs.RulesetRuleActionParametersMatchedData'] = None,
                 mirage: Optional[bool] = None,
                 opportunistic_encryption: Optional[bool] = None,
                 origin: Optional['outputs.RulesetRuleActionParametersOrigin'] = None,
                 origin_cache_control: Optional[bool] = None,
                 origin_error_page_passthru: Optional[bool] = None,
                 overrides: Optional['outputs.RulesetRuleActionParametersOverrides'] = None,
                 phases: Optional[Sequence[str]] = None,
                 polish: Optional[str] = None,
                 products: Optional[Sequence[str]] = None,
                 read_timeout: Optional[int] = None,
                 request_fields: Optional[Sequence['outputs.RulesetRuleActionParametersRequestField']] = None,
                 respect_strong_etags: Optional[bool] = None,
                 response: Optional['outputs.RulesetRuleActionParametersResponse'] = None,
                 response_fields: Optional[Sequence['outputs.RulesetRuleActionParametersResponseField']] = None,
                 rocket_loader: Optional[bool] = None,
                 rules: Optional[Mapping[str, Sequence[str]]] = None,
                 ruleset: Optional[str] = None,
                 rulesets: Optional[Sequence[str]] = None,
                 security_level: Optional[str] = None,
                 serve_stale: Optional['outputs.RulesetRuleActionParametersServeStale'] = None,
                 server_side_excludes: Optional[bool] = None,
                 sni: Optional['outputs.RulesetRuleActionParametersSni'] = None,
                 ssl: Optional[str] = None,
                 status_code: Optional[float] = None,
                 sxg: Optional[bool] = None,
                 uri: Optional['outputs.RulesetRuleActionParametersUri'] = None):
        """
        :param Sequence[int] additional_cacheable_ports: List of additional ports that caching can be enabled on.
        :param Sequence['RulesetRuleActionParametersAlgorithmArgs'] algorithms: Custom order for compression algorithms.
        :param bool automatic_https_rewrites: Turn on or off Automatic HTTPS Rewrites.
        :param 'RulesetRuleActionParametersAutominifyArgs' autominify: Select which file extensions to minify automatically.
        :param bool bic: Turn on or off Browser Integrity Check.
        :param 'RulesetRuleActionParametersBrowserTtlArgs' browser_ttl: Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        :param bool cache: Mark whether the request’s response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
        :param 'RulesetRuleActionParametersCacheKeyArgs' cache_key: Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
        :param 'RulesetRuleActionParametersCacheReserveArgs' cache_reserve: Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        :param str content: Error response content.
        :param str content_type: Content-type header to set with the response.
        :param Sequence['RulesetRuleActionParametersCookieFieldArgs'] cookie_fields: The cookie fields to log.
        :param bool disable_apps: Turn off all active Cloudflare Apps.
        :param bool disable_rum: Turn off Real User Monitoring (RUM).
        :param bool disable_zaraz: Turn off Zaraz.
        :param 'RulesetRuleActionParametersEdgeTtlArgs' edge_ttl: TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
        :param bool email_obfuscation: Turn on or off Email Obfuscation.
        :param bool fonts: Turn on or off Cloudflare Fonts.
        :param 'RulesetRuleActionParametersFromListArgs' from_list: Serve a redirect based on a bulk list lookup.
        :param 'RulesetRuleActionParametersFromValueArgs' from_value: Serve a redirect based on the request properties.
        :param Mapping[str, 'RulesetRuleActionParametersHeadersArgs'] headers: Map of request headers to modify.
        :param str host_header: Rewrite the HTTP Host header.
        :param bool hotlink_protection: Turn on or off the Hotlink Protection.
        :param str id: The ID of the ruleset to execute.
        :param int increment: Increment contains the delta to change the score and can be either positive or negative.
        :param 'RulesetRuleActionParametersMatchedDataArgs' matched_data: The configuration to use for matched data logging.
        :param bool mirage: Turn on or off Mirage.
        :param bool opportunistic_encryption: Turn on or off Opportunistic Encryption.
        :param 'RulesetRuleActionParametersOriginArgs' origin: Override the IP/TCP destination.
        :param bool origin_cache_control: When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
        :param bool origin_error_page_passthru: Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
        :param 'RulesetRuleActionParametersOverridesArgs' overrides: A set of overrides to apply to the target ruleset.
        :param Sequence[str] phases: A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
        :param str polish: Configure the Polish level.
        :param Sequence[str] products: A list of legacy security products to skip the execution of.
        :param int read_timeout: Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        :param Sequence['RulesetRuleActionParametersRequestFieldArgs'] request_fields: The request fields to log.
        :param bool respect_strong_etags: Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
        :param 'RulesetRuleActionParametersResponseArgs' response: The response to show when the block is applied.
        :param Sequence['RulesetRuleActionParametersResponseFieldArgs'] response_fields: The response fields to log.
        :param bool rocket_loader: Turn on or off Rocket Loader
        :param Mapping[str, Sequence[str]] rules: A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        :param str ruleset: A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
        :param Sequence[str] rulesets: A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        :param str security_level: Configure the Security Level.
        :param 'RulesetRuleActionParametersServeStaleArgs' serve_stale: Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
        :param bool server_side_excludes: Turn on or off Server Side Excludes.
        :param 'RulesetRuleActionParametersSniArgs' sni: Override the Server Name Indication (SNI).
        :param str ssl: Configure the SSL level.
        :param float status_code: The status code to use for the error.
        :param bool sxg: Turn on or off Signed Exchanges (SXG).
        :param 'RulesetRuleActionParametersUriArgs' uri: URI to rewrite the request to.
        """
        if additional_cacheable_ports is not None:
            pulumi.set(__self__, "additional_cacheable_ports", additional_cacheable_ports)
        if algorithms is not None:
            pulumi.set(__self__, "algorithms", algorithms)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if autominify is not None:
            pulumi.set(__self__, "autominify", autominify)
        if bic is not None:
            pulumi.set(__self__, "bic", bic)
        if browser_ttl is not None:
            pulumi.set(__self__, "browser_ttl", browser_ttl)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if cache_key is not None:
            pulumi.set(__self__, "cache_key", cache_key)
        if cache_reserve is not None:
            pulumi.set(__self__, "cache_reserve", cache_reserve)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if cookie_fields is not None:
            pulumi.set(__self__, "cookie_fields", cookie_fields)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_rum is not None:
            pulumi.set(__self__, "disable_rum", disable_rum)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            pulumi.set(__self__, "edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if from_list is not None:
            pulumi.set(__self__, "from_list", from_list)
        if from_value is not None:
            pulumi.set(__self__, "from_value", from_value)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_cache_control is not None:
            pulumi.set(__self__, "origin_cache_control", origin_cache_control)
        if origin_error_page_passthru is not None:
            pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if request_fields is not None:
            pulumi.set(__self__, "request_fields", request_fields)
        if respect_strong_etags is not None:
            pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if response_fields is not None:
            pulumi.set(__self__, "response_fields", response_fields)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if serve_stale is not None:
            pulumi.set(__self__, "serve_stale", serve_stale)
        if server_side_excludes is not None:
            pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if sxg is not None:
            pulumi.set(__self__, "sxg", sxg)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="additionalCacheablePorts")
    def additional_cacheable_ports(self) -> Optional[Sequence[int]]:
        """
        List of additional ports that caching can be enabled on.
        """
        return pulumi.get(self, "additional_cacheable_ports")

    @property
    @pulumi.getter
    def algorithms(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersAlgorithm']]:
        """
        Custom order for compression algorithms.
        """
        return pulumi.get(self, "algorithms")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[bool]:
        """
        Turn on or off Automatic HTTPS Rewrites.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter
    def autominify(self) -> Optional['outputs.RulesetRuleActionParametersAutominify']:
        """
        Select which file extensions to minify automatically.
        """
        return pulumi.get(self, "autominify")

    @property
    @pulumi.getter
    def bic(self) -> Optional[bool]:
        """
        Turn on or off Browser Integrity Check.
        """
        return pulumi.get(self, "bic")

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional['outputs.RulesetRuleActionParametersBrowserTtl']:
        """
        Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        """
        return pulumi.get(self, "browser_ttl")

    @property
    @pulumi.getter
    def cache(self) -> Optional[bool]:
        """
        Mark whether the request’s response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
        """
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional['outputs.RulesetRuleActionParametersCacheKey']:
        """
        Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
        """
        return pulumi.get(self, "cache_key")

    @property
    @pulumi.getter(name="cacheReserve")
    def cache_reserve(self) -> Optional['outputs.RulesetRuleActionParametersCacheReserve']:
        """
        Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        """
        return pulumi.get(self, "cache_reserve")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Error response content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        Content-type header to set with the response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersCookieField']]:
        """
        The cookie fields to log.
        """
        return pulumi.get(self, "cookie_fields")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[bool]:
        """
        Turn off all active Cloudflare Apps.
        """
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disableRum")
    def disable_rum(self) -> Optional[bool]:
        """
        Turn off Real User Monitoring (RUM).
        """
        return pulumi.get(self, "disable_rum")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[bool]:
        """
        Turn off Zaraz.
        """
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional['outputs.RulesetRuleActionParametersEdgeTtl']:
        """
        TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
        """
        return pulumi.get(self, "edge_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[bool]:
        """
        Turn on or off Email Obfuscation.
        """
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter
    def fonts(self) -> Optional[bool]:
        """
        Turn on or off Cloudflare Fonts.
        """
        return pulumi.get(self, "fonts")

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional['outputs.RulesetRuleActionParametersFromList']:
        """
        Serve a redirect based on a bulk list lookup.
        """
        return pulumi.get(self, "from_list")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional['outputs.RulesetRuleActionParametersFromValue']:
        """
        Serve a redirect based on the request properties.
        """
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, 'outputs.RulesetRuleActionParametersHeaders']]:
        """
        Map of request headers to modify.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        Rewrite the HTTP Host header.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[bool]:
        """
        Turn on or off the Hotlink Protection.
        """
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the ruleset to execute.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def increment(self) -> Optional[int]:
        """
        Increment contains the delta to change the score and can be either positive or negative.
        """
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional['outputs.RulesetRuleActionParametersMatchedData']:
        """
        The configuration to use for matched data logging.
        """
        return pulumi.get(self, "matched_data")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[bool]:
        """
        Turn on or off Mirage.
        """
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[bool]:
        """
        Turn on or off Opportunistic Encryption.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter
    def origin(self) -> Optional['outputs.RulesetRuleActionParametersOrigin']:
        """
        Override the IP/TCP destination.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="originCacheControl")
    def origin_cache_control(self) -> Optional[bool]:
        """
        When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
        """
        return pulumi.get(self, "origin_cache_control")

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[bool]:
        """
        Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
        """
        return pulumi.get(self, "origin_error_page_passthru")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.RulesetRuleActionParametersOverrides']:
        """
        A set of overrides to apply to the target ruleset.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def phases(self) -> Optional[Sequence[str]]:
        """
        A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
        """
        return pulumi.get(self, "phases")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        """
        Configure the Polish level.
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[str]]:
        """
        A list of legacy security products to skip the execution of.
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[int]:
        """
        Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersRequestField']]:
        """
        The request fields to log.
        """
        return pulumi.get(self, "request_fields")

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[bool]:
        """
        Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
        """
        return pulumi.get(self, "respect_strong_etags")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RulesetRuleActionParametersResponse']:
        """
        The response to show when the block is applied.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersResponseField']]:
        """
        The response fields to log.
        """
        return pulumi.get(self, "response_fields")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[bool]:
        """
        Turn on or off Rocket Loader
        """
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[str]:
        """
        A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
        """
        return pulumi.get(self, "ruleset")

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[Sequence[str]]:
        """
        A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        """
        return pulumi.get(self, "rulesets")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        Configure the Security Level.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional['outputs.RulesetRuleActionParametersServeStale']:
        """
        Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        return pulumi.get(self, "serve_stale")

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[bool]:
        """
        Turn on or off Server Side Excludes.
        """
        return pulumi.get(self, "server_side_excludes")

    @property
    @pulumi.getter
    def sni(self) -> Optional['outputs.RulesetRuleActionParametersSni']:
        """
        Override the Server Name Indication (SNI).
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Configure the SSL level.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[float]:
        """
        The status code to use for the error.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def sxg(self) -> Optional[bool]:
        """
        Turn on or off Signed Exchanges (SXG).
        """
        return pulumi.get(self, "sxg")

    @property
    @pulumi.getter
    def uri(self) -> Optional['outputs.RulesetRuleActionParametersUri']:
        """
        URI to rewrite the request to.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class RulesetRuleActionParametersAlgorithm(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of compression algorithm to enable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of compression algorithm to enable.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersAutominify(dict):
    def __init__(__self__, *,
                 css: Optional[bool] = None,
                 html: Optional[bool] = None,
                 js: Optional[bool] = None):
        """
        :param bool css: Minify CSS files.
        :param bool html: Minify HTML files.
        :param bool js: Minify JS files.
        """
        if css is not None:
            pulumi.set(__self__, "css", css)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if js is not None:
            pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> Optional[bool]:
        """
        Minify CSS files.
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> Optional[bool]:
        """
        Minify HTML files.
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> Optional[bool]:
        """
        Minify JS files.
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class RulesetRuleActionParametersBrowserTtl(dict):
    def __init__(__self__, *,
                 mode: str,
                 default: Optional[int] = None):
        """
        :param str mode: Determines which browser ttl mode to use.
        :param int default: The TTL (in seconds) if you choose override_origin mode.
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines which browser ttl mode to use.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        """
        The TTL (in seconds) if you choose override_origin mode.
        """
        return pulumi.get(self, "default")


@pulumi.output_type
class RulesetRuleActionParametersCacheKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheByDeviceType":
            suggest = "cache_by_device_type"
        elif key == "cacheDeceptionArmor":
            suggest = "cache_deception_armor"
        elif key == "customKey":
            suggest = "custom_key"
        elif key == "ignoreQueryStringsOrder":
            suggest = "ignore_query_strings_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_by_device_type: Optional[bool] = None,
                 cache_deception_armor: Optional[bool] = None,
                 custom_key: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKey'] = None,
                 ignore_query_strings_order: Optional[bool] = None):
        """
        :param bool cache_by_device_type: Separate cached content based on the visitor’s device type
        :param bool cache_deception_armor: Protect from web cache deception attacks while allowing static assets to be cached
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyArgs' custom_key: Customize which components of the request are included or excluded from the cache key.
        :param bool ignore_query_strings_order: Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
        """
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if ignore_query_strings_order is not None:
            pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[bool]:
        """
        Separate cached content based on the visitor’s device type
        """
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[bool]:
        """
        Protect from web cache deception attacks while allowing static assets to be cached
        """
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKey']:
        """
        Customize which components of the request are included or excluded from the cache key.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[bool]:
        """
        Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
        """
        return pulumi.get(self, "ignore_query_strings_order")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie'] = None,
                 header: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader'] = None,
                 host: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost'] = None,
                 query_string: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString'] = None,
                 user: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser'] = None):
        """
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs' cookie: The cookies to include in building the cache key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs' header: The header names and values to include in building the cache key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyHostArgs' host: Whether to use the original host or the resolved host in the cache key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs' query_string: Use the presence of parameters in the query string to build the cache key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyUserArgs' user: Characteristics of the request user agent used in building the cache key.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie']:
        """
        The cookies to include in building the cache key.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader']:
        """
        The header names and values to include in building the cache key.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def host(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost']:
        """
        Whether to use the original host or the resolved host in the cache key.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString']:
        """
        Use the presence of parameters in the query string to build the cache key.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser']:
        """
        Characteristics of the request user agent used in building the cache key.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] check_presences: Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
        :param Sequence[str] includes: Include these cookies' names and their values.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        """
        Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Include these cookies' names and their values.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"
        elif key == "excludeOrigin":
            suggest = "exclude_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 contains: Optional[Mapping[str, Sequence[str]]] = None,
                 exclude_origin: Optional[bool] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] check_presences: Checks for the presence of these header names. The presence of these headers is used in building the cache key.
        :param Mapping[str, Sequence[str]] contains: For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
        :param bool exclude_origin: Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
        :param Sequence[str] includes: Include these headers' names and their values.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exclude_origin is not None:
            pulumi.set(__self__, "exclude_origin", exclude_origin)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        """
        Checks for the presence of these header names. The presence of these headers is used in building the cache key.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def contains(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[bool]:
        """
        Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
        """
        return pulumi.get(self, "exclude_origin")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Include these headers' names and their values.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyHost(dict):
    def __init__(__self__, *,
                 resolved: Optional[bool] = None):
        """
        :param bool resolved: Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[bool]:
        """
        Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
        """
        return pulumi.get(self, "resolved")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryString(dict):
    def __init__(__self__, *,
                 exclude: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude'] = None,
                 include: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude'] = None):
        """
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs' exclude: A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs' include: A list of query string parameters used to build the cache key.
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)

    @property
    @pulumi.getter
    def exclude(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude']:
        """
        A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
        """
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter
    def include(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude']:
        """
        A list of query string parameters used to build the cache key.
        """
        return pulumi.get(self, "include")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude(dict):
    def __init__(__self__, *,
                 all: Optional[bool] = None,
                 lists: Optional[Sequence[str]] = None):
        """
        :param bool all: Determines whether to exclude all query string parameters from the cache key.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if lists is not None:
            pulumi.set(__self__, "lists", lists)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Determines whether to exclude all query string parameters from the cache key.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter
    def lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "lists")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude(dict):
    def __init__(__self__, *,
                 all: Optional[bool] = None,
                 lists: Optional[Sequence[str]] = None):
        """
        :param bool all: Determines whether to include all query string parameters in the cache key.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if lists is not None:
            pulumi.set(__self__, "lists", lists)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Determines whether to include all query string parameters in the cache key.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter
    def lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "lists")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_type: Optional[bool] = None,
                 geo: Optional[bool] = None,
                 lang: Optional[bool] = None):
        """
        :param bool device_type: Use the user agent's device type in the cache key.
        :param bool geo: Use the user agents's country in the cache key.
        :param bool lang: Use the user agent's language in the cache key.
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[bool]:
        """
        Use the user agent's device type in the cache key.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[bool]:
        """
        Use the user agents's country in the cache key.
        """
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[bool]:
        """
        Use the user agent's language in the cache key.
        """
        return pulumi.get(self, "lang")


@pulumi.output_type
class RulesetRuleActionParametersCacheReserve(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumFileSize":
            suggest = "minimum_file_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheReserve. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheReserve.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheReserve.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eligible: bool,
                 minimum_file_size: int):
        """
        :param bool eligible: Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
        :param int minimum_file_size: The minimum file size eligible for store in cache reserve.
        """
        pulumi.set(__self__, "eligible", eligible)
        pulumi.set(__self__, "minimum_file_size", minimum_file_size)

    @property
    @pulumi.getter
    def eligible(self) -> bool:
        """
        Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
        """
        return pulumi.get(self, "eligible")

    @property
    @pulumi.getter(name="minimumFileSize")
    def minimum_file_size(self) -> int:
        """
        The minimum file size eligible for store in cache reserve.
        """
        return pulumi.get(self, "minimum_file_size")


@pulumi.output_type
class RulesetRuleActionParametersCookieField(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeTtls":
            suggest = "status_code_ttls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: str,
                 default: Optional[int] = None,
                 status_code_ttls: Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl']] = None):
        """
        :param str mode: edge ttl options
        :param int default: The TTL (in seconds) if you choose override_origin mode.
        :param Sequence['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs'] status_code_ttls: List of single status codes, or status code ranges to apply the selected mode
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if status_code_ttls is not None:
            pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        edge ttl options
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        """
        The TTL (in seconds) if you choose override_origin mode.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl']]:
        """
        List of single status codes, or status code ranges to apply the selected mode
        """
        return pulumi.get(self, "status_code_ttls")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"
        elif key == "statusCodeRange":
            suggest = "status_code_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtlStatusCodeTtl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: int,
                 status_code: Optional[int] = None,
                 status_code_range: Optional['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange'] = None):
        """
        :param int value: Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
        :param int status_code: Set the ttl for responses with this specific status code
        :param 'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs' status_code_range: The range of status codes used to apply the selected mode.
        """
        pulumi.set(__self__, "value", value)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if status_code_range is not None:
            pulumi.set(__self__, "status_code_range", status_code_range)

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        Set the ttl for responses with this specific status code
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> Optional['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange']:
        """
        The range of status codes used to apply the selected mode.
        """
        return pulumi.get(self, "status_code_range")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        """
        :param int from_: response status code lower bound
        :param int to: response status code upper bound
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        """
        response status code lower bound
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        """
        response status code upper bound
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class RulesetRuleActionParametersFromList(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str key: Expression that evaluates to the list lookup key.
        :param str name: The name of the list to match against.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Expression that evaluates to the list lookup key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the list to match against.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preserveQueryString":
            suggest = "preserve_query_string"
        elif key == "statusCode":
            suggest = "status_code"
        elif key == "targetUrl":
            suggest = "target_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preserve_query_string: Optional[bool] = None,
                 status_code: Optional[float] = None,
                 target_url: Optional['outputs.RulesetRuleActionParametersFromValueTargetUrl'] = None):
        """
        :param bool preserve_query_string: Keep the query string of the original request.
        :param float status_code: The status code to be used for the redirect.
        :param 'RulesetRuleActionParametersFromValueTargetUrlArgs' target_url: The URL to redirect the request to.
        """
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[bool]:
        """
        Keep the query string of the original request.
        """
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[float]:
        """
        The status code to be used for the redirect.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional['outputs.RulesetRuleActionParametersFromValueTargetUrl']:
        """
        The URL to redirect the request to.
        """
        return pulumi.get(self, "target_url")


@pulumi.output_type
class RulesetRuleActionParametersFromValueTargetUrl(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str expression: An expression to evaluate to get the URL to redirect the request to.
        :param str value: The URL to redirect the request to.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        An expression to evaluate to get the URL to redirect the request to.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The URL to redirect the request to.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersHeaders(dict):
    def __init__(__self__, *,
                 operation: str,
                 expression: Optional[str] = None,
<<<<<<< HEAD
                 operation: Optional[str] = None,
=======
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 value: Optional[str] = None):
        """
        :param str expression: Expression for the header value.
        :param str value: Static value for the header.
        """
        pulumi.set(__self__, "operation", operation)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
<<<<<<< HEAD
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
=======
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Expression for the header value.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
<<<<<<< HEAD
    def operation(self) -> Optional[str]:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
=======
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    def value(self) -> Optional[str]:
        """
        Static value for the header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersMatchedData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersMatchedData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersMatchedData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersMatchedData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: str):
        """
        :param str public_key: The public key to encrypt matched data logs with.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The public key to encrypt matched data logs with.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class RulesetRuleActionParametersOrigin(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[float] = None):
        """
        :param str host: Override the resolved hostname.
        :param float port: Override the destination port.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Override the resolved hostname.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        Override the destination port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RulesetRuleActionParametersOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 categories: Optional[Sequence['outputs.RulesetRuleActionParametersOverridesCategory']] = None,
                 enabled: Optional[bool] = None,
                 rules: Optional[Sequence['outputs.RulesetRuleActionParametersOverridesRule']] = None,
                 sensitivity_level: Optional[str] = None):
        """
        :param str action: An action to override all rules with. This option has lower precedence than rule and category overrides.
        :param Sequence['RulesetRuleActionParametersOverridesCategoryArgs'] categories: A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        :param bool enabled: Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        :param Sequence['RulesetRuleActionParametersOverridesRuleArgs'] rules: A list of rule-level overrides. This option has the highest precedence.
        :param str sensitivity_level: A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        An action to override all rules with. This option has lower precedence than rule and category overrides.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersOverridesCategory']]:
        """
        A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersOverridesRule']]:
        """
        A list of rule-level overrides. This option has the highest precedence.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[str]:
        """
        A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RulesetRuleActionParametersOverridesCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersOverridesCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersOverridesCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersOverridesCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 action: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 sensitivity_level: Optional[str] = None):
        """
        :param str category: The name of the category to override.
        :param str action: The action to override rules in the category with.
        :param bool enabled: Whether to enable execution of rules in the category.
        :param str sensitivity_level: The sensitivity level to use for rules in the category.
        """
        pulumi.set(__self__, "category", category)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The name of the category to override.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to override rules in the category with.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable execution of rules in the category.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[str]:
        """
        The sensitivity level to use for rules in the category.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RulesetRuleActionParametersOverridesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoreThreshold":
            suggest = "score_threshold"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersOverridesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersOverridesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersOverridesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 action: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 score_threshold: Optional[int] = None,
                 sensitivity_level: Optional[str] = None):
        """
        :param str id: The ID of the rule to override.
        :param str action: The action to override the rule with.
        :param bool enabled: Whether to enable execution of the rule.
        :param int score_threshold: The score threshold to use for the rule.
        :param str sensitivity_level: The sensitivity level to use for the rule.
        """
        pulumi.set(__self__, "id", id)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the rule to override.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to override the rule with.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable execution of the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[int]:
        """
        The score threshold to use for the rule.
        """
        return pulumi.get(self, "score_threshold")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[str]:
        """
        The sensitivity level to use for the rule.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RulesetRuleActionParametersRequestField(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 content_type: str,
                 status_code: int):
        """
        :param str content: The content to return.
        :param str content_type: The type of the content to return.
        :param int status_code: The status code to return.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content to return.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The type of the content to return.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The status code to return.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class RulesetRuleActionParametersResponseField(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersServeStale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableStaleWhileUpdating":
            suggest = "disable_stale_while_updating"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersServeStale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersServeStale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersServeStale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_stale_while_updating: bool):
        """
        :param bool disable_stale_while_updating: Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> bool:
        """
        Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        return pulumi.get(self, "disable_stale_while_updating")


@pulumi.output_type
class RulesetRuleActionParametersSni(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: The SNI override.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The SNI override.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersUri(dict):
    def __init__(__self__, *,
                 path: Optional['outputs.RulesetRuleActionParametersUriPath'] = None,
                 query: Optional['outputs.RulesetRuleActionParametersUriQuery'] = None):
        """
        :param 'RulesetRuleActionParametersUriPathArgs' path: Path portion rewrite.
        :param 'RulesetRuleActionParametersUriQueryArgs' query: Query portion rewrite.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.RulesetRuleActionParametersUriPath']:
        """
        Path portion rewrite.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> Optional['outputs.RulesetRuleActionParametersUriQuery']:
        """
        Query portion rewrite.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class RulesetRuleActionParametersUriPath(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str expression: Expression to evaluate for the replacement value.
        :param str value: Predefined replacement value.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Expression to evaluate for the replacement value.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Predefined replacement value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersUriQuery(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str expression: Expression to evaluate for the replacement value.
        :param str value: Predefined replacement value.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Expression to evaluate for the replacement value.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Predefined replacement value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleExposedCredentialCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordExpression":
            suggest = "password_expression"
        elif key == "usernameExpression":
            suggest = "username_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleExposedCredentialCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleExposedCredentialCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleExposedCredentialCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_expression: str,
                 username_expression: str):
        """
        :param str password_expression: Expression that selects the password used in the credentials check.
        :param str username_expression: Expression that selects the user ID used in the credentials check.
        """
        pulumi.set(__self__, "password_expression", password_expression)
        pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> str:
        """
        Expression that selects the password used in the credentials check.
        """
        return pulumi.get(self, "password_expression")

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> str:
        """
        Expression that selects the user ID used in the credentials check.
        """
        return pulumi.get(self, "username_expression")


@pulumi.output_type
class RulesetRuleLogging(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether to generate a log when the rule matches.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to generate a log when the rule matches.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RulesetRuleRatelimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countingExpression":
            suggest = "counting_expression"
        elif key == "mitigationTimeout":
            suggest = "mitigation_timeout"
        elif key == "requestsPerPeriod":
            suggest = "requests_per_period"
        elif key == "requestsToOrigin":
            suggest = "requests_to_origin"
        elif key == "scorePerPeriod":
            suggest = "score_per_period"
        elif key == "scoreResponseHeaderName":
            suggest = "score_response_header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleRatelimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleRatelimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleRatelimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 characteristics: Sequence[str],
                 period: int,
                 counting_expression: Optional[str] = None,
                 mitigation_timeout: Optional[int] = None,
                 requests_per_period: Optional[int] = None,
                 requests_to_origin: Optional[bool] = None,
                 score_per_period: Optional[int] = None,
                 score_response_header_name: Optional[str] = None):
        """
        :param Sequence[str] characteristics: Characteristics of the request on which the ratelimiter counter will be incremented.
        :param int period: Period in seconds over which the counter is being incremented.
        :param str counting_expression: Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
        :param int mitigation_timeout: Period of time in seconds after which the action will be disabled following its first execution.
        :param int requests_per_period: The threshold of requests per period after which the action will be executed for the first time.
        :param bool requests_to_origin: Defines if ratelimit counting is only done when an origin is reached.
        :param int score_per_period: The score threshold per period for which the action will be executed the first time.
        :param str score_response_header_name: The response header name provided by the origin which should contain the score to increment ratelimit counter on.
        """
        pulumi.set(__self__, "characteristics", characteristics)
        pulumi.set(__self__, "period", period)
        if counting_expression is not None:
            pulumi.set(__self__, "counting_expression", counting_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)
        if requests_to_origin is not None:
            pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        if score_per_period is not None:
            pulumi.set(__self__, "score_per_period", score_per_period)
        if score_response_header_name is not None:
            pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter
    def characteristics(self) -> Sequence[str]:
        """
        Characteristics of the request on which the ratelimiter counter will be incremented.
        """
        return pulumi.get(self, "characteristics")

    @property
    @pulumi.getter
    def period(self) -> int:
        """
        Period in seconds over which the counter is being incremented.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[str]:
        """
        Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
        """
        return pulumi.get(self, "counting_expression")

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[int]:
        """
        Period of time in seconds after which the action will be disabled following its first execution.
        """
        return pulumi.get(self, "mitigation_timeout")

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[int]:
        """
        The threshold of requests per period after which the action will be executed for the first time.
        """
        return pulumi.get(self, "requests_per_period")

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> Optional[bool]:
        """
        Defines if ratelimit counting is only done when an origin is reached.
        """
        return pulumi.get(self, "requests_to_origin")

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[int]:
        """
        The score threshold per period for which the action will be executed the first time.
        """
        return pulumi.get(self, "score_per_period")

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[str]:
        """
        The response header name provided by the origin which should contain the score to increment ratelimit counter on.
        """
        return pulumi.get(self, "score_response_header_name")


@pulumi.output_type
class SnippetRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snippetName":
            suggest = "snippet_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnippetRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnippetRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnippetRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 expression: Optional[str] = None,
                 snippet_name: Optional[str] = None):
        """
        :param str snippet_name: Snippet identifying name
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if snippet_name is not None:
            pulumi.set(__self__, "snippet_name", snippet_name)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="snippetName")
    def snippet_name(self) -> Optional[str]:
        """
        Snippet identifying name
        """
        return pulumi.get(self, "snippet_name")


@pulumi.output_type
class SnippetsMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mainModule":
            suggest = "main_module"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnippetsMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnippetsMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnippetsMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 main_module: Optional[str] = None):
        """
        :param str main_module: Main module name of uploaded snippet
        """
        if main_module is not None:
            pulumi.set(__self__, "main_module", main_module)

    @property
    @pulumi.getter(name="mainModule")
    def main_module(self) -> Optional[str]:
        """
        Main module name of uploaded snippet
        """
        return pulumi.get(self, "main_module")


@pulumi.output_type
class SpectrumApplicationDns(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the DNS record associated with the application.
        :param str type: The type of DNS record associated with the application.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the DNS record associated with the application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of DNS record associated with the application.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SpectrumApplicationEdgeIps(dict):
    def __init__(__self__, *,
                 connectivity: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str connectivity: The IP versions supported for inbound connections on Spectrum anycast IPs.
        :param Sequence[str] ips: The array of customer owned IPs we broadcast via anycast for this hostname and application.
        :param str type: The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        """
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def connectivity(self) -> Optional[str]:
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs.
        """
        return pulumi.get(self, "connectivity")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        The array of customer owned IPs we broadcast via anycast for this hostname and application.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SpectrumApplicationOriginDns(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 ttl: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the DNS record associated with the origin.
        :param int ttl: The TTL of our resolution of your DNS record in seconds.
        :param str type: The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the DNS record associated with the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        The TTL of our resolution of your DNS record in seconds.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class StreamInput(dict):
    def __init__(__self__, *,
                 height: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param int height: The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        :param int width: The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class StreamLiveInputRecording(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "hideLiveViewerCount":
            suggest = "hide_live_viewer_count"
        elif key == "requireSignedUrls":
            suggest = "require_signed_urls"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamLiveInputRecording. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamLiveInputRecording.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamLiveInputRecording.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 hide_live_viewer_count: Optional[bool] = None,
                 mode: Optional[str] = None,
                 require_signed_urls: Optional[bool] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param Sequence[str] allowed_origins: Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        :param bool hide_live_viewer_count: Disables reporting the number of live viewers when this property is set to `true`.
        :param str mode: Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        :param bool require_signed_urls: Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        :param int timeout_seconds: Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if hide_live_viewer_count is not None:
            pulumi.set(__self__, "hide_live_viewer_count", hide_live_viewer_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if require_signed_urls is not None:
            pulumi.set(__self__, "require_signed_urls", require_signed_urls)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="hideLiveViewerCount")
    def hide_live_viewer_count(self) -> Optional[bool]:
        """
        Disables reporting the number of live viewers when this property is set to `true`.
        """
        return pulumi.get(self, "hide_live_viewer_count")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="requireSignedUrls")
    def require_signed_urls(self) -> Optional[bool]:
        """
        Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        """
        return pulumi.get(self, "require_signed_urls")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class StreamLiveInputRtmps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamKey":
            suggest = "stream_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamLiveInputRtmps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamLiveInputRtmps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamLiveInputRtmps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stream_key: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str stream_key: The secret key to use when streaming via RTMPS to a live input.
        :param str url: The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
        if stream_key is not None:
            pulumi.set(__self__, "stream_key", stream_key)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="streamKey")
    def stream_key(self) -> Optional[str]:
        """
        The secret key to use when streaming via RTMPS to a live input.
        """
        return pulumi.get(self, "stream_key")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class StreamLiveInputRtmpsPlayback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamKey":
            suggest = "stream_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamLiveInputRtmpsPlayback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamLiveInputRtmpsPlayback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamLiveInputRtmpsPlayback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stream_key: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str stream_key: The secret key to use for playback via RTMPS.
        :param str url: The URL used to play live video over RTMPS.
        """
        if stream_key is not None:
            pulumi.set(__self__, "stream_key", stream_key)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="streamKey")
    def stream_key(self) -> Optional[str]:
        """
        The secret key to use for playback via RTMPS.
        """
        return pulumi.get(self, "stream_key")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL used to play live video over RTMPS.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class StreamLiveInputSrt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamLiveInputSrt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamLiveInputSrt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamLiveInputSrt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 passphrase: Optional[str] = None,
                 stream_id: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str passphrase: The secret key to use when streaming via SRT to a live input.
        :param str stream_id: The identifier of the live input to use when streaming via SRT.
        :param str url: The SRT URL you provide to the broadcaster, which they stream live video to.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        """
        The secret key to use when streaming via SRT to a live input.
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        """
        The identifier of the live input to use when streaming via SRT.
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The SRT URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class StreamLiveInputSrtPlayback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamLiveInputSrtPlayback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamLiveInputSrtPlayback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamLiveInputSrtPlayback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 passphrase: Optional[str] = None,
                 stream_id: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str passphrase: The secret key to use for playback via SRT.
        :param str stream_id: The identifier of the live input to use for playback via SRT.
        :param str url: The URL used to play live video over SRT.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        """
        The secret key to use for playback via SRT.
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        """
        The identifier of the live input to use for playback via SRT.
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL used to play live video over SRT.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class StreamLiveInputWebRtc(dict):
    def __init__(__self__, *,
                 url: Optional[str] = None):
        """
        :param str url: The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class StreamLiveInputWebRtcPlayback(dict):
    def __init__(__self__, *,
                 url: Optional[str] = None):
        """
        :param str url: The URL used to play live video over WebRTC.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL used to play live video over WebRTC.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class StreamPlayback(dict):
    def __init__(__self__, *,
                 dash: Optional[str] = None,
                 hls: Optional[str] = None):
        """
        :param str dash: DASH Media Presentation Description for the video.
        :param str hls: The HLS manifest for the video.
        """
        if dash is not None:
            pulumi.set(__self__, "dash", dash)
        if hls is not None:
            pulumi.set(__self__, "hls", hls)

    @property
    @pulumi.getter
    def dash(self) -> Optional[str]:
        """
        DASH Media Presentation Description for the video.
        """
        return pulumi.get(self, "dash")

    @property
    @pulumi.getter
    def hls(self) -> Optional[str]:
        """
        The HLS manifest for the video.
        """
        return pulumi.get(self, "hls")


@pulumi.output_type
class StreamStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorReasonCode":
            suggest = "error_reason_code"
        elif key == "errorReasonText":
            suggest = "error_reason_text"
        elif key == "pctComplete":
            suggest = "pct_complete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_reason_code: Optional[str] = None,
                 error_reason_text: Optional[str] = None,
                 pct_complete: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str error_reason_code: Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        :param str error_reason_text: Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        :param str pct_complete: Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        :param str state: Specifies the processing status for all quality levels for a video.
        """
        if error_reason_code is not None:
            pulumi.set(__self__, "error_reason_code", error_reason_code)
        if error_reason_text is not None:
            pulumi.set(__self__, "error_reason_text", error_reason_text)
        if pct_complete is not None:
            pulumi.set(__self__, "pct_complete", pct_complete)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="errorReasonCode")
    def error_reason_code(self) -> Optional[str]:
        """
        Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        """
        return pulumi.get(self, "error_reason_code")

    @property
    @pulumi.getter(name="errorReasonText")
    def error_reason_text(self) -> Optional[str]:
        """
        Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        """
        return pulumi.get(self, "error_reason_text")

    @property
    @pulumi.getter(name="pctComplete")
    def pct_complete(self) -> Optional[str]:
        """
        Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        """
        return pulumi.get(self, "pct_complete")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Specifies the processing status for all quality levels for a video.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class StreamWatermark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "downloadedFrom":
            suggest = "downloaded_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamWatermark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamWatermark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamWatermark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created: Optional[str] = None,
                 downloaded_from: Optional[str] = None,
                 height: Optional[int] = None,
                 name: Optional[str] = None,
                 opacity: Optional[float] = None,
                 padding: Optional[float] = None,
                 position: Optional[str] = None,
                 scale: Optional[float] = None,
                 size: Optional[float] = None,
                 uid: Optional[str] = None,
                 width: Optional[int] = None):
        """
        :param str created: The date and a time a watermark profile was created.
        :param str downloaded_from: The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        :param int height: The height of the image in pixels.
        :param str name: A short description of the watermark profile.
        :param float opacity: The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        :param float padding: The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        :param str position: The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        :param float scale: The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        :param float size: The size of the image in bytes.
        :param str uid: The unique identifier for a watermark profile.
        :param int width: The width of the image in pixels.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if downloaded_from is not None:
            pulumi.set(__self__, "downloaded_from", downloaded_from)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if opacity is not None:
            pulumi.set(__self__, "opacity", opacity)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def created(self) -> Optional[str]:
        """
        The date and a time a watermark profile was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="downloadedFrom")
    def downloaded_from(self) -> Optional[str]:
        """
        The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        """
        return pulumi.get(self, "downloaded_from")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The height of the image in pixels.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A short description of the watermark profile.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def opacity(self) -> Optional[float]:
        """
        The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        """
        return pulumi.get(self, "opacity")

    @property
    @pulumi.getter
    def padding(self) -> Optional[float]:
        """
        The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        """
        return pulumi.get(self, "padding")

    @property
    @pulumi.getter
    def position(self) -> Optional[str]:
        """
        The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        """
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def scale(self) -> Optional[float]:
        """
        The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        """
        return pulumi.get(self, "scale")

    @property
    @pulumi.getter
    def size(self) -> Optional[float]:
        """
        The size of the image in bytes.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The unique identifier for a watermark profile.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The width of the image in pixels.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class UserAgentBlockingRuleConfiguration(dict):
    def __init__(__self__, *,
                 target: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str target: The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        :param str value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WaitingRoomAdditionalRoute(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str host: The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        :param str path: Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class WaitingRoomCookieAttributes(dict):
    def __init__(__self__, *,
                 samesite: Optional[str] = None,
                 secure: Optional[str] = None):
        """
        :param str samesite: Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        :param str secure: Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def samesite(self) -> Optional[str]:
        """
        Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> Optional[str]:
        """
        Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class WaitingRoomRulesRule(dict):
    def __init__(__self__, *,
                 action: str,
                 expression: str,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str action: The action to take when the expression matches.
        :param str expression: Criteria defining when there is a match for the current rule.
        :param str description: The description of the rule.
        :param bool enabled: When set to true, the rule is enabled.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when the expression matches.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Criteria defining when there is a match for the current rule.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When set to true, the rule is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WebAnalyticsSiteRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPaused":
            suggest = "is_paused"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAnalyticsSiteRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAnalyticsSiteRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAnalyticsSiteRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created: Optional[str] = None,
                 host: Optional[str] = None,
                 id: Optional[str] = None,
                 inclusive: Optional[bool] = None,
                 is_paused: Optional[bool] = None,
                 paths: Optional[Sequence[str]] = None,
                 priority: Optional[float] = None):
        """
        :param str host: The hostname the rule will be applied to.
        :param str id: The Web Analytics rule identifier.
        :param bool inclusive: Whether the rule includes or excludes traffic from being measured.
        :param bool is_paused: Whether the rule is paused or not.
        :param Sequence[str] paths: The paths the rule will be applied to.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if inclusive is not None:
            pulumi.set(__self__, "inclusive", inclusive)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def created(self) -> Optional[str]:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The hostname the rule will be applied to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Web Analytics rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def inclusive(self) -> Optional[bool]:
        """
        Whether the rule includes or excludes traffic from being measured.
        """
        return pulumi.get(self, "inclusive")

    @property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[bool]:
        """
        Whether the rule is paused or not.
        """
        return pulumi.get(self, "is_paused")

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[str]]:
        """
        The paths the rule will be applied to.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        return pulumi.get(self, "priority")


@pulumi.output_type
class WebAnalyticsSiteRuleset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zoneName":
            suggest = "zone_name"
        elif key == "zoneTag":
            suggest = "zone_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAnalyticsSiteRuleset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAnalyticsSiteRuleset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAnalyticsSiteRuleset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 zone_name: Optional[str] = None,
                 zone_tag: Optional[str] = None):
        """
        :param bool enabled: Whether the ruleset is enabled.
        :param str id: The Web Analytics ruleset identifier.
        :param str zone_tag: The zone identifier.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)
        if zone_tag is not None:
            pulumi.set(__self__, "zone_tag", zone_tag)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the ruleset is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Web Analytics ruleset identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        return pulumi.get(self, "zone_name")

    @property
    @pulumi.getter(name="zoneTag")
    def zone_tag(self) -> Optional[str]:
        """
        The zone identifier.
        """
        return pulumi.get(self, "zone_tag")


@pulumi.output_type
class WorkersCronTriggerSchedule(dict):
    def __init__(__self__, *,
                 cron: str):
        pulumi.set(__self__, "cron", cron)

    @property
    @pulumi.getter
    def cron(self) -> str:
        return pulumi.get(self, "cron")


@pulumi.output_type
class WorkersDeploymentAnnotations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workersMessage":
            suggest = "workers_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersDeploymentAnnotations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersDeploymentAnnotations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersDeploymentAnnotations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workers_message: Optional[str] = None):
        """
        :param str workers_message: Human-readable message about the deployment. Truncated to 100 bytes.
        """
        if workers_message is not None:
            pulumi.set(__self__, "workers_message", workers_message)

    @property
    @pulumi.getter(name="workersMessage")
    def workers_message(self) -> Optional[str]:
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
        return pulumi.get(self, "workers_message")


@pulumi.output_type
class WorkersDeploymentDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorEmail":
            suggest = "author_email"
        elif key == "createdOn":
            suggest = "created_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersDeploymentDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersDeploymentDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersDeploymentDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional['outputs.WorkersDeploymentDeploymentAnnotations'] = None,
                 author_email: Optional[str] = None,
                 created_on: Optional[str] = None,
                 id: Optional[str] = None,
                 source: Optional[str] = None,
                 strategy: Optional[str] = None,
                 versions: Optional[Sequence['outputs.WorkersDeploymentDeploymentVersion']] = None):
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def annotations(self) -> Optional['outputs.WorkersDeploymentDeploymentAnnotations']:
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[str]:
        return pulumi.get(self, "author_email")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.WorkersDeploymentDeploymentVersion']]:
        return pulumi.get(self, "versions")


@pulumi.output_type
class WorkersDeploymentDeploymentAnnotations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workersMessage":
            suggest = "workers_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersDeploymentDeploymentAnnotations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersDeploymentDeploymentAnnotations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersDeploymentDeploymentAnnotations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workers_message: Optional[str] = None):
        """
        :param str workers_message: Human-readable message about the deployment. Truncated to 100 bytes.
        """
        if workers_message is not None:
            pulumi.set(__self__, "workers_message", workers_message)

    @property
    @pulumi.getter(name="workersMessage")
    def workers_message(self) -> Optional[str]:
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
        return pulumi.get(self, "workers_message")


@pulumi.output_type
class WorkersDeploymentDeploymentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "versionId":
            suggest = "version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersDeploymentDeploymentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersDeploymentDeploymentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersDeploymentDeploymentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: Optional[float] = None,
                 version_id: Optional[str] = None):
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        return pulumi.get(self, "percentage")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[str]:
        return pulumi.get(self, "version_id")


@pulumi.output_type
class WorkersDeploymentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "versionId":
            suggest = "version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersDeploymentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersDeploymentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersDeploymentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: float,
                 version_id: str):
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter
    def percentage(self) -> float:
        return pulumi.get(self, "percentage")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        return pulumi.get(self, "version_id")


@pulumi.output_type
<<<<<<< HEAD
=======
class WorkersRouteError(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 message: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class WorkersRouteMessage(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 message: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class WorkersScriptAssets(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.WorkersScriptAssetsConfig'] = None,
                 jwt: Optional[str] = None):
        """
        :param 'WorkersScriptAssetsConfigArgs' config: Configuration for assets within a Worker.
        :param str jwt: Token provided upon successful upload of all files from a registered manifest.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if jwt is not None:
            pulumi.set(__self__, "jwt", jwt)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.WorkersScriptAssetsConfig']:
        """
        Configuration for assets within a Worker.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def jwt(self) -> Optional[str]:
        """
        Token provided upon successful upload of all files from a registered manifest.
        """
        return pulumi.get(self, "jwt")


@pulumi.output_type
class WorkersScriptAssetsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlHandling":
            suggest = "html_handling"
        elif key == "notFoundHandling":
            suggest = "not_found_handling"
        elif key == "runWorkerFirst":
            suggest = "run_worker_first"
        elif key == "serveDirectly":
            suggest = "serve_directly"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptAssetsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptAssetsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptAssetsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 html_handling: Optional[str] = None,
                 not_found_handling: Optional[str] = None,
                 run_worker_first: Optional[bool] = None,
                 serve_directly: Optional[bool] = None):
        """
        :param str html_handling: Determines the redirects and rewrites of requests for HTML content.
        :param str not_found_handling: Determines the response when a request does not match a static asset, and there is no Worker script.
        :param bool run_worker_first: When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        :param bool serve_directly: When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
        if html_handling is not None:
            pulumi.set(__self__, "html_handling", html_handling)
        if not_found_handling is not None:
            pulumi.set(__self__, "not_found_handling", not_found_handling)
        if run_worker_first is not None:
            pulumi.set(__self__, "run_worker_first", run_worker_first)
        if serve_directly is not None:
            pulumi.set(__self__, "serve_directly", serve_directly)

    @property
    @pulumi.getter(name="htmlHandling")
    def html_handling(self) -> Optional[str]:
        """
        Determines the redirects and rewrites of requests for HTML content.
        """
        return pulumi.get(self, "html_handling")

    @property
    @pulumi.getter(name="notFoundHandling")
    def not_found_handling(self) -> Optional[str]:
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        """
        return pulumi.get(self, "not_found_handling")

    @property
    @pulumi.getter(name="runWorkerFirst")
    def run_worker_first(self) -> Optional[bool]:
        """
        When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        """
        return pulumi.get(self, "run_worker_first")

    @property
    @pulumi.getter(name="serveDirectly")
    def serve_directly(self) -> Optional[bool]:
        """
        When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
        return pulumi.get(self, "serve_directly")


@pulumi.output_type
class WorkersScriptBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "className":
            suggest = "class_name"
        elif key == "indexName":
            suggest = "index_name"
        elif key == "namespaceId":
            suggest = "namespace_id"
        elif key == "queueName":
            suggest = "queue_name"
        elif key == "scriptName":
            suggest = "script_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 type: str,
                 bucket_name: Optional[str] = None,
                 certificate_id: Optional[str] = None,
                 class_name: Optional[str] = None,
                 dataset: Optional[str] = None,
                 environment: Optional[str] = None,
                 id: Optional[str] = None,
                 index_name: Optional[str] = None,
                 json: Optional[str] = None,
                 namespace: Optional[str] = None,
                 namespace_id: Optional[str] = None,
                 outbound: Optional['outputs.WorkersScriptBindingOutbound'] = None,
                 queue_name: Optional[str] = None,
                 script_name: Optional[str] = None,
                 service: Optional[str] = None,
                 text: Optional[str] = None):
        """
        :param str name: A JavaScript variable name for the binding.
        :param str type: The kind of resource that the binding provides.
        :param str bucket_name: R2 bucket to bind to.
        :param str certificate_id: Identifier of the certificate to bind to.
        :param str class_name: The exported class name of the Durable Object.
        :param str dataset: The dataset name to bind to.
        :param str environment: The environment of the script_name to bind to.
        :param str id: Identifier of the D1 database to bind to.
        :param str index_name: Name of the Vectorize index to bind to.
        :param str json: JSON data to use.
        :param str namespace: Namespace to bind to.
        :param str namespace_id: Namespace identifier tag.
        :param 'WorkersScriptBindingOutboundArgs' outbound: Outbound worker.
        :param str queue_name: Name of the Queue to bind to.
        :param str script_name: The script where the Durable Object is defined, if it is external to this Worker.
        :param str service: Name of Worker to bind to.
        :param str text: The text value to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if script_name is not None:
            pulumi.set(__self__, "script_name", script_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A JavaScript variable name for the binding.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The kind of resource that the binding provides.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        R2 bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[str]:
        """
        Identifier of the certificate to bind to.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[str]:
        """
        The exported class name of the Durable Object.
        """
        return pulumi.get(self, "class_name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional[str]:
        """
        The dataset name to bind to.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        The environment of the script_name to bind to.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier of the D1 database to bind to.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[str]:
        """
        Name of the Vectorize index to bind to.
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter
    def json(self) -> Optional[str]:
        """
        JSON data to use.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace to bind to.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[str]:
        """
        Namespace identifier tag.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter
    def outbound(self) -> Optional['outputs.WorkersScriptBindingOutbound']:
        """
        Outbound worker.
        """
        return pulumi.get(self, "outbound")

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[str]:
        """
        Name of the Queue to bind to.
        """
        return pulumi.get(self, "queue_name")

    @property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> Optional[str]:
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        return pulumi.get(self, "script_name")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of Worker to bind to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The text value to use.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkersScriptBindingOutbound(dict):
    def __init__(__self__, *,
                 params: Optional[Sequence[str]] = None,
                 worker: Optional['outputs.WorkersScriptBindingOutboundWorker'] = None):
        """
        :param Sequence[str] params: Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        :param 'WorkersScriptBindingOutboundWorkerArgs' worker: Outbound worker.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @property
    @pulumi.getter
    def params(self) -> Optional[Sequence[str]]:
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def worker(self) -> Optional['outputs.WorkersScriptBindingOutboundWorker']:
        """
        Outbound worker.
        """
        return pulumi.get(self, "worker")


@pulumi.output_type
class WorkersScriptBindingOutboundWorker(dict):
    def __init__(__self__, *,
                 environment: Optional[str] = None,
                 service: Optional[str] = None):
        """
        :param str environment: Environment of the outbound worker.
        :param str service: Name of the outbound worker.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Environment of the outbound worker.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the outbound worker.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class WorkersScriptMigrations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deletedClasses":
            suggest = "deleted_classes"
        elif key == "newClasses":
            suggest = "new_classes"
        elif key == "newSqliteClasses":
            suggest = "new_sqlite_classes"
        elif key == "newTag":
            suggest = "new_tag"
        elif key == "oldTag":
            suggest = "old_tag"
        elif key == "renamedClasses":
            suggest = "renamed_classes"
        elif key == "transferredClasses":
            suggest = "transferred_classes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptMigrations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptMigrations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptMigrations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deleted_classes: Optional[Sequence[str]] = None,
                 new_classes: Optional[Sequence[str]] = None,
                 new_sqlite_classes: Optional[Sequence[str]] = None,
                 new_tag: Optional[str] = None,
                 old_tag: Optional[str] = None,
                 renamed_classes: Optional[Sequence['outputs.WorkersScriptMigrationsRenamedClass']] = None,
                 steps: Optional[Sequence['outputs.WorkersScriptMigrationsStep']] = None,
                 transferred_classes: Optional[Sequence['outputs.WorkersScriptMigrationsTransferredClass']] = None):
        """
        :param Sequence[str] deleted_classes: A list of classes to delete Durable Object namespaces from.
        :param Sequence[str] new_classes: A list of classes to create Durable Object namespaces from.
        :param Sequence[str] new_sqlite_classes: A list of classes to create Durable Object namespaces with SQLite from.
        :param str new_tag: Tag to set as the latest migration tag.
        :param str old_tag: Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
        :param Sequence['WorkersScriptMigrationsRenamedClassArgs'] renamed_classes: A list of classes with Durable Object namespaces that were renamed.
        :param Sequence['WorkersScriptMigrationsStepArgs'] steps: Migrations to apply in order.
        :param Sequence['WorkersScriptMigrationsTransferredClassArgs'] transferred_classes: A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        if deleted_classes is not None:
            pulumi.set(__self__, "deleted_classes", deleted_classes)
        if new_classes is not None:
            pulumi.set(__self__, "new_classes", new_classes)
        if new_sqlite_classes is not None:
            pulumi.set(__self__, "new_sqlite_classes", new_sqlite_classes)
        if new_tag is not None:
            pulumi.set(__self__, "new_tag", new_tag)
        if old_tag is not None:
            pulumi.set(__self__, "old_tag", old_tag)
        if renamed_classes is not None:
            pulumi.set(__self__, "renamed_classes", renamed_classes)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if transferred_classes is not None:
            pulumi.set(__self__, "transferred_classes", transferred_classes)

    @property
    @pulumi.getter(name="deletedClasses")
    def deleted_classes(self) -> Optional[Sequence[str]]:
        """
        A list of classes to delete Durable Object namespaces from.
        """
        return pulumi.get(self, "deleted_classes")

    @property
    @pulumi.getter(name="newClasses")
    def new_classes(self) -> Optional[Sequence[str]]:
        """
        A list of classes to create Durable Object namespaces from.
        """
        return pulumi.get(self, "new_classes")

    @property
    @pulumi.getter(name="newSqliteClasses")
    def new_sqlite_classes(self) -> Optional[Sequence[str]]:
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        return pulumi.get(self, "new_sqlite_classes")

    @property
    @pulumi.getter(name="newTag")
    def new_tag(self) -> Optional[str]:
        """
        Tag to set as the latest migration tag.
        """
        return pulumi.get(self, "new_tag")

    @property
    @pulumi.getter(name="oldTag")
    def old_tag(self) -> Optional[str]:
        """
        Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
        """
        return pulumi.get(self, "old_tag")

    @property
    @pulumi.getter(name="renamedClasses")
    def renamed_classes(self) -> Optional[Sequence['outputs.WorkersScriptMigrationsRenamedClass']]:
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        return pulumi.get(self, "renamed_classes")

    @property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.WorkersScriptMigrationsStep']]:
        """
        Migrations to apply in order.
        """
        return pulumi.get(self, "steps")

    @property
    @pulumi.getter(name="transferredClasses")
    def transferred_classes(self) -> Optional[Sequence['outputs.WorkersScriptMigrationsTransferredClass']]:
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        return pulumi.get(self, "transferred_classes")


@pulumi.output_type
class WorkersScriptMigrationsRenamedClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptMigrationsRenamedClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptMigrationsRenamedClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptMigrationsRenamedClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[str] = None,
                 to: Optional[str] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        return pulumi.get(self, "to")


@pulumi.output_type
class WorkersScriptMigrationsStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deletedClasses":
            suggest = "deleted_classes"
        elif key == "newClasses":
            suggest = "new_classes"
        elif key == "newSqliteClasses":
            suggest = "new_sqlite_classes"
        elif key == "renamedClasses":
            suggest = "renamed_classes"
        elif key == "transferredClasses":
            suggest = "transferred_classes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptMigrationsStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptMigrationsStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptMigrationsStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deleted_classes: Optional[Sequence[str]] = None,
                 new_classes: Optional[Sequence[str]] = None,
                 new_sqlite_classes: Optional[Sequence[str]] = None,
                 renamed_classes: Optional[Sequence['outputs.WorkersScriptMigrationsStepRenamedClass']] = None,
                 transferred_classes: Optional[Sequence['outputs.WorkersScriptMigrationsStepTransferredClass']] = None):
        """
        :param Sequence[str] deleted_classes: A list of classes to delete Durable Object namespaces from.
        :param Sequence[str] new_classes: A list of classes to create Durable Object namespaces from.
        :param Sequence[str] new_sqlite_classes: A list of classes to create Durable Object namespaces with SQLite from.
        :param Sequence['WorkersScriptMigrationsStepRenamedClassArgs'] renamed_classes: A list of classes with Durable Object namespaces that were renamed.
        :param Sequence['WorkersScriptMigrationsStepTransferredClassArgs'] transferred_classes: A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        if deleted_classes is not None:
            pulumi.set(__self__, "deleted_classes", deleted_classes)
        if new_classes is not None:
            pulumi.set(__self__, "new_classes", new_classes)
        if new_sqlite_classes is not None:
            pulumi.set(__self__, "new_sqlite_classes", new_sqlite_classes)
        if renamed_classes is not None:
            pulumi.set(__self__, "renamed_classes", renamed_classes)
        if transferred_classes is not None:
            pulumi.set(__self__, "transferred_classes", transferred_classes)

    @property
    @pulumi.getter(name="deletedClasses")
    def deleted_classes(self) -> Optional[Sequence[str]]:
        """
        A list of classes to delete Durable Object namespaces from.
        """
        return pulumi.get(self, "deleted_classes")

    @property
    @pulumi.getter(name="newClasses")
    def new_classes(self) -> Optional[Sequence[str]]:
        """
        A list of classes to create Durable Object namespaces from.
        """
        return pulumi.get(self, "new_classes")

    @property
    @pulumi.getter(name="newSqliteClasses")
    def new_sqlite_classes(self) -> Optional[Sequence[str]]:
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        return pulumi.get(self, "new_sqlite_classes")

    @property
    @pulumi.getter(name="renamedClasses")
    def renamed_classes(self) -> Optional[Sequence['outputs.WorkersScriptMigrationsStepRenamedClass']]:
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        return pulumi.get(self, "renamed_classes")

    @property
    @pulumi.getter(name="transferredClasses")
    def transferred_classes(self) -> Optional[Sequence['outputs.WorkersScriptMigrationsStepTransferredClass']]:
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        return pulumi.get(self, "transferred_classes")


@pulumi.output_type
class WorkersScriptMigrationsStepRenamedClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptMigrationsStepRenamedClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptMigrationsStepRenamedClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptMigrationsStepRenamedClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[str] = None,
                 to: Optional[str] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        return pulumi.get(self, "to")


@pulumi.output_type
class WorkersScriptMigrationsStepTransferredClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"
        elif key == "fromScript":
            suggest = "from_script"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptMigrationsStepTransferredClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptMigrationsStepTransferredClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptMigrationsStepTransferredClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[str] = None,
                 from_script: Optional[str] = None,
                 to: Optional[str] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if from_script is not None:
            pulumi.set(__self__, "from_script", from_script)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter(name="fromScript")
    def from_script(self) -> Optional[str]:
        return pulumi.get(self, "from_script")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        return pulumi.get(self, "to")


@pulumi.output_type
class WorkersScriptMigrationsTransferredClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"
        elif key == "fromScript":
            suggest = "from_script"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptMigrationsTransferredClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptMigrationsTransferredClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptMigrationsTransferredClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[str] = None,
                 from_script: Optional[str] = None,
                 to: Optional[str] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if from_script is not None:
            pulumi.set(__self__, "from_script", from_script)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter(name="fromScript")
    def from_script(self) -> Optional[str]:
        return pulumi.get(self, "from_script")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        return pulumi.get(self, "to")


@pulumi.output_type
class WorkersScriptObservability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headSamplingRate":
            suggest = "head_sampling_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptObservability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptObservability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptObservability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 head_sampling_rate: Optional[float] = None):
        """
        :param bool enabled: Whether observability is enabled for the Worker.
        :param float head_sampling_rate: The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        pulumi.set(__self__, "enabled", enabled)
        if head_sampling_rate is not None:
            pulumi.set(__self__, "head_sampling_rate", head_sampling_rate)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether observability is enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="headSamplingRate")
    def head_sampling_rate(self) -> Optional[float]:
        """
        The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        return pulumi.get(self, "head_sampling_rate")


@pulumi.output_type
class WorkersScriptPlacement(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str mode: Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        :param str status: Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class WorkersScriptTailConsumer(dict):
    def __init__(__self__, *,
                 service: str,
                 environment: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str service: Name of Worker that is to be the consumer.
        :param str environment: Optional environment if the Worker utilizes one.
        :param str namespace: Optional dispatch namespace the script belongs to.
        """
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Name of Worker that is to be the consumer.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Optional environment if the Worker utilizes one.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Optional dispatch namespace the script belongs to.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ZeroTrustAccessApplicationCorsHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllHeaders":
            suggest = "allow_all_headers"
        elif key == "allowAllMethods":
            suggest = "allow_all_methods"
        elif key == "allowAllOrigins":
            suggest = "allow_all_origins"
        elif key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationCorsHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationCorsHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationCorsHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_headers: Optional[bool] = None,
                 allow_all_methods: Optional[bool] = None,
                 allow_all_origins: Optional[bool] = None,
                 allow_credentials: Optional[bool] = None,
                 allowed_headers: Optional[Sequence[str]] = None,
                 allowed_methods: Optional[Sequence[str]] = None,
                 allowed_origins: Optional[Sequence[str]] = None,
                 max_age: Optional[float] = None):
        """
        :param bool allow_all_headers: Allows all HTTP request headers.
        :param bool allow_all_methods: Allows all HTTP request methods.
        :param bool allow_all_origins: Allows all origins.
        :param bool allow_credentials: When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        :param Sequence[str] allowed_headers: Allowed HTTP request headers.
        :param Sequence[str] allowed_methods: Allowed HTTP request methods.
        :param Sequence[str] allowed_origins: Allowed origins.
        :param float max_age: The maximum number of seconds the results of a preflight request can be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[bool]:
        """
        Allows all HTTP request headers.
        """
        return pulumi.get(self, "allow_all_headers")

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[bool]:
        """
        Allows all HTTP request methods.
        """
        return pulumi.get(self, "allow_all_methods")

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[bool]:
        """
        Allows all origins.
        """
        return pulumi.get(self, "allow_all_origins")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[str]]:
        """
        Allowed HTTP request headers.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[str]]:
        """
        Allowed HTTP request methods.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Allowed origins.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class ZeroTrustAccessApplicationDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "l4Protocol":
            suggest = "l4_protocol"
        elif key == "portRange":
            suggest = "port_range"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 hostname: Optional[str] = None,
                 l4_protocol: Optional[str] = None,
                 port_range: Optional[str] = None,
                 type: Optional[str] = None,
                 uri: Optional[str] = None,
                 vnet_id: Optional[str] = None):
        """
        :param str cidr: The CIDR range of the destination. Single IPs will be computed as /32.
        :param str hostname: The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        :param str l4_protocol: The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        :param str port_range: The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        :param str uri: The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        :param str vnet_id: The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if l4_protocol is not None:
            pulumi.set(__self__, "l4_protocol", l4_protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="l4Protocol")
    def l4_protocol(self) -> Optional[str]:
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        """
        return pulumi.get(self, "l4_protocol")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[str]:
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class ZeroTrustAccessApplicationFooterLink(dict):
    def __init__(__self__, *,
                 name: str,
                 url: str):
        """
        :param str name: The hypertext in the footer link.
        :param str url: the hyperlink in the footer link.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The hypertext in the footer link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        the hyperlink in the footer link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ZeroTrustAccessApplicationLandingPageDesign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buttonColor":
            suggest = "button_color"
        elif key == "buttonTextColor":
            suggest = "button_text_color"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationLandingPageDesign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationLandingPageDesign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationLandingPageDesign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 button_color: Optional[str] = None,
                 button_text_color: Optional[str] = None,
                 image_url: Optional[str] = None,
                 message: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str button_color: The background color of the log in button on the landing page.
        :param str button_text_color: The color of the text in the log in button on the landing page.
        :param str image_url: The URL of the image shown on the landing page.
        :param str message: The message shown on the landing page.
        :param str title: The title shown on the landing page.
        """
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[str]:
        """
        The background color of the log in button on the landing page.
        """
        return pulumi.get(self, "button_color")

    @property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[str]:
        """
        The color of the text in the log in button on the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        The URL of the image shown on the landing page.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The message shown on the landing page.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title shown on the landing page.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRules":
            suggest = "connection_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_rules: Optional['outputs.ZeroTrustAccessApplicationPolicyConnectionRules'] = None,
                 decision: Optional[str] = None,
                 excludes: Optional[Sequence['outputs.ZeroTrustAccessApplicationPolicyExclude']] = None,
                 id: Optional[str] = None,
                 includes: Optional[Sequence['outputs.ZeroTrustAccessApplicationPolicyInclude']] = None,
                 name: Optional[str] = None,
                 precedence: Optional[int] = None,
                 requires: Optional[Sequence['outputs.ZeroTrustAccessApplicationPolicyRequire']] = None):
        """
        :param 'ZeroTrustAccessApplicationPolicyConnectionRulesArgs' connection_rules: The rules that define how users may connect to the targets secured by your application.
        :param str decision: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        :param Sequence['ZeroTrustAccessApplicationPolicyExcludeArgs'] excludes: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        :param str id: The UUID of the policy
        :param Sequence['ZeroTrustAccessApplicationPolicyIncludeArgs'] includes: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        :param str name: The name of the Access policy.
        :param int precedence: The order of execution for this policy. Must be unique for each policy within an app.
        :param Sequence['ZeroTrustAccessApplicationPolicyRequireArgs'] requires: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        if connection_rules is not None:
            pulumi.set(__self__, "connection_rules", connection_rules)
        if decision is not None:
            pulumi.set(__self__, "decision", decision)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if requires is not None:
            pulumi.set(__self__, "requires", requires)

    @property
    @pulumi.getter(name="connectionRules")
    def connection_rules(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyConnectionRules']:
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "connection_rules")

    @property
    @pulumi.getter
    def decision(self) -> Optional[str]:
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        """
        return pulumi.get(self, "decision")

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationPolicyExclude']]:
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The UUID of the policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationPolicyInclude']]:
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        return pulumi.get(self, "includes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Access policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def precedence(self) -> Optional[int]:
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        return pulumi.get(self, "precedence")

    @property
    @pulumi.getter
    def requires(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationPolicyRequire']]:
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "requires")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyConnectionRules(dict):
    def __init__(__self__, *,
                 ssh: Optional['outputs.ZeroTrustAccessApplicationPolicyConnectionRulesSsh'] = None):
        """
        :param 'ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs' ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def ssh(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyConnectionRulesSsh']:
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyConnectionRulesSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowEmailAlias":
            suggest = "allow_email_alias"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyConnectionRulesSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyConnectionRulesSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyConnectionRulesSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usernames: Sequence[str],
                 allow_email_alias: Optional[bool] = None):
        """
        :param Sequence[str] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        :param bool allow_email_alias: Enables using Identity Provider email alias as SSH username.
        """
        pulumi.set(__self__, "usernames", usernames)
        if allow_email_alias is not None:
            pulumi.set(__self__, "allow_email_alias", allow_email_alias)

    @property
    @pulumi.getter
    def usernames(self) -> Sequence[str]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")

    @property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> Optional[bool]:
        """
        Enables using Identity Provider email alias as SSH username.
        """
        return pulumi.get(self, "allow_email_alias")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeServiceToken'] = None):
        """
        :param 'ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeIpList']:
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeLoginMethod']:
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyExcludeServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessApplicationPolicyExcludeLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessApplicationPolicyExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyExcludeServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyExcludeServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyExcludeServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeServiceToken'] = None):
        """
        :param 'ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeIpList']:
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeLoginMethod']:
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyIncludeServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessApplicationPolicyIncludeLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessApplicationPolicyIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyIncludeServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyIncludeServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyIncludeServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessApplicationPolicyRequireServiceToken'] = None):
        """
        :param 'ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessApplicationPolicyRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireIpList']:
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireLoginMethod']:
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessApplicationPolicyRequireServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessApplicationPolicyRequireLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessApplicationPolicyRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessApplicationPolicyRequireServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationPolicyRequireServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationPolicyRequireServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationPolicyRequireServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenLifetime":
            suggest = "access_token_lifetime"
        elif key == "allowPkceWithoutClientSecret":
            suggest = "allow_pkce_without_client_secret"
        elif key == "appLauncherUrl":
            suggest = "app_launcher_url"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "consumerServiceUrl":
            suggest = "consumer_service_url"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "customAttributes":
            suggest = "custom_attributes"
        elif key == "customClaims":
            suggest = "custom_claims"
        elif key == "defaultRelayState":
            suggest = "default_relay_state"
        elif key == "grantTypes":
            suggest = "grant_types"
        elif key == "groupFilterRegex":
            suggest = "group_filter_regex"
        elif key == "hybridAndImplicitOptions":
            suggest = "hybrid_and_implicit_options"
        elif key == "idpEntityId":
            suggest = "idp_entity_id"
        elif key == "nameIdFormat":
            suggest = "name_id_format"
        elif key == "nameIdTransformJsonata":
            suggest = "name_id_transform_jsonata"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "redirectUris":
            suggest = "redirect_uris"
        elif key == "refreshTokenOptions":
            suggest = "refresh_token_options"
        elif key == "samlAttributeTransformJsonata":
            suggest = "saml_attribute_transform_jsonata"
        elif key == "spEntityId":
            suggest = "sp_entity_id"
        elif key == "ssoEndpoint":
            suggest = "sso_endpoint"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_lifetime: Optional[str] = None,
                 allow_pkce_without_client_secret: Optional[bool] = None,
                 app_launcher_url: Optional[str] = None,
                 auth_type: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 consumer_service_url: Optional[str] = None,
                 created_at: Optional[str] = None,
                 custom_attributes: Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomAttribute']] = None,
                 custom_claims: Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomClaim']] = None,
                 default_relay_state: Optional[str] = None,
                 grant_types: Optional[Sequence[str]] = None,
                 group_filter_regex: Optional[str] = None,
                 hybrid_and_implicit_options: Optional['outputs.ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions'] = None,
                 idp_entity_id: Optional[str] = None,
                 name_id_format: Optional[str] = None,
                 name_id_transform_jsonata: Optional[str] = None,
                 public_key: Optional[str] = None,
                 redirect_uris: Optional[Sequence[str]] = None,
                 refresh_token_options: Optional['outputs.ZeroTrustAccessApplicationSaasAppRefreshTokenOptions'] = None,
                 saml_attribute_transform_jsonata: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 sp_entity_id: Optional[str] = None,
                 sso_endpoint: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param str access_token_lifetime: The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        :param bool allow_pkce_without_client_secret: If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        :param str app_launcher_url: The URL where this applications tile redirects users
        :param str auth_type: Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        :param str client_id: The application client id
        :param str client_secret: The application client secret, only returned on POST request.
        :param str consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param str default_relay_state: The URL that the user will be redirected to after a successful login for IDP initiated logins.
        :param Sequence[str] grant_types: The OIDC flows supported by this application
        :param str group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        :param str idp_entity_id: The unique identifier for your SaaS application.
        :param str name_id_format: The format of the name identifier sent to the SaaS application.
        :param str name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param str public_key: The Access public certificate that will be used to verify your identity.
        :param Sequence[str] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        :param str saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param Sequence[str] scopes: Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        :param str sp_entity_id: A globally unique name for an identity or service provider.
        :param str sso_endpoint: The endpoint where your SaaS application will send login requests.
        """
        if access_token_lifetime is not None:
            pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        if allow_pkce_without_client_secret is not None:
            pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        if app_launcher_url is not None:
            pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if consumer_service_url is not None:
            pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if custom_claims is not None:
            pulumi.set(__self__, "custom_claims", custom_claims)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if group_filter_regex is not None:
            pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        if hybrid_and_implicit_options is not None:
            pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if name_id_transform_jsonata is not None:
            pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if refresh_token_options is not None:
            pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        if saml_attribute_transform_jsonata is not None:
            pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sso_endpoint is not None:
            pulumi.set(__self__, "sso_endpoint", sso_endpoint)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> Optional[str]:
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> Optional[bool]:
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> Optional[str]:
        """
        The URL where this applications tile redirects users
        """
        return pulumi.get(self, "app_launcher_url")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[str]:
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The application client id
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The application client secret, only returned on POST request.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> Optional[str]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomAttribute']]:
        return pulumi.get(self, "custom_attributes")

    @property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomClaim']]:
        return pulumi.get(self, "custom_claims")

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[str]:
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        return pulumi.get(self, "default_relay_state")

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional[Sequence[str]]:
        """
        The OIDC flows supported by this application
        """
        return pulumi.get(self, "grant_types")

    @property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> Optional[str]:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        return pulumi.get(self, "group_filter_regex")

    @property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> Optional['outputs.ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions']:
        return pulumi.get(self, "hybrid_and_implicit_options")

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[str]:
        """
        The unique identifier for your SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[str]:
        """
        The format of the name identifier sent to the SaaS application.
        """
        return pulumi.get(self, "name_id_format")

    @property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> Optional[str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        The Access public certificate that will be used to verify your identity.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[Sequence[str]]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> Optional['outputs.ZeroTrustAccessApplicationSaasAppRefreshTokenOptions']:
        return pulumi.get(self, "refresh_token_options")

    @property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> Optional[str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[str]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> Optional[str]:
        """
        The endpoint where your SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "friendlyName":
            suggest = "friendly_name"
        elif key == "nameFormat":
            suggest = "name_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppCustomAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 friendly_name: Optional[str] = None,
                 name: Optional[str] = None,
                 name_format: Optional[str] = None,
                 required: Optional[bool] = None,
                 source: Optional['outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSource'] = None):
        """
        :param str friendly_name: The SAML FriendlyName of the attribute.
        :param str name: The name of the attribute.
        :param str name_format: A globally unique name for an identity or service provider.
        :param bool required: If the attribute is required when building a SAML assertion.
        """
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_format is not None:
            pulumi.set(__self__, "name_format", name_format)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        The SAML FriendlyName of the attribute.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[str]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        If the attribute is required when building a SAML assertion.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSource']:
        return pulumi.get(self, "source")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameByIdps":
            suggest = "name_by_idps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppCustomAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
<<<<<<< HEAD
                 name_by_idp: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name of the IdP attribute.
        :param Mapping[str, str] name_by_idp: A mapping from IdP ID to attribute name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)
=======
                 name_by_idps: Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp']] = None):
        """
        :param str name: The name of the IdP attribute.
        :param Sequence['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs'] name_by_idps: A mapping from IdP ID to attribute name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idps is not None:
            pulumi.set(__self__, "name_by_idps", name_by_idps)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the IdP attribute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameByIdps")
    def name_by_idps(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp']]:
        """
        A mapping from IdP ID to attribute name.
        """
        return pulumi.get(self, "name_by_idps")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idpId":
            suggest = "idp_id"
        elif key == "sourceName":
            suggest = "source_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idp_id: Optional[str] = None,
                 source_name: Optional[str] = None):
        """
        :param str idp_id: The UID of the IdP.
        :param str source_name: The name of the IdP provided attribute.
        """
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[str]:
        """
        The UID of the IdP.
        """
        return pulumi.get(self, "idp_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[str]:
        """
        The name of the IdP provided attribute.
        """
        return pulumi.get(self, "source_name")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomClaim(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 required: Optional[bool] = None,
                 scope: Optional[str] = None,
                 source: Optional['outputs.ZeroTrustAccessApplicationSaasAppCustomClaimSource'] = None):
        """
        :param str name: The name of the claim.
        :param bool required: If the claim is required when building an OIDC token.
        :param str scope: The scope of the claim.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the claim.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        If the claim is required when building an OIDC token.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope of the claim.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.ZeroTrustAccessApplicationSaasAppCustomClaimSource']:
        return pulumi.get(self, "source")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomClaimSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameByIdp":
            suggest = "name_by_idp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppCustomClaimSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomClaimSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomClaimSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 name_by_idp: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name of the IdP claim.
        :param Mapping[str, str] name_by_idp: A mapping from IdP ID to claim name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the IdP claim.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[Mapping[str, str]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "returnAccessTokenFromAuthorizationEndpoint":
            suggest = "return_access_token_from_authorization_endpoint"
        elif key == "returnIdTokenFromAuthorizationEndpoint":
            suggest = "return_id_token_from_authorization_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: Optional[bool] = None,
                 return_id_token_from_authorization_endpoint: Optional[bool] = None):
        """
        :param bool return_access_token_from_authorization_endpoint: If an Access Token should be returned from the OIDC Authorization endpoint
        :param bool return_id_token_from_authorization_endpoint: If an ID Token should be returned from the OIDC Authorization endpoint
        """
        if return_access_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        if return_id_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> Optional[bool]:
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> Optional[bool]:
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppRefreshTokenOptions(dict):
    def __init__(__self__, *,
                 lifetime: Optional[str] = None):
        """
        :param str lifetime: How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        if lifetime is not None:
            pulumi.set(__self__, "lifetime", lifetime)

    @property
    @pulumi.getter
    def lifetime(self) -> Optional[str]:
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")


@pulumi.output_type
class ZeroTrustAccessApplicationScimConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idpUid":
            suggest = "idp_uid"
        elif key == "remoteUri":
            suggest = "remote_uri"
        elif key == "deactivateOnDelete":
            suggest = "deactivate_on_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationScimConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationScimConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationScimConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idp_uid: str,
                 remote_uri: str,
                 authentication: Optional['outputs.ZeroTrustAccessApplicationScimConfigAuthentication'] = None,
                 deactivate_on_delete: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 mappings: Optional[Sequence['outputs.ZeroTrustAccessApplicationScimConfigMapping']] = None):
        """
        :param str idp_uid: The UID of the IdP to use as the source for SCIM resources to provision to this application.
        :param str remote_uri: The base URI for the application's SCIM-compatible API.
        :param 'ZeroTrustAccessApplicationScimConfigAuthenticationArgs' authentication: Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        :param bool deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param bool enabled: Whether SCIM provisioning is turned on for this application.
        :param Sequence['ZeroTrustAccessApplicationScimConfigMappingArgs'] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "remote_uri", remote_uri)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if deactivate_on_delete is not None:
            pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> str:
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> str:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ZeroTrustAccessApplicationScimConfigAuthentication']:
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> Optional[bool]:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationScimConfigMapping']]:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class ZeroTrustAccessApplicationScimConfigAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationUrl":
            suggest = "authorization_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationScimConfigAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationScimConfigAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationScimConfigAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scheme: str,
                 authorization_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 password: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token: Optional[str] = None,
                 token_url: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str scheme: The authentication scheme to use when making SCIM requests to this application.
        :param str authorization_url: URL used to generate the auth code used during token generation.
        :param str client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        :param str client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        :param str password: Password used to authenticate with the remote SCIM service.
        :param Sequence[str] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        :param str token: Token used to authenticate with the remote SCIM service.
        :param str token_url: URL used to generate the token used to authenticate with the remote SCIM service.
        :param str user: User name used to authenticate with the remote SCIM service.
        """
        pulumi.set(__self__, "scheme", scheme)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[str]:
        """
        URL used to generate the auth code used during token generation.
        """
        return pulumi.get(self, "authorization_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        Token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User name used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ZeroTrustAccessApplicationScimConfigMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformJsonata":
            suggest = "transform_jsonata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationScimConfigMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationScimConfigMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationScimConfigMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: str,
                 enabled: Optional[bool] = None,
                 filter: Optional[str] = None,
                 operations: Optional['outputs.ZeroTrustAccessApplicationScimConfigMappingOperations'] = None,
                 strictness: Optional[str] = None,
                 transform_jsonata: Optional[str] = None):
        """
        :param str schema: Which SCIM resource type this mapping applies to.
        :param bool enabled: Whether or not this mapping is enabled.
        :param str filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param 'ZeroTrustAccessApplicationScimConfigMappingOperationsArgs' operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param str strictness: The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
        :param str transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "schema", schema)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if strictness is not None:
            pulumi.set(__self__, "strictness", strictness)
        if transform_jsonata is not None:
            pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @property
    @pulumi.getter
    def schema(self) -> str:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def operations(self) -> Optional['outputs.ZeroTrustAccessApplicationScimConfigMappingOperations']:
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def strictness(self) -> Optional[str]:
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
        """
        return pulumi.get(self, "strictness")

    @property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> Optional[str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")


@pulumi.output_type
class ZeroTrustAccessApplicationScimConfigMappingOperations(dict):
    def __init__(__self__, *,
                 create: Optional[bool] = None,
                 delete: Optional[bool] = None,
                 update: Optional[bool] = None):
        """
        :param bool create: Whether or not this mapping applies to create (POST) operations.
        :param bool delete: Whether or not this mapping applies to DELETE operations.
        :param bool update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[bool]:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[bool]:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[bool]:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ZeroTrustAccessApplicationTargetCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetAttributes":
            suggest = "target_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationTargetCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationTargetCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationTargetCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 protocol: str,
                 target_attributes: Mapping[str, Sequence[str]]):
        """
        :param int port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param str protocol: The communication protocol your application secures.
        :param Mapping[str, Sequence[str]] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The communication protocol your application secures.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> Mapping[str, Sequence[str]]:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")


@pulumi.output_type
class ZeroTrustAccessGroupExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessGroupExcludeAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessGroupExcludeAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessGroupExcludeAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessGroupExcludeAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessGroupExcludeCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessGroupExcludeCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessGroupExcludeDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessGroupExcludeEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessGroupExcludeEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessGroupExcludeEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessGroupExcludeEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessGroupExcludeExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessGroupExcludeGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessGroupExcludeGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessGroupExcludeGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessGroupExcludeGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessGroupExcludeIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessGroupExcludeIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessGroupExcludeLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessGroupExcludeOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessGroupExcludeSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessGroupExcludeServiceToken'] = None):
        """
        :param 'ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessGroupExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeIpList']:
        return pulumi.get(self, "ip_list")
<<<<<<< HEAD
=======

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeLoginMethod']:
        return pulumi.get(self, "login_method")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessGroupExcludeServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupExcludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupExcludeCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessGroupExcludeLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessGroupExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustAccessGroupInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessGroupIncludeAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessGroupIncludeAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessGroupIncludeAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessGroupIncludeAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessGroupIncludeCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessGroupIncludeCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessGroupIncludeDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessGroupIncludeEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessGroupIncludeEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessGroupIncludeEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessGroupIncludeEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessGroupIncludeExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessGroupIncludeGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessGroupIncludeGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessGroupIncludeGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessGroupIncludeGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessGroupIncludeIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessGroupIncludeIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessGroupIncludeLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessGroupIncludeOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessGroupIncludeSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessGroupIncludeServiceToken'] = None):
        """
        :param 'ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessGroupIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeIpList']:
        return pulumi.get(self, "ip_list")
<<<<<<< HEAD
=======

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeLoginMethod']:
        return pulumi.get(self, "login_method")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessGroupIncludeServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupIncludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupIncludeCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessGroupIncludeLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessGroupIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustAccessGroupRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessGroupRequireAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessGroupRequireAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessGroupRequireAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessGroupRequireAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessGroupRequireCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessGroupRequireCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessGroupRequireDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessGroupRequireEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessGroupRequireEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessGroupRequireEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessGroupRequireEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessGroupRequireExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessGroupRequireGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessGroupRequireGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessGroupRequireGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessGroupRequireGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessGroupRequireIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessGroupRequireIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessGroupRequireLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessGroupRequireOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessGroupRequireSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessGroupRequireServiceToken'] = None):
        """
        :param 'ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessGroupRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessGroupRequireAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessGroupRequireAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessGroupRequireAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessGroupRequireAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessGroupRequireCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessGroupRequireCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessGroupRequireDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessGroupRequireEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessGroupRequireEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessGroupRequireEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessGroupRequireEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessGroupRequireExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessGroupRequireGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessGroupRequireGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessGroupRequireGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessGroupRequireGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessGroupRequireIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessGroupRequireIpList']:
        return pulumi.get(self, "ip_list")
<<<<<<< HEAD
=======

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessGroupRequireLoginMethod']:
        return pulumi.get(self, "login_method")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessGroupRequireOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessGroupRequireSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessGroupRequireServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessGroupRequireAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupRequireAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupRequireAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessGroupRequireAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupRequireCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupRequireCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessGroupRequireDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessGroupRequireEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessGroupRequireEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessGroupRequireEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessGroupRequireEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessGroupRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessGroupRequireGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessGroupRequireGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessGroupRequireGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessGroupRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupRequireIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessGroupRequireIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessGroupRequireLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessGroupRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessGroupRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupRequireServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustAccessIdentityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appsDomain":
            suggest = "apps_domain"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "authorizationServerId":
            suggest = "authorization_server_id"
        elif key == "centrifyAccount":
            suggest = "centrify_account"
        elif key == "centrifyAppId":
            suggest = "centrify_app_id"
        elif key == "certsUrl":
            suggest = "certs_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "conditionalAccessEnabled":
            suggest = "conditional_access_enabled"
        elif key == "directoryId":
            suggest = "directory_id"
        elif key == "emailAttributeName":
            suggest = "email_attribute_name"
        elif key == "emailClaimName":
            suggest = "email_claim_name"
        elif key == "headerAttributes":
            suggest = "header_attributes"
        elif key == "idpPublicCerts":
            suggest = "idp_public_certs"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "oktaAccount":
            suggest = "okta_account"
        elif key == "oneloginAccount":
            suggest = "onelogin_account"
        elif key == "pingEnvId":
            suggest = "ping_env_id"
        elif key == "pkceEnabled":
            suggest = "pkce_enabled"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "signRequest":
            suggest = "sign_request"
        elif key == "ssoTargetUrl":
            suggest = "sso_target_url"
        elif key == "supportGroups":
            suggest = "support_groups"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessIdentityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessIdentityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessIdentityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apps_domain: Optional[str] = None,
                 attributes: Optional[Sequence[str]] = None,
                 auth_url: Optional[str] = None,
                 authorization_server_id: Optional[str] = None,
                 centrify_account: Optional[str] = None,
                 centrify_app_id: Optional[str] = None,
                 certs_url: Optional[str] = None,
                 claims: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 conditional_access_enabled: Optional[bool] = None,
                 directory_id: Optional[str] = None,
                 email_attribute_name: Optional[str] = None,
                 email_claim_name: Optional[str] = None,
                 header_attributes: Optional[Sequence['outputs.ZeroTrustAccessIdentityProviderConfigHeaderAttribute']] = None,
                 idp_public_certs: Optional[Sequence[str]] = None,
                 issuer_url: Optional[str] = None,
                 okta_account: Optional[str] = None,
                 onelogin_account: Optional[str] = None,
                 ping_env_id: Optional[str] = None,
                 pkce_enabled: Optional[bool] = None,
                 prompt: Optional[str] = None,
                 redirect_url: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 sign_request: Optional[bool] = None,
                 sso_target_url: Optional[str] = None,
                 support_groups: Optional[bool] = None,
                 token_url: Optional[str] = None):
        """
        :param str apps_domain: Your companies TLD
        :param Sequence[str] attributes: A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        :param str auth_url: The authorization_endpoint URL of your IdP
        :param str authorization_server_id: Your okta authorization server id
        :param str centrify_account: Your centrify account url
        :param str centrify_app_id: Your centrify app id
        :param str certs_url: The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        :param Sequence[str] claims: Custom claims
        :param str client_id: Your OAuth Client ID
        :param str client_secret: Your OAuth Client Secret
        :param bool conditional_access_enabled: Should Cloudflare try to load authentication contexts from your account
        :param str directory_id: Your Azure directory uuid
        :param str email_attribute_name: The attribute name for email in the SAML response.
        :param str email_claim_name: The claim name for email in the id_token response.
        :param Sequence['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs'] header_attributes: Add a list of attribute names that will be returned in the response header from the Access callback.
        :param Sequence[str] idp_public_certs: X509 certificate to verify the signature in the SAML authentication response
        :param str issuer_url: IdP Entity ID or Issuer URL
        :param str okta_account: Your okta account url
        :param str onelogin_account: Your OneLogin account url
        :param str ping_env_id: Your PingOne environment identifier
        :param bool pkce_enabled: Enable Proof Key for Code Exchange (PKCE)
        :param str prompt: Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        :param Sequence[str] scopes: OAuth scopes
        :param bool sign_request: Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        :param str sso_target_url: URL to send the SAML authentication requests to
        :param bool support_groups: Should Cloudflare try to load groups from your account
        :param str token_url: The token_endpoint URL of your IdP
        """
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if conditional_access_enabled is not None:
            pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            pulumi.set(__self__, "email_claim_name", email_claim_name)
        if header_attributes is not None:
            pulumi.set(__self__, "header_attributes", header_attributes)
        if idp_public_certs is not None:
            pulumi.set(__self__, "idp_public_certs", idp_public_certs)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if ping_env_id is not None:
            pulumi.set(__self__, "ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[str]:
        """
        Your companies TLD
        """
        return pulumi.get(self, "apps_domain")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[str]]:
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        """
        The authorization_endpoint URL of your IdP
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[str]:
        """
        Your okta authorization server id
        """
        return pulumi.get(self, "authorization_server_id")

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[str]:
        """
        Your centrify account url
        """
        return pulumi.get(self, "centrify_account")

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[str]:
        """
        Your centrify app id
        """
        return pulumi.get(self, "centrify_app_id")

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[str]:
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        return pulumi.get(self, "certs_url")

    @property
    @pulumi.getter
    def claims(self) -> Optional[Sequence[str]]:
        """
        Custom claims
        """
        return pulumi.get(self, "claims")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Your OAuth Client ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Your OAuth Client Secret
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[bool]:
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        return pulumi.get(self, "conditional_access_enabled")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[str]:
        """
        Your Azure directory uuid
        """
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[str]:
        """
        The attribute name for email in the SAML response.
        """
        return pulumi.get(self, "email_attribute_name")

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[str]:
        """
        The claim name for email in the id_token response.
        """
        return pulumi.get(self, "email_claim_name")

    @property
    @pulumi.getter(name="headerAttributes")
    def header_attributes(self) -> Optional[Sequence['outputs.ZeroTrustAccessIdentityProviderConfigHeaderAttribute']]:
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        return pulumi.get(self, "header_attributes")

    @property
    @pulumi.getter(name="idpPublicCerts")
    def idp_public_certs(self) -> Optional[Sequence[str]]:
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        return pulumi.get(self, "idp_public_certs")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[str]:
        """
        IdP Entity ID or Issuer URL
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[str]:
        """
        Your okta account url
        """
        return pulumi.get(self, "okta_account")

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[str]:
        """
        Your OneLogin account url
        """
        return pulumi.get(self, "onelogin_account")

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[str]:
        """
        Your PingOne environment identifier
        """
        return pulumi.get(self, "ping_env_id")

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[bool]:
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        return pulumi.get(self, "pkce_enabled")

    @property
    @pulumi.getter
    def prompt(self) -> Optional[str]:
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        """
        return pulumi.get(self, "prompt")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        OAuth scopes
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[bool]:
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        return pulumi.get(self, "sign_request")

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[str]:
        """
        URL to send the SAML authentication requests to
        """
        return pulumi.get(self, "sso_target_url")

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[bool]:
        """
        Should Cloudflare try to load groups from your account
        """
        return pulumi.get(self, "support_groups")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        """
        The token_endpoint URL of your IdP
        """
        return pulumi.get(self, "token_url")


@pulumi.output_type
class ZeroTrustAccessIdentityProviderConfigHeaderAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessIdentityProviderConfigHeaderAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessIdentityProviderConfigHeaderAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessIdentityProviderConfigHeaderAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 header_name: Optional[str] = None):
        """
        :param str attribute_name: attribute name from the IDP
        :param str header_name: header that will be added on the request to the origin
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        """
        attribute name from the IDP
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        header that will be added on the request to the origin
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class ZeroTrustAccessIdentityProviderScimConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityUpdateBehavior":
            suggest = "identity_update_behavior"
        elif key == "scimBaseUrl":
            suggest = "scim_base_url"
        elif key == "seatDeprovision":
            suggest = "seat_deprovision"
        elif key == "userDeprovision":
            suggest = "user_deprovision"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessIdentityProviderScimConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessIdentityProviderScimConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessIdentityProviderScimConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 identity_update_behavior: Optional[str] = None,
                 scim_base_url: Optional[str] = None,
                 seat_deprovision: Optional[bool] = None,
                 secret: Optional[str] = None,
                 user_deprovision: Optional[bool] = None):
        """
        :param bool enabled: A flag to enable or disable SCIM for the identity provider.
        :param str identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        :param str scim_base_url: The base URL of Cloudflare's SCIM V2.0 API endpoint.
        :param bool seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param str secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        :param bool user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if identity_update_behavior is not None:
            pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        if scim_base_url is not None:
            pulumi.set(__self__, "scim_base_url", scim_base_url)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> Optional[str]:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        return pulumi.get(self, "identity_update_behavior")

    @property
    @pulumi.getter(name="scimBaseUrl")
    def scim_base_url(self) -> Optional[str]:
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        return pulumi.get(self, "scim_base_url")

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[bool]:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[bool]:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")


@pulumi.output_type
class ZeroTrustAccessInfrastructureTargetIp(dict):
    def __init__(__self__, *,
                 ipv4: Optional['outputs.ZeroTrustAccessInfrastructureTargetIpIpv4'] = None,
                 ipv6: Optional['outputs.ZeroTrustAccessInfrastructureTargetIpIpv6'] = None):
        """
        :param 'ZeroTrustAccessInfrastructureTargetIpIpv4Args' ipv4: The target's IPv4 address
        :param 'ZeroTrustAccessInfrastructureTargetIpIpv6Args' ipv6: The target's IPv6 address
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.ZeroTrustAccessInfrastructureTargetIpIpv4']:
        """
        The target's IPv4 address
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.ZeroTrustAccessInfrastructureTargetIpIpv6']:
        """
        The target's IPv6 address
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class ZeroTrustAccessInfrastructureTargetIpIpv4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddr":
            suggest = "ip_addr"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessInfrastructureTargetIpIpv4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessInfrastructureTargetIpIpv4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessInfrastructureTargetIpIpv4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addr: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str ip_addr: IP address of the target
        :param str virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        if ip_addr is not None:
            pulumi.set(__self__, "ip_addr", ip_addr)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> Optional[str]:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class ZeroTrustAccessInfrastructureTargetIpIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddr":
            suggest = "ip_addr"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessInfrastructureTargetIpIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessInfrastructureTargetIpIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessInfrastructureTargetIpIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addr: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str ip_addr: IP address of the target
        :param str virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        if ip_addr is not None:
            pulumi.set(__self__, "ip_addr", ip_addr)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> Optional[str]:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class ZeroTrustAccessMtlsHostnameSettingsSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chinaNetwork":
            suggest = "china_network"
        elif key == "clientCertificateForwarding":
            suggest = "client_certificate_forwarding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessMtlsHostnameSettingsSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessMtlsHostnameSettingsSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessMtlsHostnameSettingsSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 china_network: bool,
                 client_certificate_forwarding: bool,
                 hostname: str):
        """
        :param bool china_network: Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        :param bool client_certificate_forwarding: Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        :param str hostname: The hostname that these settings apply to.
        """
        pulumi.set(__self__, "china_network", china_network)
        pulumi.set(__self__, "client_certificate_forwarding", client_certificate_forwarding)
        pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="chinaNetwork")
    def china_network(self) -> bool:
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        return pulumi.get(self, "china_network")

    @property
    @pulumi.getter(name="clientCertificateForwarding")
    def client_certificate_forwarding(self) -> bool:
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        return pulumi.get(self, "client_certificate_forwarding")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname that these settings apply to.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class ZeroTrustAccessPolicyApprovalGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalsNeeded":
            suggest = "approvals_needed"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailListUuid":
            suggest = "email_list_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyApprovalGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyApprovalGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyApprovalGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approvals_needed: float,
                 email_addresses: Optional[Sequence[str]] = None,
                 email_list_uuid: Optional[str] = None):
        """
        :param float approvals_needed: The number of approvals needed to obtain access.
        :param Sequence[str] email_addresses: A list of emails that can approve the access request.
        :param str email_list_uuid: The UUID of an re-usable email list.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> float:
        """
        The number of approvals needed to obtain access.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of emails that can approve the access request.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[str]:
        """
        The UUID of an re-usable email list.
        """
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class ZeroTrustAccessPolicyExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessPolicyExcludeAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessPolicyExcludeAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessPolicyExcludeAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessPolicyExcludeAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessPolicyExcludeCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessPolicyExcludeCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessPolicyExcludeDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessPolicyExcludeEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessPolicyExcludeEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessPolicyExcludeEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessPolicyExcludeEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessPolicyExcludeExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessPolicyExcludeGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessPolicyExcludeGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessPolicyExcludeGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessPolicyExcludeGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessPolicyExcludeIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessPolicyExcludeIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessPolicyExcludeLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessPolicyExcludeOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessPolicyExcludeSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessPolicyExcludeServiceToken'] = None):
        """
        :param 'ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessPolicyExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeIpList']:
        return pulumi.get(self, "ip_list")
<<<<<<< HEAD
=======

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeLoginMethod']:
        return pulumi.get(self, "login_method")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessPolicyExcludeServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessPolicyExcludeLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessPolicyExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustAccessPolicyInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessPolicyIncludeAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessPolicyIncludeAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessPolicyIncludeAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessPolicyIncludeAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessPolicyIncludeCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessPolicyIncludeCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessPolicyIncludeDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessPolicyIncludeEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessPolicyIncludeEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessPolicyIncludeEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessPolicyIncludeEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessPolicyIncludeExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessPolicyIncludeGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessPolicyIncludeGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessPolicyIncludeGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessPolicyIncludeGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessPolicyIncludeIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessPolicyIncludeIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessPolicyIncludeLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessPolicyIncludeOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessPolicyIncludeSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessPolicyIncludeServiceToken'] = None):
        """
        :param 'ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessPolicyIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeIpList']:
        return pulumi.get(self, "ip_list")
<<<<<<< HEAD
=======

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeLoginMethod']:
        return pulumi.get(self, "login_method")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessPolicyIncludeServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessPolicyIncludeLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessPolicyIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContext":
            suggest = "auth_context"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "azureAd":
            suggest = "azure_ad"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePosture":
            suggest = "device_posture"
        elif key == "emailDomain":
            suggest = "email_domain"
        elif key == "emailList":
            suggest = "email_list"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "githubOrganization":
            suggest = "github_organization"
        elif key == "ipList":
            suggest = "ip_list"
<<<<<<< HEAD
=======
        elif key == "loginMethod":
            suggest = "login_method"
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        elif key == "serviceToken":
            suggest = "service_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional['outputs.ZeroTrustAccessPolicyRequireAnyValidServiceToken'] = None,
                 auth_context: Optional['outputs.ZeroTrustAccessPolicyRequireAuthContext'] = None,
                 auth_method: Optional['outputs.ZeroTrustAccessPolicyRequireAuthMethod'] = None,
                 azure_ad: Optional['outputs.ZeroTrustAccessPolicyRequireAzureAd'] = None,
                 certificate: Optional['outputs.ZeroTrustAccessPolicyRequireCertificate'] = None,
                 common_name: Optional['outputs.ZeroTrustAccessPolicyRequireCommonName'] = None,
                 device_posture: Optional['outputs.ZeroTrustAccessPolicyRequireDevicePosture'] = None,
                 email: Optional['outputs.ZeroTrustAccessPolicyRequireEmail'] = None,
                 email_domain: Optional['outputs.ZeroTrustAccessPolicyRequireEmailDomain'] = None,
                 email_list: Optional['outputs.ZeroTrustAccessPolicyRequireEmailList'] = None,
                 everyone: Optional['outputs.ZeroTrustAccessPolicyRequireEveryone'] = None,
                 external_evaluation: Optional['outputs.ZeroTrustAccessPolicyRequireExternalEvaluation'] = None,
                 geo: Optional['outputs.ZeroTrustAccessPolicyRequireGeo'] = None,
                 github_organization: Optional['outputs.ZeroTrustAccessPolicyRequireGithubOrganization'] = None,
                 group: Optional['outputs.ZeroTrustAccessPolicyRequireGroup'] = None,
                 gsuite: Optional['outputs.ZeroTrustAccessPolicyRequireGsuite'] = None,
                 ip: Optional['outputs.ZeroTrustAccessPolicyRequireIp'] = None,
                 ip_list: Optional['outputs.ZeroTrustAccessPolicyRequireIpList'] = None,
<<<<<<< HEAD
=======
                 login_method: Optional['outputs.ZeroTrustAccessPolicyRequireLoginMethod'] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: Optional['outputs.ZeroTrustAccessPolicyRequireOkta'] = None,
                 saml: Optional['outputs.ZeroTrustAccessPolicyRequireSaml'] = None,
                 service_token: Optional['outputs.ZeroTrustAccessPolicyRequireServiceToken'] = None):
        """
        :param 'ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'ZeroTrustAccessPolicyRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireAnyValidServiceToken']:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireAuthContext']:
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireAuthMethod']:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireAzureAd']:
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireCommonName']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireDevicePosture']:
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireEmailDomain']:
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireEmailList']:
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireEveryone']:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireGeo']:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireGithubOrganization']:
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireGroup']:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireGsuite']:
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireIpList']:
        return pulumi.get(self, "ip_list")
<<<<<<< HEAD
=======

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireLoginMethod']:
        return pulumi.get(self, "login_method")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def okta(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireOkta']:
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireSaml']:
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional['outputs.ZeroTrustAccessPolicyRequireServiceToken']:
        return pulumi.get(self, "service_token")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireAnyValidServiceToken(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyRequireAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyRequireCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireDevicePosture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationUid":
            suggest = "integration_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireDevicePosture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireDevicePosture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireDevicePosture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireEmail(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireEmailDomain(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireEmailList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireEveryone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ZeroTrustAccessPolicyRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireGeo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireGeo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireGeo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireGeo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireGithubOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireGithubOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireGithubOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireGithubOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: Optional[str] = None):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> Optional[str]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireGroup(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireIpList(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustAccessPolicyRequireLoginMethod(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustAccessPolicyRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireServiceToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenId":
            suggest = "token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireServiceToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireServiceToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireServiceToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class ZeroTrustDeviceCustomProfileExclude(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 description: Optional[str] = None,
                 host: Optional[str] = None):
        """
        :param str address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param str description: A description of the Split Tunnel item, displayed in the client UI.
        :param str host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class ZeroTrustDeviceCustomProfileFallbackDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDeviceCustomProfileFallbackDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDeviceCustomProfileFallbackDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDeviceCustomProfileFallbackDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 dns_servers: Optional[Sequence[str]] = None,
                 suffix: Optional[str] = None):
        """
        :param str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[str] dns_servers: A list of IP addresses to handle domain resolution.
        :param str suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ZeroTrustDeviceCustomProfileInclude(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 description: Optional[str] = None,
                 host: Optional[str] = None):
        """
        :param str address: The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        :param str description: A description of the split tunnel item, displayed in the client UI.
        :param str host: The domain name to include in the tunnel. If host is present, address must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class ZeroTrustDeviceCustomProfileLocalDomainFallbackDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDeviceCustomProfileLocalDomainFallbackDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDeviceCustomProfileLocalDomainFallbackDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDeviceCustomProfileLocalDomainFallbackDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 suffix: str,
                 description: Optional[str] = None,
                 dns_servers: Optional[Sequence[str]] = None):
        """
        :param str suffix: The domain suffix to match when resolving locally.
        :param str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[str] dns_servers: A list of IP addresses to handle domain resolution.
        """
        pulumi.set(__self__, "suffix", suffix)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter
    def suffix(self) -> str:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")


@pulumi.output_type
class ZeroTrustDeviceCustomProfileServiceModeV2(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 port: Optional[float] = None):
        """
        :param str mode: The mode to run the WARP client under.
        :param float port: The port number when used with proxy mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ZeroTrustDeviceCustomProfileTargetTest(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The id of the DEX test targeting this policy
        :param str name: The name of the DEX test targeting this policy
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the DEX test targeting this policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the DEX test targeting this policy
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustDeviceDefaultProfileExclude(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 description: Optional[str] = None,
                 host: Optional[str] = None):
        """
        :param str address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param str description: A description of the Split Tunnel item, displayed in the client UI.
        :param str host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class ZeroTrustDeviceDefaultProfileFallbackDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDeviceDefaultProfileFallbackDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDeviceDefaultProfileFallbackDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDeviceDefaultProfileFallbackDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 dns_servers: Optional[Sequence[str]] = None,
                 suffix: Optional[str] = None):
        """
        :param str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[str] dns_servers: A list of IP addresses to handle domain resolution.
        :param str suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ZeroTrustDeviceDefaultProfileInclude(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 description: Optional[str] = None,
                 host: Optional[str] = None):
        """
        :param str address: The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        :param str description: A description of the split tunnel item, displayed in the client UI.
        :param str host: The domain name to include in the tunnel. If host is present, address must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 suffix: str,
                 description: Optional[str] = None,
                 dns_servers: Optional[Sequence[str]] = None):
        """
        :param str suffix: The domain suffix to match when resolving locally.
        :param str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[str] dns_servers: A list of IP addresses to handle domain resolution.
        """
        pulumi.set(__self__, "suffix", suffix)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter
    def suffix(self) -> str:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")


@pulumi.output_type
class ZeroTrustDeviceDefaultProfileServiceModeV2(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 port: Optional[float] = None):
        """
        :param str mode: The mode to run the WARP client under.
        :param float port: The port number when used with proxy mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ZeroTrustDeviceManagedNetworksConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSockaddr":
            suggest = "tls_sockaddr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDeviceManagedNetworksConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDeviceManagedNetworksConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDeviceManagedNetworksConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tls_sockaddr: str,
                 sha256: Optional[str] = None):
        """
        :param str tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        :param str sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> str:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class ZeroTrustDevicePostureIntegrationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessClientId":
            suggest = "access_client_id"
        elif key == "accessClientSecret":
            suggest = "access_client_secret"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customerId":
            suggest = "customer_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDevicePostureIntegrationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDevicePostureIntegrationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDevicePostureIntegrationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_client_id: Optional[str] = None,
                 access_client_secret: Optional[str] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_key: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 customer_id: Optional[str] = None):
        """
        :param str access_client_id: If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`
        :param str access_client_secret: If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`
        :param str api_url: The Workspace One API URL provided in the Workspace One Admin Dashboard.
        :param str auth_url: The Workspace One Authorization URL depending on your region.
        :param str client_id: The Workspace One client ID provided in the Workspace One Admin Dashboard.
        :param str client_key: The Uptycs client secret.
        :param str client_secret: The Workspace One client secret provided in the Workspace One Admin Dashboard.
        :param str customer_id: The Crowdstrike customer ID.
        """
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[str]:
        """
        If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`
        """
        return pulumi.get(self, "access_client_id")

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[str]:
        """
        If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`
        """
        return pulumi.get(self, "access_client_secret")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        """
        The Workspace One Authorization URL depending on your region.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The Uptycs client secret.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Workspace One client secret provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[str]:
        """
        The Crowdstrike customer ID.
        """
        return pulumi.get(self, "customer_id")


@pulumi.output_type
class ZeroTrustDevicePostureRuleInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeThreats":
            suggest = "active_threats"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "checkDisks":
            suggest = "check_disks"
        elif key == "checkPrivateKey":
            suggest = "check_private_key"
        elif key == "complianceStatus":
            suggest = "compliance_status"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "countOperator":
            suggest = "count_operator"
        elif key == "eidLastSeen":
            suggest = "eid_last_seen"
        elif key == "extendedKeyUsages":
            suggest = "extended_key_usages"
        elif key == "isActive":
            suggest = "is_active"
        elif key == "issueCount":
            suggest = "issue_count"
        elif key == "lastSeen":
            suggest = "last_seen"
        elif key == "networkStatus":
            suggest = "network_status"
        elif key == "operatingSystem":
            suggest = "operating_system"
        elif key == "operationalState":
            suggest = "operational_state"
        elif key == "osDistroName":
            suggest = "os_distro_name"
        elif key == "osDistroRevision":
            suggest = "os_distro_revision"
        elif key == "osVersionExtra":
            suggest = "os_version_extra"
        elif key == "requireAll":
            suggest = "require_all"
        elif key == "riskLevel":
            suggest = "risk_level"
        elif key == "scoreOperator":
            suggest = "score_operator"
        elif key == "sensorConfig":
            suggest = "sensor_config"
        elif key == "totalScore":
            suggest = "total_score"
        elif key == "versionOperator":
            suggest = "version_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDevicePostureRuleInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDevicePostureRuleInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDevicePostureRuleInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_threats: Optional[float] = None,
                 certificate_id: Optional[str] = None,
                 check_disks: Optional[Sequence[str]] = None,
                 check_private_key: Optional[bool] = None,
                 cn: Optional[str] = None,
                 compliance_status: Optional[str] = None,
                 connection_id: Optional[str] = None,
                 count_operator: Optional[str] = None,
                 domain: Optional[str] = None,
                 eid_last_seen: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 exists: Optional[bool] = None,
                 extended_key_usages: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 infected: Optional[bool] = None,
                 is_active: Optional[bool] = None,
                 issue_count: Optional[str] = None,
                 last_seen: Optional[str] = None,
                 locations: Optional['outputs.ZeroTrustDevicePostureRuleInputLocations'] = None,
                 network_status: Optional[str] = None,
                 operating_system: Optional[str] = None,
                 operational_state: Optional[str] = None,
                 operator: Optional[str] = None,
                 os: Optional[str] = None,
                 os_distro_name: Optional[str] = None,
                 os_distro_revision: Optional[str] = None,
                 os_version_extra: Optional[str] = None,
                 overall: Optional[str] = None,
                 path: Optional[str] = None,
                 require_all: Optional[bool] = None,
                 risk_level: Optional[str] = None,
                 score: Optional[float] = None,
                 score_operator: Optional[str] = None,
                 sensor_config: Optional[str] = None,
                 sha256: Optional[str] = None,
                 state: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 total_score: Optional[float] = None,
                 version: Optional[str] = None,
                 version_operator: Optional[str] = None):
        """
        :param float active_threats: The Number of active threats.
        :param str certificate_id: UUID of Cloudflare managed certificate.
        :param Sequence[str] check_disks: List of volume names to be checked for encryption.
        :param bool check_private_key: Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        :param str cn: Common Name that is protected by the certificate
        :param str compliance_status: Compliance Status
        :param str connection_id: Posture Integration ID.
        :param str count_operator: Count Operator
        :param str domain: Domain
        :param str eid_last_seen: For more details on eid last seen, refer to the Tanium documentation.
        :param bool enabled: Enabled
        :param bool exists: Whether or not file exists
        :param Sequence[str] extended_key_usages: List of values indicating purposes for which the certificate public key can be used
        :param str id: List ID.
        :param bool infected: Whether device is infected.
        :param bool is_active: Whether device is active.
        :param str issue_count: The Number of Issues.
        :param str last_seen: For more details on last seen, please refer to the Crowdstrike documentation.
        :param str network_status: Network status of device.
        :param str operating_system: Operating system
        :param str operational_state: Agent operational state.
        :param str operator: operator
        :param str os: Os Version
        :param str os_distro_name: Operating System Distribution Name (linux only)
        :param str os_distro_revision: Version of OS Distribution (linux only)
        :param str os_version_extra: Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        :param str overall: overall
        :param str path: File path.
        :param bool require_all: Whether to check all disks for encryption.
        :param str risk_level: For more details on risk level, refer to the Tanium documentation.
        :param float score: A value between 0-100 assigned to devices set by the 3rd party posture provider.
        :param str score_operator: Score Operator
        :param str sensor_config: SensorConfig
        :param str sha256: SHA-256.
        :param str state: For more details on state, please refer to the Crowdstrike documentation.
        :param str thumbprint: Signing certificate thumbprint.
        :param float total_score: For more details on total score, refer to the Tanium documentation.
        :param str version: Version of OS
        :param str version_operator: Version Operator
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if check_private_key is not None:
            pulumi.set(__self__, "check_private_key", check_private_key)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if eid_last_seen is not None:
            pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if score_operator is not None:
            pulumi.set(__self__, "score_operator", score_operator)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if total_score is not None:
            pulumi.set(__self__, "total_score", total_score)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[float]:
        """
        The Number of active threats.
        """
        return pulumi.get(self, "active_threats")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[str]:
        """
        UUID of Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[Sequence[str]]:
        """
        List of volume names to be checked for encryption.
        """
        return pulumi.get(self, "check_disks")

    @property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> Optional[bool]:
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        return pulumi.get(self, "check_private_key")

    @property
    @pulumi.getter
    def cn(self) -> Optional[str]:
        """
        Common Name that is protected by the certificate
        """
        return pulumi.get(self, "cn")

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[str]:
        """
        Compliance Status
        """
        return pulumi.get(self, "compliance_status")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[str]:
        """
        Posture Integration ID.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[str]:
        """
        Count Operator
        """
        return pulumi.get(self, "count_operator")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[str]:
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        return pulumi.get(self, "eid_last_seen")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exists(self) -> Optional[bool]:
        """
        Whether or not file exists
        """
        return pulumi.get(self, "exists")

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[Sequence[str]]:
        """
        List of values indicating purposes for which the certificate public key can be used
        """
        return pulumi.get(self, "extended_key_usages")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        List ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def infected(self) -> Optional[bool]:
        """
        Whether device is infected.
        """
        return pulumi.get(self, "infected")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[bool]:
        """
        Whether device is active.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[str]:
        """
        The Number of Issues.
        """
        return pulumi.get(self, "issue_count")

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[str]:
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "last_seen")

    @property
    @pulumi.getter
    def locations(self) -> Optional['outputs.ZeroTrustDevicePostureRuleInputLocations']:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[str]:
        """
        Network status of device.
        """
        return pulumi.get(self, "network_status")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[str]:
        """
        Operating system
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[str]:
        """
        Agent operational state.
        """
        return pulumi.get(self, "operational_state")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        operator
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def os(self) -> Optional[str]:
        """
        Os Version
        """
        return pulumi.get(self, "os")

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[str]:
        """
        Operating System Distribution Name (linux only)
        """
        return pulumi.get(self, "os_distro_name")

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[str]:
        """
        Version of OS Distribution (linux only)
        """
        return pulumi.get(self, "os_distro_revision")

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[str]:
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        """
        return pulumi.get(self, "os_version_extra")

    @property
    @pulumi.getter
    def overall(self) -> Optional[str]:
        """
        overall
        """
        return pulumi.get(self, "overall")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        File path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[bool]:
        """
        Whether to check all disks for encryption.
        """
        return pulumi.get(self, "require_all")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[str]:
        """
        For more details on risk level, refer to the Tanium documentation.
        """
        return pulumi.get(self, "risk_level")

    @property
    @pulumi.getter
    def score(self) -> Optional[float]:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter(name="scoreOperator")
    def score_operator(self) -> Optional[str]:
        """
        Score Operator
        """
        return pulumi.get(self, "score_operator")

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[str]:
        """
        SensorConfig
        """
        return pulumi.get(self, "sensor_config")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        SHA-256.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        For more details on state, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        Signing certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[float]:
        """
        For more details on total score, refer to the Tanium documentation.
        """
        return pulumi.get(self, "total_score")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of OS
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[str]:
        """
        Version Operator
        """
        return pulumi.get(self, "version_operator")


@pulumi.output_type
class ZeroTrustDevicePostureRuleInputLocations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustStores":
            suggest = "trust_stores"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDevicePostureRuleInputLocations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDevicePostureRuleInputLocations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDevicePostureRuleInputLocations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paths: Optional[Sequence[str]] = None,
                 trust_stores: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] paths: List of paths to check for client certificate on linux.
        :param Sequence[str] trust_stores: List of trust stores to check for client certificate.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if trust_stores is not None:
            pulumi.set(__self__, "trust_stores", trust_stores)

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[str]]:
        """
        List of paths to check for client certificate on linux.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Optional[Sequence[str]]:
        """
        List of trust stores to check for client certificate.
        """
        return pulumi.get(self, "trust_stores")


@pulumi.output_type
class ZeroTrustDevicePostureRuleMatch(dict):
    def __init__(__self__, *,
                 platform: Optional[str] = None):
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        return pulumi.get(self, "platform")


@pulumi.output_type
class ZeroTrustDexTestData(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 kind: Optional[str] = None,
                 method: Optional[str] = None):
        """
        :param str host: The desired endpoint to test.
        :param str kind: The type of test.
        :param str method: The HTTP request method type.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The desired endpoint to test.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        The type of test.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP request method type.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class ZeroTrustDexTestTargetPolicy(dict):
    def __init__(__self__, *,
                 default: Optional[bool] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param bool default: Whether the profile is the account default
        :param str id: The id of the device settings profile
        :param str name: The name of the device settings profile
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> Optional[bool]:
        """
        Whether the profile is the account default
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the device settings profile
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the device settings profile
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustDlpCustomProfileContextAwareness(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 skip: 'outputs.ZeroTrustDlpCustomProfileContextAwarenessSkip'):
        """
        :param bool enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param 'ZeroTrustDlpCustomProfileContextAwarenessSkipArgs' skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def skip(self) -> 'outputs.ZeroTrustDlpCustomProfileContextAwarenessSkip':
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")


@pulumi.output_type
class ZeroTrustDlpCustomProfileContextAwarenessSkip(dict):
    def __init__(__self__, *,
                 files: bool):
        """
        :param bool files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> bool:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class ZeroTrustDlpCustomProfileEntry(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 pattern: Optional['outputs.ZeroTrustDlpCustomProfileEntryPattern'] = None,
                 words: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if words is not None:
            pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['outputs.ZeroTrustDlpCustomProfileEntryPattern']:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def words(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "words")


@pulumi.output_type
class ZeroTrustDlpCustomProfileEntryPattern(dict):
    def __init__(__self__, *,
                 regex: str,
                 validation: Optional[str] = None):
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> Optional[str]:
        return pulumi.get(self, "validation")


@pulumi.output_type
class ZeroTrustDlpCustomProfileProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
<<<<<<< HEAD
        if key == "allowedMatchCount":
=======
        if key == "aiContextEnabled":
            suggest = "ai_context_enabled"
        elif key == "allowedMatchCount":
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
            suggest = "allowed_match_count"
        elif key == "confidenceThreshold":
            suggest = "confidence_threshold"
        elif key == "contextAwareness":
            suggest = "context_awareness"
        elif key == "ocrEnabled":
            suggest = "ocr_enabled"
        elif key == "sharedEntries":
            suggest = "shared_entries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpCustomProfileProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpCustomProfileProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpCustomProfileProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entries: Sequence['outputs.ZeroTrustDlpCustomProfileProfileEntry'],
                 name: str,
<<<<<<< HEAD
=======
                 ai_context_enabled: Optional[bool] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 allowed_match_count: Optional[int] = None,
                 confidence_threshold: Optional[str] = None,
                 context_awareness: Optional['outputs.ZeroTrustDlpCustomProfileProfileContextAwareness'] = None,
                 description: Optional[str] = None,
                 ocr_enabled: Optional[bool] = None,
                 shared_entries: Optional[Sequence['outputs.ZeroTrustDlpCustomProfileProfileSharedEntry']] = None):
        """
        :param int allowed_match_count: Related DLP policies will trigger when the match count exceeds the number set.
        :param 'ZeroTrustDlpCustomProfileProfileContextAwarenessArgs' context_awareness: Scan the context of predefined entries to only return matches surrounded by keywords.
        :param str description: The description of the profile
        :param Sequence['ZeroTrustDlpCustomProfileProfileSharedEntryArgs'] shared_entries: Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles).
        """
        pulumi.set(__self__, "entries", entries)
        pulumi.set(__self__, "name", name)
<<<<<<< HEAD
=======
        if ai_context_enabled is not None:
            pulumi.set(__self__, "ai_context_enabled", ai_context_enabled)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if allowed_match_count is not None:
            pulumi.set(__self__, "allowed_match_count", allowed_match_count)
        if confidence_threshold is not None:
            pulumi.set(__self__, "confidence_threshold", confidence_threshold)
        if context_awareness is not None:
            pulumi.set(__self__, "context_awareness", context_awareness)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ocr_enabled is not None:
            pulumi.set(__self__, "ocr_enabled", ocr_enabled)
        if shared_entries is not None:
            pulumi.set(__self__, "shared_entries", shared_entries)

    @property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.ZeroTrustDlpCustomProfileProfileEntry']:
        return pulumi.get(self, "entries")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="aiContextEnabled")
    def ai_context_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "ai_context_enabled")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter(name="allowedMatchCount")
    def allowed_match_count(self) -> Optional[int]:
        """
        Related DLP policies will trigger when the match count exceeds the number set.
        """
        return pulumi.get(self, "allowed_match_count")

    @property
    @pulumi.getter(name="confidenceThreshold")
    def confidence_threshold(self) -> Optional[str]:
        return pulumi.get(self, "confidence_threshold")

    @property
    @pulumi.getter(name="contextAwareness")
    def context_awareness(self) -> Optional['outputs.ZeroTrustDlpCustomProfileProfileContextAwareness']:
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "context_awareness")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the profile
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ocrEnabled")
    def ocr_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "ocr_enabled")

    @property
    @pulumi.getter(name="sharedEntries")
    def shared_entries(self) -> Optional[Sequence['outputs.ZeroTrustDlpCustomProfileProfileSharedEntry']]:
        """
        Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles).
        """
        return pulumi.get(self, "shared_entries")


@pulumi.output_type
class ZeroTrustDlpCustomProfileProfileContextAwareness(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 skip: 'outputs.ZeroTrustDlpCustomProfileProfileContextAwarenessSkip'):
        """
        :param bool enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param 'ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgs' skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def skip(self) -> 'outputs.ZeroTrustDlpCustomProfileProfileContextAwarenessSkip':
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")


@pulumi.output_type
class ZeroTrustDlpCustomProfileProfileContextAwarenessSkip(dict):
    def __init__(__self__, *,
                 files: bool):
        """
        :param bool files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> bool:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class ZeroTrustDlpCustomProfileProfileEntry(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 pattern: Optional['outputs.ZeroTrustDlpCustomProfileProfileEntryPattern'] = None,
                 words: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if words is not None:
            pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['outputs.ZeroTrustDlpCustomProfileProfileEntryPattern']:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def words(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "words")


@pulumi.output_type
class ZeroTrustDlpCustomProfileProfileEntryPattern(dict):
    def __init__(__self__, *,
                 regex: str,
                 validation: Optional[str] = None):
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> Optional[str]:
        return pulumi.get(self, "validation")


@pulumi.output_type
class ZeroTrustDlpCustomProfileProfileSharedEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryId":
            suggest = "entry_id"
        elif key == "entryType":
            suggest = "entry_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpCustomProfileProfileSharedEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpCustomProfileProfileSharedEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpCustomProfileProfileSharedEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 entry_id: str,
                 entry_type: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "entry_id", entry_id)
        pulumi.set(__self__, "entry_type", entry_type)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> str:
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter(name="entryType")
    def entry_type(self) -> str:
        return pulumi.get(self, "entry_type")


@pulumi.output_type
class ZeroTrustDlpCustomProfileSharedEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryId":
            suggest = "entry_id"
        elif key == "entryType":
            suggest = "entry_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpCustomProfileSharedEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpCustomProfileSharedEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpCustomProfileSharedEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 entry_id: str,
                 entry_type: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "entry_id", entry_id)
        pulumi.set(__self__, "entry_type", entry_type)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> str:
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter(name="entryType")
    def entry_type(self) -> str:
        return pulumi.get(self, "entry_type")


@pulumi.output_type
class ZeroTrustDlpDatasetColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryId":
            suggest = "entry_id"
        elif key == "headerName":
            suggest = "header_name"
        elif key == "numCells":
            suggest = "num_cells"
        elif key == "uploadStatus":
            suggest = "upload_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpDatasetColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpDatasetColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpDatasetColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_id: Optional[str] = None,
                 header_name: Optional[str] = None,
                 num_cells: Optional[int] = None,
                 upload_status: Optional[str] = None):
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if upload_status is not None:
            pulumi.set(__self__, "upload_status", upload_status)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[str]:
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[int]:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter(name="uploadStatus")
    def upload_status(self) -> Optional[str]:
        return pulumi.get(self, "upload_status")


@pulumi.output_type
class ZeroTrustDlpDatasetDataset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "encodingVersion":
            suggest = "encoding_version"
        elif key == "numCells":
            suggest = "num_cells"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpDatasetDataset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpDatasetDataset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpDatasetDataset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.ZeroTrustDlpDatasetDatasetColumn']] = None,
                 created_at: Optional[str] = None,
                 description: Optional[str] = None,
                 encoding_version: Optional[int] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 num_cells: Optional[int] = None,
                 secret: Optional[bool] = None,
                 status: Optional[str] = None,
                 updated_at: Optional[str] = None,
                 uploads: Optional[Sequence['outputs.ZeroTrustDlpDatasetDatasetUpload']] = None):
        """
        :param str description: The description of the dataset
        :param str updated_at: When the dataset was last updated.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_version is not None:
            pulumi.set(__self__, "encoding_version", encoding_version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uploads is not None:
            pulumi.set(__self__, "uploads", uploads)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.ZeroTrustDlpDatasetDatasetColumn']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the dataset
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encodingVersion")
    def encoding_version(self) -> Optional[int]:
        return pulumi.get(self, "encoding_version")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[int]:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter
    def secret(self) -> Optional[bool]:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        When the dataset was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def uploads(self) -> Optional[Sequence['outputs.ZeroTrustDlpDatasetDatasetUpload']]:
        return pulumi.get(self, "uploads")


@pulumi.output_type
class ZeroTrustDlpDatasetDatasetColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryId":
            suggest = "entry_id"
        elif key == "headerName":
            suggest = "header_name"
        elif key == "numCells":
            suggest = "num_cells"
        elif key == "uploadStatus":
            suggest = "upload_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpDatasetDatasetColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpDatasetDatasetColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpDatasetDatasetColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_id: Optional[str] = None,
                 header_name: Optional[str] = None,
                 num_cells: Optional[int] = None,
                 upload_status: Optional[str] = None):
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if upload_status is not None:
            pulumi.set(__self__, "upload_status", upload_status)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[str]:
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[int]:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter(name="uploadStatus")
    def upload_status(self) -> Optional[str]:
        return pulumi.get(self, "upload_status")


@pulumi.output_type
class ZeroTrustDlpDatasetDatasetUpload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numCells":
            suggest = "num_cells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpDatasetDatasetUpload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpDatasetDatasetUpload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpDatasetDatasetUpload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_cells: Optional[int] = None,
                 status: Optional[str] = None,
                 version: Optional[int] = None):
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[int]:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[int]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ZeroTrustDlpDatasetUpload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numCells":
            suggest = "num_cells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpDatasetUpload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpDatasetUpload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpDatasetUpload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_cells: Optional[int] = None,
                 status: Optional[str] = None,
                 version: Optional[int] = None):
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[int]:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[int]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ZeroTrustDlpEntryConfidence(dict):
<<<<<<< HEAD
    def __init__(__self__, *,
=======
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aiContextAvailable":
            suggest = "ai_context_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDlpEntryConfidence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDlpEntryConfidence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDlpEntryConfidence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ai_context_available: Optional[bool] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 available: Optional[bool] = None):
        """
        :param bool available: Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
               Profiles that use an entry with `available` set to true can use confidence thresholds
        """
<<<<<<< HEAD
=======
        if ai_context_available is not None:
            pulumi.set(__self__, "ai_context_available", ai_context_available)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if available is not None:
            pulumi.set(__self__, "available", available)

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> Optional[bool]:
        return pulumi.get(self, "ai_context_available")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def available(self) -> Optional[bool]:
        """
        Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
        Profiles that use an entry with `available` set to true can use confidence thresholds
        """
        return pulumi.get(self, "available")


@pulumi.output_type
class ZeroTrustDlpEntryPattern(dict):
    def __init__(__self__, *,
                 regex: str,
                 validation: Optional[str] = None):
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> Optional[str]:
        return pulumi.get(self, "validation")


@pulumi.output_type
class ZeroTrustDlpPredefinedProfileContextAwareness(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 skip: 'outputs.ZeroTrustDlpPredefinedProfileContextAwarenessSkip'):
        """
        :param bool enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param 'ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs' skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def skip(self) -> 'outputs.ZeroTrustDlpPredefinedProfileContextAwarenessSkip':
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")


@pulumi.output_type
class ZeroTrustDlpPredefinedProfileContextAwarenessSkip(dict):
    def __init__(__self__, *,
                 files: bool):
        """
        :param bool files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> bool:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class ZeroTrustDlpPredefinedProfileEntry(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 id: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustDnsLocationEndpoints(dict):
    def __init__(__self__, *,
                 doh: Optional['outputs.ZeroTrustDnsLocationEndpointsDoh'] = None,
                 dot: Optional['outputs.ZeroTrustDnsLocationEndpointsDot'] = None,
                 ipv4: Optional['outputs.ZeroTrustDnsLocationEndpointsIpv4'] = None,
                 ipv6: Optional['outputs.ZeroTrustDnsLocationEndpointsIpv6'] = None):
        if doh is not None:
            pulumi.set(__self__, "doh", doh)
        if dot is not None:
            pulumi.set(__self__, "dot", dot)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def doh(self) -> Optional['outputs.ZeroTrustDnsLocationEndpointsDoh']:
        return pulumi.get(self, "doh")

    @property
    @pulumi.getter
    def dot(self) -> Optional['outputs.ZeroTrustDnsLocationEndpointsDot']:
        return pulumi.get(self, "dot")

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.ZeroTrustDnsLocationEndpointsIpv4']:
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.ZeroTrustDnsLocationEndpointsIpv6']:
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsDoh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireToken":
            suggest = "require_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDnsLocationEndpointsDoh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDnsLocationEndpointsDoh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDnsLocationEndpointsDoh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 networks: Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsDohNetwork']] = None,
                 require_token: Optional[bool] = None):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['ZeroTrustDnsLocationEndpointsDohNetworkArgs'] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        :param bool require_token: True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if require_token is not None:
            pulumi.set(__self__, "require_token", require_token)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsDohNetwork']]:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> Optional[bool]:
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        return pulumi.get(self, "require_token")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsDohNetwork(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsDot(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 networks: Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsDotNetwork']] = None):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['ZeroTrustDnsLocationEndpointsDotNetworkArgs'] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsDotNetwork']]:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsDotNetwork(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsIpv4(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsIpv6(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 networks: Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsIpv6Network']] = None):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs'] networks: A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsIpv6Network']]:
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsIpv6Network(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IPv6 address or IPv6 CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IPv6 address or IPv6 CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ZeroTrustDnsLocationNetwork(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
<<<<<<< HEAD
=======
class ZeroTrustGatewayLoggingSettingsByRuleType(dict):
    def __init__(__self__, *,
                 dns: Optional[str] = None,
                 http: Optional[str] = None,
                 l4: Optional[str] = None):
        """
        :param str dns: Logging settings for DNS firewall.
        :param str http: Logging settings for HTTP/HTTPS firewall.
        :param str l4: Logging settings for Network firewall.
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if l4 is not None:
            pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> Optional[str]:
        """
        Logging settings for DNS firewall.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def http(self) -> Optional[str]:
        """
        Logging settings for HTTP/HTTPS firewall.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def l4(self) -> Optional[str]:
        """
        Logging settings for Network firewall.
        """
        return pulumi.get(self, "l4")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class ZeroTrustGatewayPolicyExpiration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyExpiration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyExpiration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyExpiration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expires_at: str,
                 duration: Optional[int] = None,
                 expired: Optional[bool] = None):
        """
        :param str expires_at: The time stamp at which the policy will expire and cease to be
               applied.
        :param int duration: The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        :param bool expired: Whether the policy has expired.
        """
        pulumi.set(__self__, "expires_at", expires_at)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def expired(self) -> Optional[bool]:
        """
        Whether the policy has expired.
        """
        return pulumi.get(self, "expired")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addHeaders":
            suggest = "add_headers"
        elif key == "allowChildBypass":
            suggest = "allow_child_bypass"
        elif key == "auditSsh":
            suggest = "audit_ssh"
        elif key == "bisoAdminControls":
            suggest = "biso_admin_controls"
        elif key == "blockPageEnabled":
            suggest = "block_page_enabled"
        elif key == "blockReason":
            suggest = "block_reason"
        elif key == "bypassParentRule":
            suggest = "bypass_parent_rule"
        elif key == "checkSession":
            suggest = "check_session"
        elif key == "dnsResolvers":
            suggest = "dns_resolvers"
        elif key == "ignoreCnameCategoryMatches":
            suggest = "ignore_cname_category_matches"
        elif key == "insecureDisableDnssecValidation":
            suggest = "insecure_disable_dnssec_validation"
        elif key == "ipCategories":
            suggest = "ip_categories"
        elif key == "ipIndicatorFeeds":
            suggest = "ip_indicator_feeds"
        elif key == "notificationSettings":
            suggest = "notification_settings"
        elif key == "overrideHost":
            suggest = "override_host"
        elif key == "overrideIps":
            suggest = "override_ips"
        elif key == "payloadLog":
            suggest = "payload_log"
        elif key == "resolveDnsInternally":
            suggest = "resolve_dns_internally"
        elif key == "resolveDnsThroughCloudflare":
            suggest = "resolve_dns_through_cloudflare"
        elif key == "untrustedCert":
            suggest = "untrusted_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_headers: Optional[Mapping[str, str]] = None,
                 allow_child_bypass: Optional[bool] = None,
                 audit_ssh: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsAuditSsh'] = None,
                 biso_admin_controls: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls'] = None,
                 block_page_enabled: Optional[bool] = None,
                 block_reason: Optional[str] = None,
                 bypass_parent_rule: Optional[bool] = None,
                 check_session: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsCheckSession'] = None,
                 dns_resolvers: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolvers'] = None,
                 egress: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsEgress'] = None,
                 ignore_cname_category_matches: Optional[bool] = None,
                 insecure_disable_dnssec_validation: Optional[bool] = None,
                 ip_categories: Optional[bool] = None,
                 ip_indicator_feeds: Optional[bool] = None,
                 l4override: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsL4override'] = None,
                 notification_settings: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettings'] = None,
                 override_host: Optional[str] = None,
                 override_ips: Optional[Sequence[str]] = None,
                 payload_log: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLog'] = None,
                 quarantine: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsQuarantine'] = None,
                 resolve_dns_internally: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally'] = None,
                 resolve_dns_through_cloudflare: Optional[bool] = None,
                 untrusted_cert: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCert'] = None):
        """
        :param Mapping[str, str] add_headers: Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        :param bool allow_child_bypass: Set by parent MSP accounts to enable their children to bypass this rule.
        :param 'ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs' audit_ssh: Settings for the Audit SSH action.
        :param 'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs' biso_admin_controls: Configure how browser isolation behaves.
        :param bool block_page_enabled: Enable the custom block page.
        :param str block_reason: The text describing why this block occurred, displayed on the custom block page (if enabled).
        :param bool bypass_parent_rule: Set by children MSP accounts to bypass their parent's rules.
        :param 'ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs' check_session: Configure how session check behaves.
        :param 'ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs' dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        :param 'ZeroTrustGatewayPolicyRuleSettingsEgressArgs' egress: Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        :param bool ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        :param bool insecure_disable_dnssec_validation: INSECURE - disable DNSSEC validation (for Allow actions).
        :param bool ip_categories: Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        :param bool ip_indicator_feeds: Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        :param 'ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs' l4override: Send matching traffic to the supplied destination IP address and port.
        :param 'ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs' notification_settings: Configure a notification to display on the user's device when this rule is matched.
        :param str override_host: Override matching DNS queries with a hostname.
        :param Sequence[str] override_ips: Override matching DNS queries with an IP or set of IPs.
        :param 'ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs' payload_log: Configure DLP payload logging.
        :param 'ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs' quarantine: Settings that apply to quarantine rules
        :param 'ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs' resolve_dns_internally: Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        :param bool resolve_dns_through_cloudflare: Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        :param 'ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs' untrusted_cert: Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_reason is not None:
            pulumi.set(__self__, "block_reason", block_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if dns_resolvers is not None:
            pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ignore_cname_category_matches is not None:
            pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if ip_indicator_feeds is not None:
            pulumi.set(__self__, "ip_indicator_feeds", ip_indicator_feeds)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if quarantine is not None:
            pulumi.set(__self__, "quarantine", quarantine)
        if resolve_dns_internally is not None:
            pulumi.set(__self__, "resolve_dns_internally", resolve_dns_internally)
        if resolve_dns_through_cloudflare is not None:
            pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[Mapping[str, str]]:
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        return pulumi.get(self, "add_headers")

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[bool]:
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        return pulumi.get(self, "allow_child_bypass")

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsAuditSsh']:
        """
        Settings for the Audit SSH action.
        """
        return pulumi.get(self, "audit_ssh")

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls']:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[bool]:
        """
        Enable the custom block page.
        """
        return pulumi.get(self, "block_page_enabled")

    @property
    @pulumi.getter(name="blockReason")
    def block_reason(self) -> Optional[str]:
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        return pulumi.get(self, "block_reason")

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[bool]:
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsCheckSession']:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolvers']:
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "dns_resolvers")

    @property
    @pulumi.getter
    def egress(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsEgress']:
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> Optional[bool]:
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[bool]:
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[bool]:
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        return pulumi.get(self, "ip_categories")

    @property
    @pulumi.getter(name="ipIndicatorFeeds")
    def ip_indicator_feeds(self) -> Optional[bool]:
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        return pulumi.get(self, "ip_indicator_feeds")

    @property
    @pulumi.getter
    def l4override(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsL4override']:
        """
        Send matching traffic to the supplied destination IP address and port.
        """
        return pulumi.get(self, "l4override")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettings']:
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        return pulumi.get(self, "notification_settings")

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[str]:
        """
        Override matching DNS queries with a hostname.
        """
        return pulumi.get(self, "override_host")

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[Sequence[str]]:
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        return pulumi.get(self, "override_ips")

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLog']:
        """
        Configure DLP payload logging.
        """
        return pulumi.get(self, "payload_log")

    @property
    @pulumi.getter
    def quarantine(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsQuarantine']:
        """
        Settings that apply to quarantine rules
        """
        return pulumi.get(self, "quarantine")

    @property
    @pulumi.getter(name="resolveDnsInternally")
    def resolve_dns_internally(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally']:
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_internally")

    @property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> Optional[bool]:
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCert']:
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        return pulumi.get(self, "untrusted_cert")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsAuditSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandLogging":
            suggest = "command_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsAuditSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsAuditSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsAuditSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_logging: Optional[bool] = None):
        """
        :param bool command_logging: Enable to turn on SSH command logging.
        """
        if command_logging is not None:
            pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> Optional[bool]:
        """
        Enable to turn on SSH command logging.
        """
        return pulumi.get(self, "command_logging")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls(dict):
    def __init__(__self__, *,
                 copy: Optional[str] = None,
                 dcp: Optional[bool] = None,
                 dd: Optional[bool] = None,
                 dk: Optional[bool] = None,
                 download: Optional[str] = None,
                 dp: Optional[bool] = None,
                 du: Optional[bool] = None,
                 keyboard: Optional[str] = None,
                 paste: Optional[str] = None,
                 printing: Optional[str] = None,
                 upload: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str copy: Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        :param bool dcp: Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        :param bool dd: Set to false to enable downloading. Only applies when `version == "v1"`.
        :param bool dk: Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        :param str download: Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        :param bool dp: Set to false to enable printing. Only applies when `version == "v1"`.
        :param bool du: Set to false to enable uploading. Only applies when `version == "v1"`.
        :param str keyboard: Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        :param str paste: Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        :param str printing: Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        :param str upload: Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        :param str version: Indicates which version of the browser isolation controls should apply.
        """
        if copy is not None:
            pulumi.set(__self__, "copy", copy)
        if dcp is not None:
            pulumi.set(__self__, "dcp", dcp)
        if dd is not None:
            pulumi.set(__self__, "dd", dd)
        if dk is not None:
            pulumi.set(__self__, "dk", dk)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if dp is not None:
            pulumi.set(__self__, "dp", dp)
        if du is not None:
            pulumi.set(__self__, "du", du)
        if keyboard is not None:
            pulumi.set(__self__, "keyboard", keyboard)
        if paste is not None:
            pulumi.set(__self__, "paste", paste)
        if printing is not None:
            pulumi.set(__self__, "printing", printing)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def copy(self) -> Optional[str]:
        """
        Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "copy")

    @property
    @pulumi.getter
    def dcp(self) -> Optional[bool]:
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dcp")

    @property
    @pulumi.getter
    def dd(self) -> Optional[bool]:
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dd")

    @property
    @pulumi.getter
    def dk(self) -> Optional[bool]:
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dk")

    @property
    @pulumi.getter
    def download(self) -> Optional[str]:
        """
        Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "download")

    @property
    @pulumi.getter
    def dp(self) -> Optional[bool]:
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dp")

    @property
    @pulumi.getter
    def du(self) -> Optional[bool]:
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "du")

    @property
    @pulumi.getter
    def keyboard(self) -> Optional[str]:
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "keyboard")

    @property
    @pulumi.getter
    def paste(self) -> Optional[str]:
        """
        Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "paste")

    @property
    @pulumi.getter
    def printing(self) -> Optional[str]:
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "printing")

    @property
    @pulumi.getter
    def upload(self) -> Optional[str]:
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "upload")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Indicates which version of the browser isolation controls should apply.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsCheckSession(dict):
    def __init__(__self__, *,
                 duration: Optional[str] = None,
                 enforce: Optional[bool] = None):
        """
        :param str duration: Configure how fresh the session needs to be to be considered valid.
        :param bool enforce: Set to true to enable session enforcement.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enforce(self) -> Optional[bool]:
        """
        Set to true to enable session enforcement.
        """
        return pulumi.get(self, "enforce")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolvers(dict):
    def __init__(__self__, *,
                 ipv4s: Optional[Sequence['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4']] = None,
                 ipv6s: Optional[Sequence['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6']] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[Sequence['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4']]:
        return pulumi.get(self, "ipv4s")

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[Sequence['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6']]:
        return pulumi.get(self, "ipv6s")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeThroughPrivateNetwork":
            suggest = "route_through_private_network"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: str,
                 port: Optional[int] = None,
                 route_through_private_network: Optional[bool] = None,
                 vnet_id: Optional[str] = None):
        """
        :param str ip: IPv4 address of upstream resolver.
        :param int port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param str vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[bool]:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[str]:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeThroughPrivateNetwork":
            suggest = "route_through_private_network"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: str,
                 port: Optional[int] = None,
                 route_through_private_network: Optional[bool] = None,
                 vnet_id: Optional[str] = None):
        """
        :param str ip: IPv6 address of upstream resolver.
        :param int port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param str vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv6 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[bool]:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[str]:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Fallback":
            suggest = "ipv4_fallback"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4: Optional[str] = None,
                 ipv4_fallback: Optional[str] = None,
                 ipv6: Optional[str] = None):
        """
        :param str ipv4: The IPv4 address to be used for egress.
        :param str ipv4_fallback: The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        :param str ipv6: The IPv6 range to be used for egress.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[str]:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[str]:
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[str]:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsL4override(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str ip: IPv4 or IPv6 address.
        :param int port: A port number to use for TCP/UDP overrides.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        A port number to use for TCP/UDP overrides.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportUrl":
            suggest = "support_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 msg: Optional[str] = None,
                 support_url: Optional[str] = None):
        """
        :param bool enabled: Set notification on
        :param str msg: Customize the message shown in the notification.
        :param str support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Set notification on
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def msg(self) -> Optional[str]:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[str]:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsPayloadLog(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Set to true to enable DLP payload logging for this rule.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Set to true to enable DLP payload logging for this rule.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsQuarantine(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileTypes":
            suggest = "file_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsQuarantine. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsQuarantine.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsQuarantine.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_types: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] file_types: Types of files to sandbox.
        """
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[Sequence[str]]:
        """
        Types of files to sandbox.
        """
        return pulumi.get(self, "file_types")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewId":
            suggest = "view_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback: Optional[str] = None,
                 view_id: Optional[str] = None):
        """
        :param str fallback: The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        :param str view_id: The internal DNS view identifier that's passed to the internal DNS service.
        """
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if view_id is not None:
            pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter
    def fallback(self) -> Optional[str]:
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        """
        return pulumi.get(self, "fallback")

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> Optional[str]:
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
        return pulumi.get(self, "view_id")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsUntrustedCert(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None):
        """
        :param str action: The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class ZeroTrustGatewayPolicySchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicySchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicySchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicySchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fri: Optional[str] = None,
                 mon: Optional[str] = None,
                 sat: Optional[str] = None,
                 sun: Optional[str] = None,
                 thu: Optional[str] = None,
                 time_zone: Optional[str] = None,
                 tue: Optional[str] = None,
                 wed: Optional[str] = None):
        """
        :param str fri: The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        :param str mon: The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        :param str sat: The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        :param str sun: The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        :param str thu: The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        :param str time_zone: The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        :param str tue: The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        :param str wed: The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[str]:
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        return pulumi.get(self, "fri")

    @property
    @pulumi.getter
    def mon(self) -> Optional[str]:
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        return pulumi.get(self, "mon")

    @property
    @pulumi.getter
    def sat(self) -> Optional[str]:
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        return pulumi.get(self, "sat")

    @property
    @pulumi.getter
    def sun(self) -> Optional[str]:
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        return pulumi.get(self, "sun")

    @property
    @pulumi.getter
    def thu(self) -> Optional[str]:
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        return pulumi.get(self, "thu")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def tue(self) -> Optional[str]:
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        return pulumi.get(self, "tue")

    @property
    @pulumi.getter
    def wed(self) -> Optional[str]:
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        return pulumi.get(self, "wed")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activityLog":
            suggest = "activity_log"
        elif key == "blockPage":
            suggest = "block_page"
        elif key == "bodyScanning":
            suggest = "body_scanning"
        elif key == "browserIsolation":
            suggest = "browser_isolation"
        elif key == "customCertificate":
            suggest = "custom_certificate"
        elif key == "extendedEmailMatching":
            suggest = "extended_email_matching"
        elif key == "protocolDetection":
            suggest = "protocol_detection"
        elif key == "tlsDecrypt":
            suggest = "tls_decrypt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activity_log: Optional['outputs.ZeroTrustGatewaySettingsSettingsActivityLog'] = None,
                 antivirus: Optional['outputs.ZeroTrustGatewaySettingsSettingsAntivirus'] = None,
                 block_page: Optional['outputs.ZeroTrustGatewaySettingsSettingsBlockPage'] = None,
                 body_scanning: Optional['outputs.ZeroTrustGatewaySettingsSettingsBodyScanning'] = None,
                 browser_isolation: Optional['outputs.ZeroTrustGatewaySettingsSettingsBrowserIsolation'] = None,
                 certificate: Optional['outputs.ZeroTrustGatewaySettingsSettingsCertificate'] = None,
                 custom_certificate: Optional['outputs.ZeroTrustGatewaySettingsSettingsCustomCertificate'] = None,
                 extended_email_matching: Optional['outputs.ZeroTrustGatewaySettingsSettingsExtendedEmailMatching'] = None,
                 fips: Optional['outputs.ZeroTrustGatewaySettingsSettingsFips'] = None,
                 protocol_detection: Optional['outputs.ZeroTrustGatewaySettingsSettingsProtocolDetection'] = None,
                 sandbox: Optional['outputs.ZeroTrustGatewaySettingsSettingsSandbox'] = None,
                 tls_decrypt: Optional['outputs.ZeroTrustGatewaySettingsSettingsTlsDecrypt'] = None):
        """
        :param 'ZeroTrustGatewaySettingsSettingsActivityLogArgs' activity_log: Activity log settings.
        :param 'ZeroTrustGatewaySettingsSettingsAntivirusArgs' antivirus: Anti-virus settings.
        :param 'ZeroTrustGatewaySettingsSettingsBlockPageArgs' block_page: Block page layout settings.
        :param 'ZeroTrustGatewaySettingsSettingsBodyScanningArgs' body_scanning: DLP body scanning settings.
        :param 'ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs' browser_isolation: Browser isolation settings.
        :param 'ZeroTrustGatewaySettingsSettingsCertificateArgs' certificate: Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        :param 'ZeroTrustGatewaySettingsSettingsCustomCertificateArgs' custom_certificate: Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
        :param 'ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs' extended_email_matching: Extended e-mail matching settings.
        :param 'ZeroTrustGatewaySettingsSettingsFipsArgs' fips: FIPS settings.
        :param 'ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs' protocol_detection: Protocol Detection settings.
        :param 'ZeroTrustGatewaySettingsSettingsSandboxArgs' sandbox: Sandbox settings.
        :param 'ZeroTrustGatewaySettingsSettingsTlsDecryptArgs' tls_decrypt: TLS interception settings.
        """
        if activity_log is not None:
            pulumi.set(__self__, "activity_log", activity_log)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if block_page is not None:
            pulumi.set(__self__, "block_page", block_page)
        if body_scanning is not None:
            pulumi.set(__self__, "body_scanning", body_scanning)
        if browser_isolation is not None:
            pulumi.set(__self__, "browser_isolation", browser_isolation)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if extended_email_matching is not None:
            pulumi.set(__self__, "extended_email_matching", extended_email_matching)
        if fips is not None:
            pulumi.set(__self__, "fips", fips)
        if protocol_detection is not None:
            pulumi.set(__self__, "protocol_detection", protocol_detection)
        if sandbox is not None:
            pulumi.set(__self__, "sandbox", sandbox)
        if tls_decrypt is not None:
            pulumi.set(__self__, "tls_decrypt", tls_decrypt)

    @property
    @pulumi.getter(name="activityLog")
    def activity_log(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsActivityLog']:
        """
        Activity log settings.
        """
        return pulumi.get(self, "activity_log")

    @property
    @pulumi.getter
    def antivirus(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsAntivirus']:
        """
        Anti-virus settings.
        """
        return pulumi.get(self, "antivirus")

    @property
    @pulumi.getter(name="blockPage")
    def block_page(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsBlockPage']:
        """
        Block page layout settings.
        """
        return pulumi.get(self, "block_page")

    @property
    @pulumi.getter(name="bodyScanning")
    def body_scanning(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsBodyScanning']:
        """
        DLP body scanning settings.
        """
        return pulumi.get(self, "body_scanning")

    @property
    @pulumi.getter(name="browserIsolation")
    def browser_isolation(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsBrowserIsolation']:
        """
        Browser isolation settings.
        """
        return pulumi.get(self, "browser_isolation")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsCertificate']:
        """
        Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsCustomCertificate']:
        """
        Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="extendedEmailMatching")
    def extended_email_matching(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsExtendedEmailMatching']:
        """
        Extended e-mail matching settings.
        """
        return pulumi.get(self, "extended_email_matching")

    @property
    @pulumi.getter
    def fips(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsFips']:
        """
        FIPS settings.
        """
        return pulumi.get(self, "fips")

    @property
    @pulumi.getter(name="protocolDetection")
    def protocol_detection(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsProtocolDetection']:
        """
        Protocol Detection settings.
        """
        return pulumi.get(self, "protocol_detection")

    @property
    @pulumi.getter
    def sandbox(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsSandbox']:
        """
        Sandbox settings.
        """
        return pulumi.get(self, "sandbox")

    @property
    @pulumi.getter(name="tlsDecrypt")
    def tls_decrypt(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsTlsDecrypt']:
        """
        TLS interception settings.
        """
        return pulumi.get(self, "tls_decrypt")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsActivityLog(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enable activity logging.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable activity logging.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledDownloadPhase":
            suggest = "enabled_download_phase"
        elif key == "enabledUploadPhase":
            suggest = "enabled_upload_phase"
        elif key == "failClosed":
            suggest = "fail_closed"
        elif key == "notificationSettings":
            suggest = "notification_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSettingsAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSettingsAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSettingsAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_download_phase: Optional[bool] = None,
                 enabled_upload_phase: Optional[bool] = None,
                 fail_closed: Optional[bool] = None,
                 notification_settings: Optional['outputs.ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings'] = None):
        """
        :param bool enabled_download_phase: Enable anti-virus scanning on downloads.
        :param bool enabled_upload_phase: Enable anti-virus scanning on uploads.
        :param bool fail_closed: Block requests for files that cannot be scanned.
        :param 'ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs' notification_settings: Configure a message to display on the user's device when an antivirus search is performed.
        """
        if enabled_download_phase is not None:
            pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        if enabled_upload_phase is not None:
            pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        if fail_closed is not None:
            pulumi.set(__self__, "fail_closed", fail_closed)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> Optional[bool]:
        """
        Enable anti-virus scanning on downloads.
        """
        return pulumi.get(self, "enabled_download_phase")

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> Optional[bool]:
        """
        Enable anti-virus scanning on uploads.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> Optional[bool]:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings']:
        """
        Configure a message to display on the user's device when an antivirus search is performed.
        """
        return pulumi.get(self, "notification_settings")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportUrl":
            suggest = "support_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 msg: Optional[str] = None,
                 support_url: Optional[str] = None):
        """
        :param bool enabled: Set notification on
        :param str msg: Customize the message shown in the notification.
        :param str support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Set notification on
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def msg(self) -> Optional[str]:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[str]:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsBlockPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"
        elif key == "mailtoAddress":
            suggest = "mailto_address"
        elif key == "mailtoSubject":
            suggest = "mailto_subject"
        elif key == "suppressFooter":
            suggest = "suppress_footer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSettingsBlockPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSettingsBlockPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSettingsBlockPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 footer_text: Optional[str] = None,
                 header_text: Optional[str] = None,
                 logo_path: Optional[str] = None,
                 mailto_address: Optional[str] = None,
                 mailto_subject: Optional[str] = None,
                 name: Optional[str] = None,
                 suppress_footer: Optional[bool] = None):
        """
        :param str background_color: Block page background color in #rrggbb format.
        :param bool enabled: Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        :param str footer_text: Block page footer text.
        :param str header_text: Block page header text.
        :param str logo_path: Full URL to the logo file.
        :param str mailto_address: Admin email for users to contact.
        :param str mailto_subject: Subject line for emails created from block page.
        :param str name: Block page title.
        :param bool suppress_footer: Suppress detailed info at the bottom of the block page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if suppress_footer is not None:
            pulumi.set(__self__, "suppress_footer", suppress_footer)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        Block page background color in #rrggbb format.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[str]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[str]:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[str]:
        """
        Full URL to the logo file.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[str]:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[str]:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Block page title.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="suppressFooter")
    def suppress_footer(self) -> Optional[bool]:
        """
        Suppress detailed info at the bottom of the block page.
        """
        return pulumi.get(self, "suppress_footer")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsBodyScanning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectionMode":
            suggest = "inspection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSettingsBodyScanning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSettingsBodyScanning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSettingsBodyScanning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspection_mode: Optional[str] = None):
        """
        :param str inspection_mode: Set the inspection mode to either `deep` or `shallow`.
        """
        if inspection_mode is not None:
            pulumi.set(__self__, "inspection_mode", inspection_mode)

    @property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> Optional[str]:
        """
        Set the inspection mode to either `deep` or `shallow`.
        """
        return pulumi.get(self, "inspection_mode")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsBrowserIsolation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nonIdentityEnabled":
            suggest = "non_identity_enabled"
        elif key == "urlBrowserIsolationEnabled":
            suggest = "url_browser_isolation_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSettingsBrowserIsolation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSettingsBrowserIsolation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSettingsBrowserIsolation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 non_identity_enabled: Optional[bool] = None,
                 url_browser_isolation_enabled: Optional[bool] = None):
        """
        :param bool non_identity_enabled: Enable non-identity onramp support for Browser Isolation.
        :param bool url_browser_isolation_enabled: Enable Clientless Browser Isolation.
        """
        if non_identity_enabled is not None:
            pulumi.set(__self__, "non_identity_enabled", non_identity_enabled)
        if url_browser_isolation_enabled is not None:
            pulumi.set(__self__, "url_browser_isolation_enabled", url_browser_isolation_enabled)

    @property
    @pulumi.getter(name="nonIdentityEnabled")
    def non_identity_enabled(self) -> Optional[bool]:
        """
        Enable non-identity onramp support for Browser Isolation.
        """
        return pulumi.get(self, "non_identity_enabled")

    @property
    @pulumi.getter(name="urlBrowserIsolationEnabled")
    def url_browser_isolation_enabled(self) -> Optional[bool]:
        """
        Enable Clientless Browser Isolation.
        """
        return pulumi.get(self, "url_browser_isolation_enabled")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsCertificate(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsCustomCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindingStatus":
            suggest = "binding_status"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSettingsCustomCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSettingsCustomCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSettingsCustomCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 binding_status: Optional[str] = None,
                 id: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param bool enabled: Enable use of custom certificate authority for signing Gateway traffic.
        :param str binding_status: Certificate status (internal).
        :param str id: UUID of certificate (ID from MTLS certificate store).
        """
        pulumi.set(__self__, "enabled", enabled)
        if binding_status is not None:
            pulumi.set(__self__, "binding_status", binding_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable use of custom certificate authority for signing Gateway traffic.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="bindingStatus")
    def binding_status(self) -> Optional[str]:
        """
        Certificate status (internal).
        """
        return pulumi.get(self, "binding_status")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID of certificate (ID from MTLS certificate store).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsExtendedEmailMatching(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsFips(dict):
    def __init__(__self__, *,
                 tls: Optional[bool] = None):
        """
        :param bool tls: Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[bool]:
        """
        Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsProtocolDetection(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enable detecting protocol on initial bytes of client traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable detecting protocol on initial bytes of client traffic.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsSandbox(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackAction":
            suggest = "fallback_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSettingsSandbox. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSettingsSandbox.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSettingsSandbox.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 fallback_action: Optional[str] = None):
        """
        :param bool enabled: Enable sandbox.
        :param str fallback_action: Action to take when the file cannot be scanned.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable sandbox.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[str]:
        """
        Action to take when the file cannot be scanned.
        """
        return pulumi.get(self, "fallback_action")


@pulumi.output_type
class ZeroTrustGatewaySettingsSettingsTlsDecrypt(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enable inspecting encrypted HTTP traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable inspecting encrypted HTTP traffic.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustListItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustListItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustListItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustListItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str description: The description of the list item, if present
        :param str value: The value of the item in a list.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the list item, if present
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the item in a list.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ZeroTrustOrganizationCustomPages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityDenied":
            suggest = "identity_denied"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustOrganizationCustomPages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustOrganizationCustomPages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustOrganizationCustomPages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forbidden: Optional[str] = None,
                 identity_denied: Optional[str] = None):
        """
        :param str forbidden: The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        :param str identity_denied: The uid of the custom page to use when a user is denied access.
        """
        if forbidden is not None:
            pulumi.set(__self__, "forbidden", forbidden)
        if identity_denied is not None:
            pulumi.set(__self__, "identity_denied", identity_denied)

    @property
    @pulumi.getter
    def forbidden(self) -> Optional[str]:
        """
        The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        """
        return pulumi.get(self, "forbidden")

    @property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[str]:
        """
        The uid of the custom page to use when a user is denied access.
        """
        return pulumi.get(self, "identity_denied")


@pulumi.output_type
class ZeroTrustOrganizationLoginDesign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustOrganizationLoginDesign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustOrganizationLoginDesign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustOrganizationLoginDesign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 footer_text: Optional[str] = None,
                 header_text: Optional[str] = None,
                 logo_path: Optional[str] = None,
                 text_color: Optional[str] = None):
        """
        :param str background_color: The background color on your login page.
        :param str footer_text: The text at the bottom of your login page.
        :param str header_text: The text at the top of your login page.
        :param str logo_path: The URL of the logo on your login page.
        :param str text_color: The text color on your login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color on your login page.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[str]:
        """
        The text at the bottom of your login page.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[str]:
        """
        The text at the top of your login page.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[str]:
        """
        The URL of the logo on your login page.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[str]:
        """
        The text color on your login page.
        """
        return pulumi.get(self, "text_color")


@pulumi.output_type
class ZeroTrustRiskBehaviorBehaviors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "riskLevel":
            suggest = "risk_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustRiskBehaviorBehaviors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustRiskBehaviorBehaviors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustRiskBehaviorBehaviors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 risk_level: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originRequest":
            suggest = "origin_request"
        elif key == "warpRouting":
            suggest = "warp_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingresses: Optional[Sequence['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngress']] = None,
                 origin_request: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequest'] = None,
                 warp_routing: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRouting'] = None):
        """
        :param Sequence['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs'] ingresses: List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        :param 'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs' origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param 'ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs' warp_routing: Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        if ingresses is not None:
            pulumi.set(__self__, "ingresses", ingresses)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @property
    @pulumi.getter
    def ingresses(self) -> Optional[Sequence['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngress']]:
        """
        List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        """
        return pulumi.get(self, "ingresses")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequest']:
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRouting']:
        """
        Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        return pulumi.get(self, "warp_routing")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originRequest":
            suggest = "origin_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: str,
                 hostname: Optional[str] = None,
                 origin_request: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest'] = None,
                 path: Optional[str] = None):
        """
        :param str service: Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        :param str hostname: Public hostname for this service.
        :param 'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs' origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param str path: Requests with this path route to this public hostname.
        """
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Public hostname for this service.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest']:
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Requests with this path route to this public hostname.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caPool":
            suggest = "ca_pool"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "disableChunkedEncoding":
            suggest = "disable_chunked_encoding"
        elif key == "http2Origin":
            suggest = "http2_origin"
        elif key == "httpHostHeader":
            suggest = "http_host_header"
        elif key == "keepAliveConnections":
            suggest = "keep_alive_connections"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "noHappyEyeballs":
            suggest = "no_happy_eyeballs"
        elif key == "noTlsVerify":
            suggest = "no_tls_verify"
        elif key == "originServerName":
            suggest = "origin_server_name"
        elif key == "proxyType":
            suggest = "proxy_type"
        elif key == "tcpKeepAlive":
            suggest = "tcp_keep_alive"
        elif key == "tlsTimeout":
            suggest = "tls_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess'] = None,
                 ca_pool: Optional[str] = None,
                 connect_timeout: Optional[int] = None,
                 disable_chunked_encoding: Optional[bool] = None,
                 http2_origin: Optional[bool] = None,
                 http_host_header: Optional[str] = None,
                 keep_alive_connections: Optional[int] = None,
                 keep_alive_timeout: Optional[int] = None,
                 no_happy_eyeballs: Optional[bool] = None,
                 no_tls_verify: Optional[bool] = None,
                 origin_server_name: Optional[str] = None,
                 proxy_type: Optional[str] = None,
                 tcp_keep_alive: Optional[int] = None,
                 tls_timeout: Optional[int] = None):
        """
        :param 'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs' access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param str ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param int connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param bool disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param bool http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param str http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param int keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param int keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param bool no_happy_eyeballs: Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param bool no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param str origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param str proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param int tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param int tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess']:
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[str]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[bool]:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[bool]:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[str]:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[int]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[int]:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[bool]:
        """
        Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[bool]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[str]:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[int]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[int]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audTags":
            suggest = "aud_tags"
        elif key == "teamName":
            suggest = "team_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aud_tags: Sequence[str],
                 required: Optional[bool] = None,
                 team_name: Optional[str] = None):
        """
        :param Sequence[str] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param bool required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Sequence[str]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[str]:
        return pulumi.get(self, "team_name")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caPool":
            suggest = "ca_pool"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "disableChunkedEncoding":
            suggest = "disable_chunked_encoding"
        elif key == "http2Origin":
            suggest = "http2_origin"
        elif key == "httpHostHeader":
            suggest = "http_host_header"
        elif key == "keepAliveConnections":
            suggest = "keep_alive_connections"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "noHappyEyeballs":
            suggest = "no_happy_eyeballs"
        elif key == "noTlsVerify":
            suggest = "no_tls_verify"
        elif key == "originServerName":
            suggest = "origin_server_name"
        elif key == "proxyType":
            suggest = "proxy_type"
        elif key == "tcpKeepAlive":
            suggest = "tcp_keep_alive"
        elif key == "tlsTimeout":
            suggest = "tls_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigOriginRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigOriginRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigOriginRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess'] = None,
                 ca_pool: Optional[str] = None,
                 connect_timeout: Optional[int] = None,
                 disable_chunked_encoding: Optional[bool] = None,
                 http2_origin: Optional[bool] = None,
                 http_host_header: Optional[str] = None,
                 keep_alive_connections: Optional[int] = None,
                 keep_alive_timeout: Optional[int] = None,
                 no_happy_eyeballs: Optional[bool] = None,
                 no_tls_verify: Optional[bool] = None,
                 origin_server_name: Optional[str] = None,
                 proxy_type: Optional[str] = None,
                 tcp_keep_alive: Optional[int] = None,
                 tls_timeout: Optional[int] = None):
        """
        :param 'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs' access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param str ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param int connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param bool disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param bool http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param str http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param int keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param int keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param bool no_happy_eyeballs: Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param bool no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param str origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param str proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param int tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param int tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess']:
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[str]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[bool]:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[bool]:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[str]:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[int]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[int]:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[bool]:
        """
        Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[bool]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[str]:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[int]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[int]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audTags":
            suggest = "aud_tags"
        elif key == "teamName":
            suggest = "team_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aud_tags: Sequence[str],
                 required: Optional[bool] = None,
                 team_name: Optional[str] = None):
        """
        :param Sequence[str] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param bool required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Sequence[str]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[str]:
        return pulumi.get(self, "team_name")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigWarpRouting(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientVersion":
            suggest = "client_version"
        elif key == "coloName":
            suggest = "colo_name"
        elif key == "isPendingReconnect":
            suggest = "is_pending_reconnect"
        elif key == "openedAt":
            suggest = "opened_at"
        elif key == "originIp":
            suggest = "origin_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_version: Optional[str] = None,
                 colo_name: Optional[str] = None,
                 id: Optional[str] = None,
                 is_pending_reconnect: Optional[bool] = None,
                 opened_at: Optional[str] = None,
                 origin_ip: Optional[str] = None,
                 uuid: Optional[str] = None):
        """
        :param str client_id: UUID of the Cloudflare Tunnel connector.
        :param str client_version: The cloudflared version used to establish this connection.
        :param str colo_name: The Cloudflare data center used for this connection.
        :param str id: UUID of the Cloudflare Tunnel connection.
        :param bool is_pending_reconnect: Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        :param str opened_at: Timestamp of when the connection was established.
        :param str origin_ip: The public IP address of the host running cloudflared.
        :param str uuid: UUID of the Cloudflare Tunnel connection.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_version is not None:
            pulumi.set(__self__, "client_version", client_version)
        if colo_name is not None:
            pulumi.set(__self__, "colo_name", colo_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_pending_reconnect is not None:
            pulumi.set(__self__, "is_pending_reconnect", is_pending_reconnect)
        if opened_at is not None:
            pulumi.set(__self__, "opened_at", opened_at)
        if origin_ip is not None:
            pulumi.set(__self__, "origin_ip", origin_ip)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        UUID of the Cloudflare Tunnel connector.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientVersion")
    def client_version(self) -> Optional[str]:
        """
        The cloudflared version used to establish this connection.
        """
        return pulumi.get(self, "client_version")

    @property
    @pulumi.getter(name="coloName")
    def colo_name(self) -> Optional[str]:
        """
        The Cloudflare data center used for this connection.
        """
        return pulumi.get(self, "colo_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPendingReconnect")
    def is_pending_reconnect(self) -> Optional[bool]:
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        return pulumi.get(self, "is_pending_reconnect")

    @property
    @pulumi.getter(name="openedAt")
    def opened_at(self) -> Optional[str]:
        """
        Timestamp of when the connection was established.
        """
        return pulumi.get(self, "opened_at")

    @property
    @pulumi.getter(name="originIp")
    def origin_ip(self) -> Optional[str]:
        """
        The public IP address of the host running cloudflared.
        """
        return pulumi.get(self, "origin_ip")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ZoneAccount(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: Identifier
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZoneCacheVariantsValue(dict):
    def __init__(__self__, *,
                 avifs: Optional[Sequence[str]] = None,
                 bmps: Optional[Sequence[str]] = None,
                 gifs: Optional[Sequence[str]] = None,
                 jp2s: Optional[Sequence[str]] = None,
                 jpegs: Optional[Sequence[str]] = None,
                 jpg2s: Optional[Sequence[str]] = None,
                 jpgs: Optional[Sequence[str]] = None,
                 pngs: Optional[Sequence[str]] = None,
                 tiffs: Optional[Sequence[str]] = None,
                 tifs: Optional[Sequence[str]] = None,
                 webps: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] avifs: List of strings with the MIME types of all the variants that should be served for avif.
        :param Sequence[str] bmps: List of strings with the MIME types of all the variants that should be served for bmp.
        :param Sequence[str] gifs: List of strings with the MIME types of all the variants that should be served for gif.
        :param Sequence[str] jp2s: List of strings with the MIME types of all the variants that should be served for jp2.
        :param Sequence[str] jpegs: List of strings with the MIME types of all the variants that should be served for jpeg.
        :param Sequence[str] jpg2s: List of strings with the MIME types of all the variants that should be served for jpg2.
        :param Sequence[str] jpgs: List of strings with the MIME types of all the variants that should be served for jpg.
        :param Sequence[str] pngs: List of strings with the MIME types of all the variants that should be served for png.
        :param Sequence[str] tiffs: List of strings with the MIME types of all the variants that should be served for tiff.
        :param Sequence[str] tifs: List of strings with the MIME types of all the variants that should be served for tif.
        :param Sequence[str] webps: List of strings with the MIME types of all the variants that should be served for webp.
        """
        if avifs is not None:
            pulumi.set(__self__, "avifs", avifs)
        if bmps is not None:
            pulumi.set(__self__, "bmps", bmps)
        if gifs is not None:
            pulumi.set(__self__, "gifs", gifs)
        if jp2s is not None:
            pulumi.set(__self__, "jp2s", jp2s)
        if jpegs is not None:
            pulumi.set(__self__, "jpegs", jpegs)
        if jpg2s is not None:
            pulumi.set(__self__, "jpg2s", jpg2s)
        if jpgs is not None:
            pulumi.set(__self__, "jpgs", jpgs)
        if pngs is not None:
            pulumi.set(__self__, "pngs", pngs)
        if tiffs is not None:
            pulumi.set(__self__, "tiffs", tiffs)
        if tifs is not None:
            pulumi.set(__self__, "tifs", tifs)
        if webps is not None:
            pulumi.set(__self__, "webps", webps)

    @property
    @pulumi.getter
    def avifs(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for avif.
        """
        return pulumi.get(self, "avifs")

    @property
    @pulumi.getter
    def bmps(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for bmp.
        """
        return pulumi.get(self, "bmps")

    @property
    @pulumi.getter
    def gifs(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for gif.
        """
        return pulumi.get(self, "gifs")

    @property
    @pulumi.getter
    def jp2s(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for jp2.
        """
        return pulumi.get(self, "jp2s")

    @property
    @pulumi.getter
    def jpegs(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpeg.
        """
        return pulumi.get(self, "jpegs")

    @property
    @pulumi.getter
    def jpg2s(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpg2.
        """
        return pulumi.get(self, "jpg2s")

    @property
    @pulumi.getter
    def jpgs(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpg.
        """
        return pulumi.get(self, "jpgs")

    @property
    @pulumi.getter
    def pngs(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for png.
        """
        return pulumi.get(self, "pngs")

    @property
    @pulumi.getter
    def tiffs(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for tiff.
        """
        return pulumi.get(self, "tiffs")

    @property
    @pulumi.getter
    def tifs(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for tif.
        """
        return pulumi.get(self, "tifs")

    @property
    @pulumi.getter
    def webps(self) -> Optional[Sequence[str]]:
        """
        List of strings with the MIME types of all the variants that should be served for webp.
        """
        return pulumi.get(self, "webps")


@pulumi.output_type
class ZoneLockdownConfiguration(dict):
    def __init__(__self__, *,
                 target: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str target: The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        :param str value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ZoneMeta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdnOnly":
            suggest = "cdn_only"
        elif key == "customCertificateQuota":
            suggest = "custom_certificate_quota"
        elif key == "dnsOnly":
            suggest = "dns_only"
        elif key == "foundationDns":
            suggest = "foundation_dns"
        elif key == "pageRuleQuota":
            suggest = "page_rule_quota"
        elif key == "phishingDetected":
            suggest = "phishing_detected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneMeta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneMeta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneMeta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdn_only: Optional[bool] = None,
                 custom_certificate_quota: Optional[int] = None,
                 dns_only: Optional[bool] = None,
                 foundation_dns: Optional[bool] = None,
                 page_rule_quota: Optional[int] = None,
                 phishing_detected: Optional[bool] = None,
                 step: Optional[int] = None):
        """
        :param bool cdn_only: The zone is only configured for CDN
        :param int custom_certificate_quota: Number of Custom Certificates the zone can have
        :param bool dns_only: The zone is only configured for DNS
        :param bool foundation_dns: The zone is setup with Foundation DNS
        :param int page_rule_quota: Number of Page Rules a zone can have
        :param bool phishing_detected: The zone has been flagged for phishing
        """
        if cdn_only is not None:
            pulumi.set(__self__, "cdn_only", cdn_only)
        if custom_certificate_quota is not None:
            pulumi.set(__self__, "custom_certificate_quota", custom_certificate_quota)
        if dns_only is not None:
            pulumi.set(__self__, "dns_only", dns_only)
        if foundation_dns is not None:
            pulumi.set(__self__, "foundation_dns", foundation_dns)
        if page_rule_quota is not None:
            pulumi.set(__self__, "page_rule_quota", page_rule_quota)
        if phishing_detected is not None:
            pulumi.set(__self__, "phishing_detected", phishing_detected)
        if step is not None:
            pulumi.set(__self__, "step", step)

    @property
    @pulumi.getter(name="cdnOnly")
    def cdn_only(self) -> Optional[bool]:
        """
        The zone is only configured for CDN
        """
        return pulumi.get(self, "cdn_only")

    @property
    @pulumi.getter(name="customCertificateQuota")
    def custom_certificate_quota(self) -> Optional[int]:
        """
        Number of Custom Certificates the zone can have
        """
        return pulumi.get(self, "custom_certificate_quota")

    @property
    @pulumi.getter(name="dnsOnly")
    def dns_only(self) -> Optional[bool]:
        """
        The zone is only configured for DNS
        """
        return pulumi.get(self, "dns_only")

    @property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> Optional[bool]:
        """
        The zone is setup with Foundation DNS
        """
        return pulumi.get(self, "foundation_dns")

    @property
    @pulumi.getter(name="pageRuleQuota")
    def page_rule_quota(self) -> Optional[int]:
        """
        Number of Page Rules a zone can have
        """
        return pulumi.get(self, "page_rule_quota")

    @property
    @pulumi.getter(name="phishingDetected")
    def phishing_detected(self) -> Optional[bool]:
        """
        The zone has been flagged for phishing
        """
        return pulumi.get(self, "phishing_detected")

    @property
    @pulumi.getter
    def step(self) -> Optional[int]:
        return pulumi.get(self, "step")


@pulumi.output_type
class ZoneOwner(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: Identifier
        :param str name: Name of the owner
        :param str type: The type of owner
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the owner
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of owner
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ZoneSubscriptionRatePlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externallyManaged":
            suggest = "externally_managed"
        elif key == "isContract":
            suggest = "is_contract"
        elif key == "publicName":
            suggest = "public_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSubscriptionRatePlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSubscriptionRatePlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSubscriptionRatePlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency: Optional[str] = None,
                 externally_managed: Optional[bool] = None,
                 id: Optional[str] = None,
                 is_contract: Optional[bool] = None,
                 public_name: Optional[str] = None,
                 scope: Optional[str] = None,
                 sets: Optional[Sequence[str]] = None):
        """
        :param str currency: The currency applied to the rate plan subscription.
        :param bool externally_managed: Whether this rate plan is managed externally from Cloudflare.
        :param str id: The ID of the rate plan.
        :param bool is_contract: Whether a rate plan is enterprise-based (or newly adopted term contract).
        :param str public_name: The full name of the rate plan.
        :param str scope: The scope that this rate plan applies to.
        :param Sequence[str] sets: The list of sets this rate plan applies to.
        """
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if externally_managed is not None:
            pulumi.set(__self__, "externally_managed", externally_managed)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_contract is not None:
            pulumi.set(__self__, "is_contract", is_contract)
        if public_name is not None:
            pulumi.set(__self__, "public_name", public_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sets is not None:
            pulumi.set(__self__, "sets", sets)

    @property
    @pulumi.getter
    def currency(self) -> Optional[str]:
        """
        The currency applied to the rate plan subscription.
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="externallyManaged")
    def externally_managed(self) -> Optional[bool]:
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        return pulumi.get(self, "externally_managed")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the rate plan.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isContract")
    def is_contract(self) -> Optional[bool]:
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        return pulumi.get(self, "is_contract")

    @property
    @pulumi.getter(name="publicName")
    def public_name(self) -> Optional[str]:
        """
        The full name of the rate plan.
        """
        return pulumi.get(self, "public_name")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope that this rate plan applies to.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def sets(self) -> Optional[Sequence[str]]:
        """
        The list of sets this rate plan applies to.
        """
        return pulumi.get(self, "sets")


@pulumi.output_type
class GetAccessRuleConfigurationResult(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        :param str value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccessRuleFilterResult(dict):
    def __init__(__self__, *,
                 match: str,
                 configuration: Optional['outputs.GetAccessRuleFilterConfigurationResult'] = None,
                 direction: Optional[str] = None,
                 mode: Optional[str] = None,
                 notes: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str match: When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
        :param str direction: The direction used to sort returned rules.
        :param str mode: The action to apply to a matched request.
        :param str notes: The string to search for in the notes of existing IP Access rules.
               Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
        :param str order: The field used to sort returned rules.
        """
        pulumi.set(__self__, "match", match)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.GetAccessRuleFilterConfigurationResult']:
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction used to sort returned rules.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The action to apply to a matched request.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def notes(self) -> Optional[str]:
        """
        The string to search for in the notes of existing IP Access rules.
        Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
        """
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field used to sort returned rules.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class GetAccessRuleFilterConfigurationResult(dict):
    def __init__(__self__, *,
                 target: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str target: The target to search in existing rules.
        :param str value: The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
               Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The target to search in existing rules.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccessRuleScopeResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: str,
                 type: str):
        """
        :param str email: The contact email address of the user.
        :param str id: Identifier
        :param str type: The scope of the rule.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The scope of the rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAccessRulesConfigurationResult(dict):
    def __init__(__self__, *,
                 target: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str target: The target to search in existing rules.
        :param str value: The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
               Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The target to search in existing rules.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccessRulesResultResult(dict):
    def __init__(__self__, *,
                 allowed_modes: Sequence[str],
                 configuration: 'outputs.GetAccessRulesResultConfigurationResult',
                 created_on: str,
                 id: str,
                 mode: str,
                 modified_on: str,
                 notes: str,
                 scope: 'outputs.GetAccessRulesResultScopeResult'):
        """
        :param Sequence[str] allowed_modes: The available actions that a rule can apply to a matched request.
        :param 'GetAccessRulesResultConfigurationArgs' configuration: The rule configuration.
        :param str created_on: The timestamp of when the rule was created.
        :param str id: The unique identifier of the IP Access rule.
        :param str mode: The action to apply to a matched request.
        :param str modified_on: The timestamp of when the rule was last modified.
        :param str notes: An informative summary of the rule, typically used as a reminder or explanation.
        :param 'GetAccessRulesResultScopeArgs' scope: All zones owned by the user will have the rule applied.
        """
        pulumi.set(__self__, "allowed_modes", allowed_modes)
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="allowedModes")
    def allowed_modes(self) -> Sequence[str]:
        """
        The available actions that a rule can apply to a matched request.
        """
        return pulumi.get(self, "allowed_modes")

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.GetAccessRulesResultConfigurationResult':
        """
        The rule configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The timestamp of when the rule was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the IP Access rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The action to apply to a matched request.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The timestamp of when the rule was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def notes(self) -> str:
        """
        An informative summary of the rule, typically used as a reminder or explanation.
        """
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter
    def scope(self) -> 'outputs.GetAccessRulesResultScopeResult':
        """
        All zones owned by the user will have the rule applied.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetAccessRulesResultConfigurationResult(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        :param str value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccessRulesResultScopeResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: str,
                 type: str):
        """
        :param str email: The contact email address of the user.
        :param str id: Identifier
        :param str type: The scope of the rule.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The scope of the rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAccountFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        :param str name: Name of the account.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the account.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAccountMemberFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        :param str order: Field to order results by.
        :param str status: A member's status in the account.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order results by.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        A member's status in the account.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAccountMemberPolicyResult(dict):
    def __init__(__self__, *,
                 access: str,
                 id: str,
                 permission_groups: Sequence['outputs.GetAccountMemberPolicyPermissionGroupResult'],
                 resource_groups: Sequence['outputs.GetAccountMemberPolicyResourceGroupResult']):
        """
        :param str access: Allow or deny operations against the resources.
        :param str id: Policy identifier.
        :param Sequence['GetAccountMemberPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Sequence['GetAccountMemberPolicyResourceGroupArgs'] resource_groups: A list of resource groups that the policy applies to.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.GetAccountMemberPolicyPermissionGroupResult']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Sequence['outputs.GetAccountMemberPolicyResourceGroupResult']:
        """
        A list of resource groups that the policy applies to.
        """
        return pulumi.get(self, "resource_groups")


@pulumi.output_type
class GetAccountMemberPolicyPermissionGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetAccountMemberPolicyPermissionGroupMetaResult',
                 name: str):
        """
        :param str id: Identifier of the group.
        :param 'GetAccountMemberPolicyPermissionGroupMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetAccountMemberPolicyPermissionGroupMetaResult':
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAccountMemberPolicyPermissionGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountMemberPolicyResourceGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetAccountMemberPolicyResourceGroupMetaResult',
                 name: str,
                 scopes: Sequence['outputs.GetAccountMemberPolicyResourceGroupScopeResult']):
        """
        :param str id: Identifier of the group.
        :param 'GetAccountMemberPolicyResourceGroupMetaArgs' meta: Attributes associated to the resource group.
        :param str name: Name of the resource group.
        :param Sequence['GetAccountMemberPolicyResourceGroupScopeArgs'] scopes: The scope associated to the resource group
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetAccountMemberPolicyResourceGroupMetaResult':
        """
        Attributes associated to the resource group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the resource group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetAccountMemberPolicyResourceGroupScopeResult']:
        """
        The scope associated to the resource group
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetAccountMemberPolicyResourceGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountMemberPolicyResourceGroupScopeResult(dict):
    def __init__(__self__, *,
                 key: str,
                 objects: Sequence['outputs.GetAccountMemberPolicyResourceGroupScopeObjectResult']):
        """
        :param str key: This is a combination of pre-defined resource name and identifier (like Account ID etc.)
        :param Sequence['GetAccountMemberPolicyResourceGroupScopeObjectArgs'] objects: A list of scope objects for additional context.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "objects", objects)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        This is a combination of pre-defined resource name and identifier (like Account ID etc.)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def objects(self) -> Sequence['outputs.GetAccountMemberPolicyResourceGroupScopeObjectResult']:
        """
        A list of scope objects for additional context.
        """
        return pulumi.get(self, "objects")


@pulumi.output_type
class GetAccountMemberPolicyResourceGroupScopeObjectResult(dict):
    def __init__(__self__, *,
                 key: str):
        """
        :param str key: This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class GetAccountMemberRoleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 name: str,
                 permissions: 'outputs.GetAccountMemberRolePermissionsResult'):
        """
        :param str description: Description of role's permissions.
        :param str id: Role identifier tag.
        :param str name: Role name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of role's permissions.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Role identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Role name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> 'outputs.GetAccountMemberRolePermissionsResult':
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetAccountMemberRolePermissionsResult(dict):
    def __init__(__self__, *,
                 analytics: 'outputs.GetAccountMemberRolePermissionsAnalyticsResult',
                 billing: 'outputs.GetAccountMemberRolePermissionsBillingResult',
                 cache_purge: 'outputs.GetAccountMemberRolePermissionsCachePurgeResult',
                 dns: 'outputs.GetAccountMemberRolePermissionsDnsResult',
                 dns_records: 'outputs.GetAccountMemberRolePermissionsDnsRecordsResult',
                 lb: 'outputs.GetAccountMemberRolePermissionsLbResult',
                 logs: 'outputs.GetAccountMemberRolePermissionsLogsResult',
                 organization: 'outputs.GetAccountMemberRolePermissionsOrganizationResult',
                 ssl: 'outputs.GetAccountMemberRolePermissionsSslResult',
                 waf: 'outputs.GetAccountMemberRolePermissionsWafResult',
                 zone_settings: 'outputs.GetAccountMemberRolePermissionsZoneSettingsResult',
                 zones: 'outputs.GetAccountMemberRolePermissionsZonesResult'):
        pulumi.set(__self__, "analytics", analytics)
        pulumi.set(__self__, "billing", billing)
        pulumi.set(__self__, "cache_purge", cache_purge)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_records", dns_records)
        pulumi.set(__self__, "lb", lb)
        pulumi.set(__self__, "logs", logs)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "waf", waf)
        pulumi.set(__self__, "zone_settings", zone_settings)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def analytics(self) -> 'outputs.GetAccountMemberRolePermissionsAnalyticsResult':
        return pulumi.get(self, "analytics")

    @property
    @pulumi.getter
    def billing(self) -> 'outputs.GetAccountMemberRolePermissionsBillingResult':
        return pulumi.get(self, "billing")

    @property
    @pulumi.getter(name="cachePurge")
    def cache_purge(self) -> 'outputs.GetAccountMemberRolePermissionsCachePurgeResult':
        return pulumi.get(self, "cache_purge")

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.GetAccountMemberRolePermissionsDnsResult':
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> 'outputs.GetAccountMemberRolePermissionsDnsRecordsResult':
        return pulumi.get(self, "dns_records")

    @property
    @pulumi.getter
    def lb(self) -> 'outputs.GetAccountMemberRolePermissionsLbResult':
        return pulumi.get(self, "lb")

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.GetAccountMemberRolePermissionsLogsResult':
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def organization(self) -> 'outputs.GetAccountMemberRolePermissionsOrganizationResult':
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def ssl(self) -> 'outputs.GetAccountMemberRolePermissionsSslResult':
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def waf(self) -> 'outputs.GetAccountMemberRolePermissionsWafResult':
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter(name="zoneSettings")
    def zone_settings(self) -> 'outputs.GetAccountMemberRolePermissionsZoneSettingsResult':
        return pulumi.get(self, "zone_settings")

    @property
    @pulumi.getter
    def zones(self) -> 'outputs.GetAccountMemberRolePermissionsZonesResult':
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetAccountMemberRolePermissionsAnalyticsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsBillingResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsCachePurgeResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsDnsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsDnsRecordsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsLbResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsLogsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsOrganizationResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsSslResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsWafResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsZoneSettingsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberRolePermissionsZonesResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMemberUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 first_name: str,
                 id: str,
                 last_name: str,
                 two_factor_authentication_enabled: bool):
        """
        :param str email: The contact email address of the user.
        :param str first_name: User's first name
        :param str id: Identifier
        :param str last_name: User's last name
        :param bool two_factor_authentication_enabled: Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "two_factor_authentication_enabled", two_factor_authentication_enabled)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        User's first name
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        User's last name
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="twoFactorAuthenticationEnabled")
    def two_factor_authentication_enabled(self) -> bool:
        """
        Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        return pulumi.get(self, "two_factor_authentication_enabled")


@pulumi.output_type
class GetAccountMembersResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policies: Sequence['outputs.GetAccountMembersResultPolicyResult'],
                 roles: Sequence['outputs.GetAccountMembersResultRoleResult'],
                 status: str,
                 user: 'outputs.GetAccountMembersResultUserResult'):
        """
        :param str id: Membership identifier tag.
        :param Sequence['GetAccountMembersResultPolicyArgs'] policies: Access policy for the membership
        :param Sequence['GetAccountMembersResultRoleArgs'] roles: Roles assigned to this Member.
        :param str status: A member's status in the account.
        :param 'GetAccountMembersResultUserArgs' user: Details of the user associated to the membership.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Membership identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetAccountMembersResultPolicyResult']:
        """
        Access policy for the membership
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetAccountMembersResultRoleResult']:
        """
        Roles assigned to this Member.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        A member's status in the account.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def user(self) -> 'outputs.GetAccountMembersResultUserResult':
        """
        Details of the user associated to the membership.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetAccountMembersResultPolicyResult(dict):
    def __init__(__self__, *,
                 access: str,
                 id: str,
                 permission_groups: Sequence['outputs.GetAccountMembersResultPolicyPermissionGroupResult'],
                 resource_groups: Sequence['outputs.GetAccountMembersResultPolicyResourceGroupResult']):
        """
        :param str access: Allow or deny operations against the resources.
        :param str id: Policy identifier.
        :param Sequence['GetAccountMembersResultPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Sequence['GetAccountMembersResultPolicyResourceGroupArgs'] resource_groups: A list of resource groups that the policy applies to.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.GetAccountMembersResultPolicyPermissionGroupResult']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Sequence['outputs.GetAccountMembersResultPolicyResourceGroupResult']:
        """
        A list of resource groups that the policy applies to.
        """
        return pulumi.get(self, "resource_groups")


@pulumi.output_type
class GetAccountMembersResultPolicyPermissionGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetAccountMembersResultPolicyPermissionGroupMetaResult',
                 name: str):
        """
        :param str id: Identifier of the group.
        :param 'GetAccountMembersResultPolicyPermissionGroupMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetAccountMembersResultPolicyPermissionGroupMetaResult':
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAccountMembersResultPolicyPermissionGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountMembersResultPolicyResourceGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetAccountMembersResultPolicyResourceGroupMetaResult',
                 name: str,
                 scopes: Sequence['outputs.GetAccountMembersResultPolicyResourceGroupScopeResult']):
        """
        :param str id: Identifier of the group.
        :param 'GetAccountMembersResultPolicyResourceGroupMetaArgs' meta: Attributes associated to the resource group.
        :param str name: Name of the resource group.
        :param Sequence['GetAccountMembersResultPolicyResourceGroupScopeArgs'] scopes: The scope associated to the resource group
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetAccountMembersResultPolicyResourceGroupMetaResult':
        """
        Attributes associated to the resource group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the resource group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetAccountMembersResultPolicyResourceGroupScopeResult']:
        """
        The scope associated to the resource group
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetAccountMembersResultPolicyResourceGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountMembersResultPolicyResourceGroupScopeResult(dict):
    def __init__(__self__, *,
                 key: str,
                 objects: Sequence['outputs.GetAccountMembersResultPolicyResourceGroupScopeObjectResult']):
        """
        :param str key: This is a combination of pre-defined resource name and identifier (like Account ID etc.)
        :param Sequence['GetAccountMembersResultPolicyResourceGroupScopeObjectArgs'] objects: A list of scope objects for additional context.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "objects", objects)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        This is a combination of pre-defined resource name and identifier (like Account ID etc.)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def objects(self) -> Sequence['outputs.GetAccountMembersResultPolicyResourceGroupScopeObjectResult']:
        """
        A list of scope objects for additional context.
        """
        return pulumi.get(self, "objects")


@pulumi.output_type
class GetAccountMembersResultPolicyResourceGroupScopeObjectResult(dict):
    def __init__(__self__, *,
                 key: str):
        """
        :param str key: This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class GetAccountMembersResultRoleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 name: str,
                 permissions: 'outputs.GetAccountMembersResultRolePermissionsResult'):
        """
        :param str description: Description of role's permissions.
        :param str id: Role identifier tag.
        :param str name: Role name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of role's permissions.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Role identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Role name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> 'outputs.GetAccountMembersResultRolePermissionsResult':
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsResult(dict):
    def __init__(__self__, *,
                 analytics: 'outputs.GetAccountMembersResultRolePermissionsAnalyticsResult',
                 billing: 'outputs.GetAccountMembersResultRolePermissionsBillingResult',
                 cache_purge: 'outputs.GetAccountMembersResultRolePermissionsCachePurgeResult',
                 dns: 'outputs.GetAccountMembersResultRolePermissionsDnsResult',
                 dns_records: 'outputs.GetAccountMembersResultRolePermissionsDnsRecordsResult',
                 lb: 'outputs.GetAccountMembersResultRolePermissionsLbResult',
                 logs: 'outputs.GetAccountMembersResultRolePermissionsLogsResult',
                 organization: 'outputs.GetAccountMembersResultRolePermissionsOrganizationResult',
                 ssl: 'outputs.GetAccountMembersResultRolePermissionsSslResult',
                 waf: 'outputs.GetAccountMembersResultRolePermissionsWafResult',
                 zone_settings: 'outputs.GetAccountMembersResultRolePermissionsZoneSettingsResult',
                 zones: 'outputs.GetAccountMembersResultRolePermissionsZonesResult'):
        pulumi.set(__self__, "analytics", analytics)
        pulumi.set(__self__, "billing", billing)
        pulumi.set(__self__, "cache_purge", cache_purge)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_records", dns_records)
        pulumi.set(__self__, "lb", lb)
        pulumi.set(__self__, "logs", logs)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "waf", waf)
        pulumi.set(__self__, "zone_settings", zone_settings)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def analytics(self) -> 'outputs.GetAccountMembersResultRolePermissionsAnalyticsResult':
        return pulumi.get(self, "analytics")

    @property
    @pulumi.getter
    def billing(self) -> 'outputs.GetAccountMembersResultRolePermissionsBillingResult':
        return pulumi.get(self, "billing")

    @property
    @pulumi.getter(name="cachePurge")
    def cache_purge(self) -> 'outputs.GetAccountMembersResultRolePermissionsCachePurgeResult':
        return pulumi.get(self, "cache_purge")

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.GetAccountMembersResultRolePermissionsDnsResult':
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> 'outputs.GetAccountMembersResultRolePermissionsDnsRecordsResult':
        return pulumi.get(self, "dns_records")

    @property
    @pulumi.getter
    def lb(self) -> 'outputs.GetAccountMembersResultRolePermissionsLbResult':
        return pulumi.get(self, "lb")

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.GetAccountMembersResultRolePermissionsLogsResult':
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def organization(self) -> 'outputs.GetAccountMembersResultRolePermissionsOrganizationResult':
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def ssl(self) -> 'outputs.GetAccountMembersResultRolePermissionsSslResult':
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def waf(self) -> 'outputs.GetAccountMembersResultRolePermissionsWafResult':
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter(name="zoneSettings")
    def zone_settings(self) -> 'outputs.GetAccountMembersResultRolePermissionsZoneSettingsResult':
        return pulumi.get(self, "zone_settings")

    @property
    @pulumi.getter
    def zones(self) -> 'outputs.GetAccountMembersResultRolePermissionsZonesResult':
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsAnalyticsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsBillingResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsCachePurgeResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsDnsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsDnsRecordsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsLbResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsLogsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsOrganizationResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsSslResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsWafResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsZoneSettingsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultRolePermissionsZonesResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountMembersResultUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 first_name: str,
                 id: str,
                 last_name: str,
                 two_factor_authentication_enabled: bool):
        """
        :param str email: The contact email address of the user.
        :param str first_name: User's first name
        :param str id: Identifier
        :param str last_name: User's last name
        :param bool two_factor_authentication_enabled: Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "two_factor_authentication_enabled", two_factor_authentication_enabled)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        User's first name
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        User's last name
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="twoFactorAuthenticationEnabled")
    def two_factor_authentication_enabled(self) -> bool:
        """
        Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        return pulumi.get(self, "two_factor_authentication_enabled")


@pulumi.output_type
class GetAccountRolePermissionsResult(dict):
    def __init__(__self__, *,
                 analytics: 'outputs.GetAccountRolePermissionsAnalyticsResult',
                 billing: 'outputs.GetAccountRolePermissionsBillingResult',
                 cache_purge: 'outputs.GetAccountRolePermissionsCachePurgeResult',
                 dns: 'outputs.GetAccountRolePermissionsDnsResult',
                 dns_records: 'outputs.GetAccountRolePermissionsDnsRecordsResult',
                 lb: 'outputs.GetAccountRolePermissionsLbResult',
                 logs: 'outputs.GetAccountRolePermissionsLogsResult',
                 organization: 'outputs.GetAccountRolePermissionsOrganizationResult',
                 ssl: 'outputs.GetAccountRolePermissionsSslResult',
                 waf: 'outputs.GetAccountRolePermissionsWafResult',
                 zone_settings: 'outputs.GetAccountRolePermissionsZoneSettingsResult',
                 zones: 'outputs.GetAccountRolePermissionsZonesResult'):
        pulumi.set(__self__, "analytics", analytics)
        pulumi.set(__self__, "billing", billing)
        pulumi.set(__self__, "cache_purge", cache_purge)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_records", dns_records)
        pulumi.set(__self__, "lb", lb)
        pulumi.set(__self__, "logs", logs)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "waf", waf)
        pulumi.set(__self__, "zone_settings", zone_settings)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def analytics(self) -> 'outputs.GetAccountRolePermissionsAnalyticsResult':
        return pulumi.get(self, "analytics")

    @property
    @pulumi.getter
    def billing(self) -> 'outputs.GetAccountRolePermissionsBillingResult':
        return pulumi.get(self, "billing")

    @property
    @pulumi.getter(name="cachePurge")
    def cache_purge(self) -> 'outputs.GetAccountRolePermissionsCachePurgeResult':
        return pulumi.get(self, "cache_purge")

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.GetAccountRolePermissionsDnsResult':
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> 'outputs.GetAccountRolePermissionsDnsRecordsResult':
        return pulumi.get(self, "dns_records")

    @property
    @pulumi.getter
    def lb(self) -> 'outputs.GetAccountRolePermissionsLbResult':
        return pulumi.get(self, "lb")

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.GetAccountRolePermissionsLogsResult':
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def organization(self) -> 'outputs.GetAccountRolePermissionsOrganizationResult':
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def ssl(self) -> 'outputs.GetAccountRolePermissionsSslResult':
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def waf(self) -> 'outputs.GetAccountRolePermissionsWafResult':
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter(name="zoneSettings")
    def zone_settings(self) -> 'outputs.GetAccountRolePermissionsZoneSettingsResult':
        return pulumi.get(self, "zone_settings")

    @property
    @pulumi.getter
    def zones(self) -> 'outputs.GetAccountRolePermissionsZonesResult':
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetAccountRolePermissionsAnalyticsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsBillingResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsCachePurgeResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsDnsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsDnsRecordsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsLbResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsLogsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsOrganizationResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsSslResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsWafResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsZoneSettingsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolePermissionsZonesResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 name: str,
                 permissions: 'outputs.GetAccountRolesResultPermissionsResult'):
        """
        :param str description: Description of role's permissions.
        :param str id: Role identifier tag.
        :param str name: Role name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of role's permissions.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Role identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Role name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> 'outputs.GetAccountRolesResultPermissionsResult':
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetAccountRolesResultPermissionsResult(dict):
    def __init__(__self__, *,
                 analytics: 'outputs.GetAccountRolesResultPermissionsAnalyticsResult',
                 billing: 'outputs.GetAccountRolesResultPermissionsBillingResult',
                 cache_purge: 'outputs.GetAccountRolesResultPermissionsCachePurgeResult',
                 dns: 'outputs.GetAccountRolesResultPermissionsDnsResult',
                 dns_records: 'outputs.GetAccountRolesResultPermissionsDnsRecordsResult',
                 lb: 'outputs.GetAccountRolesResultPermissionsLbResult',
                 logs: 'outputs.GetAccountRolesResultPermissionsLogsResult',
                 organization: 'outputs.GetAccountRolesResultPermissionsOrganizationResult',
                 ssl: 'outputs.GetAccountRolesResultPermissionsSslResult',
                 waf: 'outputs.GetAccountRolesResultPermissionsWafResult',
                 zone_settings: 'outputs.GetAccountRolesResultPermissionsZoneSettingsResult',
                 zones: 'outputs.GetAccountRolesResultPermissionsZonesResult'):
        pulumi.set(__self__, "analytics", analytics)
        pulumi.set(__self__, "billing", billing)
        pulumi.set(__self__, "cache_purge", cache_purge)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_records", dns_records)
        pulumi.set(__self__, "lb", lb)
        pulumi.set(__self__, "logs", logs)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "waf", waf)
        pulumi.set(__self__, "zone_settings", zone_settings)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def analytics(self) -> 'outputs.GetAccountRolesResultPermissionsAnalyticsResult':
        return pulumi.get(self, "analytics")

    @property
    @pulumi.getter
    def billing(self) -> 'outputs.GetAccountRolesResultPermissionsBillingResult':
        return pulumi.get(self, "billing")

    @property
    @pulumi.getter(name="cachePurge")
    def cache_purge(self) -> 'outputs.GetAccountRolesResultPermissionsCachePurgeResult':
        return pulumi.get(self, "cache_purge")

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.GetAccountRolesResultPermissionsDnsResult':
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> 'outputs.GetAccountRolesResultPermissionsDnsRecordsResult':
        return pulumi.get(self, "dns_records")

    @property
    @pulumi.getter
    def lb(self) -> 'outputs.GetAccountRolesResultPermissionsLbResult':
        return pulumi.get(self, "lb")

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.GetAccountRolesResultPermissionsLogsResult':
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def organization(self) -> 'outputs.GetAccountRolesResultPermissionsOrganizationResult':
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def ssl(self) -> 'outputs.GetAccountRolesResultPermissionsSslResult':
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def waf(self) -> 'outputs.GetAccountRolesResultPermissionsWafResult':
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter(name="zoneSettings")
    def zone_settings(self) -> 'outputs.GetAccountRolesResultPermissionsZoneSettingsResult':
        return pulumi.get(self, "zone_settings")

    @property
    @pulumi.getter
    def zones(self) -> 'outputs.GetAccountRolesResultPermissionsZonesResult':
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetAccountRolesResultPermissionsAnalyticsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsBillingResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsCachePurgeResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsDnsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsDnsRecordsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsLbResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsLogsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsOrganizationResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsSslResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsWafResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsZoneSettingsResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountRolesResultPermissionsZonesResult(dict):
    def __init__(__self__, *,
                 read: bool,
                 write: bool):
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def read(self) -> bool:
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> bool:
        return pulumi.get(self, "write")


@pulumi.output_type
class GetAccountSettingsResult(dict):
    def __init__(__self__, *,
                 abuse_contact_email: str,
                 default_nameservers: str,
                 enforce_twofactor: bool,
                 use_account_custom_ns_by_default: bool):
        """
        :param str abuse_contact_email: Sets an abuse contact email to notify for abuse reports.
        :param str default_nameservers: Specifies the default nameservers to be used for new zones added to this account.
        :param bool enforce_twofactor: Indicates whether membership in this account requires that
               Two-Factor Authentication is enabled
        :param bool use_account_custom_ns_by_default: Indicates whether new zones should use the account-level custom
               nameservers by default.
               
               Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
        pulumi.set(__self__, "abuse_contact_email", abuse_contact_email)
        pulumi.set(__self__, "default_nameservers", default_nameservers)
        pulumi.set(__self__, "enforce_twofactor", enforce_twofactor)
        pulumi.set(__self__, "use_account_custom_ns_by_default", use_account_custom_ns_by_default)

    @property
    @pulumi.getter(name="abuseContactEmail")
    def abuse_contact_email(self) -> str:
        """
        Sets an abuse contact email to notify for abuse reports.
        """
        return pulumi.get(self, "abuse_contact_email")

    @property
    @pulumi.getter(name="defaultNameservers")
    def default_nameservers(self) -> str:
        """
        Specifies the default nameservers to be used for new zones added to this account.
        """
        return pulumi.get(self, "default_nameservers")

    @property
    @pulumi.getter(name="enforceTwofactor")
    def enforce_twofactor(self) -> bool:
        """
        Indicates whether membership in this account requires that
        Two-Factor Authentication is enabled
        """
        return pulumi.get(self, "enforce_twofactor")

    @property
    @pulumi.getter(name="useAccountCustomNsByDefault")
    def use_account_custom_ns_by_default(self) -> bool:
        """
        Indicates whether new zones should use the account-level custom
        nameservers by default.

        Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
        return pulumi.get(self, "use_account_custom_ns_by_default")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetAccountSubscriptionRatePlanResult(dict):
    def __init__(__self__, *,
                 currency: str,
                 externally_managed: bool,
                 id: str,
                 is_contract: bool,
                 public_name: str,
                 scope: str,
                 sets: Sequence[str]):
        """
        :param str currency: The currency applied to the rate plan subscription.
        :param bool externally_managed: Whether this rate plan is managed externally from Cloudflare.
        :param str id: The ID of the rate plan.
        :param bool is_contract: Whether a rate plan is enterprise-based (or newly adopted term contract).
        :param str public_name: The full name of the rate plan.
        :param str scope: The scope that this rate plan applies to.
        :param Sequence[str] sets: The list of sets this rate plan applies to.
        """
        pulumi.set(__self__, "currency", currency)
        pulumi.set(__self__, "externally_managed", externally_managed)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_contract", is_contract)
        pulumi.set(__self__, "public_name", public_name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "sets", sets)

    @property
    @pulumi.getter
    def currency(self) -> str:
        """
        The currency applied to the rate plan subscription.
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="externallyManaged")
    def externally_managed(self) -> bool:
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        return pulumi.get(self, "externally_managed")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the rate plan.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isContract")
    def is_contract(self) -> bool:
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        return pulumi.get(self, "is_contract")

    @property
    @pulumi.getter(name="publicName")
    def public_name(self) -> str:
        """
        The full name of the rate plan.
        """
        return pulumi.get(self, "public_name")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        The scope that this rate plan applies to.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def sets(self) -> Sequence[str]:
        """
        The list of sets this rate plan applies to.
        """
        return pulumi.get(self, "sets")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetAccountTokenConditionResult(dict):
    def __init__(__self__, *,
                 request_ip: 'outputs.GetAccountTokenConditionRequestIpResult'):
        """
        :param 'GetAccountTokenConditionRequestIpArgs' request_ip: Client IP restrictions.
        """
        pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> 'outputs.GetAccountTokenConditionRequestIpResult':
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class GetAccountTokenConditionRequestIpResult(dict):
    def __init__(__self__, *,
                 ins: Sequence[str],
                 not_ins: Sequence[str]):
        """
        :param Sequence[str] ins: List of IPv4/IPv6 CIDR addresses.
        :param Sequence[str] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        pulumi.set(__self__, "ins", ins)
        pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Sequence[str]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Sequence[str]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class GetAccountTokenFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetAccountTokenPolicyResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 id: str,
                 permission_groups: Sequence['outputs.GetAccountTokenPolicyPermissionGroupResult'],
                 resources: Mapping[str, str]):
        """
        :param str effect: Allow or deny operations against the resources.
        :param str id: Policy identifier.
        :param Sequence['GetAccountTokenPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Mapping[str, str] resources: A list of resource names that the policy applies to.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.GetAccountTokenPolicyPermissionGroupResult']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, str]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetAccountTokenPolicyPermissionGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetAccountTokenPolicyPermissionGroupMetaResult',
                 name: str):
        """
        :param str id: Identifier of the group.
        :param 'GetAccountTokenPolicyPermissionGroupMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetAccountTokenPolicyPermissionGroupMetaResult':
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAccountTokenPolicyPermissionGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountTokensResultResult(dict):
    def __init__(__self__, *,
                 condition: 'outputs.GetAccountTokensResultConditionResult',
                 expires_on: str,
                 id: str,
                 issued_on: str,
                 last_used_on: str,
                 modified_on: str,
                 name: str,
                 not_before: str,
                 policies: Sequence['outputs.GetAccountTokensResultPolicyResult'],
                 status: str):
        """
        :param str expires_on: The expiration time on or after which the JWT MUST NOT be accepted for processing.
        :param str id: Token identifier tag.
        :param str issued_on: The time on which the token was created.
        :param str last_used_on: Last time the token was used.
        :param str modified_on: Last time the token was modified.
        :param str name: Token name.
        :param str not_before: The time before which the token MUST NOT be accepted for processing.
        :param Sequence['GetAccountTokensResultPolicyArgs'] policies: List of access policies assigned to the token.
        :param str status: Status of the token.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issued_on", issued_on)
        pulumi.set(__self__, "last_used_on", last_used_on)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "not_before", not_before)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.GetAccountTokensResultConditionResult':
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        """
        The expiration time on or after which the JWT MUST NOT be accepted for processing.
        """
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Token identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedOn")
    def issued_on(self) -> str:
        """
        The time on which the token was created.
        """
        return pulumi.get(self, "issued_on")

    @property
    @pulumi.getter(name="lastUsedOn")
    def last_used_on(self) -> str:
        """
        Last time the token was used.
        """
        return pulumi.get(self, "last_used_on")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        Last time the token was modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Token name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        The time before which the token MUST NOT be accepted for processing.
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetAccountTokensResultPolicyResult']:
        """
        List of access policies assigned to the token.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the token.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAccountTokensResultConditionResult(dict):
    def __init__(__self__, *,
                 request_ip: 'outputs.GetAccountTokensResultConditionRequestIpResult'):
        """
        :param 'GetAccountTokensResultConditionRequestIpArgs' request_ip: Client IP restrictions.
        """
        pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> 'outputs.GetAccountTokensResultConditionRequestIpResult':
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class GetAccountTokensResultConditionRequestIpResult(dict):
    def __init__(__self__, *,
                 ins: Sequence[str],
                 not_ins: Sequence[str]):
        """
        :param Sequence[str] ins: List of IPv4/IPv6 CIDR addresses.
        :param Sequence[str] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        pulumi.set(__self__, "ins", ins)
        pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Sequence[str]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Sequence[str]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class GetAccountTokensResultPolicyResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 id: str,
                 permission_groups: Sequence['outputs.GetAccountTokensResultPolicyPermissionGroupResult'],
                 resources: Mapping[str, str]):
        """
        :param str effect: Allow or deny operations against the resources.
        :param str id: Policy identifier.
        :param Sequence['GetAccountTokensResultPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Mapping[str, str] resources: A list of resource names that the policy applies to.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.GetAccountTokensResultPolicyPermissionGroupResult']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, str]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetAccountTokensResultPolicyPermissionGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetAccountTokensResultPolicyPermissionGroupMetaResult',
                 name: str):
        """
        :param str id: Identifier of the group.
        :param 'GetAccountTokensResultPolicyPermissionGroupMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetAccountTokensResultPolicyPermissionGroupMetaResult':
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAccountTokensResultPolicyPermissionGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountsResultResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 id: str,
                 name: str,
                 settings: 'outputs.GetAccountsResultSettingsResult'):
        """
        :param str created_on: Timestamp for the creation of the account
        :param str id: Identifier
        :param str name: Account name
        :param 'GetAccountsResultSettingsArgs' settings: Account settings
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        Timestamp for the creation of the account
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Account name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetAccountsResultSettingsResult':
        """
        Account settings
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetAccountsResultSettingsResult(dict):
    def __init__(__self__, *,
                 abuse_contact_email: str,
                 default_nameservers: str,
                 enforce_twofactor: bool,
                 use_account_custom_ns_by_default: bool):
        """
        :param str abuse_contact_email: Sets an abuse contact email to notify for abuse reports.
        :param str default_nameservers: Specifies the default nameservers to be used for new zones added to this account.
        :param bool enforce_twofactor: Indicates whether membership in this account requires that
               Two-Factor Authentication is enabled
        :param bool use_account_custom_ns_by_default: Indicates whether new zones should use the account-level custom
               nameservers by default.
               
               Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
        pulumi.set(__self__, "abuse_contact_email", abuse_contact_email)
        pulumi.set(__self__, "default_nameservers", default_nameservers)
        pulumi.set(__self__, "enforce_twofactor", enforce_twofactor)
        pulumi.set(__self__, "use_account_custom_ns_by_default", use_account_custom_ns_by_default)

    @property
    @pulumi.getter(name="abuseContactEmail")
    def abuse_contact_email(self) -> str:
        """
        Sets an abuse contact email to notify for abuse reports.
        """
        return pulumi.get(self, "abuse_contact_email")

    @property
    @pulumi.getter(name="defaultNameservers")
    def default_nameservers(self) -> str:
        """
        Specifies the default nameservers to be used for new zones added to this account.
        """
        return pulumi.get(self, "default_nameservers")

    @property
    @pulumi.getter(name="enforceTwofactor")
    def enforce_twofactor(self) -> bool:
        """
        Indicates whether membership in this account requires that
        Two-Factor Authentication is enabled
        """
        return pulumi.get(self, "enforce_twofactor")

    @property
    @pulumi.getter(name="useAccountCustomNsByDefault")
    def use_account_custom_ns_by_default(self) -> bool:
        """
        Indicates whether new zones should use the account-level custom
        nameservers by default.

        Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
        return pulumi.get(self, "use_account_custom_ns_by_default")


@pulumi.output_type
class GetAddressMapIpResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 address.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetAddressMapMembershipResult(dict):
    def __init__(__self__, *,
                 can_delete: bool,
                 created_at: str,
                 identifier: str,
                 kind: str):
        """
        :param bool can_delete: Controls whether the membership can be deleted via the API or not.
        :param str identifier: The identifier for the membership (eg. a zone or account tag).
        :param str kind: The type of the membership.
        """
        pulumi.set(__self__, "can_delete", can_delete)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> bool:
        """
        Controls whether the membership can be deleted via the API or not.
        """
        return pulumi.get(self, "can_delete")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The identifier for the membership (eg. a zone or account tag).
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type of the membership.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GetAddressMapsResultResult(dict):
    def __init__(__self__, *,
                 can_delete: bool,
                 can_modify_ips: bool,
                 created_at: str,
                 default_sni: str,
                 description: str,
                 enabled: bool,
                 id: str,
                 modified_at: str):
        """
        :param bool can_delete: If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
        :param bool can_modify_ips: If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
        :param str default_sni: If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
        :param str description: An optional description field which may be used to describe the types of IPs or zones on the map.
        :param bool enabled: Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
        :param str id: Identifier of an Address Map.
        """
        pulumi.set(__self__, "can_delete", can_delete)
        pulumi.set(__self__, "can_modify_ips", can_modify_ips)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "default_sni", default_sni)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_at", modified_at)

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> bool:
        """
        If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
        """
        return pulumi.get(self, "can_delete")

    @property
    @pulumi.getter(name="canModifyIps")
    def can_modify_ips(self) -> bool:
        """
        If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
        """
        return pulumi.get(self, "can_modify_ips")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="defaultSni")
    def default_sni(self) -> str:
        """
        If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
        """
        return pulumi.get(self, "default_sni")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An optional description field which may be used to describe the types of IPs or zones on the map.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of an Address Map.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedAt")
    def modified_at(self) -> str:
        return pulumi.get(self, "modified_at")


@pulumi.output_type
class GetApiShieldAuthIdCharacteristicResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: The name of the characteristic field, i.e., the header or cookie name.
        :param str type: The type of characteristic.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the characteristic field, i.e., the header or cookie name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of characteristic.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetApiShieldDiscoveryOperationsResultResult(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 features: 'outputs.GetApiShieldDiscoveryOperationsResultFeaturesResult',
                 host: str,
                 id: str,
                 last_updated: str,
                 method: str,
                 origins: Sequence[str],
                 state: str):
        """
        :param str endpoint: The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
        :param str host: RFC3986-compliant host.
        :param str id: UUID
        :param str method: The HTTP method used to access the endpoint.
        :param Sequence[str] origins: API discovery engine(s) that discovered this operation
        :param str state: State of operation in API Discovery
                 * `review` - Operation is not saved into API Shield Endpoint Management
                 * `saved` - Operation is saved into API Shield Endpoint Management
                 * `ignored` - Operation is marked as ignored
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "features", features)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "origins", origins)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def features(self) -> 'outputs.GetApiShieldDiscoveryOperationsResultFeaturesResult':
        return pulumi.get(self, "features")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        RFC3986-compliant host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method used to access the endpoint.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def origins(self) -> Sequence[str]:
        """
        API discovery engine(s) that discovered this operation
        """
        return pulumi.get(self, "origins")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of operation in API Discovery
          * `review` - Operation is not saved into API Shield Endpoint Management
          * `saved` - Operation is saved into API Shield Endpoint Management
          * `ignored` - Operation is marked as ignored
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetApiShieldDiscoveryOperationsResultFeaturesResult(dict):
    def __init__(__self__, *,
                 traffic_stats: 'outputs.GetApiShieldDiscoveryOperationsResultFeaturesTrafficStatsResult'):
        pulumi.set(__self__, "traffic_stats", traffic_stats)

    @property
    @pulumi.getter(name="trafficStats")
    def traffic_stats(self) -> 'outputs.GetApiShieldDiscoveryOperationsResultFeaturesTrafficStatsResult':
        return pulumi.get(self, "traffic_stats")


@pulumi.output_type
class GetApiShieldDiscoveryOperationsResultFeaturesTrafficStatsResult(dict):
    def __init__(__self__, *,
                 last_updated: str,
                 period_seconds: int,
                 requests: float):
        """
        :param int period_seconds: The period in seconds these statistics were computed over
        :param float requests: The average number of requests seen during this period
        """
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> int:
        """
        The period in seconds these statistics were computed over
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter
    def requests(self) -> float:
        """
        The average number of requests seen during this period
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class GetApiShieldOperationFeaturesResult(dict):
    def __init__(__self__, *,
                 api_routing: 'outputs.GetApiShieldOperationFeaturesApiRoutingResult',
                 confidence_intervals: 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsResult',
                 parameter_schemas: 'outputs.GetApiShieldOperationFeaturesParameterSchemasResult',
                 schema_info: 'outputs.GetApiShieldOperationFeaturesSchemaInfoResult',
                 thresholds: 'outputs.GetApiShieldOperationFeaturesThresholdsResult'):
        """
        :param 'GetApiShieldOperationFeaturesApiRoutingArgs' api_routing: API Routing settings on endpoint.
        """
        pulumi.set(__self__, "api_routing", api_routing)
        pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        pulumi.set(__self__, "parameter_schemas", parameter_schemas)
        pulumi.set(__self__, "schema_info", schema_info)
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter(name="apiRouting")
    def api_routing(self) -> 'outputs.GetApiShieldOperationFeaturesApiRoutingResult':
        """
        API Routing settings on endpoint.
        """
        return pulumi.get(self, "api_routing")

    @property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsResult':
        return pulumi.get(self, "confidence_intervals")

    @property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> 'outputs.GetApiShieldOperationFeaturesParameterSchemasResult':
        return pulumi.get(self, "parameter_schemas")

    @property
    @pulumi.getter(name="schemaInfo")
    def schema_info(self) -> 'outputs.GetApiShieldOperationFeaturesSchemaInfoResult':
        return pulumi.get(self, "schema_info")

    @property
    @pulumi.getter
    def thresholds(self) -> 'outputs.GetApiShieldOperationFeaturesThresholdsResult':
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetApiShieldOperationFeaturesApiRoutingResult(dict):
    def __init__(__self__, *,
                 last_updated: str,
                 route: str):
        """
        :param str route: Target route.
        """
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def route(self) -> str:
        """
        Target route.
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class GetApiShieldOperationFeaturesConfidenceIntervalsResult(dict):
    def __init__(__self__, *,
                 last_updated: str,
                 suggested_threshold: 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdResult'):
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdResult':
        return pulumi.get(self, "suggested_threshold")


@pulumi.output_type
class GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdResult(dict):
    def __init__(__self__, *,
                 confidence_intervals: 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsResult',
                 mean: float):
        """
        :param float mean: Suggested threshold.
        """
        pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        pulumi.set(__self__, "mean", mean)

    @property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsResult':
        return pulumi.get(self, "confidence_intervals")

    @property
    @pulumi.getter
    def mean(self) -> float:
        """
        Suggested threshold.
        """
        return pulumi.get(self, "mean")


@pulumi.output_type
class GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsResult(dict):
    def __init__(__self__, *,
                 p90: 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Result',
                 p95: 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Result',
                 p99: 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Result'):
        """
        :param 'GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args' p90: Upper and lower bound for percentile estimate
        :param 'GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args' p95: Upper and lower bound for percentile estimate
        :param 'GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args' p99: Upper and lower bound for percentile estimate
        """
        pulumi.set(__self__, "p90", p90)
        pulumi.set(__self__, "p95", p95)
        pulumi.set(__self__, "p99", p99)

    @property
    @pulumi.getter
    def p90(self) -> 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Result':
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p90")

    @property
    @pulumi.getter
    def p95(self) -> 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Result':
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p95")

    @property
    @pulumi.getter
    def p99(self) -> 'outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Result':
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p99")


@pulumi.output_type
class GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Result(dict):
    def __init__(__self__, *,
                 lower: float,
                 upper: float):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        pulumi.set(__self__, "lower", lower)
        pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> float:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> float:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Result(dict):
    def __init__(__self__, *,
                 lower: float,
                 upper: float):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        pulumi.set(__self__, "lower", lower)
        pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> float:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> float:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Result(dict):
    def __init__(__self__, *,
                 lower: float,
                 upper: float):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        pulumi.set(__self__, "lower", lower)
        pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> float:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> float:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class GetApiShieldOperationFeaturesParameterSchemasResult(dict):
    def __init__(__self__, *,
                 last_updated: str,
                 parameter_schemas: 'outputs.GetApiShieldOperationFeaturesParameterSchemasParameterSchemasResult'):
        """
        :param 'GetApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs' parameter_schemas: An operation schema object containing a response.
        """
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "parameter_schemas", parameter_schemas)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> 'outputs.GetApiShieldOperationFeaturesParameterSchemasParameterSchemasResult':
        """
        An operation schema object containing a response.
        """
        return pulumi.get(self, "parameter_schemas")


@pulumi.output_type
class GetApiShieldOperationFeaturesParameterSchemasParameterSchemasResult(dict):
    def __init__(__self__, *,
                 parameters: Sequence[str],
                 responses: str):
        """
        :param Sequence[str] parameters: An array containing the learned parameter schemas.
        :param str responses: An empty response object. This field is required to yield a valid operation schema.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "responses", responses)

    @property
    @pulumi.getter
    def parameters(self) -> Sequence[str]:
        """
        An array containing the learned parameter schemas.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def responses(self) -> str:
        """
        An empty response object. This field is required to yield a valid operation schema.
        """
        return pulumi.get(self, "responses")


@pulumi.output_type
class GetApiShieldOperationFeaturesSchemaInfoResult(dict):
    def __init__(__self__, *,
                 active_schema: 'outputs.GetApiShieldOperationFeaturesSchemaInfoActiveSchemaResult',
                 learned_available: bool,
                 mitigation_action: str):
        """
        :param 'GetApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs' active_schema: Schema active on endpoint.
        :param bool learned_available: True if a Cloudflare-provided learned schema is available for this endpoint.
        :param str mitigation_action: Action taken on requests failing validation.
        """
        pulumi.set(__self__, "active_schema", active_schema)
        pulumi.set(__self__, "learned_available", learned_available)
        pulumi.set(__self__, "mitigation_action", mitigation_action)

    @property
    @pulumi.getter(name="activeSchema")
    def active_schema(self) -> 'outputs.GetApiShieldOperationFeaturesSchemaInfoActiveSchemaResult':
        """
        Schema active on endpoint.
        """
        return pulumi.get(self, "active_schema")

    @property
    @pulumi.getter(name="learnedAvailable")
    def learned_available(self) -> bool:
        """
        True if a Cloudflare-provided learned schema is available for this endpoint.
        """
        return pulumi.get(self, "learned_available")

    @property
    @pulumi.getter(name="mitigationAction")
    def mitigation_action(self) -> str:
        """
        Action taken on requests failing validation.
        """
        return pulumi.get(self, "mitigation_action")


@pulumi.output_type
class GetApiShieldOperationFeaturesSchemaInfoActiveSchemaResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 is_learned: bool,
                 name: str):
        """
        :param str id: UUID
        :param bool is_learned: True if schema is Cloudflare-provided.
        :param str name: Schema file name.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_learned", is_learned)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isLearned")
    def is_learned(self) -> bool:
        """
        True if schema is Cloudflare-provided.
        """
        return pulumi.get(self, "is_learned")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Schema file name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApiShieldOperationFeaturesThresholdsResult(dict):
    def __init__(__self__, *,
                 auth_id_tokens: int,
                 data_points: int,
                 last_updated: str,
                 p50: int,
                 p90: int,
                 p99: int,
                 period_seconds: int,
                 requests: int,
                 suggested_threshold: int):
        """
        :param int auth_id_tokens: The total number of auth-ids seen across this calculation.
        :param int data_points: The number of data points used for the threshold suggestion calculation.
        :param int p50: The p50 quantile of requests (in period_seconds).
        :param int p90: The p90 quantile of requests (in period_seconds).
        :param int p99: The p99 quantile of requests (in period_seconds).
        :param int period_seconds: The period over which this threshold is suggested.
        :param int requests: The estimated number of requests covered by these calculations.
        :param int suggested_threshold: The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        pulumi.set(__self__, "auth_id_tokens", auth_id_tokens)
        pulumi.set(__self__, "data_points", data_points)
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "p50", p50)
        pulumi.set(__self__, "p90", p90)
        pulumi.set(__self__, "p99", p99)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @property
    @pulumi.getter(name="authIdTokens")
    def auth_id_tokens(self) -> int:
        """
        The total number of auth-ids seen across this calculation.
        """
        return pulumi.get(self, "auth_id_tokens")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> int:
        """
        The number of data points used for the threshold suggestion calculation.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def p50(self) -> int:
        """
        The p50 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p50")

    @property
    @pulumi.getter
    def p90(self) -> int:
        """
        The p90 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p90")

    @property
    @pulumi.getter
    def p99(self) -> int:
        """
        The p99 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p99")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> int:
        """
        The period over which this threshold is suggested.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter
    def requests(self) -> int:
        """
        The estimated number of requests covered by these calculations.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> int:
        """
        The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        return pulumi.get(self, "suggested_threshold")


@pulumi.output_type
class GetApiShieldOperationFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 features: Optional[Sequence[str]] = None,
                 hosts: Optional[Sequence[str]] = None,
                 methods: Optional[Sequence[str]] = None,
                 order: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        :param str endpoint: Filter results to only include endpoints containing this pattern.
        :param Sequence[str] features: Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
        :param Sequence[str] hosts: Filter results to only include the specified hosts.
        :param Sequence[str] methods: Filter results to only include the specified HTTP methods.
        :param str order: Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Filter results to only include endpoints containing this pattern.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def features(self) -> Optional[Sequence[str]]:
        """
        Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
        """
        return pulumi.get(self, "features")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        Filter results to only include the specified hosts.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[str]]:
        """
        Filter results to only include the specified HTTP methods.
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class GetApiShieldOperationsResultResult(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 features: 'outputs.GetApiShieldOperationsResultFeaturesResult',
                 host: str,
                 last_updated: str,
                 method: str,
                 operation_id: str):
        """
        :param str endpoint: The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
        :param str host: RFC3986-compliant host.
        :param str method: The HTTP method used to access the endpoint.
        :param str operation_id: UUID
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "features", features)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "operation_id", operation_id)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def features(self) -> 'outputs.GetApiShieldOperationsResultFeaturesResult':
        return pulumi.get(self, "features")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        RFC3986-compliant host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method used to access the endpoint.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="operationId")
    def operation_id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "operation_id")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesResult(dict):
    def __init__(__self__, *,
                 api_routing: 'outputs.GetApiShieldOperationsResultFeaturesApiRoutingResult',
                 confidence_intervals: 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsResult',
                 parameter_schemas: 'outputs.GetApiShieldOperationsResultFeaturesParameterSchemasResult',
                 schema_info: 'outputs.GetApiShieldOperationsResultFeaturesSchemaInfoResult',
                 thresholds: 'outputs.GetApiShieldOperationsResultFeaturesThresholdsResult'):
        """
        :param 'GetApiShieldOperationsResultFeaturesApiRoutingArgs' api_routing: API Routing settings on endpoint.
        """
        pulumi.set(__self__, "api_routing", api_routing)
        pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        pulumi.set(__self__, "parameter_schemas", parameter_schemas)
        pulumi.set(__self__, "schema_info", schema_info)
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter(name="apiRouting")
    def api_routing(self) -> 'outputs.GetApiShieldOperationsResultFeaturesApiRoutingResult':
        """
        API Routing settings on endpoint.
        """
        return pulumi.get(self, "api_routing")

    @property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsResult':
        return pulumi.get(self, "confidence_intervals")

    @property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> 'outputs.GetApiShieldOperationsResultFeaturesParameterSchemasResult':
        return pulumi.get(self, "parameter_schemas")

    @property
    @pulumi.getter(name="schemaInfo")
    def schema_info(self) -> 'outputs.GetApiShieldOperationsResultFeaturesSchemaInfoResult':
        return pulumi.get(self, "schema_info")

    @property
    @pulumi.getter
    def thresholds(self) -> 'outputs.GetApiShieldOperationsResultFeaturesThresholdsResult':
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesApiRoutingResult(dict):
    def __init__(__self__, *,
                 last_updated: str,
                 route: str):
        """
        :param str route: Target route.
        """
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def route(self) -> str:
        """
        Target route.
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesConfidenceIntervalsResult(dict):
    def __init__(__self__, *,
                 last_updated: str,
                 suggested_threshold: 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdResult'):
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdResult':
        return pulumi.get(self, "suggested_threshold")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdResult(dict):
    def __init__(__self__, *,
                 confidence_intervals: 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsResult',
                 mean: float):
        """
        :param float mean: Suggested threshold.
        """
        pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        pulumi.set(__self__, "mean", mean)

    @property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsResult':
        return pulumi.get(self, "confidence_intervals")

    @property
    @pulumi.getter
    def mean(self) -> float:
        """
        Suggested threshold.
        """
        return pulumi.get(self, "mean")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsResult(dict):
    def __init__(__self__, *,
                 p90: 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Result',
                 p95: 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Result',
                 p99: 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Result'):
        """
        :param 'GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args' p90: Upper and lower bound for percentile estimate
        :param 'GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args' p95: Upper and lower bound for percentile estimate
        :param 'GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args' p99: Upper and lower bound for percentile estimate
        """
        pulumi.set(__self__, "p90", p90)
        pulumi.set(__self__, "p95", p95)
        pulumi.set(__self__, "p99", p99)

    @property
    @pulumi.getter
    def p90(self) -> 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Result':
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p90")

    @property
    @pulumi.getter
    def p95(self) -> 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Result':
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p95")

    @property
    @pulumi.getter
    def p99(self) -> 'outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Result':
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p99")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Result(dict):
    def __init__(__self__, *,
                 lower: float,
                 upper: float):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        pulumi.set(__self__, "lower", lower)
        pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> float:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> float:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Result(dict):
    def __init__(__self__, *,
                 lower: float,
                 upper: float):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        pulumi.set(__self__, "lower", lower)
        pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> float:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> float:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Result(dict):
    def __init__(__self__, *,
                 lower: float,
                 upper: float):
        """
        :param float lower: Lower bound for percentile estimate
        :param float upper: Upper bound for percentile estimate
        """
        pulumi.set(__self__, "lower", lower)
        pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> float:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @property
    @pulumi.getter
    def upper(self) -> float:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesParameterSchemasResult(dict):
    def __init__(__self__, *,
                 last_updated: str,
                 parameter_schemas: 'outputs.GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemasResult'):
        """
        :param 'GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemasArgs' parameter_schemas: An operation schema object containing a response.
        """
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "parameter_schemas", parameter_schemas)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> 'outputs.GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemasResult':
        """
        An operation schema object containing a response.
        """
        return pulumi.get(self, "parameter_schemas")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemasResult(dict):
    def __init__(__self__, *,
                 parameters: Sequence[str],
                 responses: str):
        """
        :param Sequence[str] parameters: An array containing the learned parameter schemas.
        :param str responses: An empty response object. This field is required to yield a valid operation schema.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "responses", responses)

    @property
    @pulumi.getter
    def parameters(self) -> Sequence[str]:
        """
        An array containing the learned parameter schemas.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def responses(self) -> str:
        """
        An empty response object. This field is required to yield a valid operation schema.
        """
        return pulumi.get(self, "responses")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesSchemaInfoResult(dict):
    def __init__(__self__, *,
                 active_schema: 'outputs.GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchemaResult',
                 learned_available: bool,
                 mitigation_action: str):
        """
        :param 'GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchemaArgs' active_schema: Schema active on endpoint.
        :param bool learned_available: True if a Cloudflare-provided learned schema is available for this endpoint.
        :param str mitigation_action: Action taken on requests failing validation.
        """
        pulumi.set(__self__, "active_schema", active_schema)
        pulumi.set(__self__, "learned_available", learned_available)
        pulumi.set(__self__, "mitigation_action", mitigation_action)

    @property
    @pulumi.getter(name="activeSchema")
    def active_schema(self) -> 'outputs.GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchemaResult':
        """
        Schema active on endpoint.
        """
        return pulumi.get(self, "active_schema")

    @property
    @pulumi.getter(name="learnedAvailable")
    def learned_available(self) -> bool:
        """
        True if a Cloudflare-provided learned schema is available for this endpoint.
        """
        return pulumi.get(self, "learned_available")

    @property
    @pulumi.getter(name="mitigationAction")
    def mitigation_action(self) -> str:
        """
        Action taken on requests failing validation.
        """
        return pulumi.get(self, "mitigation_action")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchemaResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 is_learned: bool,
                 name: str):
        """
        :param str id: UUID
        :param bool is_learned: True if schema is Cloudflare-provided.
        :param str name: Schema file name.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_learned", is_learned)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isLearned")
    def is_learned(self) -> bool:
        """
        True if schema is Cloudflare-provided.
        """
        return pulumi.get(self, "is_learned")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Schema file name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApiShieldOperationsResultFeaturesThresholdsResult(dict):
    def __init__(__self__, *,
                 auth_id_tokens: int,
                 data_points: int,
                 last_updated: str,
                 p50: int,
                 p90: int,
                 p99: int,
                 period_seconds: int,
                 requests: int,
                 suggested_threshold: int):
        """
        :param int auth_id_tokens: The total number of auth-ids seen across this calculation.
        :param int data_points: The number of data points used for the threshold suggestion calculation.
        :param int p50: The p50 quantile of requests (in period_seconds).
        :param int p90: The p90 quantile of requests (in period_seconds).
        :param int p99: The p99 quantile of requests (in period_seconds).
        :param int period_seconds: The period over which this threshold is suggested.
        :param int requests: The estimated number of requests covered by these calculations.
        :param int suggested_threshold: The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        pulumi.set(__self__, "auth_id_tokens", auth_id_tokens)
        pulumi.set(__self__, "data_points", data_points)
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "p50", p50)
        pulumi.set(__self__, "p90", p90)
        pulumi.set(__self__, "p99", p99)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @property
    @pulumi.getter(name="authIdTokens")
    def auth_id_tokens(self) -> int:
        """
        The total number of auth-ids seen across this calculation.
        """
        return pulumi.get(self, "auth_id_tokens")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> int:
        """
        The number of data points used for the threshold suggestion calculation.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def p50(self) -> int:
        """
        The p50 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p50")

    @property
    @pulumi.getter
    def p90(self) -> int:
        """
        The p90 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p90")

    @property
    @pulumi.getter
    def p99(self) -> int:
        """
        The p99 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p99")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> int:
        """
        The period over which this threshold is suggested.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter
    def requests(self) -> int:
        """
        The estimated number of requests covered by these calculations.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> int:
        """
        The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        return pulumi.get(self, "suggested_threshold")


@pulumi.output_type
class GetApiShieldSchemasResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 kind: str,
                 name: str,
                 schema_id: str,
                 source: str,
                 validation_enabled: bool):
        """
        :param str kind: Kind of schema
        :param str name: Name of the schema
        :param str schema_id: UUID
        :param str source: Source of the schema
        :param bool validation_enabled: Flag whether schema is enabled for validation.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_id", schema_id)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "validation_enabled", validation_enabled)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Kind of schema
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "schema_id")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Source of the schema
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="validationEnabled")
    def validation_enabled(self) -> bool:
        """
        Flag whether schema is enabled for validation.
        """
        return pulumi.get(self, "validation_enabled")


@pulumi.output_type
class GetApiTokenConditionResult(dict):
    def __init__(__self__, *,
                 request_ip: 'outputs.GetApiTokenConditionRequestIpResult'):
        """
        :param 'GetApiTokenConditionRequestIpArgs' request_ip: Client IP restrictions.
        """
        pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> 'outputs.GetApiTokenConditionRequestIpResult':
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class GetApiTokenConditionRequestIpResult(dict):
    def __init__(__self__, *,
                 ins: Sequence[str],
                 not_ins: Sequence[str]):
        """
        :param Sequence[str] ins: List of IPv4/IPv6 CIDR addresses.
        :param Sequence[str] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        pulumi.set(__self__, "ins", ins)
        pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Sequence[str]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Sequence[str]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class GetApiTokenFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetApiTokenPermissionsGroupsListResultResult(dict):
<<<<<<< HEAD
    def __init__(__self__):
        pass
=======
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 scopes: Sequence[str]):
        """
        :param str id: Public ID.
        :param str name: Permission Group Name
        :param Sequence[str] scopes: Resources to which the Permission Group is scoped
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Public ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Permission Group Name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Resources to which the Permission Group is scoped
        """
        return pulumi.get(self, "scopes")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580


@pulumi.output_type
class GetApiTokenPolicyResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 id: str,
                 permission_groups: Sequence['outputs.GetApiTokenPolicyPermissionGroupResult'],
                 resources: Mapping[str, str]):
        """
        :param str effect: Allow or deny operations against the resources.
        :param str id: Policy identifier.
        :param Sequence['GetApiTokenPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Mapping[str, str] resources: A list of resource names that the policy applies to.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.GetApiTokenPolicyPermissionGroupResult']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, str]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetApiTokenPolicyPermissionGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetApiTokenPolicyPermissionGroupMetaResult',
                 name: str):
        """
        :param str id: Identifier of the group.
        :param 'GetApiTokenPolicyPermissionGroupMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetApiTokenPolicyPermissionGroupMetaResult':
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApiTokenPolicyPermissionGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetApiTokensResultResult(dict):
    def __init__(__self__, *,
                 condition: 'outputs.GetApiTokensResultConditionResult',
                 expires_on: str,
                 id: str,
                 issued_on: str,
                 last_used_on: str,
                 modified_on: str,
                 name: str,
                 not_before: str,
                 policies: Sequence['outputs.GetApiTokensResultPolicyResult'],
                 status: str):
        """
        :param str expires_on: The expiration time on or after which the JWT MUST NOT be accepted for processing.
        :param str id: Token identifier tag.
        :param str issued_on: The time on which the token was created.
        :param str last_used_on: Last time the token was used.
        :param str modified_on: Last time the token was modified.
        :param str name: Token name.
        :param str not_before: The time before which the token MUST NOT be accepted for processing.
        :param Sequence['GetApiTokensResultPolicyArgs'] policies: List of access policies assigned to the token.
        :param str status: Status of the token.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issued_on", issued_on)
        pulumi.set(__self__, "last_used_on", last_used_on)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "not_before", not_before)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.GetApiTokensResultConditionResult':
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        """
        The expiration time on or after which the JWT MUST NOT be accepted for processing.
        """
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Token identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedOn")
    def issued_on(self) -> str:
        """
        The time on which the token was created.
        """
        return pulumi.get(self, "issued_on")

    @property
    @pulumi.getter(name="lastUsedOn")
    def last_used_on(self) -> str:
        """
        Last time the token was used.
        """
        return pulumi.get(self, "last_used_on")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        Last time the token was modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Token name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        The time before which the token MUST NOT be accepted for processing.
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetApiTokensResultPolicyResult']:
        """
        List of access policies assigned to the token.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the token.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetApiTokensResultConditionResult(dict):
    def __init__(__self__, *,
                 request_ip: 'outputs.GetApiTokensResultConditionRequestIpResult'):
        """
        :param 'GetApiTokensResultConditionRequestIpArgs' request_ip: Client IP restrictions.
        """
        pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> 'outputs.GetApiTokensResultConditionRequestIpResult':
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class GetApiTokensResultConditionRequestIpResult(dict):
    def __init__(__self__, *,
                 ins: Sequence[str],
                 not_ins: Sequence[str]):
        """
        :param Sequence[str] ins: List of IPv4/IPv6 CIDR addresses.
        :param Sequence[str] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        pulumi.set(__self__, "ins", ins)
        pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Sequence[str]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Sequence[str]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class GetApiTokensResultPolicyResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 id: str,
                 permission_groups: Sequence['outputs.GetApiTokensResultPolicyPermissionGroupResult'],
                 resources: Mapping[str, str]):
        """
        :param str effect: Allow or deny operations against the resources.
        :param str id: Policy identifier.
        :param Sequence['GetApiTokensResultPolicyPermissionGroupArgs'] permission_groups: A set of permission groups that are specified to the policy.
        :param Mapping[str, str] resources: A list of resource names that the policy applies to.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence['outputs.GetApiTokensResultPolicyPermissionGroupResult']:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, str]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetApiTokensResultPolicyPermissionGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetApiTokensResultPolicyPermissionGroupMetaResult',
                 name: str):
        """
        :param str id: Identifier of the group.
        :param 'GetApiTokensResultPolicyPermissionGroupMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetApiTokensResultPolicyPermissionGroupMetaResult':
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApiTokensResultPolicyPermissionGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAuthenticatedOriginPullsCertificatesResultResult(dict):
    def __init__(__self__, *,
                 certificate: str,
                 enabled: bool,
                 expires_on: str,
                 id: str,
                 issuer: str,
                 private_key: str,
                 signature: str,
                 status: str,
                 uploaded_on: str):
        """
        :param str certificate: The zone's leaf certificate.
        :param bool enabled: Indicates whether zone-level authenticated origin pulls is enabled.
        :param str expires_on: When the certificate from the authority expires.
        :param str id: Identifier
        :param str issuer: The certificate authority that issued the certificate.
        :param str private_key: The zone's private key.
        :param str signature: The type of hash used for the certificate.
        :param str status: Status of the certificate activation.
        :param str uploaded_on: This is the time the certificate was uploaded.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uploaded_on", uploaded_on)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The zone's leaf certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether zone-level authenticated origin pulls is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        """
        When the certificate from the authority expires.
        """
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The certificate authority that issued the certificate.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        The zone's private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def signature(self) -> str:
        """
        The type of hash used for the certificate.
        """
        return pulumi.get(self, "signature")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the certificate activation.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uploadedOn")
    def uploaded_on(self) -> str:
        """
        This is the time the certificate was uploaded.
        """
        return pulumi.get(self, "uploaded_on")


@pulumi.output_type
class GetBotManagementStaleZoneConfigurationResult(dict):
    def __init__(__self__, *,
                 fight_mode: bool,
                 optimize_wordpress: bool,
                 sbfm_definitely_automated: str,
                 sbfm_likely_automated: str,
                 sbfm_static_resource_protection: str,
                 sbfm_verified_bots: str,
                 suppress_session_score: bool):
        """
        :param bool fight_mode: Indicates that the zone's Bot Fight Mode is turned on.
        :param bool optimize_wordpress: Indicates that the zone's wordpress optimization for SBFM is turned on.
        :param str sbfm_definitely_automated: Indicates that the zone's definitely automated requests are being blocked or challenged.
        :param str sbfm_likely_automated: Indicates that the zone's likely automated requests are being blocked or challenged.
        :param str sbfm_static_resource_protection: Indicates that the zone's static resource protection is turned on.
        :param str sbfm_verified_bots: Indicates that the zone's verified bot requests are being blocked.
        :param bool suppress_session_score: Indicates that the zone's session score tracking is disabled.
        """
        pulumi.set(__self__, "fight_mode", fight_mode)
        pulumi.set(__self__, "optimize_wordpress", optimize_wordpress)
        pulumi.set(__self__, "sbfm_definitely_automated", sbfm_definitely_automated)
        pulumi.set(__self__, "sbfm_likely_automated", sbfm_likely_automated)
        pulumi.set(__self__, "sbfm_static_resource_protection", sbfm_static_resource_protection)
        pulumi.set(__self__, "sbfm_verified_bots", sbfm_verified_bots)
        pulumi.set(__self__, "suppress_session_score", suppress_session_score)

    @property
    @pulumi.getter(name="fightMode")
    def fight_mode(self) -> bool:
        """
        Indicates that the zone's Bot Fight Mode is turned on.
        """
        return pulumi.get(self, "fight_mode")

    @property
    @pulumi.getter(name="optimizeWordpress")
    def optimize_wordpress(self) -> bool:
        """
        Indicates that the zone's wordpress optimization for SBFM is turned on.
        """
        return pulumi.get(self, "optimize_wordpress")

    @property
    @pulumi.getter(name="sbfmDefinitelyAutomated")
    def sbfm_definitely_automated(self) -> str:
        """
        Indicates that the zone's definitely automated requests are being blocked or challenged.
        """
        return pulumi.get(self, "sbfm_definitely_automated")

    @property
    @pulumi.getter(name="sbfmLikelyAutomated")
    def sbfm_likely_automated(self) -> str:
        """
        Indicates that the zone's likely automated requests are being blocked or challenged.
        """
        return pulumi.get(self, "sbfm_likely_automated")

    @property
    @pulumi.getter(name="sbfmStaticResourceProtection")
    def sbfm_static_resource_protection(self) -> str:
        """
        Indicates that the zone's static resource protection is turned on.
        """
        return pulumi.get(self, "sbfm_static_resource_protection")

    @property
    @pulumi.getter(name="sbfmVerifiedBots")
    def sbfm_verified_bots(self) -> str:
        """
        Indicates that the zone's verified bot requests are being blocked.
        """
        return pulumi.get(self, "sbfm_verified_bots")

    @property
    @pulumi.getter(name="suppressSessionScore")
    def suppress_session_score(self) -> bool:
        """
        Indicates that the zone's session score tracking is disabled.
        """
        return pulumi.get(self, "suppress_session_score")


@pulumi.output_type
class GetByoIpPrefixesResultResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 advertised: bool,
                 advertised_modified_at: str,
                 approved: str,
                 asn: int,
                 cidr: str,
                 created_at: str,
                 description: str,
                 id: str,
                 loa_document_id: str,
                 modified_at: str,
                 on_demand_enabled: bool,
                 on_demand_locked: bool):
        """
        :param str account_id: Identifier of a Cloudflare account.
        :param bool advertised: Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled.
        :param str advertised_modified_at: Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled.
        :param str approved: Approval state of the prefix (P = pending, V = active).
        :param int asn: Autonomous System Number (ASN) the prefix will be advertised under.
        :param str cidr: IP Prefix in Classless Inter-Domain Routing format.
        :param str description: Description of the prefix.
        :param str id: Identifier of an IP Prefix.
        :param str loa_document_id: Identifier for the uploaded LOA document.
        :param bool on_demand_enabled: Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled.
        :param bool on_demand_locked: Whether advertisement status of the prefix is locked, meaning it cannot be changed.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "advertised", advertised)
        pulumi.set(__self__, "advertised_modified_at", advertised_modified_at)
        pulumi.set(__self__, "approved", approved)
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "loa_document_id", loa_document_id)
        pulumi.set(__self__, "modified_at", modified_at)
        pulumi.set(__self__, "on_demand_enabled", on_demand_enabled)
        pulumi.set(__self__, "on_demand_locked", on_demand_locked)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Identifier of a Cloudflare account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def advertised(self) -> bool:
        """
        Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled.
        """
        return pulumi.get(self, "advertised")

    @property
    @pulumi.getter(name="advertisedModifiedAt")
    def advertised_modified_at(self) -> str:
        """
        Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled.
        """
        return pulumi.get(self, "advertised_modified_at")

    @property
    @pulumi.getter
    def approved(self) -> str:
        """
        Approval state of the prefix (P = pending, V = active).
        """
        return pulumi.get(self, "approved")

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        Autonomous System Number (ASN) the prefix will be advertised under.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        IP Prefix in Classless Inter-Domain Routing format.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the prefix.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of an IP Prefix.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="loaDocumentId")
    def loa_document_id(self) -> str:
        """
        Identifier for the uploaded LOA document.
        """
        return pulumi.get(self, "loa_document_id")

    @property
    @pulumi.getter(name="modifiedAt")
    def modified_at(self) -> str:
        return pulumi.get(self, "modified_at")

    @property
    @pulumi.getter(name="onDemandEnabled")
    def on_demand_enabled(self) -> bool:
        """
        Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled.
        """
        return pulumi.get(self, "on_demand_enabled")

    @property
    @pulumi.getter(name="onDemandLocked")
    def on_demand_locked(self) -> bool:
        """
        Whether advertisement status of the prefix is locked, meaning it cannot be changed.
        """
        return pulumi.get(self, "on_demand_locked")


@pulumi.output_type
class GetCallsSfuAppsResultResult(dict):
    def __init__(__self__, *,
                 created: str,
                 modified: str,
                 name: str,
                 uid: str):
        """
        :param str created: The date and time the item was created.
        :param str modified: The date and time the item was last modified.
        :param str name: A short description of Calls app, not shown to end users.
        :param str uid: A Cloudflare-generated unique identifier for a item.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "modified", modified)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The date and time the item was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def modified(self) -> str:
        """
        The date and time the item was last modified.
        """
        return pulumi.get(self, "modified")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A short description of Calls app, not shown to end users.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        A Cloudflare-generated unique identifier for a item.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetCallsTurnAppsResultResult(dict):
    def __init__(__self__, *,
                 created: str,
                 modified: str,
                 name: str,
                 uid: str):
        """
        :param str created: The date and time the item was created.
        :param str modified: The date and time the item was last modified.
        :param str name: A short description of Calls app, not shown to end users.
        :param str uid: A Cloudflare-generated unique identifier for a item.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "modified", modified)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The date and time the item was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def modified(self) -> str:
        """
        The date and time the item was last modified.
        """
        return pulumi.get(self, "modified")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A short description of Calls app, not shown to end users.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        A Cloudflare-generated unique identifier for a item.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetCertificatePacksResultResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetCloudConnectorRulesListResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 description: str,
                 enabled: bool,
                 expression: str,
                 id: str,
                 parameters: 'outputs.GetCloudConnectorRulesListResultParametersResult'):
        """
        :param str cloud_provider: Cloud Provider type
        :param 'GetCloudConnectorRulesListResultParametersArgs' parameters: Parameters of Cloud Connector Rule
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud Provider type
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.GetCloudConnectorRulesListResultParametersResult':
        """
        Parameters of Cloud Connector Rule
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetCloudConnectorRulesListResultParametersResult(dict):
    def __init__(__self__, *,
                 host: str):
        """
        :param str host: Host to perform Cloud Connection to
        """
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host to perform Cloud Connection to
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class GetCloudforceOneRequestsResultResult(dict):
    def __init__(__self__, *,
                 completed: str,
                 created: str,
                 id: str,
                 message_tokens: int,
                 priority: str,
                 readable_id: str,
                 request: str,
                 status: str,
                 summary: str,
                 tlp: str,
                 tokens: int,
                 updated: str):
        """
        :param str completed: Request completion time
        :param str created: Request creation time
        :param str id: UUID
        :param int message_tokens: Tokens for the request messages
        :param str readable_id: Readable Request ID
        :param str request: Requested information from request
        :param str status: Request Status
        :param str summary: Brief description of the request
        :param str tlp: The CISA defined Traffic Light Protocol (TLP)
        :param int tokens: Tokens for the request
        :param str updated: Request last updated time
        """
        pulumi.set(__self__, "completed", completed)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message_tokens", message_tokens)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "readable_id", readable_id)
        pulumi.set(__self__, "request", request)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "summary", summary)
        pulumi.set(__self__, "tlp", tlp)
        pulumi.set(__self__, "tokens", tokens)
        pulumi.set(__self__, "updated", updated)

    @property
    @pulumi.getter
    def completed(self) -> str:
        """
        Request completion time
        """
        return pulumi.get(self, "completed")

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        Request creation time
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="messageTokens")
    def message_tokens(self) -> int:
        """
        Tokens for the request messages
        """
        return pulumi.get(self, "message_tokens")

    @property
    @pulumi.getter
    def priority(self) -> str:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readableId")
    def readable_id(self) -> str:
        """
        Readable Request ID
        """
        return pulumi.get(self, "readable_id")

    @property
    @pulumi.getter
    def request(self) -> str:
        """
        Requested information from request
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Request Status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        Brief description of the request
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def tlp(self) -> str:
        """
        The CISA defined Traffic Light Protocol (TLP)
        """
        return pulumi.get(self, "tlp")

    @property
    @pulumi.getter
    def tokens(self) -> int:
        """
        Tokens for the request
        """
        return pulumi.get(self, "tokens")

    @property
    @pulumi.getter
    def updated(self) -> str:
        """
        Request last updated time
        """
        return pulumi.get(self, "updated")


@pulumi.output_type
class GetContentScanningExpressionsResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 payload: str):
        """
        :param str id: The unique ID for this custom scan expression
        :param str payload: Ruleset expression to use in matching content objects
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID for this custom scan expression
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        Ruleset expression to use in matching content objects
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class GetCustomHostnameFilterResult(dict):
    def __init__(__self__, *,
                 order: str,
                 direction: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 ssl: Optional[float] = None):
        """
        :param str order: Field to order hostnames by.
        :param str direction: Direction to order hostnames.
        :param str hostname: Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
        :param str id: Hostname ID to match against. This ID was generated and returned during the initial custom_hostname creation. This parameter cannot be used with the 'hostname' parameter.
        :param float ssl: Whether to filter hostnames based on if they have SSL enabled.
        """
        pulumi.set(__self__, "order", order)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Field to order hostnames by.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order hostnames.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Hostname ID to match against. This ID was generated and returned during the initial custom_hostname creation. This parameter cannot be used with the 'hostname' parameter.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[float]:
        """
        Whether to filter hostnames based on if they have SSL enabled.
        """
        return pulumi.get(self, "ssl")


@pulumi.output_type
class GetCustomHostnameOwnershipVerificationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: DNS Name for record.
        :param str type: DNS Record type.
        :param str value: Content for the record.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        DNS Name for record.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        DNS Record type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Content for the record.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCustomHostnameOwnershipVerificationHttpResult(dict):
    def __init__(__self__, *,
                 http_body: str,
                 http_url: str):
        """
        :param str http_body: Token to be served.
        :param str http_url: The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        pulumi.set(__self__, "http_body", http_body)
        pulumi.set(__self__, "http_url", http_url)

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> str:
        """
        Token to be served.
        """
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> str:
        """
        The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        return pulumi.get(self, "http_url")


@pulumi.output_type
class GetCustomHostnameSslResult(dict):
    def __init__(__self__, *,
                 bundle_method: str,
                 certificate_authority: str,
                 custom_certificate: str,
                 custom_csr_id: str,
                 custom_key: str,
                 expires_on: str,
                 hosts: Sequence[str],
                 id: str,
                 issuer: str,
                 method: str,
                 serial_number: str,
                 settings: 'outputs.GetCustomHostnameSslSettingsResult',
                 signature: str,
                 status: str,
                 type: str,
                 uploaded_on: str,
                 validation_errors: Sequence['outputs.GetCustomHostnameSslValidationErrorResult'],
                 validation_records: Sequence['outputs.GetCustomHostnameSslValidationRecordResult'],
                 wildcard: bool):
        """
        :param str bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        :param str certificate_authority: The Certificate Authority that will issue the certificate
        :param str custom_certificate: If a custom uploaded certificate is used.
        :param str custom_csr_id: The identifier for the Custom CSR that was used.
        :param str custom_key: The key for a custom uploaded certificate.
        :param str expires_on: The time the custom certificate expires on.
        :param Sequence[str] hosts: A list of Hostnames on a custom uploaded certificate.
        :param str id: Custom hostname SSL identifier tag.
        :param str issuer: The issuer on a custom uploaded certificate.
        :param str method: Domain control validation (DCV) method used for this hostname.
        :param str serial_number: The serial number on a custom uploaded certificate.
        :param str signature: The signature on a custom uploaded certificate.
        :param str status: Status of the hostname's SSL certificates.
        :param str type: Level of validation to be used for this hostname. Domain validation (dv) must be used.
        :param str uploaded_on: The time the custom certificate was uploaded.
        :param Sequence['GetCustomHostnameSslValidationErrorArgs'] validation_errors: Domain validation errors that have been received by the certificate authority (CA).
        :param bool wildcard: Indicates whether the certificate covers a wildcard.
        """
        pulumi.set(__self__, "bundle_method", bundle_method)
        pulumi.set(__self__, "certificate_authority", certificate_authority)
        pulumi.set(__self__, "custom_certificate", custom_certificate)
        pulumi.set(__self__, "custom_csr_id", custom_csr_id)
        pulumi.set(__self__, "custom_key", custom_key)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "serial_number", serial_number)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uploaded_on", uploaded_on)
        pulumi.set(__self__, "validation_errors", validation_errors)
        pulumi.set(__self__, "validation_records", validation_records)
        pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> str:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> str:
        """
        The Certificate Authority that will issue the certificate
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> str:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="customCsrId")
    def custom_csr_id(self) -> str:
        """
        The identifier for the Custom CSR that was used.
        """
        return pulumi.get(self, "custom_csr_id")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> str:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        """
        The time the custom certificate expires on.
        """
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        A list of Hostnames on a custom uploaded certificate.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Custom hostname SSL identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The issuer on a custom uploaded certificate.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Domain control validation (DCV) method used for this hostname.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> str:
        """
        The serial number on a custom uploaded certificate.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetCustomHostnameSslSettingsResult':
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def signature(self) -> str:
        """
        The signature on a custom uploaded certificate.
        """
        return pulumi.get(self, "signature")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the hostname's SSL certificates.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Level of validation to be used for this hostname. Domain validation (dv) must be used.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="uploadedOn")
    def uploaded_on(self) -> str:
        """
        The time the custom certificate was uploaded.
        """
        return pulumi.get(self, "uploaded_on")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.GetCustomHostnameSslValidationErrorResult']:
        """
        Domain validation errors that have been received by the certificate authority (CA).
        """
        return pulumi.get(self, "validation_errors")

    @property
    @pulumi.getter(name="validationRecords")
    def validation_records(self) -> Sequence['outputs.GetCustomHostnameSslValidationRecordResult']:
        return pulumi.get(self, "validation_records")

    @property
    @pulumi.getter
    def wildcard(self) -> bool:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")


@pulumi.output_type
class GetCustomHostnameSslSettingsResult(dict):
    def __init__(__self__, *,
                 ciphers: Sequence[str],
                 early_hints: str,
                 http2: str,
                 min_tls_version: str,
                 tls13: str):
        """
        :param Sequence[str] ciphers: An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        :param str early_hints: Whether or not Early Hints is enabled.
        :param str http2: Whether or not HTTP2 is enabled.
        :param str min_tls_version: The minimum TLS version supported.
        :param str tls13: Whether or not TLS 1.3 is enabled.
        """
        pulumi.set(__self__, "ciphers", ciphers)
        pulumi.set(__self__, "early_hints", early_hints)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "min_tls_version", min_tls_version)
        pulumi.set(__self__, "tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Sequence[str]:
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> str:
        """
        Whether or not Early Hints is enabled.
        """
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter
    def http2(self) -> str:
        """
        Whether or not HTTP2 is enabled.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> str:
        """
        The minimum TLS version supported.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def tls13(self) -> str:
        """
        Whether or not TLS 1.3 is enabled.
        """
        return pulumi.get(self, "tls13")


@pulumi.output_type
class GetCustomHostnameSslValidationErrorResult(dict):
    def __init__(__self__, *,
                 message: str):
        """
        :param str message: A domain validation error.
        """
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A domain validation error.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class GetCustomHostnameSslValidationRecordResult(dict):
    def __init__(__self__, *,
                 emails: Sequence[str],
                 http_body: str,
                 http_url: str,
                 txt_name: str,
                 txt_value: str):
        """
        :param Sequence[str] emails: The set of email addresses that the certificate authority (CA) will use to complete domain validation.
        :param str http_body: The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
        :param str http_url: The url that will be checked during domain validation.
        :param str txt_name: The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
        :param str txt_value: The TXT record that the certificate authority (CA) will check during domain validation.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "http_body", http_body)
        pulumi.set(__self__, "http_url", http_url)
        pulumi.set(__self__, "txt_name", txt_name)
        pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[str]:
        """
        The set of email addresses that the certificate authority (CA) will use to complete domain validation.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> str:
        """
        The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
        """
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> str:
        """
        The url that will be checked during domain validation.
        """
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> str:
        """
        The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
        """
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> str:
        """
        The TXT record that the certificate authority (CA) will check during domain validation.
        """
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class GetCustomHostnamesResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 custom_metadata: Mapping[str, str],
                 custom_origin_server: str,
                 custom_origin_sni: str,
                 hostname: str,
                 id: str,
                 ownership_verification: 'outputs.GetCustomHostnamesResultOwnershipVerificationResult',
                 ownership_verification_http: 'outputs.GetCustomHostnamesResultOwnershipVerificationHttpResult',
                 ssl: 'outputs.GetCustomHostnamesResultSslResult',
                 status: str,
                 verification_errors: Sequence[str]):
        """
        :param str created_at: This is the time the hostname was created.
        :param Mapping[str, str] custom_metadata: Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
        :param str custom_origin_server: a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
        :param str custom_origin_sni: A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request*host*header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
        :param str hostname: The custom hostname that will point to your hostname via CNAME.
        :param str id: Identifier
        :param 'GetCustomHostnamesResultOwnershipVerificationArgs' ownership_verification: This is a record which can be placed to activate a hostname.
        :param 'GetCustomHostnamesResultOwnershipVerificationHttpArgs' ownership_verification_http: This presents the token to be served by the given http url to activate a hostname.
        :param str status: Status of the hostname's activation.
        :param Sequence[str] verification_errors: These are errors that were encountered while trying to activate a hostname.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_metadata", custom_metadata)
        pulumi.set(__self__, "custom_origin_server", custom_origin_server)
        pulumi.set(__self__, "custom_origin_sni", custom_origin_sni)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ownership_verification", ownership_verification)
        pulumi.set(__self__, "ownership_verification_http", ownership_verification_http)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "verification_errors", verification_errors)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        This is the time the hostname was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customMetadata")
    def custom_metadata(self) -> Mapping[str, str]:
        """
        Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
        """
        return pulumi.get(self, "custom_metadata")

    @property
    @pulumi.getter(name="customOriginServer")
    def custom_origin_server(self) -> str:
        """
        a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
        """
        return pulumi.get(self, "custom_origin_server")

    @property
    @pulumi.getter(name="customOriginSni")
    def custom_origin_sni(self) -> str:
        """
        A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request*host*header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
        """
        return pulumi.get(self, "custom_origin_sni")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The custom hostname that will point to your hostname via CNAME.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ownershipVerification")
    def ownership_verification(self) -> 'outputs.GetCustomHostnamesResultOwnershipVerificationResult':
        """
        This is a record which can be placed to activate a hostname.
        """
        return pulumi.get(self, "ownership_verification")

    @property
    @pulumi.getter(name="ownershipVerificationHttp")
    def ownership_verification_http(self) -> 'outputs.GetCustomHostnamesResultOwnershipVerificationHttpResult':
        """
        This presents the token to be served by the given http url to activate a hostname.
        """
        return pulumi.get(self, "ownership_verification_http")

    @property
    @pulumi.getter
    def ssl(self) -> 'outputs.GetCustomHostnamesResultSslResult':
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the hostname's activation.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="verificationErrors")
    def verification_errors(self) -> Sequence[str]:
        """
        These are errors that were encountered while trying to activate a hostname.
        """
        return pulumi.get(self, "verification_errors")


@pulumi.output_type
class GetCustomHostnamesResultOwnershipVerificationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: DNS Name for record.
        :param str type: DNS Record type.
        :param str value: Content for the record.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        DNS Name for record.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        DNS Record type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Content for the record.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCustomHostnamesResultOwnershipVerificationHttpResult(dict):
    def __init__(__self__, *,
                 http_body: str,
                 http_url: str):
        """
        :param str http_body: Token to be served.
        :param str http_url: The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        pulumi.set(__self__, "http_body", http_body)
        pulumi.set(__self__, "http_url", http_url)

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> str:
        """
        Token to be served.
        """
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> str:
        """
        The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        return pulumi.get(self, "http_url")


@pulumi.output_type
class GetCustomHostnamesResultSslResult(dict):
    def __init__(__self__, *,
                 bundle_method: str,
                 certificate_authority: str,
                 custom_certificate: str,
                 custom_csr_id: str,
                 custom_key: str,
                 expires_on: str,
                 hosts: Sequence[str],
                 id: str,
                 issuer: str,
                 method: str,
                 serial_number: str,
                 settings: 'outputs.GetCustomHostnamesResultSslSettingsResult',
                 signature: str,
                 status: str,
                 type: str,
                 uploaded_on: str,
                 validation_errors: Sequence['outputs.GetCustomHostnamesResultSslValidationErrorResult'],
                 validation_records: Sequence['outputs.GetCustomHostnamesResultSslValidationRecordResult'],
                 wildcard: bool):
        """
        :param str bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        :param str certificate_authority: The Certificate Authority that will issue the certificate
        :param str custom_certificate: If a custom uploaded certificate is used.
        :param str custom_csr_id: The identifier for the Custom CSR that was used.
        :param str custom_key: The key for a custom uploaded certificate.
        :param str expires_on: The time the custom certificate expires on.
        :param Sequence[str] hosts: A list of Hostnames on a custom uploaded certificate.
        :param str id: Custom hostname SSL identifier tag.
        :param str issuer: The issuer on a custom uploaded certificate.
        :param str method: Domain control validation (DCV) method used for this hostname.
        :param str serial_number: The serial number on a custom uploaded certificate.
        :param str signature: The signature on a custom uploaded certificate.
        :param str status: Status of the hostname's SSL certificates.
        :param str type: Level of validation to be used for this hostname. Domain validation (dv) must be used.
        :param str uploaded_on: The time the custom certificate was uploaded.
        :param Sequence['GetCustomHostnamesResultSslValidationErrorArgs'] validation_errors: Domain validation errors that have been received by the certificate authority (CA).
        :param bool wildcard: Indicates whether the certificate covers a wildcard.
        """
        pulumi.set(__self__, "bundle_method", bundle_method)
        pulumi.set(__self__, "certificate_authority", certificate_authority)
        pulumi.set(__self__, "custom_certificate", custom_certificate)
        pulumi.set(__self__, "custom_csr_id", custom_csr_id)
        pulumi.set(__self__, "custom_key", custom_key)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "serial_number", serial_number)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uploaded_on", uploaded_on)
        pulumi.set(__self__, "validation_errors", validation_errors)
        pulumi.set(__self__, "validation_records", validation_records)
        pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> str:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> str:
        """
        The Certificate Authority that will issue the certificate
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> str:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="customCsrId")
    def custom_csr_id(self) -> str:
        """
        The identifier for the Custom CSR that was used.
        """
        return pulumi.get(self, "custom_csr_id")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> str:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        """
        The time the custom certificate expires on.
        """
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        A list of Hostnames on a custom uploaded certificate.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Custom hostname SSL identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The issuer on a custom uploaded certificate.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Domain control validation (DCV) method used for this hostname.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> str:
        """
        The serial number on a custom uploaded certificate.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetCustomHostnamesResultSslSettingsResult':
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def signature(self) -> str:
        """
        The signature on a custom uploaded certificate.
        """
        return pulumi.get(self, "signature")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the hostname's SSL certificates.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Level of validation to be used for this hostname. Domain validation (dv) must be used.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="uploadedOn")
    def uploaded_on(self) -> str:
        """
        The time the custom certificate was uploaded.
        """
        return pulumi.get(self, "uploaded_on")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.GetCustomHostnamesResultSslValidationErrorResult']:
        """
        Domain validation errors that have been received by the certificate authority (CA).
        """
        return pulumi.get(self, "validation_errors")

    @property
    @pulumi.getter(name="validationRecords")
    def validation_records(self) -> Sequence['outputs.GetCustomHostnamesResultSslValidationRecordResult']:
        return pulumi.get(self, "validation_records")

    @property
    @pulumi.getter
    def wildcard(self) -> bool:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")


@pulumi.output_type
class GetCustomHostnamesResultSslSettingsResult(dict):
    def __init__(__self__, *,
                 ciphers: Sequence[str],
                 early_hints: str,
                 http2: str,
                 min_tls_version: str,
                 tls13: str):
        """
        :param Sequence[str] ciphers: An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        :param str early_hints: Whether or not Early Hints is enabled.
        :param str http2: Whether or not HTTP2 is enabled.
        :param str min_tls_version: The minimum TLS version supported.
        :param str tls13: Whether or not TLS 1.3 is enabled.
        """
        pulumi.set(__self__, "ciphers", ciphers)
        pulumi.set(__self__, "early_hints", early_hints)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "min_tls_version", min_tls_version)
        pulumi.set(__self__, "tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Sequence[str]:
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> str:
        """
        Whether or not Early Hints is enabled.
        """
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter
    def http2(self) -> str:
        """
        Whether or not HTTP2 is enabled.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> str:
        """
        The minimum TLS version supported.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def tls13(self) -> str:
        """
        Whether or not TLS 1.3 is enabled.
        """
        return pulumi.get(self, "tls13")


@pulumi.output_type
class GetCustomHostnamesResultSslValidationErrorResult(dict):
    def __init__(__self__, *,
                 message: str):
        """
        :param str message: A domain validation error.
        """
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A domain validation error.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class GetCustomHostnamesResultSslValidationRecordResult(dict):
    def __init__(__self__, *,
                 emails: Sequence[str],
                 http_body: str,
                 http_url: str,
                 txt_name: str,
                 txt_value: str):
        """
        :param Sequence[str] emails: The set of email addresses that the certificate authority (CA) will use to complete domain validation.
        :param str http_body: The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
        :param str http_url: The url that will be checked during domain validation.
        :param str txt_name: The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
        :param str txt_value: The TXT record that the certificate authority (CA) will check during domain validation.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "http_body", http_body)
        pulumi.set(__self__, "http_url", http_url)
        pulumi.set(__self__, "txt_name", txt_name)
        pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[str]:
        """
        The set of email addresses that the certificate authority (CA) will use to complete domain validation.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> str:
        """
        The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
        """
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> str:
        """
        The url that will be checked during domain validation.
        """
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> str:
        """
        The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
        """
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> str:
        """
        The TXT record that the certificate authority (CA) will check during domain validation.
        """
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class GetCustomSslFilterResult(dict):
    def __init__(__self__, *,
                 match: str,
                 status: Optional[str] = None):
        """
        :param str match: Whether to match all search requirements or at least one (any).
        :param str status: Status of the zone's custom SSL.
        """
        pulumi.set(__self__, "match", match)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        Whether to match all search requirements or at least one (any).
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the zone's custom SSL.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetCustomSslGeoRestrictionsResult(dict):
    def __init__(__self__, *,
                 label: str):
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")


@pulumi.output_type
class GetCustomSslKeylessServerResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 enabled: bool,
                 host: str,
                 id: str,
                 modified_on: str,
                 name: str,
                 permissions: Sequence[str],
                 port: float,
                 status: str,
                 tunnel: 'outputs.GetCustomSslKeylessServerTunnelResult'):
        """
        :param str created_on: When the Keyless SSL was created.
        :param bool enabled: Whether or not the Keyless SSL is on or off.
        :param str host: The keyless SSL name.
        :param str id: Keyless certificate identifier tag.
        :param str modified_on: When the Keyless SSL was last modified.
        :param str name: The keyless SSL name.
        :param Sequence[str] permissions: Available permissions for the Keyless SSL for the current user requesting the item.
        :param float port: The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        :param str status: Status of the Keyless SSL.
        :param 'GetCustomSslKeylessServerTunnelArgs' tunnel: Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tunnel", tunnel)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the Keyless SSL was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not the Keyless SSL is on or off.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Keyless certificate identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the Keyless SSL was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        """
        Available permissions for the Keyless SSL for the current user requesting the item.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Keyless SSL.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tunnel(self) -> 'outputs.GetCustomSslKeylessServerTunnelResult':
        """
        Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        return pulumi.get(self, "tunnel")


@pulumi.output_type
class GetCustomSslKeylessServerTunnelResult(dict):
    def __init__(__self__, *,
                 private_ip: str,
                 vnet_id: str):
        """
        :param str private_ip: Private IP of the Key Server Host
        :param str vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetCustomSslsResultResult(dict):
    def __init__(__self__, *,
                 bundle_method: str,
                 expires_on: str,
                 geo_restrictions: 'outputs.GetCustomSslsResultGeoRestrictionsResult',
                 hosts: Sequence[str],
                 id: str,
                 issuer: str,
                 keyless_server: 'outputs.GetCustomSslsResultKeylessServerResult',
                 modified_on: str,
                 policy: str,
                 priority: float,
                 signature: str,
                 status: str,
                 uploaded_on: str,
                 zone_id: str):
        """
        :param str bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        :param str expires_on: When the certificate from the authority expires.
        :param 'GetCustomSslsResultGeoRestrictionsArgs' geo_restrictions: Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
        :param str id: Identifier
        :param str issuer: The certificate authority that issued the certificate.
        :param str modified_on: When the certificate was last modified.
        :param str policy: Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
        :param float priority: The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy*custom' certificates, but 'legacy*custom' certificates will always supercede 'sni_custom' certificates.
        :param str signature: The type of hash used for the certificate.
        :param str status: Status of the zone's custom SSL.
        :param str uploaded_on: When the certificate was uploaded to Cloudflare.
        :param str zone_id: Identifier
        """
        pulumi.set(__self__, "bundle_method", bundle_method)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "geo_restrictions", geo_restrictions)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "keyless_server", keyless_server)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uploaded_on", uploaded_on)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> str:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        """
        When the certificate from the authority expires.
        """
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter(name="geoRestrictions")
    def geo_restrictions(self) -> 'outputs.GetCustomSslsResultGeoRestrictionsResult':
        """
        Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
        """
        return pulumi.get(self, "geo_restrictions")

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The certificate authority that issued the certificate.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="keylessServer")
    def keyless_server(self) -> 'outputs.GetCustomSslsResultKeylessServerResult':
        return pulumi.get(self, "keyless_server")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the certificate was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy*custom' certificates, but 'legacy*custom' certificates will always supercede 'sni_custom' certificates.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def signature(self) -> str:
        """
        The type of hash used for the certificate.
        """
        return pulumi.get(self, "signature")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the zone's custom SSL.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uploadedOn")
    def uploaded_on(self) -> str:
        """
        When the certificate was uploaded to Cloudflare.
        """
        return pulumi.get(self, "uploaded_on")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetCustomSslsResultGeoRestrictionsResult(dict):
    def __init__(__self__, *,
                 label: str):
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")


@pulumi.output_type
class GetCustomSslsResultKeylessServerResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 enabled: bool,
                 host: str,
                 id: str,
                 modified_on: str,
                 name: str,
                 permissions: Sequence[str],
                 port: float,
                 status: str,
                 tunnel: 'outputs.GetCustomSslsResultKeylessServerTunnelResult'):
        """
        :param str created_on: When the Keyless SSL was created.
        :param bool enabled: Whether or not the Keyless SSL is on or off.
        :param str host: The keyless SSL name.
        :param str id: Keyless certificate identifier tag.
        :param str modified_on: When the Keyless SSL was last modified.
        :param str name: The keyless SSL name.
        :param Sequence[str] permissions: Available permissions for the Keyless SSL for the current user requesting the item.
        :param float port: The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        :param str status: Status of the Keyless SSL.
        :param 'GetCustomSslsResultKeylessServerTunnelArgs' tunnel: Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tunnel", tunnel)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the Keyless SSL was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not the Keyless SSL is on or off.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Keyless certificate identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the Keyless SSL was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        """
        Available permissions for the Keyless SSL for the current user requesting the item.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Keyless SSL.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tunnel(self) -> 'outputs.GetCustomSslsResultKeylessServerTunnelResult':
        """
        Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        return pulumi.get(self, "tunnel")


@pulumi.output_type
class GetCustomSslsResultKeylessServerTunnelResult(dict):
    def __init__(__self__, *,
                 private_ip: str,
                 vnet_id: str):
        """
        :param str private_ip: Private IP of the Key Server Host
        :param str vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetD1DatabaseFilterResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: a database name to search for.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        a database name to search for.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetD1DatabasesResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 name: str,
                 uuid: str,
                 version: str):
        """
        :param str created_at: Specifies the timestamp the resource was created as an ISO8601 string.
<<<<<<< HEAD
=======
        :param str name: D1 database name.
        :param str uuid: D1 database identifier (UUID).
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uuid", uuid)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Specifies the timestamp the resource was created as an ISO8601 string.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def name(self) -> str:
<<<<<<< HEAD
=======
        """
        D1 database name.
        """
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uuid(self) -> str:
<<<<<<< HEAD
=======
        """
        D1 database identifier (UUID).
        """
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDnsFirewallAttackMitigationResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 only_when_upstream_unhealthy: bool):
        """
        :param bool enabled: When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        :param bool only_when_upstream_unhealthy: Only mitigate attacks when upstream servers seem unhealthy
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "only_when_upstream_unhealthy", only_when_upstream_unhealthy)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="onlyWhenUpstreamUnhealthy")
    def only_when_upstream_unhealthy(self) -> bool:
        """
        Only mitigate attacks when upstream servers seem unhealthy
        """
        return pulumi.get(self, "only_when_upstream_unhealthy")


@pulumi.output_type
class GetDnsFirewallsResultResult(dict):
    def __init__(__self__, *,
                 attack_mitigation: 'outputs.GetDnsFirewallsResultAttackMitigationResult',
                 deprecate_any_requests: bool,
                 dns_firewall_ips: Sequence[str],
                 ecs_fallback: bool,
                 id: str,
                 maximum_cache_ttl: float,
                 minimum_cache_ttl: float,
                 modified_on: str,
                 name: str,
                 negative_cache_ttl: float,
                 ratelimit: float,
                 retries: float,
                 upstream_ips: Sequence[str]):
        """
        :param 'GetDnsFirewallsResultAttackMitigationArgs' attack_mitigation: Attack mitigation settings
        :param bool deprecate_any_requests: Whether to refuse to answer queries for the ANY type
        :param bool ecs_fallback: Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
        :param str id: Identifier
        :param float maximum_cache_ttl: Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
        :param float minimum_cache_ttl: Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
        :param str modified_on: Last modification of DNS Firewall cluster
        :param str name: DNS Firewall cluster name
        :param float negative_cache_ttl: Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
        :param float ratelimit: Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
        :param float retries: Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
        """
        pulumi.set(__self__, "attack_mitigation", attack_mitigation)
        pulumi.set(__self__, "deprecate_any_requests", deprecate_any_requests)
        pulumi.set(__self__, "dns_firewall_ips", dns_firewall_ips)
        pulumi.set(__self__, "ecs_fallback", ecs_fallback)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "maximum_cache_ttl", maximum_cache_ttl)
        pulumi.set(__self__, "minimum_cache_ttl", minimum_cache_ttl)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "negative_cache_ttl", negative_cache_ttl)
        pulumi.set(__self__, "ratelimit", ratelimit)
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "upstream_ips", upstream_ips)

    @property
    @pulumi.getter(name="attackMitigation")
    def attack_mitigation(self) -> 'outputs.GetDnsFirewallsResultAttackMitigationResult':
        """
        Attack mitigation settings
        """
        return pulumi.get(self, "attack_mitigation")

    @property
    @pulumi.getter(name="deprecateAnyRequests")
    def deprecate_any_requests(self) -> bool:
        """
        Whether to refuse to answer queries for the ANY type
        """
        return pulumi.get(self, "deprecate_any_requests")

    @property
    @pulumi.getter(name="dnsFirewallIps")
    def dns_firewall_ips(self) -> Sequence[str]:
        return pulumi.get(self, "dns_firewall_ips")

    @property
    @pulumi.getter(name="ecsFallback")
    def ecs_fallback(self) -> bool:
        """
        Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
        """
        return pulumi.get(self, "ecs_fallback")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maximumCacheTtl")
    def maximum_cache_ttl(self) -> float:
        """
        Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
        """
        return pulumi.get(self, "maximum_cache_ttl")

    @property
    @pulumi.getter(name="minimumCacheTtl")
    def minimum_cache_ttl(self) -> float:
        """
        Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
        """
        return pulumi.get(self, "minimum_cache_ttl")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        Last modification of DNS Firewall cluster
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        DNS Firewall cluster name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="negativeCacheTtl")
    def negative_cache_ttl(self) -> float:
        """
        Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
        """
        return pulumi.get(self, "negative_cache_ttl")

    @property
    @pulumi.getter
    def ratelimit(self) -> float:
        """
        Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
        """
        return pulumi.get(self, "ratelimit")

    @property
    @pulumi.getter
    def retries(self) -> float:
        """
        Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter(name="upstreamIps")
    def upstream_ips(self) -> Sequence[str]:
        return pulumi.get(self, "upstream_ips")


@pulumi.output_type
class GetDnsFirewallsResultAttackMitigationResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 only_when_upstream_unhealthy: bool):
        """
        :param bool enabled: When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        :param bool only_when_upstream_unhealthy: Only mitigate attacks when upstream servers seem unhealthy
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "only_when_upstream_unhealthy", only_when_upstream_unhealthy)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="onlyWhenUpstreamUnhealthy")
    def only_when_upstream_unhealthy(self) -> bool:
        """
        Only mitigate attacks when upstream servers seem unhealthy
        """
        return pulumi.get(self, "only_when_upstream_unhealthy")


@pulumi.output_type
class GetDnsRecordDataResult(dict):
    def __init__(__self__, *,
                 algorithm: float,
                 altitude: float,
                 certificate: str,
                 digest: str,
                 digest_type: float,
                 fingerprint: str,
                 flags: Any,
                 key_tag: float,
                 lat_degrees: float,
                 lat_direction: str,
                 lat_minutes: float,
                 lat_seconds: float,
                 long_degrees: float,
                 long_direction: str,
                 long_minutes: float,
                 long_seconds: float,
                 matching_type: float,
                 order: float,
                 port: float,
                 precision_horz: float,
                 precision_vert: float,
                 preference: float,
                 priority: float,
                 protocol: float,
                 public_key: str,
                 regex: str,
                 replacement: str,
                 selector: float,
                 service: str,
                 size: float,
                 tag: str,
                 target: str,
                 type: float,
                 usage: float,
                 value: str,
                 weight: float):
        """
        :param float algorithm: Algorithm.
        :param float altitude: Altitude of location in meters.
        :param str certificate: Certificate.
        :param str digest: Digest.
        :param float digest_type: Digest Type.
        :param str fingerprint: fingerprint.
        :param Any flags: Flags for the CAA record.
        :param float key_tag: Key Tag.
        :param float lat_degrees: Degrees of latitude.
        :param str lat_direction: Latitude direction.
        :param float lat_minutes: Minutes of latitude.
        :param float lat_seconds: Seconds of latitude.
        :param float long_degrees: Degrees of longitude.
        :param str long_direction: Longitude direction.
        :param float long_minutes: Minutes of longitude.
        :param float long_seconds: Seconds of longitude.
        :param float matching_type: Matching Type.
        :param float order: Order.
        :param float port: The port of the service.
        :param float precision_horz: Horizontal precision of location.
        :param float precision_vert: Vertical precision of location.
        :param float preference: Preference.
        :param float priority: priority.
        :param float protocol: Protocol.
        :param str public_key: Public Key.
        :param str regex: Regex.
        :param str replacement: Replacement.
        :param float selector: Selector.
        :param str service: Service.
        :param float size: Size of location in meters.
        :param str tag: Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        :param str target: target.
        :param float type: Type.
        :param float usage: Usage.
        :param str value: Value of the record. This field's semantics depend on the chosen tag.
        :param float weight: The record weight.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "altitude", altitude)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "digest_type", digest_type)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "key_tag", key_tag)
        pulumi.set(__self__, "lat_degrees", lat_degrees)
        pulumi.set(__self__, "lat_direction", lat_direction)
        pulumi.set(__self__, "lat_minutes", lat_minutes)
        pulumi.set(__self__, "lat_seconds", lat_seconds)
        pulumi.set(__self__, "long_degrees", long_degrees)
        pulumi.set(__self__, "long_direction", long_direction)
        pulumi.set(__self__, "long_minutes", long_minutes)
        pulumi.set(__self__, "long_seconds", long_seconds)
        pulumi.set(__self__, "matching_type", matching_type)
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "precision_horz", precision_horz)
        pulumi.set(__self__, "precision_vert", precision_vert)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "replacement", replacement)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "usage", usage)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> float:
        """
        Algorithm.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def altitude(self) -> float:
        """
        Altitude of location in meters.
        """
        return pulumi.get(self, "altitude")

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        Certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def digest(self) -> str:
        """
        Digest.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> float:
        """
        Digest Type.
        """
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        """
        fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def flags(self) -> Any:
        """
        Flags for the CAA record.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> float:
        """
        Key Tag.
        """
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> float:
        """
        Degrees of latitude.
        """
        return pulumi.get(self, "lat_degrees")

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> str:
        """
        Latitude direction.
        """
        return pulumi.get(self, "lat_direction")

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> float:
        """
        Minutes of latitude.
        """
        return pulumi.get(self, "lat_minutes")

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> float:
        """
        Seconds of latitude.
        """
        return pulumi.get(self, "lat_seconds")

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> float:
        """
        Degrees of longitude.
        """
        return pulumi.get(self, "long_degrees")

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> str:
        """
        Longitude direction.
        """
        return pulumi.get(self, "long_direction")

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> float:
        """
        Minutes of longitude.
        """
        return pulumi.get(self, "long_minutes")

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> float:
        """
        Seconds of longitude.
        """
        return pulumi.get(self, "long_seconds")

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> float:
        """
        Matching Type.
        """
        return pulumi.get(self, "matching_type")

    @property
    @pulumi.getter
    def order(self) -> float:
        """
        Order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> float:
        """
        Horizontal precision of location.
        """
        return pulumi.get(self, "precision_horz")

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> float:
        """
        Vertical precision of location.
        """
        return pulumi.get(self, "precision_vert")

    @property
    @pulumi.getter
    def preference(self) -> float:
        """
        Preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> float:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def regex(self) -> str:
        """
        Regex.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def replacement(self) -> str:
        """
        Replacement.
        """
        return pulumi.get(self, "replacement")

    @property
    @pulumi.getter
    def selector(self) -> float:
        """
        Selector.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        Size of location in meters.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        target.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> float:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> float:
        """
        Usage.
        """
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def weight(self) -> float:
        """
        The record weight.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetDnsRecordFilterResult(dict):
    def __init__(__self__, *,
                 direction: str,
                 match: str,
                 order: str,
                 proxied: bool,
                 tag_match: str,
                 comment: Optional['outputs.GetDnsRecordFilterCommentResult'] = None,
                 content: Optional['outputs.GetDnsRecordFilterContentResult'] = None,
                 name: Optional['outputs.GetDnsRecordFilterNameResult'] = None,
                 search: Optional[str] = None,
                 tag: Optional['outputs.GetDnsRecordFilterTagResult'] = None,
                 type: Optional[str] = None):
        """
        :param str direction: Direction to order DNS records in.
        :param str match: Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        :param str order: Field to order DNS records by.
        :param bool proxied: Whether the record is receiving the performance and security benefits of Cloudflare.
        :param str tag_match: Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        :param str search: Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        :param str type: Record type.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "proxied", proxied)
        pulumi.set(__self__, "tag_match", tag_match)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction to order DNS records in.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Field to order DNS records by.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def proxied(self) -> bool:
        """
        Whether the record is receiving the performance and security benefits of Cloudflare.
        """
        return pulumi.get(self, "proxied")

    @property
    @pulumi.getter(name="tagMatch")
    def tag_match(self) -> str:
        """
        Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        """
        return pulumi.get(self, "tag_match")

    @property
    @pulumi.getter
    def comment(self) -> Optional['outputs.GetDnsRecordFilterCommentResult']:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def content(self) -> Optional['outputs.GetDnsRecordFilterContentResult']:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> Optional['outputs.GetDnsRecordFilterNameResult']:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def tag(self) -> Optional['outputs.GetDnsRecordFilterTagResult']:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDnsRecordFilterCommentResult(dict):
    def __init__(__self__, *,
                 absent: Optional[str] = None,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 present: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str absent: If this parameter is present, only records *without* a comment are returned.
        :param str contains: Substring of the DNS record comment. Comment filters are case-insensitive.
        :param str endswith: Suffix of the DNS record comment. Comment filters are case-insensitive.
        :param str exact: Exact value of the DNS record comment. Comment filters are case-insensitive.
        :param str present: If this parameter is present, only records *with* a comment are returned.
        :param str startswith: Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def absent(self) -> Optional[str]:
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        return pulumi.get(self, "absent")

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def present(self) -> Optional[str]:
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        return pulumi.get(self, "present")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsRecordFilterContentResult(dict):
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS record content. Content filters are case-insensitive.
        :param str endswith: Suffix of the DNS record content. Content filters are case-insensitive.
        :param str exact: Exact value of the DNS record content. Content filters are case-insensitive.
        :param str startswith: Prefix of the DNS record content. Content filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsRecordFilterNameResult(dict):
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS record name. Name filters are case-insensitive.
        :param str endswith: Suffix of the DNS record name. Name filters are case-insensitive.
        :param str exact: Exact value of the DNS record name. Name filters are case-insensitive.
        :param str startswith: Prefix of the DNS record name. Name filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsRecordFilterTagResult(dict):
    def __init__(__self__, *,
                 absent: Optional[str] = None,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 present: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str absent: Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        :param str contains: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        :param str endswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        :param str exact: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        :param str present: Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        :param str startswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def absent(self) -> Optional[str]:
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "absent")

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def present(self) -> Optional[str]:
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "present")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsRecordSettingsResult(dict):
    def __init__(__self__, *,
                 flatten_cname: bool,
                 ipv4_only: bool,
                 ipv6_only: bool):
        """
        :param bool flatten_cname: If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        :param bool ipv4_only: When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        :param bool ipv6_only: When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        pulumi.set(__self__, "flatten_cname", flatten_cname)
        pulumi.set(__self__, "ipv4_only", ipv4_only)
        pulumi.set(__self__, "ipv6_only", ipv6_only)

    @property
    @pulumi.getter(name="flattenCname")
    def flatten_cname(self) -> bool:
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        return pulumi.get(self, "flatten_cname")

    @property
    @pulumi.getter(name="ipv4Only")
    def ipv4_only(self) -> bool:
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv4_only")

    @property
    @pulumi.getter(name="ipv6Only")
    def ipv6_only(self) -> bool:
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv6_only")


@pulumi.output_type
class GetDnsRecordsCommentResult(dict):
    def __init__(__self__, *,
                 absent: Optional[str] = None,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 present: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str absent: If this parameter is present, only records *without* a comment are returned.
        :param str contains: Substring of the DNS record comment. Comment filters are case-insensitive.
        :param str endswith: Suffix of the DNS record comment. Comment filters are case-insensitive.
        :param str exact: Exact value of the DNS record comment. Comment filters are case-insensitive.
        :param str present: If this parameter is present, only records *with* a comment are returned.
        :param str startswith: Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def absent(self) -> Optional[str]:
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        return pulumi.get(self, "absent")

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def present(self) -> Optional[str]:
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        return pulumi.get(self, "present")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsRecordsContentResult(dict):
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS record content. Content filters are case-insensitive.
        :param str endswith: Suffix of the DNS record content. Content filters are case-insensitive.
        :param str exact: Exact value of the DNS record content. Content filters are case-insensitive.
        :param str startswith: Prefix of the DNS record content. Content filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsRecordsNameResult(dict):
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS record name. Name filters are case-insensitive.
        :param str endswith: Suffix of the DNS record name. Name filters are case-insensitive.
        :param str exact: Exact value of the DNS record name. Name filters are case-insensitive.
        :param str startswith: Prefix of the DNS record name. Name filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsRecordsResultResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 comment_modified_on: str,
                 content: str,
                 created_on: str,
                 data: 'outputs.GetDnsRecordsResultDataResult',
                 id: str,
                 meta: str,
                 modified_on: str,
                 name: str,
                 priority: float,
                 proxiable: bool,
                 proxied: bool,
                 settings: 'outputs.GetDnsRecordsResultSettingsResult',
                 tags: Sequence[str],
                 tags_modified_on: str,
                 ttl: float,
                 type: str):
        """
        :param str comment: Comments or notes about the DNS record. This field has no effect on DNS responses.
        :param str comment_modified_on: When the record comment was last modified. Omitted if there is no comment.
        :param str content: A valid IPv4 address.
        :param str created_on: When the record was created.
        :param 'GetDnsRecordsResultDataArgs' data: Components of a CAA record.
        :param str id: Identifier
        :param str meta: Extra Cloudflare-specific information about the record.
        :param str modified_on: When the record was last modified.
        :param str name: DNS record name (or @ for the zone apex) in Punycode.
        :param float priority: Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
        :param bool proxiable: Whether the record can be proxied by Cloudflare or not.
        :param bool proxied: Whether the record is receiving the performance and security benefits of Cloudflare.
        :param 'GetDnsRecordsResultSettingsArgs' settings: Settings for the DNS record.
        :param Sequence[str] tags: Custom tags for the DNS record. This field has no effect on DNS responses.
        :param str tags_modified_on: When the record tags were last modified. Omitted if there are no tags.
        :param float ttl: Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
        :param str type: Record type.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "comment_modified_on", comment_modified_on)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "proxiable", proxiable)
        pulumi.set(__self__, "proxied", proxied)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "tags_modified_on", tags_modified_on)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Comments or notes about the DNS record. This field has no effect on DNS responses.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="commentModifiedOn")
    def comment_modified_on(self) -> str:
        """
        When the record comment was last modified. Omitted if there is no comment.
        """
        return pulumi.get(self, "comment_modified_on")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the record was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def data(self) -> 'outputs.GetDnsRecordsResultDataResult':
        """
        Components of a CAA record.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> str:
        """
        Extra Cloudflare-specific information about the record.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the record was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        DNS record name (or @ for the zone apex) in Punycode.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def proxiable(self) -> bool:
        """
        Whether the record can be proxied by Cloudflare or not.
        """
        return pulumi.get(self, "proxiable")

    @property
    @pulumi.getter
    def proxied(self) -> bool:
        """
        Whether the record is receiving the performance and security benefits of Cloudflare.
        """
        return pulumi.get(self, "proxied")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetDnsRecordsResultSettingsResult':
        """
        Settings for the DNS record.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        Custom tags for the DNS record. This field has no effect on DNS responses.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tagsModifiedOn")
    def tags_modified_on(self) -> str:
        """
        When the record tags were last modified. Omitted if there are no tags.
        """
        return pulumi.get(self, "tags_modified_on")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDnsRecordsResultDataResult(dict):
    def __init__(__self__, *,
                 algorithm: float,
                 altitude: float,
                 certificate: str,
                 digest: str,
                 digest_type: float,
                 fingerprint: str,
                 flags: Any,
                 key_tag: float,
                 lat_degrees: float,
                 lat_direction: str,
                 lat_minutes: float,
                 lat_seconds: float,
                 long_degrees: float,
                 long_direction: str,
                 long_minutes: float,
                 long_seconds: float,
                 matching_type: float,
                 order: float,
                 port: float,
                 precision_horz: float,
                 precision_vert: float,
                 preference: float,
                 priority: float,
                 protocol: float,
                 public_key: str,
                 regex: str,
                 replacement: str,
                 selector: float,
                 service: str,
                 size: float,
                 tag: str,
                 target: str,
                 type: float,
                 usage: float,
                 value: str,
                 weight: float):
        """
        :param float algorithm: Algorithm.
        :param float altitude: Altitude of location in meters.
        :param str certificate: Certificate.
        :param str digest: Digest.
        :param float digest_type: Digest Type.
        :param str fingerprint: fingerprint.
        :param Any flags: Flags for the CAA record.
        :param float key_tag: Key Tag.
        :param float lat_degrees: Degrees of latitude.
        :param str lat_direction: Latitude direction.
        :param float lat_minutes: Minutes of latitude.
        :param float lat_seconds: Seconds of latitude.
        :param float long_degrees: Degrees of longitude.
        :param str long_direction: Longitude direction.
        :param float long_minutes: Minutes of longitude.
        :param float long_seconds: Seconds of longitude.
        :param float matching_type: Matching Type.
        :param float order: Order.
        :param float port: The port of the service.
        :param float precision_horz: Horizontal precision of location.
        :param float precision_vert: Vertical precision of location.
        :param float preference: Preference.
        :param float priority: priority.
        :param float protocol: Protocol.
        :param str public_key: Public Key.
        :param str regex: Regex.
        :param str replacement: Replacement.
        :param float selector: Selector.
        :param str service: Service.
        :param float size: Size of location in meters.
        :param str tag: Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        :param str target: target.
        :param float type: Type.
        :param float usage: Usage.
        :param str value: Value of the record. This field's semantics depend on the chosen tag.
        :param float weight: The record weight.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "altitude", altitude)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "digest_type", digest_type)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "key_tag", key_tag)
        pulumi.set(__self__, "lat_degrees", lat_degrees)
        pulumi.set(__self__, "lat_direction", lat_direction)
        pulumi.set(__self__, "lat_minutes", lat_minutes)
        pulumi.set(__self__, "lat_seconds", lat_seconds)
        pulumi.set(__self__, "long_degrees", long_degrees)
        pulumi.set(__self__, "long_direction", long_direction)
        pulumi.set(__self__, "long_minutes", long_minutes)
        pulumi.set(__self__, "long_seconds", long_seconds)
        pulumi.set(__self__, "matching_type", matching_type)
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "precision_horz", precision_horz)
        pulumi.set(__self__, "precision_vert", precision_vert)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "replacement", replacement)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "usage", usage)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> float:
        """
        Algorithm.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def altitude(self) -> float:
        """
        Altitude of location in meters.
        """
        return pulumi.get(self, "altitude")

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        Certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def digest(self) -> str:
        """
        Digest.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> float:
        """
        Digest Type.
        """
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        """
        fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def flags(self) -> Any:
        """
        Flags for the CAA record.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> float:
        """
        Key Tag.
        """
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> float:
        """
        Degrees of latitude.
        """
        return pulumi.get(self, "lat_degrees")

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> str:
        """
        Latitude direction.
        """
        return pulumi.get(self, "lat_direction")

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> float:
        """
        Minutes of latitude.
        """
        return pulumi.get(self, "lat_minutes")

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> float:
        """
        Seconds of latitude.
        """
        return pulumi.get(self, "lat_seconds")

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> float:
        """
        Degrees of longitude.
        """
        return pulumi.get(self, "long_degrees")

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> str:
        """
        Longitude direction.
        """
        return pulumi.get(self, "long_direction")

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> float:
        """
        Minutes of longitude.
        """
        return pulumi.get(self, "long_minutes")

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> float:
        """
        Seconds of longitude.
        """
        return pulumi.get(self, "long_seconds")

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> float:
        """
        Matching Type.
        """
        return pulumi.get(self, "matching_type")

    @property
    @pulumi.getter
    def order(self) -> float:
        """
        Order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> float:
        """
        Horizontal precision of location.
        """
        return pulumi.get(self, "precision_horz")

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> float:
        """
        Vertical precision of location.
        """
        return pulumi.get(self, "precision_vert")

    @property
    @pulumi.getter
    def preference(self) -> float:
        """
        Preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> float:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def regex(self) -> str:
        """
        Regex.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def replacement(self) -> str:
        """
        Replacement.
        """
        return pulumi.get(self, "replacement")

    @property
    @pulumi.getter
    def selector(self) -> float:
        """
        Selector.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        Size of location in meters.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        target.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> float:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> float:
        """
        Usage.
        """
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def weight(self) -> float:
        """
        The record weight.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetDnsRecordsResultSettingsResult(dict):
    def __init__(__self__, *,
                 flatten_cname: bool,
                 ipv4_only: bool,
                 ipv6_only: bool):
        """
        :param bool flatten_cname: If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        :param bool ipv4_only: When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        :param bool ipv6_only: When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        pulumi.set(__self__, "flatten_cname", flatten_cname)
        pulumi.set(__self__, "ipv4_only", ipv4_only)
        pulumi.set(__self__, "ipv6_only", ipv6_only)

    @property
    @pulumi.getter(name="flattenCname")
    def flatten_cname(self) -> bool:
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        return pulumi.get(self, "flatten_cname")

    @property
    @pulumi.getter(name="ipv4Only")
    def ipv4_only(self) -> bool:
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv4_only")

    @property
    @pulumi.getter(name="ipv6Only")
    def ipv6_only(self) -> bool:
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv6_only")


@pulumi.output_type
class GetDnsRecordsTagResult(dict):
    def __init__(__self__, *,
                 absent: Optional[str] = None,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 present: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str absent: Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        :param str contains: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        :param str endswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        :param str exact: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        :param str present: Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        :param str startswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def absent(self) -> Optional[str]:
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "absent")

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def present(self) -> Optional[str]:
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "present")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetDnsSettingsInternalViewFilterResult(dict):
    def __init__(__self__, *,
                 direction: str,
                 match: str,
                 name: Optional['outputs.GetDnsSettingsInternalViewFilterNameResult'] = None,
                 order: Optional[str] = None,
                 zone_id: Optional[str] = None,
                 zone_name: Optional[str] = None):
        """
        :param str direction: Direction to order DNS views in.
        :param str match: Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
        :param str order: Field to order DNS views by.
        :param str zone_id: A zone ID that exists in the zones list for the view.
        :param str zone_name: A zone name that exists in the zones list for the view.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction to order DNS views in.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def name(self) -> Optional['outputs.GetDnsSettingsInternalViewFilterNameResult']:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order DNS views by.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        A zone ID that exists in the zones list for the view.
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        A zone name that exists in the zones list for the view.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetDnsSettingsInternalViewFilterNameResult(dict):
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS view name.
        :param str endswith: Suffix of the DNS view name.
        :param str exact: Exact value of the DNS view name.
        :param str startswith: Prefix of the DNS view name.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS view name.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS view name.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS view name.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS view name.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsSettingsInternalViewsNameResult(dict):
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS view name.
        :param str endswith: Suffix of the DNS view name.
        :param str exact: Exact value of the DNS view name.
        :param str startswith: Prefix of the DNS view name.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS view name.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS view name.
        """
        return pulumi.get(self, "endswith")

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS view name.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS view name.
        """
        return pulumi.get(self, "startswith")


@pulumi.output_type
class GetDnsSettingsInternalViewsResultResult(dict):
    def __init__(__self__, *,
                 created_time: str,
                 id: str,
                 modified_time: str,
                 name: str,
                 zones: Sequence[str]):
        """
        :param str created_time: When the view was created.
        :param str id: Identifier
        :param str modified_time: When the view was last modified.
        :param str name: The name of the view.
        :param Sequence[str] zones: The list of zones linked to this view.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        When the view was created.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> str:
        """
        When the view was last modified.
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the view.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        The list of zones linked to this view.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetDnsSettingsZoneDefaultsResult(dict):
    def __init__(__self__, *,
                 flatten_all_cnames: bool,
                 foundation_dns: bool,
                 internal_dns: 'outputs.GetDnsSettingsZoneDefaultsInternalDnsResult',
                 multi_provider: bool,
                 nameservers: 'outputs.GetDnsSettingsZoneDefaultsNameserversResult',
                 ns_ttl: float,
                 secondary_overrides: bool,
                 soa: 'outputs.GetDnsSettingsZoneDefaultsSoaResult',
                 zone_mode: str):
        """
        :param bool flatten_all_cnames: Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        :param bool foundation_dns: Whether to enable Foundation DNS Advanced Nameservers on the zone.
        :param 'GetDnsSettingsZoneDefaultsInternalDnsArgs' internal_dns: Settings for this internal zone.
        :param bool multi_provider: Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        :param 'GetDnsSettingsZoneDefaultsNameserversArgs' nameservers: Settings determining the nameservers through which the zone should be available.
        :param float ns_ttl: The time to live (TTL) of the zone's nameserver (NS) records.
        :param bool secondary_overrides: Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        :param 'GetDnsSettingsZoneDefaultsSoaArgs' soa: Components of the zone's SOA record.
        :param str zone_mode: Whether the zone mode is a regular or CDN/DNS only zone.
        """
        pulumi.set(__self__, "flatten_all_cnames", flatten_all_cnames)
        pulumi.set(__self__, "foundation_dns", foundation_dns)
        pulumi.set(__self__, "internal_dns", internal_dns)
        pulumi.set(__self__, "multi_provider", multi_provider)
        pulumi.set(__self__, "nameservers", nameservers)
        pulumi.set(__self__, "ns_ttl", ns_ttl)
        pulumi.set(__self__, "secondary_overrides", secondary_overrides)
        pulumi.set(__self__, "soa", soa)
        pulumi.set(__self__, "zone_mode", zone_mode)

    @property
    @pulumi.getter(name="flattenAllCnames")
    def flatten_all_cnames(self) -> bool:
        """
        Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        """
        return pulumi.get(self, "flatten_all_cnames")

    @property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> bool:
        """
        Whether to enable Foundation DNS Advanced Nameservers on the zone.
        """
        return pulumi.get(self, "foundation_dns")

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> 'outputs.GetDnsSettingsZoneDefaultsInternalDnsResult':
        """
        Settings for this internal zone.
        """
        return pulumi.get(self, "internal_dns")

    @property
    @pulumi.getter(name="multiProvider")
    def multi_provider(self) -> bool:
        """
        Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        """
        return pulumi.get(self, "multi_provider")

    @property
    @pulumi.getter
    def nameservers(self) -> 'outputs.GetDnsSettingsZoneDefaultsNameserversResult':
        """
        Settings determining the nameservers through which the zone should be available.
        """
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter(name="nsTtl")
    def ns_ttl(self) -> float:
        """
        The time to live (TTL) of the zone's nameserver (NS) records.
        """
        return pulumi.get(self, "ns_ttl")

    @property
    @pulumi.getter(name="secondaryOverrides")
    def secondary_overrides(self) -> bool:
        """
        Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        """
        return pulumi.get(self, "secondary_overrides")

    @property
    @pulumi.getter
    def soa(self) -> 'outputs.GetDnsSettingsZoneDefaultsSoaResult':
        """
        Components of the zone's SOA record.
        """
        return pulumi.get(self, "soa")

    @property
    @pulumi.getter(name="zoneMode")
    def zone_mode(self) -> str:
        """
        Whether the zone mode is a regular or CDN/DNS only zone.
        """
        return pulumi.get(self, "zone_mode")


@pulumi.output_type
class GetDnsSettingsZoneDefaultsInternalDnsResult(dict):
    def __init__(__self__, *,
                 reference_zone_id: str):
        """
        :param str reference_zone_id: The ID of the zone to fallback to.
        """
        pulumi.set(__self__, "reference_zone_id", reference_zone_id)

    @property
    @pulumi.getter(name="referenceZoneId")
    def reference_zone_id(self) -> str:
        """
        The ID of the zone to fallback to.
        """
        return pulumi.get(self, "reference_zone_id")


@pulumi.output_type
class GetDnsSettingsZoneDefaultsNameserversResult(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Nameserver type
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Nameserver type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDnsSettingsZoneDefaultsSoaResult(dict):
    def __init__(__self__, *,
                 expire: float,
                 min_ttl: float,
                 mname: str,
                 refresh: float,
                 retry: float,
                 rname: str,
                 ttl: float):
        """
        :param float expire: Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        :param float min_ttl: The time to live (TTL) for negative caching of records within the zone.
        :param str mname: The primary nameserver, which may be used for outbound zone transfers.
        :param float refresh: Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        :param float retry: Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        :param str rname: The email address of the zone administrator, with the first label representing the local part of the email address.
        :param float ttl: The time to live (TTL) of the SOA record itself.
        """
        pulumi.set(__self__, "expire", expire)
        pulumi.set(__self__, "min_ttl", min_ttl)
        pulumi.set(__self__, "mname", mname)
        pulumi.set(__self__, "refresh", refresh)
        pulumi.set(__self__, "retry", retry)
        pulumi.set(__self__, "rname", rname)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def expire(self) -> float:
        """
        Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        """
        return pulumi.get(self, "expire")

    @property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> float:
        """
        The time to live (TTL) for negative caching of records within the zone.
        """
        return pulumi.get(self, "min_ttl")

    @property
    @pulumi.getter
    def mname(self) -> str:
        """
        The primary nameserver, which may be used for outbound zone transfers.
        """
        return pulumi.get(self, "mname")

    @property
    @pulumi.getter
    def refresh(self) -> float:
        """
        Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        """
        return pulumi.get(self, "refresh")

    @property
    @pulumi.getter
    def retry(self) -> float:
        """
        Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        """
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def rname(self) -> str:
        """
        The email address of the zone administrator, with the first label representing the local part of the email address.
        """
        return pulumi.get(self, "rname")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        The time to live (TTL) of the SOA record itself.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetDnsZoneTransfersAclsResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip_range: str,
                 name: str):
        """
        :param str ip_range: Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
        :param str name: The name of the acl.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_range", ip_range)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> str:
        """
        Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the acl.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDnsZoneTransfersPeersResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip: str,
                 ixfr_enable: bool,
                 name: str,
                 port: float,
                 tsig_id: str):
        """
        :param str ip: IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to.
        :param bool ixfr_enable: Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones.
        :param str name: The name of the peer.
        :param float port: DNS port of primary or secondary nameserver, depending on what zone this peer is linked to.
        :param str tsig_id: TSIG authentication will be used for zone transfer if configured.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ixfr_enable", ixfr_enable)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "tsig_id", tsig_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ixfrEnable")
    def ixfr_enable(self) -> bool:
        """
        Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones.
        """
        return pulumi.get(self, "ixfr_enable")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the peer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        DNS port of primary or secondary nameserver, depending on what zone this peer is linked to.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tsigId")
    def tsig_id(self) -> str:
        """
        TSIG authentication will be used for zone transfer if configured.
        """
        return pulumi.get(self, "tsig_id")


@pulumi.output_type
class GetDnsZoneTransfersTsigsResultResult(dict):
    def __init__(__self__, *,
                 algo: str,
                 id: str,
                 name: str,
                 secret: str):
        """
        :param str algo: TSIG algorithm.
        :param str name: TSIG key name.
        :param str secret: TSIG secret.
        """
        pulumi.set(__self__, "algo", algo)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def algo(self) -> str:
        """
        TSIG algorithm.
        """
        return pulumi.get(self, "algo")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        TSIG key name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        TSIG secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetEmailRoutingAddressFilterResult(dict):
    def __init__(__self__, *,
                 direction: str,
                 verified: bool):
        """
        :param str direction: Sorts results in an ascending or descending order.
        :param bool verified: Filter by verified destination addresses.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "verified", verified)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Sorts results in an ascending or descending order.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def verified(self) -> bool:
        """
        Filter by verified destination addresses.
        """
        return pulumi.get(self, "verified")


@pulumi.output_type
class GetEmailRoutingAddressesResultResult(dict):
    def __init__(__self__, *,
                 created: str,
                 email: str,
                 id: str,
                 modified: str,
                 tag: str,
                 verified: str):
        """
        :param str created: The date and time the destination address has been created.
        :param str email: The contact email address of the user.
        :param str id: Destination address identifier.
        :param str modified: The date and time the destination address was last modified.
        :param str tag: Destination address tag. (Deprecated, replaced by destination address identifier)
        :param str verified: The date and time the destination address has been verified. Null means not verified yet.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified", modified)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "verified", verified)

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The date and time the destination address has been created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Destination address identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def modified(self) -> str:
        """
        The date and time the destination address was last modified.
        """
        return pulumi.get(self, "modified")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Destination address tag. (Deprecated, replaced by destination address identifier)
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def verified(self) -> str:
        """
        The date and time the destination address has been verified. Null means not verified yet.
        """
        return pulumi.get(self, "verified")


@pulumi.output_type
class GetEmailRoutingCatchAllActionResult(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Type of action for catch-all rule.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of action for catch-all rule.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetEmailRoutingCatchAllMatcherResult(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Type of matcher. Default is 'all'.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of matcher. Default is 'all'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEmailRoutingDnsErrorResult(dict):
    def __init__(__self__, *,
                 code: int,
                 message: str):
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> int:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> str:
        return pulumi.get(self, "message")


@pulumi.output_type
class GetEmailRoutingDnsMessageResult(dict):
    def __init__(__self__, *,
                 code: int,
                 message: str):
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> int:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> str:
        return pulumi.get(self, "message")


@pulumi.output_type
class GetEmailRoutingDnsResultResult(dict):
    def __init__(__self__, *,
                 content: str,
                 errors: Sequence['outputs.GetEmailRoutingDnsResultErrorResult'],
                 name: str,
                 priority: float,
                 records: Sequence['outputs.GetEmailRoutingDnsResultRecordResult'],
                 ttl: float,
                 type: str):
        """
        :param str content: DNS record content.
        :param str name: DNS record name (or @ for the zone apex).
        :param float priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param float ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param str type: DNS record type.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "records", records)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.GetEmailRoutingDnsResultErrorResult']:
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def records(self) -> Sequence['outputs.GetEmailRoutingDnsResultRecordResult']:
        return pulumi.get(self, "records")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEmailRoutingDnsResultErrorResult(dict):
    def __init__(__self__, *,
                 code: str,
                 missing: 'outputs.GetEmailRoutingDnsResultErrorMissingResult'):
        """
        :param 'GetEmailRoutingDnsResultErrorMissingArgs' missing: List of records needed to enable an Email Routing zone.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "missing", missing)

    @property
    @pulumi.getter
    def code(self) -> str:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def missing(self) -> 'outputs.GetEmailRoutingDnsResultErrorMissingResult':
        """
        List of records needed to enable an Email Routing zone.
        """
        return pulumi.get(self, "missing")


@pulumi.output_type
class GetEmailRoutingDnsResultErrorMissingResult(dict):
    def __init__(__self__, *,
                 content: str,
                 name: str,
                 priority: float,
                 ttl: float,
                 type: str):
        """
        :param str content: DNS record content.
        :param str name: DNS record name (or @ for the zone apex).
        :param float priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param float ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param str type: DNS record type.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEmailRoutingDnsResultInfoResult(dict):
    def __init__(__self__, *,
                 count: float,
                 page: float,
                 per_page: float,
                 total_count: float):
        """
        :param float count: Total number of results for the requested service
        :param float page: Current page within paginated list of results
        :param float per_page: Number of results per page of results
        :param float total_count: Total results available without any search parameters
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "page", page)
        pulumi.set(__self__, "per_page", per_page)
        pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter
    def count(self) -> float:
        """
        Total number of results for the requested service
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def page(self) -> float:
        """
        Current page within paginated list of results
        """
        return pulumi.get(self, "page")

    @property
    @pulumi.getter(name="perPage")
    def per_page(self) -> float:
        """
        Number of results per page of results
        """
        return pulumi.get(self, "per_page")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> float:
        """
        Total results available without any search parameters
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetEmailRoutingDnsResultRecordResult(dict):
    def __init__(__self__, *,
                 content: str,
                 name: str,
                 priority: float,
                 ttl: float,
                 type: str):
        """
        :param str content: DNS record content.
        :param str name: DNS record name (or @ for the zone apex).
        :param float priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param float ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param str type: DNS record type.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEmailRoutingRuleActionResult(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Type of supported action.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of supported action.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetEmailRoutingRuleFilterResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Filter by enabled routing rules.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Filter by enabled routing rules.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetEmailRoutingRuleMatcherResult(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str,
                 value: str):
        """
        :param str field: Field for type matcher.
        :param str type: Type of matcher.
        :param str value: Value for matcher.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Field for type matcher.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of matcher.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for matcher.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetEmailRoutingRulesResultResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetEmailRoutingRulesResultActionResult'],
                 enabled: bool,
                 id: str,
                 matchers: Sequence['outputs.GetEmailRoutingRulesResultMatcherResult'],
                 name: str,
                 priority: float,
                 tag: str):
        """
        :param Sequence['GetEmailRoutingRulesResultActionArgs'] actions: List actions patterns.
        :param bool enabled: Routing rule status.
        :param str id: Routing rule identifier.
        :param Sequence['GetEmailRoutingRulesResultMatcherArgs'] matchers: Matching patterns to forward to your actions.
        :param str name: Routing rule name.
        :param float priority: Priority of the routing rule.
        :param str tag: Routing rule tag. (Deprecated, replaced by routing rule identifier)
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "matchers", matchers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetEmailRoutingRulesResultActionResult']:
        """
        List actions patterns.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Routing rule status.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Routing rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.GetEmailRoutingRulesResultMatcherResult']:
        """
        Matching patterns to forward to your actions.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Routing rule name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        Priority of the routing rule.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Routing rule tag. (Deprecated, replaced by routing rule identifier)
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetEmailRoutingRulesResultActionResult(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Type of supported action.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of supported action.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetEmailRoutingRulesResultMatcherResult(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str,
                 value: str):
        """
        :param str field: Field for type matcher.
        :param str type: Type of matcher.
        :param str value: Value for matcher.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Field for type matcher.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of matcher.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for matcher.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetEmailSecurityBlockSenderFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None,
                 pattern_type: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str direction: The sorting direction.
        :param str order: The field to sort by.
        :param str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if pattern_type is not None:
            pulumi.set(__self__, "pattern_type", pattern_type)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sorting direction.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field to sort by.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="patternType")
    def pattern_type(self) -> Optional[str]:
        return pulumi.get(self, "pattern_type")

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")


@pulumi.output_type
class GetEmailSecurityBlockSendersResultResult(dict):
    def __init__(__self__, *,
                 comments: str,
                 created_at: str,
                 id: int,
                 is_regex: bool,
                 last_modified: str,
                 pattern: str,
                 pattern_type: str):
        """
        :param int id: The unique identifier for the allow policy.
        """
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_regex", is_regex)
        pulumi.set(__self__, "last_modified", last_modified)
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "pattern_type", pattern_type)

    @property
    @pulumi.getter
    def comments(self) -> str:
        return pulumi.get(self, "comments")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The unique identifier for the allow policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isRegex")
    def is_regex(self) -> bool:
        return pulumi.get(self, "is_regex")

    @property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> str:
        return pulumi.get(self, "last_modified")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="patternType")
    def pattern_type(self) -> str:
        return pulumi.get(self, "pattern_type")


@pulumi.output_type
class GetEmailSecurityImpersonationRegistriesResultResult(dict):
    def __init__(__self__, *,
                 comments: str,
                 created_at: str,
                 directory_id: int,
                 directory_node_id: int,
                 email: str,
                 external_directory_node_id: str,
                 id: int,
                 is_email_regex: bool,
                 last_modified: str,
                 name: str,
                 provenance: str):
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "directory_id", directory_id)
        pulumi.set(__self__, "directory_node_id", directory_node_id)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "external_directory_node_id", external_directory_node_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_email_regex", is_email_regex)
        pulumi.set(__self__, "last_modified", last_modified)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provenance", provenance)

    @property
    @pulumi.getter
    def comments(self) -> str:
        return pulumi.get(self, "comments")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> int:
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter(name="directoryNodeId")
    def directory_node_id(self) -> int:
        return pulumi.get(self, "directory_node_id")

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="externalDirectoryNodeId")
    def external_directory_node_id(self) -> str:
        return pulumi.get(self, "external_directory_node_id")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEmailRegex")
    def is_email_regex(self) -> bool:
        return pulumi.get(self, "is_email_regex")

    @property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> str:
        return pulumi.get(self, "last_modified")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def provenance(self) -> str:
        return pulumi.get(self, "provenance")


@pulumi.output_type
class GetEmailSecurityImpersonationRegistryFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None,
                 provenance: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str direction: The sorting direction.
        :param str order: The field to sort by.
        :param str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sorting direction.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field to sort by.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def provenance(self) -> Optional[str]:
        return pulumi.get(self, "provenance")

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")


@pulumi.output_type
class GetEmailSecurityTrustedDomainsFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 is_recent: Optional[bool] = None,
                 is_similarity: Optional[bool] = None,
                 order: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str direction: The sorting direction.
        :param str order: The field to sort by.
        :param str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if is_recent is not None:
            pulumi.set(__self__, "is_recent", is_recent)
        if is_similarity is not None:
            pulumi.set(__self__, "is_similarity", is_similarity)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sorting direction.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="isRecent")
    def is_recent(self) -> Optional[bool]:
        return pulumi.get(self, "is_recent")

    @property
    @pulumi.getter(name="isSimilarity")
    def is_similarity(self) -> Optional[bool]:
        return pulumi.get(self, "is_similarity")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field to sort by.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")


@pulumi.output_type
class GetEmailSecurityTrustedDomainsListResultResult(dict):
    def __init__(__self__, *,
                 comments: str,
                 created_at: str,
                 id: int,
                 is_recent: bool,
                 is_regex: bool,
                 is_similarity: bool,
                 last_modified: str,
                 pattern: str):
        """
        :param int id: The unique identifier for the trusted domain.
        :param bool is_recent: Select to prevent recently registered domains from triggering a
               Suspicious or Malicious disposition.
        :param bool is_similarity: Select for partner or other approved domains that have similar
               spelling to your connected domains. Prevents listed domains from
               triggering a Spoof disposition.
        """
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_recent", is_recent)
        pulumi.set(__self__, "is_regex", is_regex)
        pulumi.set(__self__, "is_similarity", is_similarity)
        pulumi.set(__self__, "last_modified", last_modified)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def comments(self) -> str:
        return pulumi.get(self, "comments")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The unique identifier for the trusted domain.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isRecent")
    def is_recent(self) -> bool:
        """
        Select to prevent recently registered domains from triggering a
        Suspicious or Malicious disposition.
        """
        return pulumi.get(self, "is_recent")

    @property
    @pulumi.getter(name="isRegex")
    def is_regex(self) -> bool:
        return pulumi.get(self, "is_regex")

    @property
    @pulumi.getter(name="isSimilarity")
    def is_similarity(self) -> bool:
        """
        Select for partner or other approved domains that have similar
        spelling to your connected domains. Prevents listed domains from
        triggering a Spoof disposition.
        """
        return pulumi.get(self, "is_similarity")

    @property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> str:
        return pulumi.get(self, "last_modified")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        return pulumi.get(self, "pattern")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetFilterFilterResult(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 expression: Optional[str] = None,
                 id: Optional[str] = None,
                 paused: Optional[bool] = None,
                 ref: Optional[str] = None):
        """
        :param str description: A case-insensitive string to find in the description.
        :param str expression: A case-insensitive string to find in the expression.
        :param str id: The unique identifier of the filter.
        :param bool paused: When true, indicates that the filter is currently paused.
        :param str ref: The filter ref (a short reference tag) to search for. Must be an exact match.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A case-insensitive string to find in the description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        A case-insensitive string to find in the expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        The filter ref (a short reference tag) to search for. Must be an exact match.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetFiltersResultResult(dict):
    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 id: str,
                 paused: bool,
                 ref: str):
        """
        :param str description: An informative summary of the filter.
        :param str expression: The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        :param str id: The unique identifier of the filter.
        :param bool paused: When true, indicates that the filter is currently paused.
        :param str ref: A short reference tag. Allows you to select related filters.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative summary of the filter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        A short reference tag. Allows you to select related filters.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
<<<<<<< HEAD
class GetFirewallRuleFilterResult(dict):
    def __init__(__self__, *,
                 deleted: bool,
                 description: str,
                 expression: str,
                 id: str,
                 paused: bool,
                 ref: str):
        """
        :param bool deleted: When true, indicates that the firewall rule was deleted.
        :param str description: An informative summary of the filter.
        :param str expression: The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        :param str id: The unique identifier of the filter.
        :param bool paused: When true, indicates that the filter is currently paused.
        :param str ref: A short reference tag. Allows you to select related filters.
        """
        pulumi.set(__self__, "deleted", deleted)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def deleted(self) -> bool:
        """
        When true, indicates that the firewall rule was deleted.
        """
        return pulumi.get(self, "deleted")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative summary of the filter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        A short reference tag. Allows you to select related filters.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
=======
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetFirewallRulesResultResult(dict):
    def __init__(__self__, *,
                 action: str,
                 description: str,
                 filter: 'outputs.GetFirewallRulesResultFilterResult',
                 id: str,
                 paused: bool,
                 priority: float,
                 products: Sequence[str],
                 ref: str):
        """
        :param str action: The action to apply to a matched request. The `log` action is only available on an Enterprise plan.
        :param str description: An informative summary of the firewall rule.
        :param str id: The unique identifier of the firewall rule.
        :param bool paused: When true, indicates that the firewall rule is currently paused.
        :param float priority: The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority.
        :param str ref: A short reference tag. Allows you to select related firewall rules.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "products", products)
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to apply to a matched request. The `log` action is only available on an Enterprise plan.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative summary of the firewall rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.GetFirewallRulesResultFilterResult':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the firewall rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        When true, indicates that the firewall rule is currently paused.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def products(self) -> Sequence[str]:
        return pulumi.get(self, "products")

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        A short reference tag. Allows you to select related firewall rules.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class GetFirewallRulesResultFilterResult(dict):
    def __init__(__self__, *,
                 deleted: bool,
                 description: str,
                 expression: str,
                 id: str,
                 paused: bool,
                 ref: str):
        """
        :param bool deleted: When true, indicates that the firewall rule was deleted.
        :param str description: An informative summary of the filter.
        :param str expression: The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        :param str id: The unique identifier of the filter.
        :param bool paused: When true, indicates that the filter is currently paused.
        :param str ref: A short reference tag. Allows you to select related filters.
        """
        pulumi.set(__self__, "deleted", deleted)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def deleted(self) -> bool:
        """
        When true, indicates that the firewall rule was deleted.
        """
        return pulumi.get(self, "deleted")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative summary of the filter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        A short reference tag. Allows you to select related filters.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class GetHealthcheckHttpConfigResult(dict):
    def __init__(__self__, *,
                 allow_insecure: bool,
                 expected_body: str,
                 expected_codes: Sequence[str],
                 follow_redirects: bool,
                 header: Mapping[str, Sequence[str]],
                 method: str,
                 path: str,
                 port: int):
        """
        :param bool allow_insecure: Do not validate the certificate when the health check uses HTTPS.
        :param str expected_body: A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        :param Sequence[str] expected_codes: The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        :param bool follow_redirects: Follow redirects if the origin returns a 3xx status code.
        :param Mapping[str, Sequence[str]] header: The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        :param str method: The HTTP method to use for the health check.
        :param str path: The endpoint path to health check against.
        :param int port: Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "expected_body", expected_body)
        pulumi.set(__self__, "expected_codes", expected_codes)
        pulumi.set(__self__, "follow_redirects", follow_redirects)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        """
        Do not validate the certificate when the health check uses HTTPS.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="expectedBody")
    def expected_body(self) -> str:
        """
        A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        """
        return pulumi.get(self, "expected_body")

    @property
    @pulumi.getter(name="expectedCodes")
    def expected_codes(self) -> Sequence[str]:
        """
        The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        """
        return pulumi.get(self, "expected_codes")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> bool:
        """
        Follow redirects if the origin returns a 3xx status code.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def header(self) -> Mapping[str, Sequence[str]]:
        """
        The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use for the health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The endpoint path to health check against.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetHealthcheckTcpConfigResult(dict):
    def __init__(__self__, *,
                 method: str,
                 port: int):
        """
        :param str method: The TCP connection method to use for the health check.
        :param int port: Port number to connect to for the health check. Defaults to 80.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The TCP connection method to use for the health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number to connect to for the health check. Defaults to 80.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetHealthchecksResultResult(dict):
    def __init__(__self__, *,
                 address: str,
                 check_regions: Sequence[str],
                 consecutive_fails: int,
                 consecutive_successes: int,
                 created_on: str,
                 description: str,
                 failure_reason: str,
                 http_config: 'outputs.GetHealthchecksResultHttpConfigResult',
                 id: str,
                 interval: int,
                 modified_on: str,
                 name: str,
                 retries: int,
                 status: str,
                 suspended: bool,
                 tcp_config: 'outputs.GetHealthchecksResultTcpConfigResult',
                 timeout: int,
                 type: str):
        """
        :param str address: The hostname or IP address of the origin server to run health checks on.
        :param Sequence[str] check_regions: A list of regions from which to run health checks. Null means Cloudflare will pick a default region.
        :param int consecutive_fails: The number of consecutive fails required from a health check before changing the health to unhealthy.
        :param int consecutive_successes: The number of consecutive successes required from a health check before changing the health to healthy.
        :param str description: A human-readable description of the health check.
        :param str failure_reason: The current failure reason if status is unhealthy.
        :param 'GetHealthchecksResultHttpConfigArgs' http_config: Parameters specific to an HTTP or HTTPS health check.
        :param str id: Identifier
        :param int interval: The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations.
        :param str name: A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.
        :param int retries: The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
        :param str status: The current status of the origin server according to the health check.
        :param bool suspended: If suspended, no health checks are sent to the origin.
        :param 'GetHealthchecksResultTcpConfigArgs' tcp_config: Parameters specific to TCP health check.
        :param int timeout: The timeout (in seconds) before marking the health check as failed.
        :param str type: The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "check_regions", check_regions)
        pulumi.set(__self__, "consecutive_fails", consecutive_fails)
        pulumi.set(__self__, "consecutive_successes", consecutive_successes)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "failure_reason", failure_reason)
        pulumi.set(__self__, "http_config", http_config)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "suspended", suspended)
        pulumi.set(__self__, "tcp_config", tcp_config)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The hostname or IP address of the origin server to run health checks on.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="checkRegions")
    def check_regions(self) -> Sequence[str]:
        """
        A list of regions from which to run health checks. Null means Cloudflare will pick a default region.
        """
        return pulumi.get(self, "check_regions")

    @property
    @pulumi.getter(name="consecutiveFails")
    def consecutive_fails(self) -> int:
        """
        The number of consecutive fails required from a health check before changing the health to unhealthy.
        """
        return pulumi.get(self, "consecutive_fails")

    @property
    @pulumi.getter(name="consecutiveSuccesses")
    def consecutive_successes(self) -> int:
        """
        The number of consecutive successes required from a health check before changing the health to healthy.
        """
        return pulumi.get(self, "consecutive_successes")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A human-readable description of the health check.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> str:
        """
        The current failure reason if status is unhealthy.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="httpConfig")
    def http_config(self) -> 'outputs.GetHealthchecksResultHttpConfigResult':
        """
        Parameters specific to an HTTP or HTTPS health check.
        """
        return pulumi.get(self, "http_config")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current status of the origin server according to the health check.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def suspended(self) -> bool:
        """
        If suspended, no health checks are sent to the origin.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter(name="tcpConfig")
    def tcp_config(self) -> 'outputs.GetHealthchecksResultTcpConfigResult':
        """
        Parameters specific to TCP health check.
        """
        return pulumi.get(self, "tcp_config")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        The timeout (in seconds) before marking the health check as failed.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetHealthchecksResultHttpConfigResult(dict):
    def __init__(__self__, *,
                 allow_insecure: bool,
                 expected_body: str,
                 expected_codes: Sequence[str],
                 follow_redirects: bool,
                 header: Mapping[str, Sequence[str]],
                 method: str,
                 path: str,
                 port: int):
        """
        :param bool allow_insecure: Do not validate the certificate when the health check uses HTTPS.
        :param str expected_body: A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        :param Sequence[str] expected_codes: The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        :param bool follow_redirects: Follow redirects if the origin returns a 3xx status code.
        :param Mapping[str, Sequence[str]] header: The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        :param str method: The HTTP method to use for the health check.
        :param str path: The endpoint path to health check against.
        :param int port: Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "expected_body", expected_body)
        pulumi.set(__self__, "expected_codes", expected_codes)
        pulumi.set(__self__, "follow_redirects", follow_redirects)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        """
        Do not validate the certificate when the health check uses HTTPS.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="expectedBody")
    def expected_body(self) -> str:
        """
        A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        """
        return pulumi.get(self, "expected_body")

    @property
    @pulumi.getter(name="expectedCodes")
    def expected_codes(self) -> Sequence[str]:
        """
        The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        """
        return pulumi.get(self, "expected_codes")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> bool:
        """
        Follow redirects if the origin returns a 3xx status code.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def header(self) -> Mapping[str, Sequence[str]]:
        """
        The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use for the health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The endpoint path to health check against.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetHealthchecksResultTcpConfigResult(dict):
    def __init__(__self__, *,
                 method: str,
                 port: int):
        """
        :param str method: The TCP connection method to use for the health check.
        :param int port: Port number to connect to for the health check. Defaults to 80.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The TCP connection method to use for the health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number to connect to for the health check. Defaults to 80.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetHyperdriveConfigCachingResult(dict):
    def __init__(__self__, *,
                 disabled: bool,
                 max_age: int,
                 stale_while_revalidate: int):
        """
        :param bool disabled: When set to true, disables the caching of SQL responses. (Default: false)
        :param int max_age: When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        :param int stale_while_revalidate: When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "stale_while_revalidate", stale_while_revalidate)

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        When set to true, disables the caching of SQL responses. (Default: false)
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        """
        When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="staleWhileRevalidate")
    def stale_while_revalidate(self) -> int:
        """
        When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
        return pulumi.get(self, "stale_while_revalidate")


@pulumi.output_type
class GetHyperdriveConfigOriginResult(dict):
    def __init__(__self__, *,
                 access_client_id: str,
                 access_client_secret: str,
                 database: str,
                 host: str,
                 password: str,
                 port: int,
                 scheme: str,
                 user: str):
        """
        :param str access_client_id: The Client ID of the Access token to use when connecting to the origin database.
        :param str access_client_secret: The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        :param str database: The name of your origin database.
        :param str host: The host (hostname or IP) of your origin database.
        :param str password: The password required to access your origin database. This value is write-only and never returned by the API.
        :param int port: The port (default: 5432 for Postgres) of your origin database.
        :param str scheme: Specifies the URL scheme used to connect to your origin database.
        :param str user: The user of your origin database.
        """
        pulumi.set(__self__, "access_client_id", access_client_id)
        pulumi.set(__self__, "access_client_secret", access_client_secret)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> str:
        """
        The Client ID of the Access token to use when connecting to the origin database.
        """
        return pulumi.get(self, "access_client_id")

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> str:
        """
        The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        """
        return pulumi.get(self, "access_client_secret")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of your origin database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host (hostname or IP) of your origin database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password required to access your origin database. This value is write-only and never returned by the API.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port (default: 5432 for Postgres) of your origin database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        Specifies the URL scheme used to connect to your origin database.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The user of your origin database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetHyperdriveConfigsResultResult(dict):
    def __init__(__self__, *,
                 caching: 'outputs.GetHyperdriveConfigsResultCachingResult',
                 created_on: str,
                 id: str,
                 modified_on: str,
                 name: str,
                 origin: 'outputs.GetHyperdriveConfigsResultOriginResult'):
        """
        :param str created_on: When the Hyperdrive configuration was created.
        :param str id: Identifier
        :param str modified_on: When the Hyperdrive configuration was last modified.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "origin", origin)

    @property
    @pulumi.getter
    def caching(self) -> 'outputs.GetHyperdriveConfigsResultCachingResult':
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the Hyperdrive configuration was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the Hyperdrive configuration was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def origin(self) -> 'outputs.GetHyperdriveConfigsResultOriginResult':
        return pulumi.get(self, "origin")


@pulumi.output_type
class GetHyperdriveConfigsResultCachingResult(dict):
    def __init__(__self__, *,
                 disabled: bool,
                 max_age: int,
                 stale_while_revalidate: int):
        """
        :param bool disabled: When set to true, disables the caching of SQL responses. (Default: false)
        :param int max_age: When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        :param int stale_while_revalidate: When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "stale_while_revalidate", stale_while_revalidate)

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        When set to true, disables the caching of SQL responses. (Default: false)
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        """
        When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="staleWhileRevalidate")
    def stale_while_revalidate(self) -> int:
        """
        When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
        return pulumi.get(self, "stale_while_revalidate")


@pulumi.output_type
class GetHyperdriveConfigsResultOriginResult(dict):
    def __init__(__self__, *,
                 access_client_id: str,
                 access_client_secret: str,
                 database: str,
                 host: str,
                 password: str,
                 port: int,
                 scheme: str,
                 user: str):
        """
        :param str access_client_id: The Client ID of the Access token to use when connecting to the origin database.
        :param str access_client_secret: The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        :param str database: The name of your origin database.
        :param str host: The host (hostname or IP) of your origin database.
        :param str password: The password required to access your origin database. This value is write-only and never returned by the API.
        :param int port: The port (default: 5432 for Postgres) of your origin database.
        :param str scheme: Specifies the URL scheme used to connect to your origin database.
        :param str user: The user of your origin database.
        """
        pulumi.set(__self__, "access_client_id", access_client_id)
        pulumi.set(__self__, "access_client_secret", access_client_secret)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> str:
        """
        The Client ID of the Access token to use when connecting to the origin database.
        """
        return pulumi.get(self, "access_client_id")

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> str:
        """
        The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        """
        return pulumi.get(self, "access_client_secret")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of your origin database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host (hostname or IP) of your origin database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password required to access your origin database. This value is write-only and never returned by the API.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port (default: 5432 for Postgres) of your origin database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        Specifies the URL scheme used to connect to your origin database.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The user of your origin database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetImageVariantVariantResult(dict):
    def __init__(__self__, *,
                 id: str,
                 never_require_signed_urls: bool,
                 options: 'outputs.GetImageVariantVariantOptionsResult'):
        """
        :param bool never_require_signed_urls: Indicates whether the variant can access an image without a signature, regardless of image access control.
        :param 'GetImageVariantVariantOptionsArgs' options: Allows you to define image resizing sizes for different use cases.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "never_require_signed_urls", never_require_signed_urls)
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="neverRequireSignedUrls")
    def never_require_signed_urls(self) -> bool:
        """
        Indicates whether the variant can access an image without a signature, regardless of image access control.
        """
        return pulumi.get(self, "never_require_signed_urls")

    @property
    @pulumi.getter
    def options(self) -> 'outputs.GetImageVariantVariantOptionsResult':
        """
        Allows you to define image resizing sizes for different use cases.
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class GetImageVariantVariantOptionsResult(dict):
    def __init__(__self__, *,
                 fit: str,
                 height: float,
                 metadata: str,
                 width: float):
        """
        :param str fit: The fit property describes how the width and height dimensions should be interpreted.
        :param float height: Maximum height in image pixels.
        :param str metadata: What EXIF data should be preserved in the output image.
        :param float width: Maximum width in image pixels.
        """
        pulumi.set(__self__, "fit", fit)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def fit(self) -> str:
        """
        The fit property describes how the width and height dimensions should be interpreted.
        """
        return pulumi.get(self, "fit")

    @property
    @pulumi.getter
    def height(self) -> float:
        """
        Maximum height in image pixels.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        What EXIF data should be preserved in the output image.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def width(self) -> float:
        """
        Maximum width in image pixels.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetImagesResultResult(dict):
    def __init__(__self__, *,
                 images: Sequence['outputs.GetImagesResultImageResult']):
        pulumi.set(__self__, "images", images)

    @property
    @pulumi.getter
    def images(self) -> Sequence['outputs.GetImagesResultImageResult']:
        return pulumi.get(self, "images")


@pulumi.output_type
class GetImagesResultImageResult(dict):
    def __init__(__self__, *,
                 filename: str,
                 id: str,
                 meta: str,
                 require_signed_urls: bool,
                 uploaded: str,
                 variants: Sequence[str]):
        """
        :param str filename: Image file name.
        :param str id: Image unique identifier.
        :param str meta: User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes.
        :param bool require_signed_urls: Indicates whether the image can be a accessed only using it's UID. If set to true, a signed token needs to be generated with a signing key to view the image.
        :param str uploaded: When the media item was uploaded.
        :param Sequence[str] variants: Object specifying available variants for an image.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "require_signed_urls", require_signed_urls)
        pulumi.set(__self__, "uploaded", uploaded)
        pulumi.set(__self__, "variants", variants)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        Image file name.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Image unique identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> str:
        """
        User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter(name="requireSignedUrls")
    def require_signed_urls(self) -> bool:
        """
        Indicates whether the image can be a accessed only using it's UID. If set to true, a signed token needs to be generated with a signing key to view the image.
        """
        return pulumi.get(self, "require_signed_urls")

    @property
    @pulumi.getter
    def uploaded(self) -> str:
        """
        When the media item was uploaded.
        """
        return pulumi.get(self, "uploaded")

    @property
    @pulumi.getter
    def variants(self) -> Sequence[str]:
        """
        Object specifying available variants for an image.
        """
        return pulumi.get(self, "variants")


@pulumi.output_type
class GetKeylessCertificateTunnelResult(dict):
    def __init__(__self__, *,
                 private_ip: str,
                 vnet_id: str):
        """
        :param str private_ip: Private IP of the Key Server Host
        :param str vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetKeylessCertificatesResultResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 enabled: bool,
                 host: str,
                 id: str,
                 modified_on: str,
                 name: str,
                 permissions: Sequence[str],
                 port: float,
                 status: str,
                 tunnel: 'outputs.GetKeylessCertificatesResultTunnelResult'):
        """
        :param str created_on: When the Keyless SSL was created.
        :param bool enabled: Whether or not the Keyless SSL is on or off.
        :param str host: The keyless SSL name.
        :param str id: Keyless certificate identifier tag.
        :param str modified_on: When the Keyless SSL was last modified.
        :param str name: The keyless SSL name.
        :param Sequence[str] permissions: Available permissions for the Keyless SSL for the current user requesting the item.
        :param float port: The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        :param str status: Status of the Keyless SSL.
        :param 'GetKeylessCertificatesResultTunnelArgs' tunnel: Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tunnel", tunnel)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the Keyless SSL was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not the Keyless SSL is on or off.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Keyless certificate identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the Keyless SSL was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        """
        Available permissions for the Keyless SSL for the current user requesting the item.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Keyless SSL.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tunnel(self) -> 'outputs.GetKeylessCertificatesResultTunnelResult':
        """
        Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        return pulumi.get(self, "tunnel")


@pulumi.output_type
class GetKeylessCertificatesResultTunnelResult(dict):
    def __init__(__self__, *,
                 private_ip: str,
                 vnet_id: str):
        """
        :param str private_ip: Private IP of the Key Server Host
        :param str vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetLeakedCredentialCheckRulesResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 password: str,
                 username: str):
        """
        :param str id: The unique ID for this custom detection
        :param str password: The ruleset expression to use in matching the password in a request
        :param str username: The ruleset expression to use in matching the username in a request
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID for this custom detection
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The ruleset expression to use in matching the password in a request
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The ruleset expression to use in matching the username in a request
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetListItemHostnameResult(dict):
    def __init__(__self__, *,
                 url_hostname: str):
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> str:
        return pulumi.get(self, "url_hostname")


@pulumi.output_type
class GetListItemRedirectResult(dict):
    def __init__(__self__, *,
                 include_subdomains: bool,
                 preserve_path_suffix: bool,
                 preserve_query_string: bool,
                 source_url: str,
                 status_code: int,
                 subpath_matching: bool,
                 target_url: str):
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "subpath_matching", subpath_matching)
        pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> bool:
        return pulumi.get(self, "preserve_path_suffix")

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> bool:
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> str:
        return pulumi.get(self, "source_url")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> bool:
        return pulumi.get(self, "subpath_matching")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        return pulumi.get(self, "target_url")


@pulumi.output_type
class GetListItemsResultResult(dict):
    def __init__(__self__, *,
                 asn: int,
                 comment: str,
                 created_on: str,
                 hostname: 'outputs.GetListItemsResultHostnameResult',
                 id: str,
                 ip: str,
                 modified_on: str,
                 redirect: 'outputs.GetListItemsResultRedirectResult'):
        """
        :param int asn: A non-negative 32 bit integer
        :param str comment: An informative summary of the list item.
        :param str created_on: The RFC 3339 timestamp of when the item was created.
        :param 'GetListItemsResultHostnameArgs' hostname: Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
        :param str id: The unique ID of the list.
        :param str ip: An IPv4 address, an IPv4 CIDR, or an IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64.
        :param str modified_on: The RFC 3339 timestamp of when the item was last modified.
        :param 'GetListItemsResultRedirectArgs' redirect: The definition of the redirect.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "redirect", redirect)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        A non-negative 32 bit integer
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        An informative summary of the list item.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The RFC 3339 timestamp of when the item was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def hostname(self) -> 'outputs.GetListItemsResultHostnameResult':
        """
        Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the list.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 address, an IPv4 CIDR, or an IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The RFC 3339 timestamp of when the item was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def redirect(self) -> 'outputs.GetListItemsResultRedirectResult':
        """
        The definition of the redirect.
        """
        return pulumi.get(self, "redirect")


@pulumi.output_type
class GetListItemsResultHostnameResult(dict):
    def __init__(__self__, *,
                 url_hostname: str):
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> str:
        return pulumi.get(self, "url_hostname")


@pulumi.output_type
class GetListItemsResultRedirectResult(dict):
    def __init__(__self__, *,
                 include_subdomains: bool,
                 preserve_path_suffix: bool,
                 preserve_query_string: bool,
                 source_url: str,
                 status_code: int,
                 subpath_matching: bool,
                 target_url: str):
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "subpath_matching", subpath_matching)
        pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> bool:
        return pulumi.get(self, "preserve_path_suffix")

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> bool:
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> str:
        return pulumi.get(self, "source_url")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> bool:
        return pulumi.get(self, "subpath_matching")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        return pulumi.get(self, "target_url")


@pulumi.output_type
class GetListsResultResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 description: str,
                 id: str,
                 kind: str,
                 modified_on: str,
                 name: str,
                 num_items: float,
                 num_referencing_filters: float):
        """
        :param str created_on: The RFC 3339 timestamp of when the list was created.
        :param str description: An informative summary of the list.
        :param str id: The unique ID of the list.
        :param str kind: The type of the list. Each type supports specific list items (IP addresses, ASNs, hostnames or redirects).
        :param str modified_on: The RFC 3339 timestamp of when the list was last modified.
        :param str name: An informative name for the list. Use this name in filter and rule expressions.
        :param float num_items: The number of items in the list.
        :param float num_referencing_filters: The number of [filters](https://www.terraform.io/operations/filters-list-filters) referencing the list.
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "num_items", num_items)
        pulumi.set(__self__, "num_referencing_filters", num_referencing_filters)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The RFC 3339 timestamp of when the list was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative summary of the list.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the list.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type of the list. Each type supports specific list items (IP addresses, ASNs, hostnames or redirects).
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The RFC 3339 timestamp of when the list was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        An informative name for the list. Use this name in filter and rule expressions.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numItems")
    def num_items(self) -> float:
        """
        The number of items in the list.
        """
        return pulumi.get(self, "num_items")

    @property
    @pulumi.getter(name="numReferencingFilters")
    def num_referencing_filters(self) -> float:
        """
        The number of [filters](https://www.terraform.io/operations/filters-list-filters) referencing the list.
        """
        return pulumi.get(self, "num_referencing_filters")


@pulumi.output_type
class GetLoadBalancerAdaptiveRoutingResult(dict):
    def __init__(__self__, *,
                 failover_across_pools: bool):
        """
        :param bool failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> bool:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class GetLoadBalancerLocationStrategyResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 prefer_ecs: str):
        """
        :param str mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param str prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> str:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class GetLoadBalancerMonitorsResultResult(dict):
    def __init__(__self__, *,
                 allow_insecure: bool,
                 consecutive_down: int,
                 consecutive_up: int,
                 created_on: str,
                 description: str,
                 expected_body: str,
                 expected_codes: str,
                 follow_redirects: bool,
                 header: Mapping[str, Sequence[str]],
                 id: str,
                 interval: int,
                 method: str,
                 modified_on: str,
                 path: str,
                 port: int,
                 probe_zone: str,
                 retries: int,
                 timeout: int,
                 type: str):
        """
        :param bool allow_insecure: Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
        :param int consecutive_down: To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
        :param int consecutive_up: To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
        :param str description: Object description.
        :param str expected_body: A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
        :param str expected_codes: The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
        :param bool follow_redirects: Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
        :param Mapping[str, Sequence[str]] header: The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
        :param int interval: The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
        :param str method: The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
        :param str path: The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
        :param int port: The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
        :param str probe_zone: Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
        :param int retries: The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
        :param int timeout: The timeout (in seconds) before marking the health check as failed.
        :param str type: The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
        """
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "consecutive_down", consecutive_down)
        pulumi.set(__self__, "consecutive_up", consecutive_up)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expected_body", expected_body)
        pulumi.set(__self__, "expected_codes", expected_codes)
        pulumi.set(__self__, "follow_redirects", follow_redirects)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "probe_zone", probe_zone)
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        """
        Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="consecutiveDown")
    def consecutive_down(self) -> int:
        """
        To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
        """
        return pulumi.get(self, "consecutive_down")

    @property
    @pulumi.getter(name="consecutiveUp")
    def consecutive_up(self) -> int:
        """
        To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
        """
        return pulumi.get(self, "consecutive_up")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Object description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expectedBody")
    def expected_body(self) -> str:
        """
        A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
        """
        return pulumi.get(self, "expected_body")

    @property
    @pulumi.getter(name="expectedCodes")
    def expected_codes(self) -> str:
        """
        The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
        """
        return pulumi.get(self, "expected_codes")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> bool:
        """
        Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def header(self) -> Mapping[str, Sequence[str]]:
        """
        The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="probeZone")
    def probe_zone(self) -> str:
        """
        Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
        """
        return pulumi.get(self, "probe_zone")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        The timeout (in seconds) before marking the health check as failed.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLoadBalancerPoolFilterResult(dict):
    def __init__(__self__, *,
                 monitor: Optional[str] = None):
        """
        :param str monitor: The ID of the Monitor to use for checking the health of origins within this pool.
        """
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)

    @property
    @pulumi.getter
    def monitor(self) -> Optional[str]:
        """
        The ID of the Monitor to use for checking the health of origins within this pool.
        """
        return pulumi.get(self, "monitor")


@pulumi.output_type
class GetLoadBalancerPoolLoadSheddingResult(dict):
    def __init__(__self__, *,
                 default_percent: float,
                 default_policy: str,
                 session_percent: float,
                 session_policy: str):
        """
        :param float default_percent: The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        :param str default_policy: The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        :param float session_percent: The percent of existing sessions to shed from the pool, according to the session policy.
        :param str session_policy: Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
        pulumi.set(__self__, "default_percent", default_percent)
        pulumi.set(__self__, "default_policy", default_policy)
        pulumi.set(__self__, "session_percent", session_percent)
        pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> float:
        """
        The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        """
        return pulumi.get(self, "default_percent")

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> str:
        """
        The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        """
        return pulumi.get(self, "default_policy")

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> float:
        """
        The percent of existing sessions to shed from the pool, according to the session policy.
        """
        return pulumi.get(self, "session_percent")

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> str:
        """
        Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
        return pulumi.get(self, "session_policy")


@pulumi.output_type
class GetLoadBalancerPoolNotificationFilterResult(dict):
    def __init__(__self__, *,
                 origin: 'outputs.GetLoadBalancerPoolNotificationFilterOriginResult',
                 pool: 'outputs.GetLoadBalancerPoolNotificationFilterPoolResult'):
        """
        :param 'GetLoadBalancerPoolNotificationFilterOriginArgs' origin: Filter options for a particular resource type (pool or origin). Use null to reset.
        :param 'GetLoadBalancerPoolNotificationFilterPoolArgs' pool: Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "pool", pool)

    @property
    @pulumi.getter
    def origin(self) -> 'outputs.GetLoadBalancerPoolNotificationFilterOriginResult':
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def pool(self) -> 'outputs.GetLoadBalancerPoolNotificationFilterPoolResult':
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "pool")


@pulumi.output_type
class GetLoadBalancerPoolNotificationFilterOriginResult(dict):
    def __init__(__self__, *,
                 disable: bool,
                 healthy: bool):
        """
        :param bool disable: If set true, disable notifications for this type of resource (pool or origin).
        :param bool healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "healthy", healthy)

    @property
    @pulumi.getter
    def disable(self) -> bool:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")


@pulumi.output_type
class GetLoadBalancerPoolNotificationFilterPoolResult(dict):
    def __init__(__self__, *,
                 disable: bool,
                 healthy: bool):
        """
        :param bool disable: If set true, disable notifications for this type of resource (pool or origin).
        :param bool healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "healthy", healthy)

    @property
    @pulumi.getter
    def disable(self) -> bool:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")


@pulumi.output_type
class GetLoadBalancerPoolOriginResult(dict):
    def __init__(__self__, *,
                 address: str,
                 disabled_at: str,
                 enabled: bool,
                 header: 'outputs.GetLoadBalancerPoolOriginHeaderResult',
                 name: str,
                 virtual_network_id: str,
                 weight: float):
        """
        :param str address: The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        :param str disabled_at: This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        :param bool enabled: Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        :param 'GetLoadBalancerPoolOriginHeaderArgs' header: The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        :param str name: A human-identifiable name for the origin.
        :param str virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param float weight: The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "disabled_at", disabled_at)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="disabledAt")
    def disabled_at(self) -> str:
        """
        This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        """
        return pulumi.get(self, "disabled_at")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def header(self) -> 'outputs.GetLoadBalancerPoolOriginHeaderResult':
        """
        The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> str:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @property
    @pulumi.getter
    def weight(self) -> float:
        """
        The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetLoadBalancerPoolOriginHeaderResult(dict):
    def __init__(__self__, *,
                 hosts: Sequence[str]):
        """
        :param Sequence[str] hosts: The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        pulumi.set(__self__, "hosts", hosts)

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        return pulumi.get(self, "hosts")


@pulumi.output_type
class GetLoadBalancerPoolOriginSteeringResult(dict):
    def __init__(__self__, *,
                 policy: str):
        """
        :param str policy: The type of origin steering policy to use.
        """
        pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        The type of origin steering policy to use.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class GetLoadBalancerPoolsResultResult(dict):
    def __init__(__self__, *,
                 check_regions: Sequence[str],
                 created_on: str,
                 description: str,
                 disabled_at: str,
                 enabled: bool,
                 id: str,
                 latitude: float,
                 load_shedding: 'outputs.GetLoadBalancerPoolsResultLoadSheddingResult',
                 longitude: float,
                 minimum_origins: int,
                 modified_on: str,
                 monitor: str,
                 name: str,
                 networks: Sequence[str],
                 notification_email: str,
                 notification_filter: 'outputs.GetLoadBalancerPoolsResultNotificationFilterResult',
                 origin_steering: 'outputs.GetLoadBalancerPoolsResultOriginSteeringResult',
                 origins: Sequence['outputs.GetLoadBalancerPoolsResultOriginResult']):
        """
        :param Sequence[str] check_regions: A list of regions from which to run health checks. Null means every Cloudflare data center.
        :param str description: A human-readable description of the pool.
        :param str disabled_at: This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at.
        :param bool enabled: Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any).
        :param float latitude: The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set.
        :param 'GetLoadBalancerPoolsResultLoadSheddingArgs' load_shedding: Configures load shedding policies and percentages for the pool.
        :param float longitude: The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set.
        :param int minimum_origins: The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool.
        :param str monitor: The ID of the Monitor to use for checking the health of origins within this pool.
        :param str name: A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed.
        :param Sequence[str] networks: List of networks where Load Balancer or Pool is enabled.
        :param str notification_email: This field is now deprecated. It has been moved to Cloudflare's Centralized Notification service https://developers.cloudflare.com/fundamentals/notifications/. The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
        :param 'GetLoadBalancerPoolsResultNotificationFilterArgs' notification_filter: Filter pool and origin health notifications by resource type or health status. Use null to reset.
        :param 'GetLoadBalancerPoolsResultOriginSteeringArgs' origin_steering: Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity.
        :param Sequence['GetLoadBalancerPoolsResultOriginArgs'] origins: The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
        """
        pulumi.set(__self__, "check_regions", check_regions)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disabled_at", disabled_at)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "load_shedding", load_shedding)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "minimum_origins", minimum_origins)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "monitor", monitor)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "notification_email", notification_email)
        pulumi.set(__self__, "notification_filter", notification_filter)
        pulumi.set(__self__, "origin_steering", origin_steering)
        pulumi.set(__self__, "origins", origins)

    @property
    @pulumi.getter(name="checkRegions")
    def check_regions(self) -> Sequence[str]:
        """
        A list of regions from which to run health checks. Null means every Cloudflare data center.
        """
        return pulumi.get(self, "check_regions")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A human-readable description of the pool.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disabledAt")
    def disabled_at(self) -> str:
        """
        This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at.
        """
        return pulumi.get(self, "disabled_at")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def latitude(self) -> float:
        """
        The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set.
        """
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter(name="loadShedding")
    def load_shedding(self) -> 'outputs.GetLoadBalancerPoolsResultLoadSheddingResult':
        """
        Configures load shedding policies and percentages for the pool.
        """
        return pulumi.get(self, "load_shedding")

    @property
    @pulumi.getter
    def longitude(self) -> float:
        """
        The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set.
        """
        return pulumi.get(self, "longitude")

    @property
    @pulumi.getter(name="minimumOrigins")
    def minimum_origins(self) -> int:
        """
        The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool.
        """
        return pulumi.get(self, "minimum_origins")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def monitor(self) -> str:
        """
        The ID of the Monitor to use for checking the health of origins within this pool.
        """
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def networks(self) -> Sequence[str]:
        """
        List of networks where Load Balancer or Pool is enabled.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="notificationEmail")
    def notification_email(self) -> str:
        """
        This field is now deprecated. It has been moved to Cloudflare's Centralized Notification service https://developers.cloudflare.com/fundamentals/notifications/. The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
        """
        return pulumi.get(self, "notification_email")

    @property
    @pulumi.getter(name="notificationFilter")
    def notification_filter(self) -> 'outputs.GetLoadBalancerPoolsResultNotificationFilterResult':
        """
        Filter pool and origin health notifications by resource type or health status. Use null to reset.
        """
        return pulumi.get(self, "notification_filter")

    @property
    @pulumi.getter(name="originSteering")
    def origin_steering(self) -> 'outputs.GetLoadBalancerPoolsResultOriginSteeringResult':
        """
        Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity.
        """
        return pulumi.get(self, "origin_steering")

    @property
    @pulumi.getter
    def origins(self) -> Sequence['outputs.GetLoadBalancerPoolsResultOriginResult']:
        """
        The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
        """
        return pulumi.get(self, "origins")


@pulumi.output_type
class GetLoadBalancerPoolsResultLoadSheddingResult(dict):
    def __init__(__self__, *,
                 default_percent: float,
                 default_policy: str,
                 session_percent: float,
                 session_policy: str):
        """
        :param float default_percent: The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        :param str default_policy: The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        :param float session_percent: The percent of existing sessions to shed from the pool, according to the session policy.
        :param str session_policy: Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
        pulumi.set(__self__, "default_percent", default_percent)
        pulumi.set(__self__, "default_policy", default_policy)
        pulumi.set(__self__, "session_percent", session_percent)
        pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> float:
        """
        The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        """
        return pulumi.get(self, "default_percent")

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> str:
        """
        The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        """
        return pulumi.get(self, "default_policy")

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> float:
        """
        The percent of existing sessions to shed from the pool, according to the session policy.
        """
        return pulumi.get(self, "session_percent")

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> str:
        """
        Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
        return pulumi.get(self, "session_policy")


@pulumi.output_type
class GetLoadBalancerPoolsResultNotificationFilterResult(dict):
    def __init__(__self__, *,
                 origin: 'outputs.GetLoadBalancerPoolsResultNotificationFilterOriginResult',
                 pool: 'outputs.GetLoadBalancerPoolsResultNotificationFilterPoolResult'):
        """
        :param 'GetLoadBalancerPoolsResultNotificationFilterOriginArgs' origin: Filter options for a particular resource type (pool or origin). Use null to reset.
        :param 'GetLoadBalancerPoolsResultNotificationFilterPoolArgs' pool: Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "pool", pool)

    @property
    @pulumi.getter
    def origin(self) -> 'outputs.GetLoadBalancerPoolsResultNotificationFilterOriginResult':
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def pool(self) -> 'outputs.GetLoadBalancerPoolsResultNotificationFilterPoolResult':
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "pool")


@pulumi.output_type
class GetLoadBalancerPoolsResultNotificationFilterOriginResult(dict):
    def __init__(__self__, *,
                 disable: bool,
                 healthy: bool):
        """
        :param bool disable: If set true, disable notifications for this type of resource (pool or origin).
        :param bool healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "healthy", healthy)

    @property
    @pulumi.getter
    def disable(self) -> bool:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")


@pulumi.output_type
class GetLoadBalancerPoolsResultNotificationFilterPoolResult(dict):
    def __init__(__self__, *,
                 disable: bool,
                 healthy: bool):
        """
        :param bool disable: If set true, disable notifications for this type of resource (pool or origin).
        :param bool healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "healthy", healthy)

    @property
    @pulumi.getter
    def disable(self) -> bool:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")


@pulumi.output_type
class GetLoadBalancerPoolsResultOriginResult(dict):
    def __init__(__self__, *,
                 address: str,
                 disabled_at: str,
                 enabled: bool,
                 header: 'outputs.GetLoadBalancerPoolsResultOriginHeaderResult',
                 name: str,
                 virtual_network_id: str,
                 weight: float):
        """
        :param str address: The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        :param str disabled_at: This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        :param bool enabled: Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        :param 'GetLoadBalancerPoolsResultOriginHeaderArgs' header: The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        :param str name: A human-identifiable name for the origin.
        :param str virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param float weight: The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "disabled_at", disabled_at)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="disabledAt")
    def disabled_at(self) -> str:
        """
        This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        """
        return pulumi.get(self, "disabled_at")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def header(self) -> 'outputs.GetLoadBalancerPoolsResultOriginHeaderResult':
        """
        The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> str:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @property
    @pulumi.getter
    def weight(self) -> float:
        """
        The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetLoadBalancerPoolsResultOriginHeaderResult(dict):
    def __init__(__self__, *,
                 hosts: Sequence[str]):
        """
        :param Sequence[str] hosts: The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        pulumi.set(__self__, "hosts", hosts)

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        return pulumi.get(self, "hosts")


@pulumi.output_type
class GetLoadBalancerPoolsResultOriginSteeringResult(dict):
    def __init__(__self__, *,
                 policy: str):
        """
        :param str policy: The type of origin steering policy to use.
        """
        pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        The type of origin steering policy to use.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class GetLoadBalancerRandomSteeringResult(dict):
    def __init__(__self__, *,
                 default_weight: float,
                 pool_weights: Mapping[str, float]):
        """
        :param float default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param Mapping[str, float] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        pulumi.set(__self__, "default_weight", default_weight)
        pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> float:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Mapping[str, float]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class GetLoadBalancerRuleResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 disabled: bool,
                 fixed_response: 'outputs.GetLoadBalancerRuleFixedResponseResult',
                 name: str,
                 overrides: 'outputs.GetLoadBalancerRuleOverridesResult',
                 priority: int,
                 terminates: bool):
        """
        :param str condition: The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        :param bool disabled: Disable this specific rule. It will no longer be evaluated by this load balancer.
        :param 'GetLoadBalancerRuleFixedResponseArgs' fixed_response: A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        :param str name: Name of this rule. Only used for human readability.
        :param 'GetLoadBalancerRuleOverridesArgs' overrides: A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        :param int priority: The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        :param bool terminates: If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "fixed_response", fixed_response)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "overrides", overrides)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "terminates", terminates)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        Disable this specific rule. It will no longer be evaluated by this load balancer.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> 'outputs.GetLoadBalancerRuleFixedResponseResult':
        """
        A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        """
        return pulumi.get(self, "fixed_response")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this rule. Only used for human readability.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def overrides(self) -> 'outputs.GetLoadBalancerRuleOverridesResult':
        """
        A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def terminates(self) -> bool:
        """
        If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        return pulumi.get(self, "terminates")


@pulumi.output_type
class GetLoadBalancerRuleFixedResponseResult(dict):
    def __init__(__self__, *,
                 content_type: str,
                 location: str,
                 message_body: str,
                 status_code: int):
        """
        :param str content_type: The http 'Content-Type' header to include in the response.
        :param str location: The http 'Location' header to include in the response.
        :param str message_body: Text to include as the http body.
        :param int status_code: The http status code to respond with.
        """
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "message_body", message_body)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The http 'Content-Type' header to include in the response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The http 'Location' header to include in the response.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> str:
        """
        Text to include as the http body.
        """
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The http status code to respond with.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetLoadBalancerRuleOverridesResult(dict):
    def __init__(__self__, *,
                 adaptive_routing: 'outputs.GetLoadBalancerRuleOverridesAdaptiveRoutingResult',
                 country_pools: Mapping[str, Sequence[str]],
                 default_pools: Sequence[str],
                 fallback_pool: str,
                 location_strategy: 'outputs.GetLoadBalancerRuleOverridesLocationStrategyResult',
                 pop_pools: Mapping[str, Sequence[str]],
                 random_steering: 'outputs.GetLoadBalancerRuleOverridesRandomSteeringResult',
                 region_pools: Mapping[str, Sequence[str]],
                 session_affinity: str,
                 session_affinity_attributes: 'outputs.GetLoadBalancerRuleOverridesSessionAffinityAttributesResult',
                 session_affinity_ttl: float,
                 steering_policy: str,
                 ttl: float):
        """
        :param 'GetLoadBalancerRuleOverridesAdaptiveRoutingArgs' adaptive_routing: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        :param Mapping[str, Sequence[str]] country_pools: A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        :param Sequence[str] default_pools: A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        :param str fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param 'GetLoadBalancerRuleOverridesLocationStrategyArgs' location_strategy: Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        :param Mapping[str, Sequence[str]] pop_pools: (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        :param 'GetLoadBalancerRuleOverridesRandomSteeringArgs' random_steering: Configures pool weights.
        :param Mapping[str, Sequence[str]] region_pools: A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        :param str session_affinity: Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        :param 'GetLoadBalancerRuleOverridesSessionAffinityAttributesArgs' session_affinity_attributes: Configures attributes for session affinity.
        :param float session_affinity_ttl: Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        :param str steering_policy: Steering Policy for this load balancer.
        :param float ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        pulumi.set(__self__, "adaptive_routing", adaptive_routing)
        pulumi.set(__self__, "country_pools", country_pools)
        pulumi.set(__self__, "default_pools", default_pools)
        pulumi.set(__self__, "fallback_pool", fallback_pool)
        pulumi.set(__self__, "location_strategy", location_strategy)
        pulumi.set(__self__, "pop_pools", pop_pools)
        pulumi.set(__self__, "random_steering", random_steering)
        pulumi.set(__self__, "region_pools", region_pools)
        pulumi.set(__self__, "session_affinity", session_affinity)
        pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        pulumi.set(__self__, "steering_policy", steering_policy)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRouting")
    def adaptive_routing(self) -> 'outputs.GetLoadBalancerRuleOverridesAdaptiveRoutingResult':
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        """
        return pulumi.get(self, "adaptive_routing")

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Mapping[str, Sequence[str]]:
        """
        A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        """
        return pulumi.get(self, "country_pools")

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Sequence[str]:
        """
        A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        """
        return pulumi.get(self, "default_pools")

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> str:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @property
    @pulumi.getter(name="locationStrategy")
    def location_strategy(self) -> 'outputs.GetLoadBalancerRuleOverridesLocationStrategyResult':
        """
        Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        """
        return pulumi.get(self, "location_strategy")

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Mapping[str, Sequence[str]]:
        """
        (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        """
        return pulumi.get(self, "pop_pools")

    @property
    @pulumi.getter(name="randomSteering")
    def random_steering(self) -> 'outputs.GetLoadBalancerRuleOverridesRandomSteeringResult':
        """
        Configures pool weights.
        """
        return pulumi.get(self, "random_steering")

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Mapping[str, Sequence[str]]:
        """
        A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        """
        return pulumi.get(self, "region_pools")

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> str:
        """
        Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        """
        return pulumi.get(self, "session_affinity")

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> 'outputs.GetLoadBalancerRuleOverridesSessionAffinityAttributesResult':
        """
        Configures attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> float:
        """
        Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        """
        return pulumi.get(self, "session_affinity_ttl")

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> str:
        """
        Steering Policy for this load balancer.
        """
        return pulumi.get(self, "steering_policy")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetLoadBalancerRuleOverridesAdaptiveRoutingResult(dict):
    def __init__(__self__, *,
                 failover_across_pools: bool):
        """
        :param bool failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> bool:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class GetLoadBalancerRuleOverridesLocationStrategyResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 prefer_ecs: str):
        """
        :param str mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param str prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> str:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class GetLoadBalancerRuleOverridesRandomSteeringResult(dict):
    def __init__(__self__, *,
                 default_weight: float,
                 pool_weights: Mapping[str, float]):
        """
        :param float default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param Mapping[str, float] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        pulumi.set(__self__, "default_weight", default_weight)
        pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> float:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Mapping[str, float]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class GetLoadBalancerRuleOverridesSessionAffinityAttributesResult(dict):
    def __init__(__self__, *,
                 drain_duration: float,
                 headers: Sequence[str],
                 require_all_headers: bool,
                 samesite: str,
                 secure: str,
                 zero_downtime_failover: str):
        """
        :param float drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param Sequence[str] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param bool require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        :param str samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        :param str secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        :param str zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        pulumi.set(__self__, "drain_duration", drain_duration)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "require_all_headers", require_all_headers)
        pulumi.set(__self__, "samesite", samesite)
        pulumi.set(__self__, "secure", secure)
        pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> float:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> bool:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> str:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> str:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> str:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class GetLoadBalancerSessionAffinityAttributesResult(dict):
    def __init__(__self__, *,
                 drain_duration: float,
                 headers: Sequence[str],
                 require_all_headers: bool,
                 samesite: str,
                 secure: str,
                 zero_downtime_failover: str):
        """
        :param float drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param Sequence[str] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param bool require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        :param str samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        :param str secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        :param str zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        pulumi.set(__self__, "drain_duration", drain_duration)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "require_all_headers", require_all_headers)
        pulumi.set(__self__, "samesite", samesite)
        pulumi.set(__self__, "secure", secure)
        pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> float:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> bool:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> str:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> str:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> str:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class GetLoadBalancersResultResult(dict):
    def __init__(__self__, *,
                 adaptive_routing: 'outputs.GetLoadBalancersResultAdaptiveRoutingResult',
                 country_pools: Mapping[str, Sequence[str]],
                 created_on: str,
                 default_pools: Sequence[str],
                 description: str,
                 enabled: bool,
                 fallback_pool: str,
                 id: str,
                 location_strategy: 'outputs.GetLoadBalancersResultLocationStrategyResult',
                 modified_on: str,
                 name: str,
                 networks: Sequence[str],
                 pop_pools: Mapping[str, Sequence[str]],
                 proxied: bool,
                 random_steering: 'outputs.GetLoadBalancersResultRandomSteeringResult',
                 region_pools: Mapping[str, Sequence[str]],
                 rules: Sequence['outputs.GetLoadBalancersResultRuleResult'],
                 session_affinity: str,
                 session_affinity_attributes: 'outputs.GetLoadBalancersResultSessionAffinityAttributesResult',
                 session_affinity_ttl: float,
                 steering_policy: str,
                 ttl: float):
        """
        :param 'GetLoadBalancersResultAdaptiveRoutingArgs' adaptive_routing: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        :param Mapping[str, Sequence[str]] country_pools: A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        :param Sequence[str] default_pools: A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        :param str description: Object description.
        :param bool enabled: Whether to enable (the default) this load balancer.
        :param str fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param 'GetLoadBalancersResultLocationStrategyArgs' location_strategy: Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        :param str name: The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used.
        :param Sequence[str] networks: List of networks where Load Balancer or Pool is enabled.
        :param Mapping[str, Sequence[str]] pop_pools: (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        :param bool proxied: Whether the hostname should be gray clouded (false) or orange clouded (true).
        :param 'GetLoadBalancersResultRandomSteeringArgs' random_steering: Configures pool weights.
        :param Mapping[str, Sequence[str]] region_pools: A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        :param Sequence['GetLoadBalancersResultRuleArgs'] rules: BETA Field Not General Access: A list of rules for this load balancer to execute.
        :param str session_affinity: Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        :param 'GetLoadBalancersResultSessionAffinityAttributesArgs' session_affinity_attributes: Configures attributes for session affinity.
        :param float session_affinity_ttl: Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        :param str steering_policy: Steering Policy for this load balancer.
        :param float ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        pulumi.set(__self__, "adaptive_routing", adaptive_routing)
        pulumi.set(__self__, "country_pools", country_pools)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "default_pools", default_pools)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "fallback_pool", fallback_pool)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location_strategy", location_strategy)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "pop_pools", pop_pools)
        pulumi.set(__self__, "proxied", proxied)
        pulumi.set(__self__, "random_steering", random_steering)
        pulumi.set(__self__, "region_pools", region_pools)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "session_affinity", session_affinity)
        pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        pulumi.set(__self__, "steering_policy", steering_policy)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRouting")
    def adaptive_routing(self) -> 'outputs.GetLoadBalancersResultAdaptiveRoutingResult':
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        """
        return pulumi.get(self, "adaptive_routing")

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Mapping[str, Sequence[str]]:
        """
        A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        """
        return pulumi.get(self, "country_pools")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Sequence[str]:
        """
        A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        """
        return pulumi.get(self, "default_pools")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Object description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable (the default) this load balancer.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> str:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="locationStrategy")
    def location_strategy(self) -> 'outputs.GetLoadBalancersResultLocationStrategyResult':
        """
        Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        """
        return pulumi.get(self, "location_strategy")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def networks(self) -> Sequence[str]:
        """
        List of networks where Load Balancer or Pool is enabled.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Mapping[str, Sequence[str]]:
        """
        (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        """
        return pulumi.get(self, "pop_pools")

    @property
    @pulumi.getter
    def proxied(self) -> bool:
        """
        Whether the hostname should be gray clouded (false) or orange clouded (true).
        """
        return pulumi.get(self, "proxied")

    @property
    @pulumi.getter(name="randomSteering")
    def random_steering(self) -> 'outputs.GetLoadBalancersResultRandomSteeringResult':
        """
        Configures pool weights.
        """
        return pulumi.get(self, "random_steering")

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Mapping[str, Sequence[str]]:
        """
        A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        """
        return pulumi.get(self, "region_pools")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetLoadBalancersResultRuleResult']:
        """
        BETA Field Not General Access: A list of rules for this load balancer to execute.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> str:
        """
        Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        """
        return pulumi.get(self, "session_affinity")

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> 'outputs.GetLoadBalancersResultSessionAffinityAttributesResult':
        """
        Configures attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> float:
        """
        Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        """
        return pulumi.get(self, "session_affinity_ttl")

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> str:
        """
        Steering Policy for this load balancer.
        """
        return pulumi.get(self, "steering_policy")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetLoadBalancersResultAdaptiveRoutingResult(dict):
    def __init__(__self__, *,
                 failover_across_pools: bool):
        """
        :param bool failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> bool:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class GetLoadBalancersResultLocationStrategyResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 prefer_ecs: str):
        """
        :param str mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param str prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> str:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class GetLoadBalancersResultRandomSteeringResult(dict):
    def __init__(__self__, *,
                 default_weight: float,
                 pool_weights: Mapping[str, float]):
        """
        :param float default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param Mapping[str, float] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        pulumi.set(__self__, "default_weight", default_weight)
        pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> float:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Mapping[str, float]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class GetLoadBalancersResultRuleResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 disabled: bool,
                 fixed_response: 'outputs.GetLoadBalancersResultRuleFixedResponseResult',
                 name: str,
                 overrides: 'outputs.GetLoadBalancersResultRuleOverridesResult',
                 priority: int,
                 terminates: bool):
        """
        :param str condition: The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        :param bool disabled: Disable this specific rule. It will no longer be evaluated by this load balancer.
        :param 'GetLoadBalancersResultRuleFixedResponseArgs' fixed_response: A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        :param str name: Name of this rule. Only used for human readability.
        :param 'GetLoadBalancersResultRuleOverridesArgs' overrides: A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        :param int priority: The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        :param bool terminates: If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "fixed_response", fixed_response)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "overrides", overrides)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "terminates", terminates)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        Disable this specific rule. It will no longer be evaluated by this load balancer.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> 'outputs.GetLoadBalancersResultRuleFixedResponseResult':
        """
        A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        """
        return pulumi.get(self, "fixed_response")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this rule. Only used for human readability.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def overrides(self) -> 'outputs.GetLoadBalancersResultRuleOverridesResult':
        """
        A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def terminates(self) -> bool:
        """
        If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        return pulumi.get(self, "terminates")


@pulumi.output_type
class GetLoadBalancersResultRuleFixedResponseResult(dict):
    def __init__(__self__, *,
                 content_type: str,
                 location: str,
                 message_body: str,
                 status_code: int):
        """
        :param str content_type: The http 'Content-Type' header to include in the response.
        :param str location: The http 'Location' header to include in the response.
        :param str message_body: Text to include as the http body.
        :param int status_code: The http status code to respond with.
        """
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "message_body", message_body)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The http 'Content-Type' header to include in the response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The http 'Location' header to include in the response.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> str:
        """
        Text to include as the http body.
        """
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The http status code to respond with.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetLoadBalancersResultRuleOverridesResult(dict):
    def __init__(__self__, *,
                 adaptive_routing: 'outputs.GetLoadBalancersResultRuleOverridesAdaptiveRoutingResult',
                 country_pools: Mapping[str, Sequence[str]],
                 default_pools: Sequence[str],
                 fallback_pool: str,
                 location_strategy: 'outputs.GetLoadBalancersResultRuleOverridesLocationStrategyResult',
                 pop_pools: Mapping[str, Sequence[str]],
                 random_steering: 'outputs.GetLoadBalancersResultRuleOverridesRandomSteeringResult',
                 region_pools: Mapping[str, Sequence[str]],
                 session_affinity: str,
                 session_affinity_attributes: 'outputs.GetLoadBalancersResultRuleOverridesSessionAffinityAttributesResult',
                 session_affinity_ttl: float,
                 steering_policy: str,
                 ttl: float):
        """
        :param 'GetLoadBalancersResultRuleOverridesAdaptiveRoutingArgs' adaptive_routing: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        :param Mapping[str, Sequence[str]] country_pools: A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        :param Sequence[str] default_pools: A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        :param str fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param 'GetLoadBalancersResultRuleOverridesLocationStrategyArgs' location_strategy: Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        :param Mapping[str, Sequence[str]] pop_pools: (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        :param 'GetLoadBalancersResultRuleOverridesRandomSteeringArgs' random_steering: Configures pool weights.
        :param Mapping[str, Sequence[str]] region_pools: A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        :param str session_affinity: Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        :param 'GetLoadBalancersResultRuleOverridesSessionAffinityAttributesArgs' session_affinity_attributes: Configures attributes for session affinity.
        :param float session_affinity_ttl: Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        :param str steering_policy: Steering Policy for this load balancer.
        :param float ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        pulumi.set(__self__, "adaptive_routing", adaptive_routing)
        pulumi.set(__self__, "country_pools", country_pools)
        pulumi.set(__self__, "default_pools", default_pools)
        pulumi.set(__self__, "fallback_pool", fallback_pool)
        pulumi.set(__self__, "location_strategy", location_strategy)
        pulumi.set(__self__, "pop_pools", pop_pools)
        pulumi.set(__self__, "random_steering", random_steering)
        pulumi.set(__self__, "region_pools", region_pools)
        pulumi.set(__self__, "session_affinity", session_affinity)
        pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        pulumi.set(__self__, "steering_policy", steering_policy)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRouting")
    def adaptive_routing(self) -> 'outputs.GetLoadBalancersResultRuleOverridesAdaptiveRoutingResult':
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        """
        return pulumi.get(self, "adaptive_routing")

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Mapping[str, Sequence[str]]:
        """
        A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        """
        return pulumi.get(self, "country_pools")

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Sequence[str]:
        """
        A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        """
        return pulumi.get(self, "default_pools")

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> str:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @property
    @pulumi.getter(name="locationStrategy")
    def location_strategy(self) -> 'outputs.GetLoadBalancersResultRuleOverridesLocationStrategyResult':
        """
        Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        """
        return pulumi.get(self, "location_strategy")

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Mapping[str, Sequence[str]]:
        """
        (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        """
        return pulumi.get(self, "pop_pools")

    @property
    @pulumi.getter(name="randomSteering")
    def random_steering(self) -> 'outputs.GetLoadBalancersResultRuleOverridesRandomSteeringResult':
        """
        Configures pool weights.
        """
        return pulumi.get(self, "random_steering")

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Mapping[str, Sequence[str]]:
        """
        A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        """
        return pulumi.get(self, "region_pools")

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> str:
        """
        Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        """
        return pulumi.get(self, "session_affinity")

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> 'outputs.GetLoadBalancersResultRuleOverridesSessionAffinityAttributesResult':
        """
        Configures attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> float:
        """
        Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        """
        return pulumi.get(self, "session_affinity_ttl")

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> str:
        """
        Steering Policy for this load balancer.
        """
        return pulumi.get(self, "steering_policy")

    @property
    @pulumi.getter
    def ttl(self) -> float:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetLoadBalancersResultRuleOverridesAdaptiveRoutingResult(dict):
    def __init__(__self__, *,
                 failover_across_pools: bool):
        """
        :param bool failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> bool:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class GetLoadBalancersResultRuleOverridesLocationStrategyResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 prefer_ecs: str):
        """
        :param str mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param str prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> str:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class GetLoadBalancersResultRuleOverridesRandomSteeringResult(dict):
    def __init__(__self__, *,
                 default_weight: float,
                 pool_weights: Mapping[str, float]):
        """
        :param float default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param Mapping[str, float] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        pulumi.set(__self__, "default_weight", default_weight)
        pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> float:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Mapping[str, float]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class GetLoadBalancersResultRuleOverridesSessionAffinityAttributesResult(dict):
    def __init__(__self__, *,
                 drain_duration: float,
                 headers: Sequence[str],
                 require_all_headers: bool,
                 samesite: str,
                 secure: str,
                 zero_downtime_failover: str):
        """
        :param float drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param Sequence[str] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param bool require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        :param str samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        :param str secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        :param str zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        pulumi.set(__self__, "drain_duration", drain_duration)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "require_all_headers", require_all_headers)
        pulumi.set(__self__, "samesite", samesite)
        pulumi.set(__self__, "secure", secure)
        pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> float:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> bool:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> str:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> str:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> str:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class GetLoadBalancersResultSessionAffinityAttributesResult(dict):
    def __init__(__self__, *,
                 drain_duration: float,
                 headers: Sequence[str],
                 require_all_headers: bool,
                 samesite: str,
                 secure: str,
                 zero_downtime_failover: str):
        """
        :param float drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param Sequence[str] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param bool require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        :param str samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        :param str secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        :param str zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        pulumi.set(__self__, "drain_duration", drain_duration)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "require_all_headers", require_all_headers)
        pulumi.set(__self__, "samesite", samesite)
        pulumi.set(__self__, "secure", secure)
        pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> float:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> bool:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> str:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> str:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> str:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetLogpushDatasetJobOutputOptionsResult(dict):
    def __init__(__self__, *,
                 batch_prefix: str,
                 batch_suffix: str,
                 cve20214428: bool,
                 field_delimiter: str,
                 field_names: Sequence[str],
                 output_type: str,
                 record_delimiter: str,
                 record_prefix: str,
                 record_suffix: str,
                 record_template: str,
                 sample_rate: float,
                 timestamp_format: str):
        """
        :param str batch_prefix: String to be prepended before each batch.
        :param str batch_suffix: String to be appended after each batch.
        :param bool cve20214428: If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        :param str field_delimiter: String to join fields. This field be ignored when `record_template` is set.
        :param Sequence[str] field_names: List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        :param str output_type: Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        :param str record_delimiter: String to be inserted in-between the records as separator.
        :param str record_prefix: String to be prepended before each record.
        :param str record_suffix: String to be appended after each record.
        :param str record_template: String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        :param float sample_rate: Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        :param str timestamp_format: String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        pulumi.set(__self__, "batch_prefix", batch_prefix)
        pulumi.set(__self__, "batch_suffix", batch_suffix)
        pulumi.set(__self__, "cve20214428", cve20214428)
        pulumi.set(__self__, "field_delimiter", field_delimiter)
        pulumi.set(__self__, "field_names", field_names)
        pulumi.set(__self__, "output_type", output_type)
        pulumi.set(__self__, "record_delimiter", record_delimiter)
        pulumi.set(__self__, "record_prefix", record_prefix)
        pulumi.set(__self__, "record_suffix", record_suffix)
        pulumi.set(__self__, "record_template", record_template)
        pulumi.set(__self__, "sample_rate", sample_rate)
        pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter(name="batchPrefix")
    def batch_prefix(self) -> str:
        """
        String to be prepended before each batch.
        """
        return pulumi.get(self, "batch_prefix")

    @property
    @pulumi.getter(name="batchSuffix")
    def batch_suffix(self) -> str:
        """
        String to be appended after each batch.
        """
        return pulumi.get(self, "batch_suffix")

    @property
    @pulumi.getter
    def cve20214428(self) -> bool:
        """
        If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        """
        return pulumi.get(self, "cve20214428")

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> str:
        """
        String to join fields. This field be ignored when `record_template` is set.
        """
        return pulumi.get(self, "field_delimiter")

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Sequence[str]:
        """
        List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        """
        return pulumi.get(self, "field_names")

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> str:
        """
        Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        """
        return pulumi.get(self, "output_type")

    @property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> str:
        """
        String to be inserted in-between the records as separator.
        """
        return pulumi.get(self, "record_delimiter")

    @property
    @pulumi.getter(name="recordPrefix")
    def record_prefix(self) -> str:
        """
        String to be prepended before each record.
        """
        return pulumi.get(self, "record_prefix")

    @property
    @pulumi.getter(name="recordSuffix")
    def record_suffix(self) -> str:
        """
        String to be appended after each record.
        """
        return pulumi.get(self, "record_suffix")

    @property
    @pulumi.getter(name="recordTemplate")
    def record_template(self) -> str:
        """
        String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        """
        return pulumi.get(self, "record_template")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        """
        Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> str:
        """
        String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        return pulumi.get(self, "timestamp_format")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetLogpushJobOutputOptionsResult(dict):
    def __init__(__self__, *,
                 batch_prefix: str,
                 batch_suffix: str,
                 cve20214428: bool,
                 field_delimiter: str,
                 field_names: Sequence[str],
                 output_type: str,
                 record_delimiter: str,
                 record_prefix: str,
                 record_suffix: str,
                 record_template: str,
                 sample_rate: float,
                 timestamp_format: str):
        """
        :param str batch_prefix: String to be prepended before each batch.
        :param str batch_suffix: String to be appended after each batch.
        :param bool cve20214428: If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        :param str field_delimiter: String to join fields. This field be ignored when `record_template` is set.
        :param Sequence[str] field_names: List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        :param str output_type: Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        :param str record_delimiter: String to be inserted in-between the records as separator.
        :param str record_prefix: String to be prepended before each record.
        :param str record_suffix: String to be appended after each record.
        :param str record_template: String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        :param float sample_rate: Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        :param str timestamp_format: String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        pulumi.set(__self__, "batch_prefix", batch_prefix)
        pulumi.set(__self__, "batch_suffix", batch_suffix)
        pulumi.set(__self__, "cve20214428", cve20214428)
        pulumi.set(__self__, "field_delimiter", field_delimiter)
        pulumi.set(__self__, "field_names", field_names)
        pulumi.set(__self__, "output_type", output_type)
        pulumi.set(__self__, "record_delimiter", record_delimiter)
        pulumi.set(__self__, "record_prefix", record_prefix)
        pulumi.set(__self__, "record_suffix", record_suffix)
        pulumi.set(__self__, "record_template", record_template)
        pulumi.set(__self__, "sample_rate", sample_rate)
        pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter(name="batchPrefix")
    def batch_prefix(self) -> str:
        """
        String to be prepended before each batch.
        """
        return pulumi.get(self, "batch_prefix")

    @property
    @pulumi.getter(name="batchSuffix")
    def batch_suffix(self) -> str:
        """
        String to be appended after each batch.
        """
        return pulumi.get(self, "batch_suffix")

    @property
    @pulumi.getter
    def cve20214428(self) -> bool:
        """
        If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        """
        return pulumi.get(self, "cve20214428")

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> str:
        """
        String to join fields. This field be ignored when `record_template` is set.
        """
        return pulumi.get(self, "field_delimiter")

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Sequence[str]:
        """
        List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        """
        return pulumi.get(self, "field_names")

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> str:
        """
        Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        """
        return pulumi.get(self, "output_type")

    @property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> str:
        """
        String to be inserted in-between the records as separator.
        """
        return pulumi.get(self, "record_delimiter")

    @property
    @pulumi.getter(name="recordPrefix")
    def record_prefix(self) -> str:
        """
        String to be prepended before each record.
        """
        return pulumi.get(self, "record_prefix")

    @property
    @pulumi.getter(name="recordSuffix")
    def record_suffix(self) -> str:
        """
        String to be appended after each record.
        """
        return pulumi.get(self, "record_suffix")

    @property
    @pulumi.getter(name="recordTemplate")
    def record_template(self) -> str:
        """
        String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        """
        return pulumi.get(self, "record_template")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        """
        Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> str:
        """
        String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        return pulumi.get(self, "timestamp_format")


@pulumi.output_type
class GetLogpushJobsResultResult(dict):
    def __init__(__self__, *,
                 dataset: str,
                 destination_conf: str,
                 enabled: bool,
                 error_message: str,
                 frequency: str,
                 id: int,
                 kind: str,
                 last_complete: str,
                 last_error: str,
                 logpull_options: str,
                 max_upload_bytes: int,
                 max_upload_interval_seconds: int,
                 max_upload_records: int,
                 name: str,
                 output_options: 'outputs.GetLogpushJobsResultOutputOptionsResult'):
        """
        :param str dataset: Name of the dataset. A list of supported datasets can be found on the [Developer Docs](https://developers.cloudflare.com/logs/reference/log-fields/).
        :param str destination_conf: Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included.
        :param bool enabled: Flag that indicates if the job is enabled.
        :param str error_message: If not null, the job is currently failing. Failures are usually repetitive (example: no permissions to write to destination bucket). Only the last failure is recorded. On successful execution of a job the error*message and last*error are set to null.
        :param str frequency: This field is deprecated. Please use `max_upload_*` parameters instead. The frequency at which Cloudflare sends batches of logs to your destination. Setting frequency to high sends your logs in larger quantities of smaller files. Setting frequency to low sends logs in smaller quantities of larger files.
        :param int id: Unique id of the job.
        :param str kind: The kind parameter (optional) is used to differentiate between Logpush and Edge Log Delivery jobs. Currently, Edge Log Delivery is only supported for the `http_requests` dataset.
        :param str last_complete: Records the last time for which logs have been successfully pushed. If the last successful push was for logs range 2018-07-23T10:00:00Z to 2018-07-23T10:01:00Z then the value of this field will be 2018-07-23T10:01:00Z. If the job has never run or has just been enabled and hasn't run yet then the field will be empty.
        :param str last_error: Records the last time the job failed. If not null, the job is currently failing. If null, the job has either never failed or has run successfully at least once since last failure. See also the error_message field.
        :param str logpull_options: This field is deprecated. Use `output_options` instead. Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately.
        :param int max_upload_bytes: The maximum uncompressed file size of a batch of logs. This setting value must be between `5 MB` and `1 GB`, or `0` to disable it. Note that you cannot set a minimum file size; this means that log files may be much smaller than this batch size. This parameter is not available for jobs with `edge` as its kind.
        :param int max_upload_interval_seconds: The maximum interval in seconds for log batches. This setting must be between 30 and 300 seconds (5 minutes), or `0` to disable it. Note that you cannot specify a minimum interval for log batches; this means that log files may be sent in shorter intervals than this. This parameter is only used for jobs with `edge` as its kind.
        :param int max_upload_records: The maximum number of log lines per batch. This setting must be between 1000 and 1,000,000 lines, or `0` to disable it. Note that you cannot specify a minimum number of log lines per batch; this means that log files may contain many fewer lines than this. This parameter is not available for jobs with `edge` as its kind.
        :param str name: Optional human readable job name. Not unique. Cloudflare suggests that you set this to a meaningful string, like the domain name, to make it easier to identify your job.
        :param 'GetLogpushJobsResultOutputOptionsArgs' output_options: The structured replacement for `logpull_options`. When including this field, the `logpull_option` field will be ignored.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "destination_conf", destination_conf)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "last_complete", last_complete)
        pulumi.set(__self__, "last_error", last_error)
        pulumi.set(__self__, "logpull_options", logpull_options)
        pulumi.set(__self__, "max_upload_bytes", max_upload_bytes)
        pulumi.set(__self__, "max_upload_interval_seconds", max_upload_interval_seconds)
        pulumi.set(__self__, "max_upload_records", max_upload_records)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_options", output_options)

    @property
    @pulumi.getter
    def dataset(self) -> str:
        """
        Name of the dataset. A list of supported datasets can be found on the [Developer Docs](https://developers.cloudflare.com/logs/reference/log-fields/).
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter(name="destinationConf")
    def destination_conf(self) -> str:
        """
        Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included.
        """
        return pulumi.get(self, "destination_conf")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Flag that indicates if the job is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        If not null, the job is currently failing. Failures are usually repetitive (example: no permissions to write to destination bucket). Only the last failure is recorded. On successful execution of a job the error*message and last*error are set to null.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def frequency(self) -> str:
        """
        This field is deprecated. Please use `max_upload_*` parameters instead. The frequency at which Cloudflare sends batches of logs to your destination. Setting frequency to high sends your logs in larger quantities of smaller files. Setting frequency to low sends logs in smaller quantities of larger files.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Unique id of the job.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The kind parameter (optional) is used to differentiate between Logpush and Edge Log Delivery jobs. Currently, Edge Log Delivery is only supported for the `http_requests` dataset.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="lastComplete")
    def last_complete(self) -> str:
        """
        Records the last time for which logs have been successfully pushed. If the last successful push was for logs range 2018-07-23T10:00:00Z to 2018-07-23T10:01:00Z then the value of this field will be 2018-07-23T10:01:00Z. If the job has never run or has just been enabled and hasn't run yet then the field will be empty.
        """
        return pulumi.get(self, "last_complete")

    @property
    @pulumi.getter(name="lastError")
    def last_error(self) -> str:
        """
        Records the last time the job failed. If not null, the job is currently failing. If null, the job has either never failed or has run successfully at least once since last failure. See also the error_message field.
        """
        return pulumi.get(self, "last_error")

    @property
    @pulumi.getter(name="logpullOptions")
    def logpull_options(self) -> str:
        """
        This field is deprecated. Use `output_options` instead. Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately.
        """
        return pulumi.get(self, "logpull_options")

    @property
    @pulumi.getter(name="maxUploadBytes")
    def max_upload_bytes(self) -> int:
        """
        The maximum uncompressed file size of a batch of logs. This setting value must be between `5 MB` and `1 GB`, or `0` to disable it. Note that you cannot set a minimum file size; this means that log files may be much smaller than this batch size. This parameter is not available for jobs with `edge` as its kind.
        """
        return pulumi.get(self, "max_upload_bytes")

    @property
    @pulumi.getter(name="maxUploadIntervalSeconds")
    def max_upload_interval_seconds(self) -> int:
        """
        The maximum interval in seconds for log batches. This setting must be between 30 and 300 seconds (5 minutes), or `0` to disable it. Note that you cannot specify a minimum interval for log batches; this means that log files may be sent in shorter intervals than this. This parameter is only used for jobs with `edge` as its kind.
        """
        return pulumi.get(self, "max_upload_interval_seconds")

    @property
    @pulumi.getter(name="maxUploadRecords")
    def max_upload_records(self) -> int:
        """
        The maximum number of log lines per batch. This setting must be between 1000 and 1,000,000 lines, or `0` to disable it. Note that you cannot specify a minimum number of log lines per batch; this means that log files may contain many fewer lines than this. This parameter is not available for jobs with `edge` as its kind.
        """
        return pulumi.get(self, "max_upload_records")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional human readable job name. Not unique. Cloudflare suggests that you set this to a meaningful string, like the domain name, to make it easier to identify your job.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="outputOptions")
    def output_options(self) -> 'outputs.GetLogpushJobsResultOutputOptionsResult':
        """
        The structured replacement for `logpull_options`. When including this field, the `logpull_option` field will be ignored.
        """
        return pulumi.get(self, "output_options")


@pulumi.output_type
class GetLogpushJobsResultOutputOptionsResult(dict):
    def __init__(__self__, *,
                 batch_prefix: str,
                 batch_suffix: str,
                 cve20214428: bool,
                 field_delimiter: str,
                 field_names: Sequence[str],
                 output_type: str,
                 record_delimiter: str,
                 record_prefix: str,
                 record_suffix: str,
                 record_template: str,
                 sample_rate: float,
                 timestamp_format: str):
        """
        :param str batch_prefix: String to be prepended before each batch.
        :param str batch_suffix: String to be appended after each batch.
        :param bool cve20214428: If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        :param str field_delimiter: String to join fields. This field be ignored when `record_template` is set.
        :param Sequence[str] field_names: List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        :param str output_type: Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        :param str record_delimiter: String to be inserted in-between the records as separator.
        :param str record_prefix: String to be prepended before each record.
        :param str record_suffix: String to be appended after each record.
        :param str record_template: String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        :param float sample_rate: Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        :param str timestamp_format: String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        pulumi.set(__self__, "batch_prefix", batch_prefix)
        pulumi.set(__self__, "batch_suffix", batch_suffix)
        pulumi.set(__self__, "cve20214428", cve20214428)
        pulumi.set(__self__, "field_delimiter", field_delimiter)
        pulumi.set(__self__, "field_names", field_names)
        pulumi.set(__self__, "output_type", output_type)
        pulumi.set(__self__, "record_delimiter", record_delimiter)
        pulumi.set(__self__, "record_prefix", record_prefix)
        pulumi.set(__self__, "record_suffix", record_suffix)
        pulumi.set(__self__, "record_template", record_template)
        pulumi.set(__self__, "sample_rate", sample_rate)
        pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter(name="batchPrefix")
    def batch_prefix(self) -> str:
        """
        String to be prepended before each batch.
        """
        return pulumi.get(self, "batch_prefix")

    @property
    @pulumi.getter(name="batchSuffix")
    def batch_suffix(self) -> str:
        """
        String to be appended after each batch.
        """
        return pulumi.get(self, "batch_suffix")

    @property
    @pulumi.getter
    def cve20214428(self) -> bool:
        """
        If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        """
        return pulumi.get(self, "cve20214428")

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> str:
        """
        String to join fields. This field be ignored when `record_template` is set.
        """
        return pulumi.get(self, "field_delimiter")

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Sequence[str]:
        """
        List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        """
        return pulumi.get(self, "field_names")

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> str:
        """
        Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        """
        return pulumi.get(self, "output_type")

    @property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> str:
        """
        String to be inserted in-between the records as separator.
        """
        return pulumi.get(self, "record_delimiter")

    @property
    @pulumi.getter(name="recordPrefix")
    def record_prefix(self) -> str:
        """
        String to be prepended before each record.
        """
        return pulumi.get(self, "record_prefix")

    @property
    @pulumi.getter(name="recordSuffix")
    def record_suffix(self) -> str:
        """
        String to be appended after each record.
        """
        return pulumi.get(self, "record_suffix")

    @property
    @pulumi.getter(name="recordTemplate")
    def record_template(self) -> str:
        """
        String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        """
        return pulumi.get(self, "record_template")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        """
        Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> str:
        """
        String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        return pulumi.get(self, "timestamp_format")


@pulumi.output_type
class GetMagicNetworkMonitoringConfigurationWarpDeviceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 router_ip: str):
        """
        :param str id: Unique identifier for the warp device.
        :param str name: Name of the warp device.
        :param str router_ip: IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "router_ip", router_ip)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the warp device.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the warp device.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="routerIp")
    def router_ip(self) -> str:
        """
        IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
        return pulumi.get(self, "router_ip")


@pulumi.output_type
class GetMagicNetworkMonitoringRulesResultResult(dict):
    def __init__(__self__, *,
                 automatic_advertisement: bool,
                 bandwidth_threshold: float,
                 duration: str,
                 id: str,
                 name: str,
                 packet_threshold: float,
                 prefixes: Sequence[str]):
        """
        :param bool automatic_advertisement: Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit.
        :param float bandwidth_threshold: The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
        :param str duration: The amount of time that the rule threshold must be exceeded to send an alert notification. The final value must be equivalent to one of the following 8 values ["1m","5m","10m","15m","20m","30m","45m","60m"]. The format is AhBmCsDmsEusFns where A, B, C, D, E and F durations are optional; however at least one unit must be provided.
        :param str id: The id of the rule. Must be unique.
        :param str name: The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters.
        :param float packet_threshold: The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
        """
        pulumi.set(__self__, "automatic_advertisement", automatic_advertisement)
        pulumi.set(__self__, "bandwidth_threshold", bandwidth_threshold)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "packet_threshold", packet_threshold)
        pulumi.set(__self__, "prefixes", prefixes)

    @property
    @pulumi.getter(name="automaticAdvertisement")
    def automatic_advertisement(self) -> bool:
        """
        Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit.
        """
        return pulumi.get(self, "automatic_advertisement")

    @property
    @pulumi.getter(name="bandwidthThreshold")
    def bandwidth_threshold(self) -> float:
        """
        The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
        """
        return pulumi.get(self, "bandwidth_threshold")

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        The amount of time that the rule threshold must be exceeded to send an alert notification. The final value must be equivalent to one of the following 8 values ["1m","5m","10m","15m","20m","30m","45m","60m"]. The format is AhBmCsDmsEusFns where A, B, C, D, E and F durations are optional; however at least one unit must be provided.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the rule. Must be unique.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="packetThreshold")
    def packet_threshold(self) -> float:
        """
        The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
        """
        return pulumi.get(self, "packet_threshold")

    @property
    @pulumi.getter
    def prefixes(self) -> Sequence[str]:
        return pulumi.get(self, "prefixes")


@pulumi.output_type
class GetMagicTransitConnectorDeviceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 serial_number: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "serial_number", serial_number)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> str:
        return pulumi.get(self, "serial_number")


@pulumi.output_type
class GetMagicTransitConnectorsResultResult(dict):
    def __init__(__self__, *,
                 activated: bool,
                 device: 'outputs.GetMagicTransitConnectorsResultDeviceResult',
                 id: str,
                 interrupt_window_duration_hours: float,
                 interrupt_window_hour_of_day: float,
                 last_heartbeat: str,
                 last_seen_version: str,
                 last_updated: str,
                 notes: str,
                 timezone: str):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interrupt_window_duration_hours", interrupt_window_duration_hours)
        pulumi.set(__self__, "interrupt_window_hour_of_day", interrupt_window_hour_of_day)
        pulumi.set(__self__, "last_heartbeat", last_heartbeat)
        pulumi.set(__self__, "last_seen_version", last_seen_version)
        pulumi.set(__self__, "last_updated", last_updated)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def activated(self) -> bool:
        return pulumi.get(self, "activated")

    @property
    @pulumi.getter
    def device(self) -> 'outputs.GetMagicTransitConnectorsResultDeviceResult':
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interruptWindowDurationHours")
    def interrupt_window_duration_hours(self) -> float:
        return pulumi.get(self, "interrupt_window_duration_hours")

    @property
    @pulumi.getter(name="interruptWindowHourOfDay")
    def interrupt_window_hour_of_day(self) -> float:
        return pulumi.get(self, "interrupt_window_hour_of_day")

    @property
    @pulumi.getter(name="lastHeartbeat")
    def last_heartbeat(self) -> str:
        return pulumi.get(self, "last_heartbeat")

    @property
    @pulumi.getter(name="lastSeenVersion")
    def last_seen_version(self) -> str:
        return pulumi.get(self, "last_seen_version")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> str:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def notes(self) -> str:
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        return pulumi.get(self, "timezone")


@pulumi.output_type
class GetMagicTransitConnectorsResultDeviceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 serial_number: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "serial_number", serial_number)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> str:
        return pulumi.get(self, "serial_number")


@pulumi.output_type
class GetMagicTransitSiteAclLan1Result(dict):
    def __init__(__self__, *,
                 lan_id: str,
                 lan_name: str,
                 port_ranges: Sequence[str],
                 ports: Sequence[int],
                 subnets: Sequence[str]):
        """
        :param str lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param str lan_name: The name of the LAN based on the provided lan_id.
        :param Sequence[str] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param Sequence[int] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param Sequence[str] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        pulumi.set(__self__, "lan_name", lan_name)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> str:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence[str]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetMagicTransitSiteAclLan2Result(dict):
    def __init__(__self__, *,
                 lan_id: str,
                 lan_name: str,
                 port_ranges: Sequence[str],
                 ports: Sequence[int],
                 subnets: Sequence[str]):
        """
        :param str lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param str lan_name: The name of the LAN based on the provided lan_id.
        :param Sequence[str] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param Sequence[int] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param Sequence[str] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        pulumi.set(__self__, "lan_name", lan_name)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> str:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence[str]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetMagicTransitSiteAclsResultResult(dict):
    def __init__(__self__, *,
                 description: str,
                 forward_locally: bool,
                 id: str,
                 lan1: 'outputs.GetMagicTransitSiteAclsResultLan1Result',
                 lan2: 'outputs.GetMagicTransitSiteAclsResultLan2Result',
                 name: str,
                 protocols: Sequence[str],
                 unidirectional: bool):
        """
        :param str description: Description for the ACL.
        :param bool forward_locally: The desired forwarding action for this ACL policy. If set to "false", the policy will forward traffic to Cloudflare. If set to "true", the policy will forward traffic locally on the Magic Connector. If not included in request, will default to false.
        :param str id: Identifier
        :param str name: The name of the ACL.
        :param bool unidirectional: The desired traffic direction for this ACL policy. If set to "false", the policy will allow bidirectional traffic. If set to "true", the policy will only allow traffic in one direction. If not included in request, will default to false.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "forward_locally", forward_locally)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lan1", lan1)
        pulumi.set(__self__, "lan2", lan2)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "unidirectional", unidirectional)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for the ACL.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="forwardLocally")
    def forward_locally(self) -> bool:
        """
        The desired forwarding action for this ACL policy. If set to "false", the policy will forward traffic to Cloudflare. If set to "true", the policy will forward traffic locally on the Magic Connector. If not included in request, will default to false.
        """
        return pulumi.get(self, "forward_locally")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def lan1(self) -> 'outputs.GetMagicTransitSiteAclsResultLan1Result':
        return pulumi.get(self, "lan1")

    @property
    @pulumi.getter
    def lan2(self) -> 'outputs.GetMagicTransitSiteAclsResultLan2Result':
        return pulumi.get(self, "lan2")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ACL.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def unidirectional(self) -> bool:
        """
        The desired traffic direction for this ACL policy. If set to "false", the policy will allow bidirectional traffic. If set to "true", the policy will only allow traffic in one direction. If not included in request, will default to false.
        """
        return pulumi.get(self, "unidirectional")


@pulumi.output_type
class GetMagicTransitSiteAclsResultLan1Result(dict):
    def __init__(__self__, *,
                 lan_id: str,
                 lan_name: str,
                 port_ranges: Sequence[str],
                 ports: Sequence[int],
                 subnets: Sequence[str]):
        """
        :param str lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param str lan_name: The name of the LAN based on the provided lan_id.
        :param Sequence[str] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param Sequence[int] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param Sequence[str] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        pulumi.set(__self__, "lan_name", lan_name)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> str:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence[str]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetMagicTransitSiteAclsResultLan2Result(dict):
    def __init__(__self__, *,
                 lan_id: str,
                 lan_name: str,
                 port_ranges: Sequence[str],
                 ports: Sequence[int],
                 subnets: Sequence[str]):
        """
        :param str lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param str lan_name: The name of the LAN based on the provided lan_id.
        :param Sequence[str] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param Sequence[int] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param Sequence[str] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        pulumi.set(__self__, "lan_name", lan_name)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> str:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence[str]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetMagicTransitSiteFilterResult(dict):
    def __init__(__self__, *,
<<<<<<< HEAD
                 connector_identifier: Optional[str] = None):
        """
        :param str connector_identifier: Identifier
        """
        if connector_identifier is not None:
            pulumi.set(__self__, "connector_identifier", connector_identifier)

    @property
    @pulumi.getter(name="connectorIdentifier")
    def connector_identifier(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "connector_identifier")
=======
                 connectorid: Optional[str] = None):
        """
        :param str connectorid: Identifier
        """
        if connectorid is not None:
            pulumi.set(__self__, "connectorid", connectorid)

    @property
    @pulumi.getter
    def connectorid(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "connectorid")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580


@pulumi.output_type
class GetMagicTransitSiteLanNatResult(dict):
    def __init__(__self__, *,
                 static_prefix: str):
        """
        :param str static_prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "static_prefix", static_prefix)

    @property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class GetMagicTransitSiteLanRoutedSubnetResult(dict):
    def __init__(__self__, *,
                 nat: 'outputs.GetMagicTransitSiteLanRoutedSubnetNatResult',
                 next_hop: str,
                 prefix: str):
        """
        :param str next_hop: A valid IPv4 address.
        :param str prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def nat(self) -> 'outputs.GetMagicTransitSiteLanRoutedSubnetNatResult':
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetMagicTransitSiteLanRoutedSubnetNatResult(dict):
    def __init__(__self__, *,
                 static_prefix: str):
        """
        :param str static_prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "static_prefix", static_prefix)

    @property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class GetMagicTransitSiteLanStaticAddressingResult(dict):
    def __init__(__self__, *,
                 address: str,
                 dhcp_relay: 'outputs.GetMagicTransitSiteLanStaticAddressingDhcpRelayResult',
                 dhcp_server: 'outputs.GetMagicTransitSiteLanStaticAddressingDhcpServerResult',
                 secondary_address: str,
                 virtual_address: str):
        """
        :param str address: A valid CIDR notation representing an IP range.
        :param str secondary_address: A valid CIDR notation representing an IP range.
        :param str virtual_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "dhcp_relay", dhcp_relay)
        pulumi.set(__self__, "dhcp_server", dhcp_server)
        pulumi.set(__self__, "secondary_address", secondary_address)
        pulumi.set(__self__, "virtual_address", virtual_address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="dhcpRelay")
    def dhcp_relay(self) -> 'outputs.GetMagicTransitSiteLanStaticAddressingDhcpRelayResult':
        return pulumi.get(self, "dhcp_relay")

    @property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> 'outputs.GetMagicTransitSiteLanStaticAddressingDhcpServerResult':
        return pulumi.get(self, "dhcp_server")

    @property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")

    @property
    @pulumi.getter(name="virtualAddress")
    def virtual_address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "virtual_address")


@pulumi.output_type
class GetMagicTransitSiteLanStaticAddressingDhcpRelayResult(dict):
    def __init__(__self__, *,
                 server_addresses: Sequence[str]):
        """
        :param Sequence[str] server_addresses: List of DHCP server IPs.
        """
        pulumi.set(__self__, "server_addresses", server_addresses)

    @property
    @pulumi.getter(name="serverAddresses")
    def server_addresses(self) -> Sequence[str]:
        """
        List of DHCP server IPs.
        """
        return pulumi.get(self, "server_addresses")


@pulumi.output_type
class GetMagicTransitSiteLanStaticAddressingDhcpServerResult(dict):
    def __init__(__self__, *,
                 dhcp_pool_end: str,
                 dhcp_pool_start: str,
                 dns_server: str,
<<<<<<< HEAD
=======
                 dns_servers: Sequence[str],
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 reservations: Mapping[str, str]):
        """
        :param str dhcp_pool_end: A valid IPv4 address.
        :param str dhcp_pool_start: A valid IPv4 address.
        :param str dns_server: A valid IPv4 address.
        :param Mapping[str, str] reservations: Mapping of MAC addresses to IP addresses
        """
        pulumi.set(__self__, "dhcp_pool_end", dhcp_pool_end)
        pulumi.set(__self__, "dhcp_pool_start", dhcp_pool_start)
        pulumi.set(__self__, "dns_server", dns_server)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "dns_servers", dns_servers)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "reservations", reservations)

    @property
    @pulumi.getter(name="dhcpPoolEnd")
    def dhcp_pool_end(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_end")

    @property
    @pulumi.getter(name="dhcpPoolStart")
    def dhcp_pool_start(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_start")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dns_server")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        return pulumi.get(self, "dns_servers")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def reservations(self) -> Mapping[str, str]:
        """
        Mapping of MAC addresses to IP addresses
        """
        return pulumi.get(self, "reservations")


@pulumi.output_type
class GetMagicTransitSiteLansResultResult(dict):
    def __init__(__self__, *,
                 ha_link: bool,
                 id: str,
                 name: str,
                 nat: 'outputs.GetMagicTransitSiteLansResultNatResult',
                 physport: int,
                 routed_subnets: Sequence['outputs.GetMagicTransitSiteLansResultRoutedSubnetResult'],
                 site_id: str,
                 static_addressing: 'outputs.GetMagicTransitSiteLansResultStaticAddressingResult',
                 vlan_tag: int):
        """
        :param bool ha_link: mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
        :param str id: Identifier
        :param str site_id: Identifier
        :param 'GetMagicTransitSiteLansResultStaticAddressingArgs' static_addressing: If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
        :param int vlan_tag: VLAN port number.
        """
        pulumi.set(__self__, "ha_link", ha_link)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "physport", physport)
        pulumi.set(__self__, "routed_subnets", routed_subnets)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "static_addressing", static_addressing)
        pulumi.set(__self__, "vlan_tag", vlan_tag)

    @property
    @pulumi.getter(name="haLink")
    def ha_link(self) -> bool:
        """
        mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
        """
        return pulumi.get(self, "ha_link")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def nat(self) -> 'outputs.GetMagicTransitSiteLansResultNatResult':
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter
    def physport(self) -> int:
        return pulumi.get(self, "physport")

    @property
    @pulumi.getter(name="routedSubnets")
    def routed_subnets(self) -> Sequence['outputs.GetMagicTransitSiteLansResultRoutedSubnetResult']:
        return pulumi.get(self, "routed_subnets")

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter(name="staticAddressing")
    def static_addressing(self) -> 'outputs.GetMagicTransitSiteLansResultStaticAddressingResult':
        """
        If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
        """
        return pulumi.get(self, "static_addressing")

    @property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> int:
        """
        VLAN port number.
        """
        return pulumi.get(self, "vlan_tag")


@pulumi.output_type
class GetMagicTransitSiteLansResultNatResult(dict):
    def __init__(__self__, *,
                 static_prefix: str):
        """
        :param str static_prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "static_prefix", static_prefix)

    @property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class GetMagicTransitSiteLansResultRoutedSubnetResult(dict):
    def __init__(__self__, *,
                 nat: 'outputs.GetMagicTransitSiteLansResultRoutedSubnetNatResult',
                 next_hop: str,
                 prefix: str):
        """
        :param str next_hop: A valid IPv4 address.
        :param str prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def nat(self) -> 'outputs.GetMagicTransitSiteLansResultRoutedSubnetNatResult':
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetMagicTransitSiteLansResultRoutedSubnetNatResult(dict):
    def __init__(__self__, *,
                 static_prefix: str):
        """
        :param str static_prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "static_prefix", static_prefix)

    @property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")


@pulumi.output_type
class GetMagicTransitSiteLansResultStaticAddressingResult(dict):
    def __init__(__self__, *,
                 address: str,
                 dhcp_relay: 'outputs.GetMagicTransitSiteLansResultStaticAddressingDhcpRelayResult',
                 dhcp_server: 'outputs.GetMagicTransitSiteLansResultStaticAddressingDhcpServerResult',
                 secondary_address: str,
                 virtual_address: str):
        """
        :param str address: A valid CIDR notation representing an IP range.
        :param str secondary_address: A valid CIDR notation representing an IP range.
        :param str virtual_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "dhcp_relay", dhcp_relay)
        pulumi.set(__self__, "dhcp_server", dhcp_server)
        pulumi.set(__self__, "secondary_address", secondary_address)
        pulumi.set(__self__, "virtual_address", virtual_address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="dhcpRelay")
    def dhcp_relay(self) -> 'outputs.GetMagicTransitSiteLansResultStaticAddressingDhcpRelayResult':
        return pulumi.get(self, "dhcp_relay")

    @property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> 'outputs.GetMagicTransitSiteLansResultStaticAddressingDhcpServerResult':
        return pulumi.get(self, "dhcp_server")

    @property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")

    @property
    @pulumi.getter(name="virtualAddress")
    def virtual_address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "virtual_address")


@pulumi.output_type
class GetMagicTransitSiteLansResultStaticAddressingDhcpRelayResult(dict):
    def __init__(__self__, *,
                 server_addresses: Sequence[str]):
        """
        :param Sequence[str] server_addresses: List of DHCP server IPs.
        """
        pulumi.set(__self__, "server_addresses", server_addresses)

    @property
    @pulumi.getter(name="serverAddresses")
    def server_addresses(self) -> Sequence[str]:
        """
        List of DHCP server IPs.
        """
        return pulumi.get(self, "server_addresses")


@pulumi.output_type
class GetMagicTransitSiteLansResultStaticAddressingDhcpServerResult(dict):
    def __init__(__self__, *,
                 dhcp_pool_end: str,
                 dhcp_pool_start: str,
                 dns_server: str,
<<<<<<< HEAD
=======
                 dns_servers: Sequence[str],
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 reservations: Mapping[str, str]):
        """
        :param str dhcp_pool_end: A valid IPv4 address.
        :param str dhcp_pool_start: A valid IPv4 address.
        :param str dns_server: A valid IPv4 address.
        :param Mapping[str, str] reservations: Mapping of MAC addresses to IP addresses
        """
        pulumi.set(__self__, "dhcp_pool_end", dhcp_pool_end)
        pulumi.set(__self__, "dhcp_pool_start", dhcp_pool_start)
        pulumi.set(__self__, "dns_server", dns_server)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "dns_servers", dns_servers)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "reservations", reservations)

    @property
    @pulumi.getter(name="dhcpPoolEnd")
    def dhcp_pool_end(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_end")

    @property
    @pulumi.getter(name="dhcpPoolStart")
    def dhcp_pool_start(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_start")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dns_server")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        return pulumi.get(self, "dns_servers")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def reservations(self) -> Mapping[str, str]:
        """
        Mapping of MAC addresses to IP addresses
        """
        return pulumi.get(self, "reservations")


@pulumi.output_type
class GetMagicTransitSiteLocationResult(dict):
    def __init__(__self__, *,
                 lat: str,
                 lon: str):
        """
        :param str lat: Latitude
        :param str lon: Longitude
        """
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lon", lon)

    @property
    @pulumi.getter
    def lat(self) -> str:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> str:
        """
        Longitude
        """
        return pulumi.get(self, "lon")


@pulumi.output_type
class GetMagicTransitSiteWanStaticAddressingResult(dict):
    def __init__(__self__, *,
                 address: str,
                 gateway_address: str,
                 secondary_address: str):
        """
        :param str address: A valid CIDR notation representing an IP range.
        :param str gateway_address: A valid IPv4 address.
        :param str secondary_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "gateway_address", gateway_address)
        pulumi.set(__self__, "secondary_address", secondary_address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="gatewayAddress")
    def gateway_address(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "gateway_address")

    @property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")


@pulumi.output_type
class GetMagicTransitSiteWansResultResult(dict):
    def __init__(__self__, *,
                 health_check_rate: str,
                 id: str,
                 name: str,
                 physport: int,
                 priority: int,
                 site_id: str,
                 static_addressing: 'outputs.GetMagicTransitSiteWansResultStaticAddressingResult',
                 vlan_tag: int):
        """
        :param str health_check_rate: Magic WAN health check rate for tunnels created on this link. The default value is `mid`.
        :param str id: Identifier
        :param int priority: Priority of WAN for traffic loadbalancing.
        :param str site_id: Identifier
        :param 'GetMagicTransitSiteWansResultStaticAddressingArgs' static_addressing: (optional) if omitted, use DHCP. Submit secondary*address when site is in high availability mode.
        :param int vlan_tag: VLAN port number.
        """
        pulumi.set(__self__, "health_check_rate", health_check_rate)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "physport", physport)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "static_addressing", static_addressing)
        pulumi.set(__self__, "vlan_tag", vlan_tag)

    @property
    @pulumi.getter(name="healthCheckRate")
    def health_check_rate(self) -> str:
        """
        Magic WAN health check rate for tunnels created on this link. The default value is `mid`.
        """
        return pulumi.get(self, "health_check_rate")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def physport(self) -> int:
        return pulumi.get(self, "physport")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Priority of WAN for traffic loadbalancing.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter(name="staticAddressing")
    def static_addressing(self) -> 'outputs.GetMagicTransitSiteWansResultStaticAddressingResult':
        """
        (optional) if omitted, use DHCP. Submit secondary*address when site is in high availability mode.
        """
        return pulumi.get(self, "static_addressing")

    @property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> int:
        """
        VLAN port number.
        """
        return pulumi.get(self, "vlan_tag")


@pulumi.output_type
class GetMagicTransitSiteWansResultStaticAddressingResult(dict):
    def __init__(__self__, *,
                 address: str,
                 gateway_address: str,
                 secondary_address: str):
        """
        :param str address: A valid CIDR notation representing an IP range.
        :param str gateway_address: A valid IPv4 address.
        :param str secondary_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "gateway_address", gateway_address)
        pulumi.set(__self__, "secondary_address", secondary_address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="gatewayAddress")
    def gateway_address(self) -> str:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "gateway_address")

    @property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> str:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")


@pulumi.output_type
class GetMagicTransitSitesResultResult(dict):
    def __init__(__self__, *,
                 connector_id: str,
                 description: str,
                 ha_mode: bool,
                 id: str,
                 location: 'outputs.GetMagicTransitSitesResultLocationResult',
                 name: str,
                 secondary_connector_id: str):
        """
        :param str connector_id: Magic Connector identifier tag.
        :param bool ha_mode: Site high availability mode. If set to true, the site can have two connectors and runs in high availability mode.
        :param str id: Identifier
        :param 'GetMagicTransitSitesResultLocationArgs' location: Location of site in latitude and longitude.
        :param str name: The name of the site.
        :param str secondary_connector_id: Magic Connector identifier tag. Used when high availability mode is on.
        """
        pulumi.set(__self__, "connector_id", connector_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ha_mode", ha_mode)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secondary_connector_id", secondary_connector_id)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> str:
        """
        Magic Connector identifier tag.
        """
        return pulumi.get(self, "connector_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="haMode")
    def ha_mode(self) -> bool:
        """
        Site high availability mode. If set to true, the site can have two connectors and runs in high availability mode.
        """
        return pulumi.get(self, "ha_mode")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> 'outputs.GetMagicTransitSitesResultLocationResult':
        """
        Location of site in latitude and longitude.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the site.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secondaryConnectorId")
    def secondary_connector_id(self) -> str:
        """
        Magic Connector identifier tag. Used when high availability mode is on.
        """
        return pulumi.get(self, "secondary_connector_id")


@pulumi.output_type
class GetMagicTransitSitesResultLocationResult(dict):
    def __init__(__self__, *,
                 lat: str,
                 lon: str):
        """
        :param str lat: Latitude
        :param str lon: Longitude
        """
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lon", lon)

    @property
    @pulumi.getter
    def lat(self) -> str:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> str:
        """
        Longitude
        """
        return pulumi.get(self, "lon")


@pulumi.output_type
class GetMagicWanGreTunnelGreTunnelResult(dict):
    def __init__(__self__, *,
                 cloudflare_gre_endpoint: str,
                 created_on: str,
                 customer_gre_endpoint: str,
                 description: str,
                 health_check: 'outputs.GetMagicWanGreTunnelGreTunnelHealthCheckResult',
                 id: str,
                 interface_address: str,
                 modified_on: str,
                 mtu: int,
                 name: str,
                 ttl: int):
        """
        :param str cloudflare_gre_endpoint: The IP address assigned to the Cloudflare side of the GRE tunnel.
        :param str created_on: The date and time the tunnel was created.
        :param str customer_gre_endpoint: The IP address assigned to the customer side of the GRE tunnel.
        :param str description: An optional description of the GRE tunnel.
        :param str id: Tunnel identifier tag.
        :param str interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        :param str modified_on: The date and time the tunnel was last modified.
        :param int mtu: Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        :param str name: The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        :param int ttl: Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        pulumi.set(__self__, "cloudflare_gre_endpoint", cloudflare_gre_endpoint)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "customer_gre_endpoint", customer_gre_endpoint)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interface_address", interface_address)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "mtu", mtu)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="cloudflareGreEndpoint")
    def cloudflare_gre_endpoint(self) -> str:
        """
        The IP address assigned to the Cloudflare side of the GRE tunnel.
        """
        return pulumi.get(self, "cloudflare_gre_endpoint")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="customerGreEndpoint")
    def customer_gre_endpoint(self) -> str:
        """
        The IP address assigned to the customer side of the GRE tunnel.
        """
        return pulumi.get(self, "customer_gre_endpoint")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An optional description of the GRE tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> 'outputs.GetMagicWanGreTunnelGreTunnelHealthCheckResult':
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> str:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def mtu(self) -> int:
        """
        Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetMagicWanGreTunnelGreTunnelHealthCheckResult(dict):
    def __init__(__self__, *,
                 direction: str,
                 enabled: bool,
                 rate: str,
                 target: 'outputs.GetMagicWanGreTunnelGreTunnelHealthCheckTargetResult',
                 type: str):
        """
        :param str direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param bool enabled: Determines whether to run healthchecks for a tunnel.
        :param str rate: How frequent the health check is run. The default value is `mid`.
        :param 'GetMagicWanGreTunnelGreTunnelHealthCheckTargetArgs' target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param str type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "rate", rate)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rate(self) -> str:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter
    def target(self) -> 'outputs.GetMagicWanGreTunnelGreTunnelHealthCheckTargetResult':
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMagicWanGreTunnelGreTunnelHealthCheckTargetResult(dict):
    def __init__(__self__, *,
                 effective: str,
                 saved: str):
        """
        :param str effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param str saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        pulumi.set(__self__, "effective", effective)
        pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> str:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @property
    @pulumi.getter
    def saved(self) -> str:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")


@pulumi.output_type
class GetMagicWanIpsecTunnelIpsecTunnelResult(dict):
    def __init__(__self__, *,
                 allow_null_cipher: bool,
                 cloudflare_endpoint: str,
                 created_on: str,
                 customer_endpoint: str,
                 description: str,
                 health_check: 'outputs.GetMagicWanIpsecTunnelIpsecTunnelHealthCheckResult',
                 id: str,
                 interface_address: str,
                 modified_on: str,
                 name: str,
                 psk_metadata: 'outputs.GetMagicWanIpsecTunnelIpsecTunnelPskMetadataResult',
                 replay_protection: bool):
        """
        :param bool allow_null_cipher: When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        :param str cloudflare_endpoint: The IP address assigned to the Cloudflare side of the IPsec tunnel.
        :param str created_on: The date and time the tunnel was created.
        :param str customer_endpoint: The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        :param str description: An optional description forthe IPsec tunnel.
        :param str id: Tunnel identifier tag.
        :param str interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        :param str modified_on: The date and time the tunnel was last modified.
        :param str name: The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        :param 'GetMagicWanIpsecTunnelIpsecTunnelPskMetadataArgs' psk_metadata: The PSK metadata that includes when the PSK was generated.
        :param bool replay_protection: If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        pulumi.set(__self__, "allow_null_cipher", allow_null_cipher)
        pulumi.set(__self__, "cloudflare_endpoint", cloudflare_endpoint)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "customer_endpoint", customer_endpoint)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interface_address", interface_address)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "psk_metadata", psk_metadata)
        pulumi.set(__self__, "replay_protection", replay_protection)

    @property
    @pulumi.getter(name="allowNullCipher")
    def allow_null_cipher(self) -> bool:
        """
        When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        """
        return pulumi.get(self, "allow_null_cipher")

    @property
    @pulumi.getter(name="cloudflareEndpoint")
    def cloudflare_endpoint(self) -> str:
        """
        The IP address assigned to the Cloudflare side of the IPsec tunnel.
        """
        return pulumi.get(self, "cloudflare_endpoint")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="customerEndpoint")
    def customer_endpoint(self) -> str:
        """
        The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        """
        return pulumi.get(self, "customer_endpoint")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An optional description forthe IPsec tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> 'outputs.GetMagicWanIpsecTunnelIpsecTunnelHealthCheckResult':
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> str:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pskMetadata")
    def psk_metadata(self) -> 'outputs.GetMagicWanIpsecTunnelIpsecTunnelPskMetadataResult':
        """
        The PSK metadata that includes when the PSK was generated.
        """
        return pulumi.get(self, "psk_metadata")

    @property
    @pulumi.getter(name="replayProtection")
    def replay_protection(self) -> bool:
        """
        If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        return pulumi.get(self, "replay_protection")


@pulumi.output_type
class GetMagicWanIpsecTunnelIpsecTunnelHealthCheckResult(dict):
    def __init__(__self__, *,
                 direction: str,
                 enabled: bool,
                 rate: str,
                 target: 'outputs.GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTargetResult',
                 type: str):
        """
        :param str direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param bool enabled: Determines whether to run healthchecks for a tunnel.
        :param str rate: How frequent the health check is run. The default value is `mid`.
        :param 'GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgs' target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param str type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "rate", rate)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rate(self) -> str:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter
    def target(self) -> 'outputs.GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTargetResult':
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTargetResult(dict):
    def __init__(__self__, *,
                 effective: str,
                 saved: str):
        """
        :param str effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param str saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        pulumi.set(__self__, "effective", effective)
        pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> str:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @property
    @pulumi.getter
    def saved(self) -> str:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")


@pulumi.output_type
class GetMagicWanIpsecTunnelIpsecTunnelPskMetadataResult(dict):
    def __init__(__self__, *,
                 last_generated_on: str):
        """
        :param str last_generated_on: The date and time the tunnel was last modified.
        """
        pulumi.set(__self__, "last_generated_on", last_generated_on)

    @property
    @pulumi.getter(name="lastGeneratedOn")
    def last_generated_on(self) -> str:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "last_generated_on")


@pulumi.output_type
class GetMagicWanStaticRouteRouteResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 description: str,
                 id: str,
                 modified_on: str,
                 nexthop: str,
                 prefix: str,
                 priority: int,
                 scope: 'outputs.GetMagicWanStaticRouteRouteScopeResult',
                 weight: int):
        """
        :param str created_on: When the route was created.
        :param str description: An optional human provided description of the static route.
        :param str id: Identifier
        :param str modified_on: When the route was last modified.
        :param str nexthop: The next-hop IP Address for the static route.
        :param str prefix: IP Prefix in Classless Inter-Domain Routing format.
        :param int priority: Priority of the static route.
        :param 'GetMagicWanStaticRouteRouteScopeArgs' scope: Used only for ECMP routes.
        :param int weight: Optional weight of the ECMP scope - if provided.
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "nexthop", nexthop)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the route was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An optional human provided description of the static route.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the route was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def nexthop(self) -> str:
        """
        The next-hop IP Address for the static route.
        """
        return pulumi.get(self, "nexthop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        IP Prefix in Classless Inter-Domain Routing format.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Priority of the static route.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def scope(self) -> 'outputs.GetMagicWanStaticRouteRouteScopeResult':
        """
        Used only for ECMP routes.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Optional weight of the ECMP scope - if provided.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetMagicWanStaticRouteRouteScopeResult(dict):
    def __init__(__self__, *,
                 colo_names: Sequence[str],
                 colo_regions: Sequence[str]):
        """
        :param Sequence[str] colo_names: List of colo names for the ECMP scope.
        :param Sequence[str] colo_regions: List of colo regions for the ECMP scope.
        """
        pulumi.set(__self__, "colo_names", colo_names)
        pulumi.set(__self__, "colo_regions", colo_regions)

    @property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Sequence[str]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Sequence[str]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")


@pulumi.output_type
class GetManagedTransformsManagedRequestHeaderResult(dict):
    def __init__(__self__, *,
                 conflicts_withs: Sequence[str],
                 enabled: bool,
                 has_conflict: bool,
                 id: str):
        """
        :param Sequence[str] conflicts_withs: The Managed Transforms that this Managed Transform conflicts with.
        :param bool enabled: Whether the Managed Transform is enabled.
        :param bool has_conflict: Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        :param str id: The human-readable identifier of the Managed Transform.
        """
        pulumi.set(__self__, "conflicts_withs", conflicts_withs)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "has_conflict", has_conflict)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="conflictsWiths")
    def conflicts_withs(self) -> Sequence[str]:
        """
        The Managed Transforms that this Managed Transform conflicts with.
        """
        return pulumi.get(self, "conflicts_withs")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="hasConflict")
    def has_conflict(self) -> bool:
        """
        Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        return pulumi.get(self, "has_conflict")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetManagedTransformsManagedResponseHeaderResult(dict):
    def __init__(__self__, *,
                 conflicts_withs: Sequence[str],
                 enabled: bool,
                 has_conflict: bool,
                 id: str):
        """
        :param Sequence[str] conflicts_withs: The Managed Transforms that this Managed Transform conflicts with.
        :param bool enabled: Whether the Managed Transform is enabled.
        :param bool has_conflict: Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        :param str id: The human-readable identifier of the Managed Transform.
        """
        pulumi.set(__self__, "conflicts_withs", conflicts_withs)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "has_conflict", has_conflict)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="conflictsWiths")
    def conflicts_withs(self) -> Sequence[str]:
        """
        The Managed Transforms that this Managed Transform conflicts with.
        """
        return pulumi.get(self, "conflicts_withs")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="hasConflict")
    def has_conflict(self) -> bool:
        """
        Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        return pulumi.get(self, "has_conflict")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetMtlsCertificatesResultResult(dict):
    def __init__(__self__, *,
                 ca: bool,
                 certificates: str,
                 expires_on: str,
                 id: str,
                 issuer: str,
                 name: str,
                 serial_number: str,
                 signature: str,
                 uploaded_on: str):
        """
        :param bool ca: Indicates whether the certificate is a CA or leaf certificate.
        :param str certificates: The uploaded root CA certificate.
        :param str expires_on: When the certificate expires.
        :param str id: Identifier
        :param str issuer: The certificate authority that issued the certificate.
        :param str name: Optional unique name for the certificate. Only used for human readability.
        :param str serial_number: The certificate serial number.
        :param str signature: The type of hash used for the certificate.
        :param str uploaded_on: This is the time the certificate was uploaded.
        """
        pulumi.set(__self__, "ca", ca)
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serial_number", serial_number)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "uploaded_on", uploaded_on)

    @property
    @pulumi.getter
    def ca(self) -> bool:
        """
        Indicates whether the certificate is a CA or leaf certificate.
        """
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter
    def certificates(self) -> str:
        """
        The uploaded root CA certificate.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        """
        When the certificate expires.
        """
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The certificate authority that issued the certificate.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional unique name for the certificate. Only used for human readability.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> str:
        """
        The certificate serial number.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def signature(self) -> str:
        """
        The type of hash used for the certificate.
        """
        return pulumi.get(self, "signature")

    @property
    @pulumi.getter(name="uploadedOn")
    def uploaded_on(self) -> str:
        """
        This is the time the certificate was uploaded.
        """
        return pulumi.get(self, "uploaded_on")


@pulumi.output_type
class GetNotificationPoliciesResultResult(dict):
    def __init__(__self__, *,
                 alert_interval: str,
                 alert_type: str,
                 created: str,
                 description: str,
                 enabled: bool,
                 filters: 'outputs.GetNotificationPoliciesResultFiltersResult',
                 id: str,
                 mechanisms: 'outputs.GetNotificationPoliciesResultMechanismsResult',
                 modified: str,
                 name: str):
        """
        :param str alert_interval: Optional specification of how often to re-alert from the same incident, not support on all alert types.
        :param str alert_type: Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values.
        :param str description: Optional description for the Notification policy.
        :param bool enabled: Whether or not the Notification policy is enabled.
        :param 'GetNotificationPoliciesResultFiltersArgs' filters: Optional filters that allow you to be alerted only on a subset of events for that alert type based on some criteria. This is only available for select alert types. See alert type documentation for more details.
        :param str id: The unique identifier of a notification policy
        :param 'GetNotificationPoliciesResultMechanismsArgs' mechanisms: List of IDs that will be used when dispatching a notification. IDs for email type will be the email address.
        :param str name: Name of the policy.
        """
        pulumi.set(__self__, "alert_interval", alert_interval)
        pulumi.set(__self__, "alert_type", alert_type)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mechanisms", mechanisms)
        pulumi.set(__self__, "modified", modified)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="alertInterval")
    def alert_interval(self) -> str:
        """
        Optional specification of how often to re-alert from the same incident, not support on all alert types.
        """
        return pulumi.get(self, "alert_interval")

    @property
    @pulumi.getter(name="alertType")
    def alert_type(self) -> str:
        """
        Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values.
        """
        return pulumi.get(self, "alert_type")

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional description for the Notification policy.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not the Notification policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filters(self) -> 'outputs.GetNotificationPoliciesResultFiltersResult':
        """
        Optional filters that allow you to be alerted only on a subset of events for that alert type based on some criteria. This is only available for select alert types. See alert type documentation for more details.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of a notification policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mechanisms(self) -> 'outputs.GetNotificationPoliciesResultMechanismsResult':
        """
        List of IDs that will be used when dispatching a notification. IDs for email type will be the email address.
        """
        return pulumi.get(self, "mechanisms")

    @property
    @pulumi.getter
    def modified(self) -> str:
        return pulumi.get(self, "modified")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNotificationPoliciesResultFiltersResult(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 affected_asns: Sequence[str],
                 affected_components: Sequence[str],
                 affected_locations: Sequence[str],
                 airport_codes: Sequence[str],
                 alert_trigger_preferences: Sequence[str],
                 alert_trigger_preferences_values: Sequence[str],
                 enableds: Sequence[str],
                 environments: Sequence[str],
                 event_sources: Sequence[str],
                 event_types: Sequence[str],
                 events: Sequence[str],
                 group_bies: Sequence[str],
                 health_check_ids: Sequence[str],
                 incident_impacts: Sequence[str],
                 input_ids: Sequence[str],
                 insight_classes: Sequence[str],
                 limits: Sequence[str],
                 logo_tags: Sequence[str],
                 megabits_per_seconds: Sequence[str],
                 new_healths: Sequence[str],
                 new_statuses: Sequence[str],
                 packets_per_seconds: Sequence[str],
                 pool_ids: Sequence[str],
                 pop_names: Sequence[str],
                 products: Sequence[str],
                 project_ids: Sequence[str],
                 protocols: Sequence[str],
                 query_tags: Sequence[str],
                 requests_per_seconds: Sequence[str],
                 selectors: Sequence[str],
                 services: Sequence[str],
                 slos: Sequence[str],
                 statuses: Sequence[str],
                 target_hostnames: Sequence[str],
                 target_ips: Sequence[str],
                 target_zone_names: Sequence[str],
                 traffic_exclusions: Sequence[str],
                 tunnel_ids: Sequence[str],
                 tunnel_names: Sequence[str],
                 wheres: Sequence[str],
                 zones: Sequence[str]):
        """
        :param Sequence[str] actions: Usage depends on specific alert type
        :param Sequence[str] affected_asns: Used for configuring radar_notification
        :param Sequence[str] affected_components: Used for configuring incident_alert
        :param Sequence[str] affected_locations: Used for configuring radar_notification
        :param Sequence[str] airport_codes: Used for configuring maintenance*event*notification
        :param Sequence[str] alert_trigger_preferences: Usage depends on specific alert type
        :param Sequence[str] alert_trigger_preferences_values: Usage depends on specific alert type
        :param Sequence[str] enableds: Used for configuring load*balancing*pool*enablement*alert
        :param Sequence[str] environments: Used for configuring pages*event*alert
        :param Sequence[str] event_sources: Used for configuring load*balancing*health_alert
        :param Sequence[str] event_types: Usage depends on specific alert type
        :param Sequence[str] events: Used for configuring pages*event*alert
        :param Sequence[str] group_bies: Usage depends on specific alert type
        :param Sequence[str] health_check_ids: Used for configuring health*check*status_notification
        :param Sequence[str] incident_impacts: Used for configuring incident_alert
        :param Sequence[str] input_ids: Used for configuring stream*live*notifications
        :param Sequence[str] insight_classes: Used for configuring security*insights*alert
        :param Sequence[str] limits: Used for configuring billing*usage*alert
        :param Sequence[str] logo_tags: Used for configuring logo*match*alert
        :param Sequence[str] megabits_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] new_healths: Used for configuring load*balancing*health_alert
        :param Sequence[str] new_statuses: Used for configuring tunnel*health*event
        :param Sequence[str] packets_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] pool_ids: Usage depends on specific alert type
        :param Sequence[str] pop_names: Usage depends on specific alert type
        :param Sequence[str] products: Used for configuring billing*usage*alert
        :param Sequence[str] project_ids: Used for configuring pages*event*alert
        :param Sequence[str] protocols: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] query_tags: Usage depends on specific alert type
        :param Sequence[str] requests_per_seconds: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] selectors: Usage depends on specific alert type
        :param Sequence[str] services: Used for configuring clickhouse*alert*fw*ent*anomaly
        :param Sequence[str] slos: Usage depends on specific alert type
        :param Sequence[str] statuses: Used for configuring health*check*status_notification
        :param Sequence[str] target_hostnames: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] target_ips: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] target_zone_names: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] traffic_exclusions: Used for configuring traffic*anomalies*alert
        :param Sequence[str] tunnel_ids: Used for configuring tunnel*health*event
        :param Sequence[str] tunnel_names: Usage depends on specific alert type
        :param Sequence[str] wheres: Usage depends on specific alert type
        :param Sequence[str] zones: Usage depends on specific alert type
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "affected_asns", affected_asns)
        pulumi.set(__self__, "affected_components", affected_components)
        pulumi.set(__self__, "affected_locations", affected_locations)
        pulumi.set(__self__, "airport_codes", airport_codes)
        pulumi.set(__self__, "alert_trigger_preferences", alert_trigger_preferences)
        pulumi.set(__self__, "alert_trigger_preferences_values", alert_trigger_preferences_values)
        pulumi.set(__self__, "enableds", enableds)
        pulumi.set(__self__, "environments", environments)
        pulumi.set(__self__, "event_sources", event_sources)
        pulumi.set(__self__, "event_types", event_types)
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "health_check_ids", health_check_ids)
        pulumi.set(__self__, "incident_impacts", incident_impacts)
        pulumi.set(__self__, "input_ids", input_ids)
        pulumi.set(__self__, "insight_classes", insight_classes)
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "logo_tags", logo_tags)
        pulumi.set(__self__, "megabits_per_seconds", megabits_per_seconds)
        pulumi.set(__self__, "new_healths", new_healths)
        pulumi.set(__self__, "new_statuses", new_statuses)
        pulumi.set(__self__, "packets_per_seconds", packets_per_seconds)
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop_names", pop_names)
        pulumi.set(__self__, "products", products)
        pulumi.set(__self__, "project_ids", project_ids)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "query_tags", query_tags)
        pulumi.set(__self__, "requests_per_seconds", requests_per_seconds)
        pulumi.set(__self__, "selectors", selectors)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "slos", slos)
        pulumi.set(__self__, "statuses", statuses)
        pulumi.set(__self__, "target_hostnames", target_hostnames)
        pulumi.set(__self__, "target_ips", target_ips)
        pulumi.set(__self__, "target_zone_names", target_zone_names)
        pulumi.set(__self__, "traffic_exclusions", traffic_exclusions)
        pulumi.set(__self__, "tunnel_ids", tunnel_ids)
        pulumi.set(__self__, "tunnel_names", tunnel_names)
        pulumi.set(__self__, "wheres", wheres)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="affectedAsns")
    def affected_asns(self) -> Sequence[str]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_asns")

    @property
    @pulumi.getter(name="affectedComponents")
    def affected_components(self) -> Sequence[str]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "affected_components")

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> Sequence[str]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="airportCodes")
    def airport_codes(self) -> Sequence[str]:
        """
        Used for configuring maintenance*event*notification
        """
        return pulumi.get(self, "airport_codes")

    @property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @property
    @pulumi.getter(name="alertTriggerPreferencesValues")
    def alert_trigger_preferences_values(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences_values")

    @property
    @pulumi.getter
    def enableds(self) -> Sequence[str]:
        """
        Used for configuring load*balancing*pool*enablement*alert
        """
        return pulumi.get(self, "enableds")

    @property
    @pulumi.getter
    def environments(self) -> Sequence[str]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Sequence[str]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "event_sources")

    @property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "event_types")

    @property
    @pulumi.getter
    def events(self) -> Sequence[str]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Sequence[str]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "health_check_ids")

    @property
    @pulumi.getter(name="incidentImpacts")
    def incident_impacts(self) -> Sequence[str]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "incident_impacts")

    @property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Sequence[str]:
        """
        Used for configuring stream*live*notifications
        """
        return pulumi.get(self, "input_ids")

    @property
    @pulumi.getter(name="insightClasses")
    def insight_classes(self) -> Sequence[str]:
        """
        Used for configuring security*insights*alert
        """
        return pulumi.get(self, "insight_classes")

    @property
    @pulumi.getter
    def limits(self) -> Sequence[str]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="logoTags")
    def logo_tags(self) -> Sequence[str]:
        """
        Used for configuring logo*match*alert
        """
        return pulumi.get(self, "logo_tags")

    @property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "megabits_per_seconds")

    @property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Sequence[str]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "new_healths")

    @property
    @pulumi.getter(name="newStatuses")
    def new_statuses(self) -> Sequence[str]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "new_statuses")

    @property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "packets_per_seconds")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter(name="popNames")
    def pop_names(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pop_names")

    @property
    @pulumi.getter
    def products(self) -> Sequence[str]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Sequence[str]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "project_ids")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="queryTags")
    def query_tags(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "query_tags")

    @property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "requests_per_seconds")

    @property
    @pulumi.getter
    def selectors(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "selectors")

    @property
    @pulumi.getter
    def services(self) -> Sequence[str]:
        """
        Used for configuring clickhouse*alert*fw*ent*anomaly
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def slos(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "slos")

    @property
    @pulumi.getter
    def statuses(self) -> Sequence[str]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_hostnames")

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "target_ips")

    @property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_zone_names")

    @property
    @pulumi.getter(name="trafficExclusions")
    def traffic_exclusions(self) -> Sequence[str]:
        """
        Used for configuring traffic*anomalies*alert
        """
        return pulumi.get(self, "traffic_exclusions")

    @property
    @pulumi.getter(name="tunnelIds")
    def tunnel_ids(self) -> Sequence[str]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "tunnel_ids")

    @property
    @pulumi.getter(name="tunnelNames")
    def tunnel_names(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "tunnel_names")

    @property
    @pulumi.getter
    def wheres(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "wheres")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetNotificationPoliciesResultMechanismsResult(dict):
    def __init__(__self__, *,
                 emails: Sequence['outputs.GetNotificationPoliciesResultMechanismsEmailResult'],
                 pagerduties: Sequence['outputs.GetNotificationPoliciesResultMechanismsPagerdutyResult'],
                 webhooks: Sequence['outputs.GetNotificationPoliciesResultMechanismsWebhookResult']):
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "pagerduties", pagerduties)
        pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter
    def emails(self) -> Sequence['outputs.GetNotificationPoliciesResultMechanismsEmailResult']:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def pagerduties(self) -> Sequence['outputs.GetNotificationPoliciesResultMechanismsPagerdutyResult']:
        return pulumi.get(self, "pagerduties")

    @property
    @pulumi.getter
    def webhooks(self) -> Sequence['outputs.GetNotificationPoliciesResultMechanismsWebhookResult']:
        return pulumi.get(self, "webhooks")


@pulumi.output_type
class GetNotificationPoliciesResultMechanismsEmailResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The email address
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The email address
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNotificationPoliciesResultMechanismsPagerdutyResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: UUID
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNotificationPoliciesResultMechanismsWebhookResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: UUID
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNotificationPolicyFiltersResult(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 affected_asns: Sequence[str],
                 affected_components: Sequence[str],
                 affected_locations: Sequence[str],
                 airport_codes: Sequence[str],
                 alert_trigger_preferences: Sequence[str],
                 alert_trigger_preferences_values: Sequence[str],
                 enableds: Sequence[str],
                 environments: Sequence[str],
                 event_sources: Sequence[str],
                 event_types: Sequence[str],
                 events: Sequence[str],
                 group_bies: Sequence[str],
                 health_check_ids: Sequence[str],
                 incident_impacts: Sequence[str],
                 input_ids: Sequence[str],
                 insight_classes: Sequence[str],
                 limits: Sequence[str],
                 logo_tags: Sequence[str],
                 megabits_per_seconds: Sequence[str],
                 new_healths: Sequence[str],
                 new_statuses: Sequence[str],
                 packets_per_seconds: Sequence[str],
                 pool_ids: Sequence[str],
                 pop_names: Sequence[str],
                 products: Sequence[str],
                 project_ids: Sequence[str],
                 protocols: Sequence[str],
                 query_tags: Sequence[str],
                 requests_per_seconds: Sequence[str],
                 selectors: Sequence[str],
                 services: Sequence[str],
                 slos: Sequence[str],
                 statuses: Sequence[str],
                 target_hostnames: Sequence[str],
                 target_ips: Sequence[str],
                 target_zone_names: Sequence[str],
                 traffic_exclusions: Sequence[str],
                 tunnel_ids: Sequence[str],
                 tunnel_names: Sequence[str],
                 wheres: Sequence[str],
                 zones: Sequence[str]):
        """
        :param Sequence[str] actions: Usage depends on specific alert type
        :param Sequence[str] affected_asns: Used for configuring radar_notification
        :param Sequence[str] affected_components: Used for configuring incident_alert
        :param Sequence[str] affected_locations: Used for configuring radar_notification
        :param Sequence[str] airport_codes: Used for configuring maintenance*event*notification
        :param Sequence[str] alert_trigger_preferences: Usage depends on specific alert type
        :param Sequence[str] alert_trigger_preferences_values: Usage depends on specific alert type
        :param Sequence[str] enableds: Used for configuring load*balancing*pool*enablement*alert
        :param Sequence[str] environments: Used for configuring pages*event*alert
        :param Sequence[str] event_sources: Used for configuring load*balancing*health_alert
        :param Sequence[str] event_types: Usage depends on specific alert type
        :param Sequence[str] events: Used for configuring pages*event*alert
        :param Sequence[str] group_bies: Usage depends on specific alert type
        :param Sequence[str] health_check_ids: Used for configuring health*check*status_notification
        :param Sequence[str] incident_impacts: Used for configuring incident_alert
        :param Sequence[str] input_ids: Used for configuring stream*live*notifications
        :param Sequence[str] insight_classes: Used for configuring security*insights*alert
        :param Sequence[str] limits: Used for configuring billing*usage*alert
        :param Sequence[str] logo_tags: Used for configuring logo*match*alert
        :param Sequence[str] megabits_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] new_healths: Used for configuring load*balancing*health_alert
        :param Sequence[str] new_statuses: Used for configuring tunnel*health*event
        :param Sequence[str] packets_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] pool_ids: Usage depends on specific alert type
        :param Sequence[str] pop_names: Usage depends on specific alert type
        :param Sequence[str] products: Used for configuring billing*usage*alert
        :param Sequence[str] project_ids: Used for configuring pages*event*alert
        :param Sequence[str] protocols: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] query_tags: Usage depends on specific alert type
        :param Sequence[str] requests_per_seconds: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] selectors: Usage depends on specific alert type
        :param Sequence[str] services: Used for configuring clickhouse*alert*fw*ent*anomaly
        :param Sequence[str] slos: Usage depends on specific alert type
        :param Sequence[str] statuses: Used for configuring health*check*status_notification
        :param Sequence[str] target_hostnames: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] target_ips: Used for configuring advanced*ddos*attack*l4*alert
        :param Sequence[str] target_zone_names: Used for configuring advanced*ddos*attack*l7*alert
        :param Sequence[str] traffic_exclusions: Used for configuring traffic*anomalies*alert
        :param Sequence[str] tunnel_ids: Used for configuring tunnel*health*event
        :param Sequence[str] tunnel_names: Usage depends on specific alert type
        :param Sequence[str] wheres: Usage depends on specific alert type
        :param Sequence[str] zones: Usage depends on specific alert type
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "affected_asns", affected_asns)
        pulumi.set(__self__, "affected_components", affected_components)
        pulumi.set(__self__, "affected_locations", affected_locations)
        pulumi.set(__self__, "airport_codes", airport_codes)
        pulumi.set(__self__, "alert_trigger_preferences", alert_trigger_preferences)
        pulumi.set(__self__, "alert_trigger_preferences_values", alert_trigger_preferences_values)
        pulumi.set(__self__, "enableds", enableds)
        pulumi.set(__self__, "environments", environments)
        pulumi.set(__self__, "event_sources", event_sources)
        pulumi.set(__self__, "event_types", event_types)
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "health_check_ids", health_check_ids)
        pulumi.set(__self__, "incident_impacts", incident_impacts)
        pulumi.set(__self__, "input_ids", input_ids)
        pulumi.set(__self__, "insight_classes", insight_classes)
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "logo_tags", logo_tags)
        pulumi.set(__self__, "megabits_per_seconds", megabits_per_seconds)
        pulumi.set(__self__, "new_healths", new_healths)
        pulumi.set(__self__, "new_statuses", new_statuses)
        pulumi.set(__self__, "packets_per_seconds", packets_per_seconds)
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop_names", pop_names)
        pulumi.set(__self__, "products", products)
        pulumi.set(__self__, "project_ids", project_ids)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "query_tags", query_tags)
        pulumi.set(__self__, "requests_per_seconds", requests_per_seconds)
        pulumi.set(__self__, "selectors", selectors)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "slos", slos)
        pulumi.set(__self__, "statuses", statuses)
        pulumi.set(__self__, "target_hostnames", target_hostnames)
        pulumi.set(__self__, "target_ips", target_ips)
        pulumi.set(__self__, "target_zone_names", target_zone_names)
        pulumi.set(__self__, "traffic_exclusions", traffic_exclusions)
        pulumi.set(__self__, "tunnel_ids", tunnel_ids)
        pulumi.set(__self__, "tunnel_names", tunnel_names)
        pulumi.set(__self__, "wheres", wheres)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="affectedAsns")
    def affected_asns(self) -> Sequence[str]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_asns")

    @property
    @pulumi.getter(name="affectedComponents")
    def affected_components(self) -> Sequence[str]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "affected_components")

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> Sequence[str]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="airportCodes")
    def airport_codes(self) -> Sequence[str]:
        """
        Used for configuring maintenance*event*notification
        """
        return pulumi.get(self, "airport_codes")

    @property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @property
    @pulumi.getter(name="alertTriggerPreferencesValues")
    def alert_trigger_preferences_values(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences_values")

    @property
    @pulumi.getter
    def enableds(self) -> Sequence[str]:
        """
        Used for configuring load*balancing*pool*enablement*alert
        """
        return pulumi.get(self, "enableds")

    @property
    @pulumi.getter
    def environments(self) -> Sequence[str]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Sequence[str]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "event_sources")

    @property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "event_types")

    @property
    @pulumi.getter
    def events(self) -> Sequence[str]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Sequence[str]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "health_check_ids")

    @property
    @pulumi.getter(name="incidentImpacts")
    def incident_impacts(self) -> Sequence[str]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "incident_impacts")

    @property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Sequence[str]:
        """
        Used for configuring stream*live*notifications
        """
        return pulumi.get(self, "input_ids")

    @property
    @pulumi.getter(name="insightClasses")
    def insight_classes(self) -> Sequence[str]:
        """
        Used for configuring security*insights*alert
        """
        return pulumi.get(self, "insight_classes")

    @property
    @pulumi.getter
    def limits(self) -> Sequence[str]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="logoTags")
    def logo_tags(self) -> Sequence[str]:
        """
        Used for configuring logo*match*alert
        """
        return pulumi.get(self, "logo_tags")

    @property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "megabits_per_seconds")

    @property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Sequence[str]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "new_healths")

    @property
    @pulumi.getter(name="newStatuses")
    def new_statuses(self) -> Sequence[str]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "new_statuses")

    @property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "packets_per_seconds")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter(name="popNames")
    def pop_names(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pop_names")

    @property
    @pulumi.getter
    def products(self) -> Sequence[str]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Sequence[str]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "project_ids")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="queryTags")
    def query_tags(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "query_tags")

    @property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "requests_per_seconds")

    @property
    @pulumi.getter
    def selectors(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "selectors")

    @property
    @pulumi.getter
    def services(self) -> Sequence[str]:
        """
        Used for configuring clickhouse*alert*fw*ent*anomaly
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def slos(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "slos")

    @property
    @pulumi.getter
    def statuses(self) -> Sequence[str]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_hostnames")

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "target_ips")

    @property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Sequence[str]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_zone_names")

    @property
    @pulumi.getter(name="trafficExclusions")
    def traffic_exclusions(self) -> Sequence[str]:
        """
        Used for configuring traffic*anomalies*alert
        """
        return pulumi.get(self, "traffic_exclusions")

    @property
    @pulumi.getter(name="tunnelIds")
    def tunnel_ids(self) -> Sequence[str]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "tunnel_ids")

    @property
    @pulumi.getter(name="tunnelNames")
    def tunnel_names(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "tunnel_names")

    @property
    @pulumi.getter
    def wheres(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "wheres")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetNotificationPolicyMechanismsResult(dict):
    def __init__(__self__, *,
                 emails: Sequence['outputs.GetNotificationPolicyMechanismsEmailResult'],
                 pagerduties: Sequence['outputs.GetNotificationPolicyMechanismsPagerdutyResult'],
                 webhooks: Sequence['outputs.GetNotificationPolicyMechanismsWebhookResult']):
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "pagerduties", pagerduties)
        pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter
    def emails(self) -> Sequence['outputs.GetNotificationPolicyMechanismsEmailResult']:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def pagerduties(self) -> Sequence['outputs.GetNotificationPolicyMechanismsPagerdutyResult']:
        return pulumi.get(self, "pagerduties")

    @property
    @pulumi.getter
    def webhooks(self) -> Sequence['outputs.GetNotificationPolicyMechanismsWebhookResult']:
        return pulumi.get(self, "webhooks")


@pulumi.output_type
class GetNotificationPolicyMechanismsEmailResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The email address
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The email address
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNotificationPolicyMechanismsPagerdutyResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: UUID
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNotificationPolicyMechanismsWebhookResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: UUID
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNotificationPolicyWebhooksListResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 last_failure: str,
                 last_success: str,
                 name: str,
                 secret: str,
                 type: str,
                 url: str):
        """
        :param str created_at: Timestamp of when the webhook destination was created.
        :param str id: The unique identifier of a webhook
        :param str last_failure: Timestamp of the last time an attempt to dispatch a notification to this webhook failed.
        :param str last_success: Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook.
        :param str name: The name of the webhook destination. This will be included in the request body when you receive a webhook notification.
        :param str secret: Optional secret that will be passed in the `cf-webhook-auth` header when dispatching generic webhook notifications or formatted for supported destinations. Secrets are not returned in any API response body.
        :param str type: Type of webhook endpoint.
        :param str url: The POST endpoint to call when dispatching a notification.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_failure", last_failure)
        pulumi.set(__self__, "last_success", last_success)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Timestamp of when the webhook destination was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of a webhook
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastFailure")
    def last_failure(self) -> str:
        """
        Timestamp of the last time an attempt to dispatch a notification to this webhook failed.
        """
        return pulumi.get(self, "last_failure")

    @property
    @pulumi.getter(name="lastSuccess")
    def last_success(self) -> str:
        """
        Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook.
        """
        return pulumi.get(self, "last_success")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the webhook destination. This will be included in the request body when you receive a webhook notification.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        Optional secret that will be passed in the `cf-webhook-auth` header when dispatching generic webhook notifications or formatted for supported destinations. Secrets are not returned in any API response body.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of webhook endpoint.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The POST endpoint to call when dispatching a notification.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetOriginCaCertificateFilterResult(dict):
    def __init__(__self__, *,
                 zone_id: Optional[str] = None):
        """
        :param str zone_id: Identifier
        """
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetOriginCaCertificatesResultResult(dict):
    def __init__(__self__, *,
                 certificate: str,
                 csr: str,
                 expires_on: str,
                 hostnames: Sequence[str],
                 id: str,
                 request_type: str,
                 requested_validity: float):
        """
        :param str certificate: The Origin CA certificate. Will be newline-encoded.
        :param str csr: The Certificate Signing Request (CSR). Must be newline-encoded.
        :param str expires_on: When the certificate will expire.
        :param Sequence[str] hostnames: Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate.
        :param str id: Identifier
        :param str request_type: Signature type desired on certificate ("origin-rsa" (rsa), "origin-ecc" (ecdsa), or "keyless-certificate" (for Keyless SSL servers).
        :param float requested_validity: The number of days for which the certificate should be valid.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "csr", csr)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "request_type", request_type)
        pulumi.set(__self__, "requested_validity", requested_validity)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The Origin CA certificate. Will be newline-encoded.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def csr(self) -> str:
        """
        The Certificate Signing Request (CSR). Must be newline-encoded.
        """
        return pulumi.get(self, "csr")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        """
        When the certificate will expire.
        """
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        Signature type desired on certificate ("origin-rsa" (rsa), "origin-ecc" (ecdsa), or "keyless-certificate" (for Keyless SSL servers).
        """
        return pulumi.get(self, "request_type")

    @property
    @pulumi.getter(name="requestedValidity")
    def requested_validity(self) -> float:
        """
        The number of days for which the certificate should be valid.
        """
        return pulumi.get(self, "requested_validity")


@pulumi.output_type
class GetPageShieldConnectionsListResultResult(dict):
    def __init__(__self__, *,
                 added_at: str,
                 domain_reported_malicious: bool,
                 first_page_url: str,
                 first_seen_at: str,
                 host: str,
                 id: str,
                 last_seen_at: str,
                 malicious_domain_categories: Sequence[str],
                 malicious_url_categories: Sequence[str],
                 page_urls: Sequence[str],
                 url: str,
                 url_contains_cdn_cgi_path: bool,
                 url_reported_malicious: bool):
        """
        :param str id: Identifier
        """
        pulumi.set(__self__, "added_at", added_at)
        pulumi.set(__self__, "domain_reported_malicious", domain_reported_malicious)
        pulumi.set(__self__, "first_page_url", first_page_url)
        pulumi.set(__self__, "first_seen_at", first_seen_at)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_seen_at", last_seen_at)
        pulumi.set(__self__, "malicious_domain_categories", malicious_domain_categories)
        pulumi.set(__self__, "malicious_url_categories", malicious_url_categories)
        pulumi.set(__self__, "page_urls", page_urls)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "url_contains_cdn_cgi_path", url_contains_cdn_cgi_path)
        pulumi.set(__self__, "url_reported_malicious", url_reported_malicious)

    @property
    @pulumi.getter(name="addedAt")
    def added_at(self) -> str:
        return pulumi.get(self, "added_at")

    @property
    @pulumi.getter(name="domainReportedMalicious")
    def domain_reported_malicious(self) -> bool:
        return pulumi.get(self, "domain_reported_malicious")

    @property
    @pulumi.getter(name="firstPageUrl")
    def first_page_url(self) -> str:
        return pulumi.get(self, "first_page_url")

    @property
    @pulumi.getter(name="firstSeenAt")
    def first_seen_at(self) -> str:
        return pulumi.get(self, "first_seen_at")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastSeenAt")
    def last_seen_at(self) -> str:
        return pulumi.get(self, "last_seen_at")

    @property
    @pulumi.getter(name="maliciousDomainCategories")
    def malicious_domain_categories(self) -> Sequence[str]:
        return pulumi.get(self, "malicious_domain_categories")

    @property
    @pulumi.getter(name="maliciousUrlCategories")
    def malicious_url_categories(self) -> Sequence[str]:
        return pulumi.get(self, "malicious_url_categories")

    @property
    @pulumi.getter(name="pageUrls")
    def page_urls(self) -> Sequence[str]:
        return pulumi.get(self, "page_urls")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="urlContainsCdnCgiPath")
    def url_contains_cdn_cgi_path(self) -> bool:
        return pulumi.get(self, "url_contains_cdn_cgi_path")

    @property
    @pulumi.getter(name="urlReportedMalicious")
    def url_reported_malicious(self) -> bool:
        return pulumi.get(self, "url_reported_malicious")


@pulumi.output_type
class GetPageShieldCookiesListResultResult(dict):
    def __init__(__self__, *,
                 domain_attribute: str,
                 expires_attribute: str,
                 first_seen_at: str,
                 host: str,
                 http_only_attribute: bool,
                 id: str,
                 last_seen_at: str,
                 max_age_attribute: int,
                 name: str,
                 page_urls: Sequence[str],
                 path_attribute: str,
                 same_site_attribute: str,
                 secure_attribute: bool,
                 type: str):
        """
        :param str id: Identifier
        """
        pulumi.set(__self__, "domain_attribute", domain_attribute)
        pulumi.set(__self__, "expires_attribute", expires_attribute)
        pulumi.set(__self__, "first_seen_at", first_seen_at)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http_only_attribute", http_only_attribute)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_seen_at", last_seen_at)
        pulumi.set(__self__, "max_age_attribute", max_age_attribute)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "page_urls", page_urls)
        pulumi.set(__self__, "path_attribute", path_attribute)
        pulumi.set(__self__, "same_site_attribute", same_site_attribute)
        pulumi.set(__self__, "secure_attribute", secure_attribute)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="domainAttribute")
    def domain_attribute(self) -> str:
        return pulumi.get(self, "domain_attribute")

    @property
    @pulumi.getter(name="expiresAttribute")
    def expires_attribute(self) -> str:
        return pulumi.get(self, "expires_attribute")

    @property
    @pulumi.getter(name="firstSeenAt")
    def first_seen_at(self) -> str:
        return pulumi.get(self, "first_seen_at")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpOnlyAttribute")
    def http_only_attribute(self) -> bool:
        return pulumi.get(self, "http_only_attribute")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastSeenAt")
    def last_seen_at(self) -> str:
        return pulumi.get(self, "last_seen_at")

    @property
    @pulumi.getter(name="maxAgeAttribute")
    def max_age_attribute(self) -> int:
        return pulumi.get(self, "max_age_attribute")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pageUrls")
    def page_urls(self) -> Sequence[str]:
        return pulumi.get(self, "page_urls")

    @property
    @pulumi.getter(name="pathAttribute")
    def path_attribute(self) -> str:
        return pulumi.get(self, "path_attribute")

    @property
    @pulumi.getter(name="sameSiteAttribute")
    def same_site_attribute(self) -> str:
        return pulumi.get(self, "same_site_attribute")

    @property
    @pulumi.getter(name="secureAttribute")
    def secure_attribute(self) -> bool:
        return pulumi.get(self, "secure_attribute")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPageShieldPoliciesResultResult(dict):
    def __init__(__self__, *,
                 action: str,
                 description: str,
                 enabled: bool,
                 expression: str,
                 id: str,
                 value: str):
        """
        :param str action: The action to take if the expression matches
        :param str description: A description for the policy
        :param bool enabled: Whether the policy is enabled
        :param str expression: The expression which must match for the policy to be applied, using the Cloudflare Firewall rule expression syntax
        :param str id: Identifier
        :param str value: The policy which will be applied
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take if the expression matches
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description for the policy
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the policy is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression which must match for the policy to be applied, using the Cloudflare Firewall rule expression syntax
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The policy which will be applied
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPageShieldScriptsListResultResult(dict):
    def __init__(__self__, *,
                 added_at: str,
                 cryptomining_score: int,
                 dataflow_score: int,
                 domain_reported_malicious: bool,
                 fetched_at: str,
                 first_page_url: str,
                 first_seen_at: str,
                 hash: str,
                 host: str,
                 id: str,
                 js_integrity_score: int,
                 last_seen_at: str,
                 magecart_score: int,
                 malicious_domain_categories: Sequence[str],
                 malicious_url_categories: Sequence[str],
                 malware_score: int,
                 obfuscation_score: int,
                 page_urls: Sequence[str],
                 url: str,
                 url_contains_cdn_cgi_path: bool,
                 url_reported_malicious: bool):
        """
        :param int cryptomining_score: The cryptomining score of the JavaScript content.
        :param int dataflow_score: The dataflow score of the JavaScript content.
        :param str fetched_at: The timestamp of when the script was last fetched.
        :param str hash: The computed hash of the analyzed script.
        :param str id: Identifier
        :param int js_integrity_score: The integrity score of the JavaScript content.
        :param int magecart_score: The magecart score of the JavaScript content.
        :param int malware_score: The malware score of the JavaScript content.
        :param int obfuscation_score: The obfuscation score of the JavaScript content.
        """
        pulumi.set(__self__, "added_at", added_at)
        pulumi.set(__self__, "cryptomining_score", cryptomining_score)
        pulumi.set(__self__, "dataflow_score", dataflow_score)
        pulumi.set(__self__, "domain_reported_malicious", domain_reported_malicious)
        pulumi.set(__self__, "fetched_at", fetched_at)
        pulumi.set(__self__, "first_page_url", first_page_url)
        pulumi.set(__self__, "first_seen_at", first_seen_at)
        pulumi.set(__self__, "hash", hash)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "js_integrity_score", js_integrity_score)
        pulumi.set(__self__, "last_seen_at", last_seen_at)
        pulumi.set(__self__, "magecart_score", magecart_score)
        pulumi.set(__self__, "malicious_domain_categories", malicious_domain_categories)
        pulumi.set(__self__, "malicious_url_categories", malicious_url_categories)
        pulumi.set(__self__, "malware_score", malware_score)
        pulumi.set(__self__, "obfuscation_score", obfuscation_score)
        pulumi.set(__self__, "page_urls", page_urls)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "url_contains_cdn_cgi_path", url_contains_cdn_cgi_path)
        pulumi.set(__self__, "url_reported_malicious", url_reported_malicious)

    @property
    @pulumi.getter(name="addedAt")
    def added_at(self) -> str:
        return pulumi.get(self, "added_at")

    @property
    @pulumi.getter(name="cryptominingScore")
    def cryptomining_score(self) -> int:
        """
        The cryptomining score of the JavaScript content.
        """
        return pulumi.get(self, "cryptomining_score")

    @property
    @pulumi.getter(name="dataflowScore")
    def dataflow_score(self) -> int:
        """
        The dataflow score of the JavaScript content.
        """
        return pulumi.get(self, "dataflow_score")

    @property
    @pulumi.getter(name="domainReportedMalicious")
    def domain_reported_malicious(self) -> bool:
        return pulumi.get(self, "domain_reported_malicious")

    @property
    @pulumi.getter(name="fetchedAt")
    def fetched_at(self) -> str:
        """
        The timestamp of when the script was last fetched.
        """
        return pulumi.get(self, "fetched_at")

    @property
    @pulumi.getter(name="firstPageUrl")
    def first_page_url(self) -> str:
        return pulumi.get(self, "first_page_url")

    @property
    @pulumi.getter(name="firstSeenAt")
    def first_seen_at(self) -> str:
        return pulumi.get(self, "first_seen_at")

    @property
    @pulumi.getter
    def hash(self) -> str:
        """
        The computed hash of the analyzed script.
        """
        return pulumi.get(self, "hash")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="jsIntegrityScore")
    def js_integrity_score(self) -> int:
        """
        The integrity score of the JavaScript content.
        """
        return pulumi.get(self, "js_integrity_score")

    @property
    @pulumi.getter(name="lastSeenAt")
    def last_seen_at(self) -> str:
        return pulumi.get(self, "last_seen_at")

    @property
    @pulumi.getter(name="magecartScore")
    def magecart_score(self) -> int:
        """
        The magecart score of the JavaScript content.
        """
        return pulumi.get(self, "magecart_score")

    @property
    @pulumi.getter(name="maliciousDomainCategories")
    def malicious_domain_categories(self) -> Sequence[str]:
        return pulumi.get(self, "malicious_domain_categories")

    @property
    @pulumi.getter(name="maliciousUrlCategories")
    def malicious_url_categories(self) -> Sequence[str]:
        return pulumi.get(self, "malicious_url_categories")

    @property
    @pulumi.getter(name="malwareScore")
    def malware_score(self) -> int:
        """
        The malware score of the JavaScript content.
        """
        return pulumi.get(self, "malware_score")

    @property
    @pulumi.getter(name="obfuscationScore")
    def obfuscation_score(self) -> int:
        """
        The obfuscation score of the JavaScript content.
        """
        return pulumi.get(self, "obfuscation_score")

    @property
    @pulumi.getter(name="pageUrls")
    def page_urls(self) -> Sequence[str]:
        return pulumi.get(self, "page_urls")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="urlContainsCdnCgiPath")
    def url_contains_cdn_cgi_path(self) -> bool:
        return pulumi.get(self, "url_contains_cdn_cgi_path")

    @property
    @pulumi.getter(name="urlReportedMalicious")
    def url_reported_malicious(self) -> bool:
        return pulumi.get(self, "url_reported_malicious")


@pulumi.output_type
class GetPageShieldScriptsVersionResult(dict):
    def __init__(__self__, *,
                 cryptomining_score: int,
                 dataflow_score: int,
                 fetched_at: str,
                 hash: str,
                 js_integrity_score: int,
                 magecart_score: int,
                 malware_score: int,
                 obfuscation_score: int):
        """
        :param int cryptomining_score: The cryptomining score of the JavaScript content.
        :param int dataflow_score: The dataflow score of the JavaScript content.
        :param str fetched_at: The timestamp of when the script was last fetched.
        :param str hash: The computed hash of the analyzed script.
        :param int js_integrity_score: The integrity score of the JavaScript content.
        :param int magecart_score: The magecart score of the JavaScript content.
        :param int malware_score: The malware score of the JavaScript content.
        :param int obfuscation_score: The obfuscation score of the JavaScript content.
        """
        pulumi.set(__self__, "cryptomining_score", cryptomining_score)
        pulumi.set(__self__, "dataflow_score", dataflow_score)
        pulumi.set(__self__, "fetched_at", fetched_at)
        pulumi.set(__self__, "hash", hash)
        pulumi.set(__self__, "js_integrity_score", js_integrity_score)
        pulumi.set(__self__, "magecart_score", magecart_score)
        pulumi.set(__self__, "malware_score", malware_score)
        pulumi.set(__self__, "obfuscation_score", obfuscation_score)

    @property
    @pulumi.getter(name="cryptominingScore")
    def cryptomining_score(self) -> int:
        """
        The cryptomining score of the JavaScript content.
        """
        return pulumi.get(self, "cryptomining_score")

    @property
    @pulumi.getter(name="dataflowScore")
    def dataflow_score(self) -> int:
        """
        The dataflow score of the JavaScript content.
        """
        return pulumi.get(self, "dataflow_score")

    @property
    @pulumi.getter(name="fetchedAt")
    def fetched_at(self) -> str:
        """
        The timestamp of when the script was last fetched.
        """
        return pulumi.get(self, "fetched_at")

    @property
    @pulumi.getter
    def hash(self) -> str:
        """
        The computed hash of the analyzed script.
        """
        return pulumi.get(self, "hash")

    @property
    @pulumi.getter(name="jsIntegrityScore")
    def js_integrity_score(self) -> int:
        """
        The integrity score of the JavaScript content.
        """
        return pulumi.get(self, "js_integrity_score")

    @property
    @pulumi.getter(name="magecartScore")
    def magecart_score(self) -> int:
        """
        The magecart score of the JavaScript content.
        """
        return pulumi.get(self, "magecart_score")

    @property
    @pulumi.getter(name="malwareScore")
    def malware_score(self) -> int:
        """
        The malware score of the JavaScript content.
        """
        return pulumi.get(self, "malware_score")

    @property
    @pulumi.getter(name="obfuscationScore")
    def obfuscation_score(self) -> int:
        """
        The obfuscation score of the JavaScript content.
        """
        return pulumi.get(self, "obfuscation_score")


@pulumi.output_type
class GetPagesDomainValidationDataResult(dict):
    def __init__(__self__, *,
                 error_message: str,
                 method: str,
                 status: str,
                 txt_name: str,
                 txt_value: str):
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "txt_name", txt_name)
        pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> str:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> str:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class GetPagesDomainVerificationDataResult(dict):
    def __init__(__self__, *,
                 error_message: str,
                 status: str):
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPagesDomainsResultResult(dict):
    def __init__(__self__, *,
                 certificate_authority: str,
                 created_on: str,
                 domain_id: str,
                 id: str,
                 name: str,
                 status: str,
                 validation_data: 'outputs.GetPagesDomainsResultValidationDataResult',
                 verification_data: 'outputs.GetPagesDomainsResultVerificationDataResult',
                 zone_tag: str):
        pulumi.set(__self__, "certificate_authority", certificate_authority)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "validation_data", validation_data)
        pulumi.set(__self__, "verification_data", verification_data)
        pulumi.set(__self__, "zone_tag", zone_tag)

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> str:
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> str:
        return pulumi.get(self, "domain_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> 'outputs.GetPagesDomainsResultValidationDataResult':
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="verificationData")
    def verification_data(self) -> 'outputs.GetPagesDomainsResultVerificationDataResult':
        return pulumi.get(self, "verification_data")

    @property
    @pulumi.getter(name="zoneTag")
    def zone_tag(self) -> str:
        return pulumi.get(self, "zone_tag")


@pulumi.output_type
class GetPagesDomainsResultValidationDataResult(dict):
    def __init__(__self__, *,
                 error_message: str,
                 method: str,
                 status: str,
                 txt_name: str,
                 txt_value: str):
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "txt_name", txt_name)
        pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> str:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> str:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class GetPagesDomainsResultVerificationDataResult(dict):
    def __init__(__self__, *,
                 error_message: str,
                 status: str):
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPagesProjectBuildConfigResult(dict):
    def __init__(__self__, *,
                 build_caching: bool,
                 build_command: str,
                 destination_dir: str,
                 root_dir: str,
                 web_analytics_tag: str,
                 web_analytics_token: str):
        """
        :param bool build_caching: Enable build caching for the project.
        :param str build_command: Command used to build project.
        :param str destination_dir: Output directory of the build.
        :param str root_dir: Directory to run the command.
        :param str web_analytics_tag: The classifying tag for analytics.
        :param str web_analytics_token: The auth token for analytics.
        """
        pulumi.set(__self__, "build_caching", build_caching)
        pulumi.set(__self__, "build_command", build_command)
        pulumi.set(__self__, "destination_dir", destination_dir)
        pulumi.set(__self__, "root_dir", root_dir)
        pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> bool:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> str:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> str:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> str:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> str:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> str:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentResult(dict):
    def __init__(__self__, *,
                 aliases: Sequence[str],
                 build_config: 'outputs.GetPagesProjectCanonicalDeploymentBuildConfigResult',
                 created_on: str,
                 deployment_trigger: 'outputs.GetPagesProjectCanonicalDeploymentDeploymentTriggerResult',
                 env_vars: Mapping[str, 'outputs.GetPagesProjectCanonicalDeploymentEnvVarsResult'],
                 environment: str,
                 id: str,
                 is_skipped: bool,
                 latest_stage: 'outputs.GetPagesProjectCanonicalDeploymentLatestStageResult',
                 modified_on: str,
                 project_id: str,
                 project_name: str,
                 short_id: str,
                 source: 'outputs.GetPagesProjectCanonicalDeploymentSourceResult',
                 stages: Sequence['outputs.GetPagesProjectCanonicalDeploymentStageResult'],
                 url: str):
        """
        :param Sequence[str] aliases: A list of alias URLs pointing to this deployment.
        :param 'GetPagesProjectCanonicalDeploymentBuildConfigArgs' build_config: Configs for the project build process.
        :param str created_on: When the deployment was created.
        :param 'GetPagesProjectCanonicalDeploymentDeploymentTriggerArgs' deployment_trigger: Info about what caused the deployment.
        :param Mapping[str, 'GetPagesProjectCanonicalDeploymentEnvVarsArgs'] env_vars: A dict of env variables to build this deploy.
        :param str environment: Type of deploy.
        :param str id: Id of the deployment.
        :param bool is_skipped: If the deployment has been skipped.
        :param 'GetPagesProjectCanonicalDeploymentLatestStageArgs' latest_stage: The status of the deployment.
        :param str modified_on: When the deployment was last modified.
        :param str project_id: Id of the project.
        :param str project_name: Name of the project.
        :param str short_id: Short Id (8 character) of the deployment.
        :param Sequence['GetPagesProjectCanonicalDeploymentStageArgs'] stages: List of past stages.
        :param str url: The live URL to view this deployment.
        """
        pulumi.set(__self__, "aliases", aliases)
        pulumi.set(__self__, "build_config", build_config)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        pulumi.set(__self__, "env_vars", env_vars)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_skipped", is_skipped)
        pulumi.set(__self__, "latest_stage", latest_stage)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "short_id", short_id)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "stages", stages)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def aliases(self) -> Sequence[str]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> 'outputs.GetPagesProjectCanonicalDeploymentBuildConfigResult':
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> 'outputs.GetPagesProjectCanonicalDeploymentDeploymentTriggerResult':
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Mapping[str, 'outputs.GetPagesProjectCanonicalDeploymentEnvVarsResult']:
        """
        A dict of env variables to build this deploy.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        Type of deploy.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> bool:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> 'outputs.GetPagesProjectCanonicalDeploymentLatestStageResult':
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> str:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.GetPagesProjectCanonicalDeploymentSourceResult':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def stages(self) -> Sequence['outputs.GetPagesProjectCanonicalDeploymentStageResult']:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentBuildConfigResult(dict):
    def __init__(__self__, *,
                 build_caching: bool,
                 build_command: str,
                 destination_dir: str,
                 root_dir: str,
                 web_analytics_tag: str,
                 web_analytics_token: str):
        """
        :param bool build_caching: Enable build caching for the project.
        :param str build_command: Command used to build project.
        :param str destination_dir: Output directory of the build.
        :param str root_dir: Directory to run the command.
        :param str web_analytics_tag: The classifying tag for analytics.
        :param str web_analytics_token: The auth token for analytics.
        """
        pulumi.set(__self__, "build_caching", build_caching)
        pulumi.set(__self__, "build_command", build_command)
        pulumi.set(__self__, "destination_dir", destination_dir)
        pulumi.set(__self__, "root_dir", root_dir)
        pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> bool:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> str:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> str:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> str:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> str:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> str:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentDeploymentTriggerResult(dict):
    def __init__(__self__, *,
                 metadata: 'outputs.GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadataResult',
                 type: str):
        """
        :param 'GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs' metadata: Additional info about the trigger.
        :param str type: What caused the deployment.
        """
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadataResult':
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        What caused the deployment.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadataResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 commit_hash: str,
                 commit_message: str):
        """
        :param str branch: Where the trigger happened.
        :param str commit_hash: Hash of the deployment trigger commit.
        :param str commit_message: Message of the deployment trigger commit.
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "commit_hash", commit_hash)
        pulumi.set(__self__, "commit_message", commit_message)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> str:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> str:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentEnvVarsResult(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: The type of environment variable.
        :param str value: Environment variable value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentLatestStageResult(dict):
    def __init__(__self__, *,
                 ended_on: str,
                 name: str,
                 started_on: str,
                 status: str):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        pulumi.set(__self__, "ended_on", ended_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "started_on", started_on)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentSourceResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetPagesProjectCanonicalDeploymentSourceConfigResult',
                 type: str):
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.GetPagesProjectCanonicalDeploymentSourceConfigResult':
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentSourceConfigResult(dict):
    def __init__(__self__, *,
                 deployments_enabled: bool,
                 owner: str,
                 path_excludes: Sequence[str],
                 path_includes: Sequence[str],
                 pr_comments_enabled: bool,
                 preview_branch_excludes: Sequence[str],
                 preview_branch_includes: Sequence[str],
                 preview_deployment_setting: str,
                 production_branch: str,
                 production_deployments_enabled: bool,
                 repo_name: str):
        pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "path_excludes", path_excludes)
        pulumi.set(__self__, "path_includes", path_includes)
        pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        pulumi.set(__self__, "production_branch", production_branch)
        pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> bool:
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> str:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Sequence[str]:
        return pulumi.get(self, "path_excludes")

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Sequence[str]:
        return pulumi.get(self, "path_includes")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> bool:
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Sequence[str]:
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Sequence[str]:
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> str:
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> str:
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> bool:
        return pulumi.get(self, "production_deployments_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetPagesProjectCanonicalDeploymentStageResult(dict):
    def __init__(__self__, *,
                 ended_on: str,
                 name: str,
                 started_on: str,
                 status: str):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        pulumi.set(__self__, "ended_on", ended_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "started_on", started_on)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsResult(dict):
    def __init__(__self__, *,
                 preview: 'outputs.GetPagesProjectDeploymentConfigsPreviewResult',
                 production: 'outputs.GetPagesProjectDeploymentConfigsProductionResult'):
        """
        :param 'GetPagesProjectDeploymentConfigsPreviewArgs' preview: Configs for preview deploys.
        :param 'GetPagesProjectDeploymentConfigsProductionArgs' production: Configs for production deploys.
        """
        pulumi.set(__self__, "preview", preview)
        pulumi.set(__self__, "production", production)

    @property
    @pulumi.getter
    def preview(self) -> 'outputs.GetPagesProjectDeploymentConfigsPreviewResult':
        """
        Configs for preview deploys.
        """
        return pulumi.get(self, "preview")

    @property
    @pulumi.getter
    def production(self) -> 'outputs.GetPagesProjectDeploymentConfigsProductionResult':
        """
        Configs for production deploys.
        """
        return pulumi.get(self, "production")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewResult(dict):
    def __init__(__self__, *,
                 ai_bindings: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewAiBindingsResult'],
                 analytics_engine_datasets: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsResult'],
                 browsers: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewBrowsersResult'],
                 compatibility_date: str,
                 compatibility_flags: Sequence[str],
                 d1_databases: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewD1DatabasesResult'],
                 durable_object_namespaces: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespacesResult'],
                 env_vars: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewEnvVarsResult'],
                 hyperdrive_bindings: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewHyperdriveBindingsResult'],
                 kv_namespaces: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewKvNamespacesResult'],
                 mtls_certificates: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewMtlsCertificatesResult'],
                 placement: 'outputs.GetPagesProjectDeploymentConfigsPreviewPlacementResult',
                 queue_producers: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewQueueProducersResult'],
                 r2_buckets: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewR2BucketsResult'],
                 services: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewServicesResult'],
                 vectorize_bindings: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewVectorizeBindingsResult']):
        """
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewAiBindingsArgs'] ai_bindings: Constellation bindings used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs'] analytics_engine_datasets: Analytics Engine bindings used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewBrowsersArgs'] browsers: Browser bindings used for Pages Functions.
        :param str compatibility_date: Compatibility date used for Pages Functions.
        :param Sequence[str] compatibility_flags: Compatibility flags used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewD1DatabasesArgs'] d1_databases: D1 databases used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs'] durable_object_namespaces: Durabble Object namespaces used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewEnvVarsArgs'] env_vars: Environment variables for build configs.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs'] hyperdrive_bindings: Hyperdrive bindings used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewKvNamespacesArgs'] kv_namespaces: KV namespaces used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs'] mtls_certificates: mTLS bindings used for Pages Functions.
        :param 'GetPagesProjectDeploymentConfigsPreviewPlacementArgs' placement: Placement setting used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewQueueProducersArgs'] queue_producers: Queue Producer bindings used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewR2BucketsArgs'] r2_buckets: R2 buckets used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewServicesArgs'] services: Services used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs'] vectorize_bindings: Vectorize bindings used for Pages Functions.
        """
        pulumi.set(__self__, "ai_bindings", ai_bindings)
        pulumi.set(__self__, "analytics_engine_datasets", analytics_engine_datasets)
        pulumi.set(__self__, "browsers", browsers)
        pulumi.set(__self__, "compatibility_date", compatibility_date)
        pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        pulumi.set(__self__, "d1_databases", d1_databases)
        pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        pulumi.set(__self__, "env_vars", env_vars)
        pulumi.set(__self__, "hyperdrive_bindings", hyperdrive_bindings)
        pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        pulumi.set(__self__, "mtls_certificates", mtls_certificates)
        pulumi.set(__self__, "placement", placement)
        pulumi.set(__self__, "queue_producers", queue_producers)
        pulumi.set(__self__, "r2_buckets", r2_buckets)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "vectorize_bindings", vectorize_bindings)

    @property
    @pulumi.getter(name="aiBindings")
    def ai_bindings(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewAiBindingsResult']:
        """
        Constellation bindings used for Pages Functions.
        """
        return pulumi.get(self, "ai_bindings")

    @property
    @pulumi.getter(name="analyticsEngineDatasets")
    def analytics_engine_datasets(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsResult']:
        """
        Analytics Engine bindings used for Pages Functions.
        """
        return pulumi.get(self, "analytics_engine_datasets")

    @property
    @pulumi.getter
    def browsers(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewBrowsersResult']:
        """
        Browser bindings used for Pages Functions.
        """
        return pulumi.get(self, "browsers")

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> str:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Sequence[str]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewD1DatabasesResult']:
        """
        D1 databases used for Pages Functions.
        """
        return pulumi.get(self, "d1_databases")

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespacesResult']:
        """
        Durabble Object namespaces used for Pages Functions.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewEnvVarsResult']:
        """
        Environment variables for build configs.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter(name="hyperdriveBindings")
    def hyperdrive_bindings(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewHyperdriveBindingsResult']:
        """
        Hyperdrive bindings used for Pages Functions.
        """
        return pulumi.get(self, "hyperdrive_bindings")

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewKvNamespacesResult']:
        """
        KV namespaces used for Pages Functions.
        """
        return pulumi.get(self, "kv_namespaces")

    @property
    @pulumi.getter(name="mtlsCertificates")
    def mtls_certificates(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewMtlsCertificatesResult']:
        """
        mTLS bindings used for Pages Functions.
        """
        return pulumi.get(self, "mtls_certificates")

    @property
    @pulumi.getter
    def placement(self) -> 'outputs.GetPagesProjectDeploymentConfigsPreviewPlacementResult':
        """
        Placement setting used for Pages Functions.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="queueProducers")
    def queue_producers(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewQueueProducersResult']:
        """
        Queue Producer bindings used for Pages Functions.
        """
        return pulumi.get(self, "queue_producers")

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewR2BucketsResult']:
        """
        R2 buckets used for Pages Functions.
        """
        return pulumi.get(self, "r2_buckets")

    @property
    @pulumi.getter
    def services(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewServicesResult']:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter(name="vectorizeBindings")
    def vectorize_bindings(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsPreviewVectorizeBindingsResult']:
        """
        Vectorize bindings used for Pages Functions.
        """
        return pulumi.get(self, "vectorize_bindings")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewAiBindingsResult(dict):
    def __init__(__self__, *,
                 project_id: str):
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsResult(dict):
    def __init__(__self__, *,
                 dataset: str):
        """
        :param str dataset: Name of the dataset.
        """
        pulumi.set(__self__, "dataset", dataset)

    @property
    @pulumi.getter
    def dataset(self) -> str:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "dataset")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewBrowsersResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewD1DatabasesResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: UUID of the D1 database.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of the D1 database.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespacesResult(dict):
    def __init__(__self__, *,
                 namespace_id: str):
        """
        :param str namespace_id: ID of the Durabble Object namespace.
        """
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        ID of the Durabble Object namespace.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewEnvVarsResult(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: The type of environment variable.
        :param str value: Environment variable value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewHyperdriveBindingsResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewKvNamespacesResult(dict):
    def __init__(__self__, *,
                 namespace_id: str):
        """
        :param str namespace_id: ID of the KV namespace.
        """
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        ID of the KV namespace.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewMtlsCertificatesResult(dict):
    def __init__(__self__, *,
                 certificate_id: str):
        pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> str:
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewPlacementResult(dict):
    def __init__(__self__, *,
                 mode: str):
        """
        :param str mode: Placement mode.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Placement mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewQueueProducersResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the Queue.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Queue.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewR2BucketsResult(dict):
    def __init__(__self__, *,
                 jurisdiction: str,
                 name: str):
        """
        :param str jurisdiction: Jurisdiction of the R2 bucket.
        :param str name: Name of the R2 bucket.
        """
        pulumi.set(__self__, "jurisdiction", jurisdiction)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def jurisdiction(self) -> str:
        """
        Jurisdiction of the R2 bucket.
        """
        return pulumi.get(self, "jurisdiction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the R2 bucket.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewServicesResult(dict):
    def __init__(__self__, *,
                 entrypoint: str,
                 environment: str,
                 service: str):
        """
        :param str entrypoint: The entrypoint to bind to.
        :param str environment: The Service environment.
        :param str service: The Service name.
        """
        pulumi.set(__self__, "entrypoint", entrypoint)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def entrypoint(self) -> str:
        """
        The entrypoint to bind to.
        """
        return pulumi.get(self, "entrypoint")

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        The Service environment.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The Service name.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsPreviewVectorizeBindingsResult(dict):
    def __init__(__self__, *,
                 index_name: str):
        pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> str:
        return pulumi.get(self, "index_name")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionResult(dict):
    def __init__(__self__, *,
                 ai_bindings: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionAiBindingsResult'],
                 analytics_engine_datasets: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsResult'],
                 browsers: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionBrowsersResult'],
                 compatibility_date: str,
                 compatibility_flags: Sequence[str],
                 d1_databases: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionD1DatabasesResult'],
                 durable_object_namespaces: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionDurableObjectNamespacesResult'],
                 env_vars: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionEnvVarsResult'],
                 hyperdrive_bindings: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionHyperdriveBindingsResult'],
                 kv_namespaces: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionKvNamespacesResult'],
                 mtls_certificates: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionMtlsCertificatesResult'],
                 placement: 'outputs.GetPagesProjectDeploymentConfigsProductionPlacementResult',
                 queue_producers: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionQueueProducersResult'],
                 r2_buckets: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionR2BucketsResult'],
                 services: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionServicesResult'],
                 vectorize_bindings: Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionVectorizeBindingsResult']):
        """
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionAiBindingsArgs'] ai_bindings: Constellation bindings used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs'] analytics_engine_datasets: Analytics Engine bindings used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionBrowsersArgs'] browsers: Browser bindings used for Pages Functions.
        :param str compatibility_date: Compatibility date used for Pages Functions.
        :param Sequence[str] compatibility_flags: Compatibility flags used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionD1DatabasesArgs'] d1_databases: D1 databases used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs'] durable_object_namespaces: Durabble Object namespaces used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionEnvVarsArgs'] env_vars: Environment variables for build configs.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs'] hyperdrive_bindings: Hyperdrive bindings used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionKvNamespacesArgs'] kv_namespaces: KV namespaces used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionMtlsCertificatesArgs'] mtls_certificates: mTLS bindings used for Pages Functions.
        :param 'GetPagesProjectDeploymentConfigsProductionPlacementArgs' placement: Placement setting used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionQueueProducersArgs'] queue_producers: Queue Producer bindings used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionR2BucketsArgs'] r2_buckets: R2 buckets used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionServicesArgs'] services: Services used for Pages Functions.
        :param Mapping[str, 'GetPagesProjectDeploymentConfigsProductionVectorizeBindingsArgs'] vectorize_bindings: Vectorize bindings used for Pages Functions.
        """
        pulumi.set(__self__, "ai_bindings", ai_bindings)
        pulumi.set(__self__, "analytics_engine_datasets", analytics_engine_datasets)
        pulumi.set(__self__, "browsers", browsers)
        pulumi.set(__self__, "compatibility_date", compatibility_date)
        pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        pulumi.set(__self__, "d1_databases", d1_databases)
        pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        pulumi.set(__self__, "env_vars", env_vars)
        pulumi.set(__self__, "hyperdrive_bindings", hyperdrive_bindings)
        pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        pulumi.set(__self__, "mtls_certificates", mtls_certificates)
        pulumi.set(__self__, "placement", placement)
        pulumi.set(__self__, "queue_producers", queue_producers)
        pulumi.set(__self__, "r2_buckets", r2_buckets)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "vectorize_bindings", vectorize_bindings)

    @property
    @pulumi.getter(name="aiBindings")
    def ai_bindings(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionAiBindingsResult']:
        """
        Constellation bindings used for Pages Functions.
        """
        return pulumi.get(self, "ai_bindings")

    @property
    @pulumi.getter(name="analyticsEngineDatasets")
    def analytics_engine_datasets(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsResult']:
        """
        Analytics Engine bindings used for Pages Functions.
        """
        return pulumi.get(self, "analytics_engine_datasets")

    @property
    @pulumi.getter
    def browsers(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionBrowsersResult']:
        """
        Browser bindings used for Pages Functions.
        """
        return pulumi.get(self, "browsers")

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> str:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Sequence[str]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionD1DatabasesResult']:
        """
        D1 databases used for Pages Functions.
        """
        return pulumi.get(self, "d1_databases")

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionDurableObjectNamespacesResult']:
        """
        Durabble Object namespaces used for Pages Functions.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionEnvVarsResult']:
        """
        Environment variables for build configs.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter(name="hyperdriveBindings")
    def hyperdrive_bindings(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionHyperdriveBindingsResult']:
        """
        Hyperdrive bindings used for Pages Functions.
        """
        return pulumi.get(self, "hyperdrive_bindings")

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionKvNamespacesResult']:
        """
        KV namespaces used for Pages Functions.
        """
        return pulumi.get(self, "kv_namespaces")

    @property
    @pulumi.getter(name="mtlsCertificates")
    def mtls_certificates(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionMtlsCertificatesResult']:
        """
        mTLS bindings used for Pages Functions.
        """
        return pulumi.get(self, "mtls_certificates")

    @property
    @pulumi.getter
    def placement(self) -> 'outputs.GetPagesProjectDeploymentConfigsProductionPlacementResult':
        """
        Placement setting used for Pages Functions.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="queueProducers")
    def queue_producers(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionQueueProducersResult']:
        """
        Queue Producer bindings used for Pages Functions.
        """
        return pulumi.get(self, "queue_producers")

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionR2BucketsResult']:
        """
        R2 buckets used for Pages Functions.
        """
        return pulumi.get(self, "r2_buckets")

    @property
    @pulumi.getter
    def services(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionServicesResult']:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter(name="vectorizeBindings")
    def vectorize_bindings(self) -> Mapping[str, 'outputs.GetPagesProjectDeploymentConfigsProductionVectorizeBindingsResult']:
        """
        Vectorize bindings used for Pages Functions.
        """
        return pulumi.get(self, "vectorize_bindings")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionAiBindingsResult(dict):
    def __init__(__self__, *,
                 project_id: str):
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsResult(dict):
    def __init__(__self__, *,
                 dataset: str):
        """
        :param str dataset: Name of the dataset.
        """
        pulumi.set(__self__, "dataset", dataset)

    @property
    @pulumi.getter
    def dataset(self) -> str:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "dataset")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionBrowsersResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionD1DatabasesResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: UUID of the D1 database.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of the D1 database.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionDurableObjectNamespacesResult(dict):
    def __init__(__self__, *,
                 namespace_id: str):
        """
        :param str namespace_id: ID of the Durabble Object namespace.
        """
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        ID of the Durabble Object namespace.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionEnvVarsResult(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: The type of environment variable.
        :param str value: Environment variable value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionHyperdriveBindingsResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionKvNamespacesResult(dict):
    def __init__(__self__, *,
                 namespace_id: str):
        """
        :param str namespace_id: ID of the KV namespace.
        """
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        ID of the KV namespace.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionMtlsCertificatesResult(dict):
    def __init__(__self__, *,
                 certificate_id: str):
        pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> str:
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionPlacementResult(dict):
    def __init__(__self__, *,
                 mode: str):
        """
        :param str mode: Placement mode.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Placement mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionQueueProducersResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the Queue.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Queue.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionR2BucketsResult(dict):
    def __init__(__self__, *,
                 jurisdiction: str,
                 name: str):
        """
        :param str jurisdiction: Jurisdiction of the R2 bucket.
        :param str name: Name of the R2 bucket.
        """
        pulumi.set(__self__, "jurisdiction", jurisdiction)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def jurisdiction(self) -> str:
        """
        Jurisdiction of the R2 bucket.
        """
        return pulumi.get(self, "jurisdiction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the R2 bucket.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionServicesResult(dict):
    def __init__(__self__, *,
                 entrypoint: str,
                 environment: str,
                 service: str):
        """
        :param str entrypoint: The entrypoint to bind to.
        :param str environment: The Service environment.
        :param str service: The Service name.
        """
        pulumi.set(__self__, "entrypoint", entrypoint)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def entrypoint(self) -> str:
        """
        The entrypoint to bind to.
        """
        return pulumi.get(self, "entrypoint")

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        The Service environment.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The Service name.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetPagesProjectDeploymentConfigsProductionVectorizeBindingsResult(dict):
    def __init__(__self__, *,
                 index_name: str):
        pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> str:
        return pulumi.get(self, "index_name")


@pulumi.output_type
class GetPagesProjectLatestDeploymentResult(dict):
    def __init__(__self__, *,
                 aliases: Sequence[str],
                 build_config: 'outputs.GetPagesProjectLatestDeploymentBuildConfigResult',
                 created_on: str,
                 deployment_trigger: 'outputs.GetPagesProjectLatestDeploymentDeploymentTriggerResult',
                 env_vars: Mapping[str, 'outputs.GetPagesProjectLatestDeploymentEnvVarsResult'],
                 environment: str,
                 id: str,
                 is_skipped: bool,
                 latest_stage: 'outputs.GetPagesProjectLatestDeploymentLatestStageResult',
                 modified_on: str,
                 project_id: str,
                 project_name: str,
                 short_id: str,
                 source: 'outputs.GetPagesProjectLatestDeploymentSourceResult',
                 stages: Sequence['outputs.GetPagesProjectLatestDeploymentStageResult'],
                 url: str):
        """
        :param Sequence[str] aliases: A list of alias URLs pointing to this deployment.
        :param 'GetPagesProjectLatestDeploymentBuildConfigArgs' build_config: Configs for the project build process.
        :param str created_on: When the deployment was created.
        :param 'GetPagesProjectLatestDeploymentDeploymentTriggerArgs' deployment_trigger: Info about what caused the deployment.
        :param Mapping[str, 'GetPagesProjectLatestDeploymentEnvVarsArgs'] env_vars: A dict of env variables to build this deploy.
        :param str environment: Type of deploy.
        :param str id: Id of the deployment.
        :param bool is_skipped: If the deployment has been skipped.
        :param 'GetPagesProjectLatestDeploymentLatestStageArgs' latest_stage: The status of the deployment.
        :param str modified_on: When the deployment was last modified.
        :param str project_id: Id of the project.
        :param str project_name: Name of the project.
        :param str short_id: Short Id (8 character) of the deployment.
        :param Sequence['GetPagesProjectLatestDeploymentStageArgs'] stages: List of past stages.
        :param str url: The live URL to view this deployment.
        """
        pulumi.set(__self__, "aliases", aliases)
        pulumi.set(__self__, "build_config", build_config)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        pulumi.set(__self__, "env_vars", env_vars)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_skipped", is_skipped)
        pulumi.set(__self__, "latest_stage", latest_stage)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "short_id", short_id)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "stages", stages)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def aliases(self) -> Sequence[str]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> 'outputs.GetPagesProjectLatestDeploymentBuildConfigResult':
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> 'outputs.GetPagesProjectLatestDeploymentDeploymentTriggerResult':
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Mapping[str, 'outputs.GetPagesProjectLatestDeploymentEnvVarsResult']:
        """
        A dict of env variables to build this deploy.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        Type of deploy.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> bool:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> 'outputs.GetPagesProjectLatestDeploymentLatestStageResult':
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> str:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.GetPagesProjectLatestDeploymentSourceResult':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def stages(self) -> Sequence['outputs.GetPagesProjectLatestDeploymentStageResult']:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetPagesProjectLatestDeploymentBuildConfigResult(dict):
    def __init__(__self__, *,
                 build_caching: bool,
                 build_command: str,
                 destination_dir: str,
                 root_dir: str,
                 web_analytics_tag: str,
                 web_analytics_token: str):
        """
        :param bool build_caching: Enable build caching for the project.
        :param str build_command: Command used to build project.
        :param str destination_dir: Output directory of the build.
        :param str root_dir: Directory to run the command.
        :param str web_analytics_tag: The classifying tag for analytics.
        :param str web_analytics_token: The auth token for analytics.
        """
        pulumi.set(__self__, "build_caching", build_caching)
        pulumi.set(__self__, "build_command", build_command)
        pulumi.set(__self__, "destination_dir", destination_dir)
        pulumi.set(__self__, "root_dir", root_dir)
        pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> bool:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> str:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> str:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> str:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> str:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> str:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class GetPagesProjectLatestDeploymentDeploymentTriggerResult(dict):
    def __init__(__self__, *,
                 metadata: 'outputs.GetPagesProjectLatestDeploymentDeploymentTriggerMetadataResult',
                 type: str):
        """
        :param 'GetPagesProjectLatestDeploymentDeploymentTriggerMetadataArgs' metadata: Additional info about the trigger.
        :param str type: What caused the deployment.
        """
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetPagesProjectLatestDeploymentDeploymentTriggerMetadataResult':
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        What caused the deployment.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPagesProjectLatestDeploymentDeploymentTriggerMetadataResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 commit_hash: str,
                 commit_message: str):
        """
        :param str branch: Where the trigger happened.
        :param str commit_hash: Hash of the deployment trigger commit.
        :param str commit_message: Message of the deployment trigger commit.
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "commit_hash", commit_hash)
        pulumi.set(__self__, "commit_message", commit_message)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> str:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> str:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")


@pulumi.output_type
class GetPagesProjectLatestDeploymentEnvVarsResult(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: The type of environment variable.
        :param str value: Environment variable value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPagesProjectLatestDeploymentLatestStageResult(dict):
    def __init__(__self__, *,
                 ended_on: str,
                 name: str,
                 started_on: str,
                 status: str):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        pulumi.set(__self__, "ended_on", ended_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "started_on", started_on)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPagesProjectLatestDeploymentSourceResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetPagesProjectLatestDeploymentSourceConfigResult',
                 type: str):
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.GetPagesProjectLatestDeploymentSourceConfigResult':
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPagesProjectLatestDeploymentSourceConfigResult(dict):
    def __init__(__self__, *,
                 deployments_enabled: bool,
                 owner: str,
                 path_excludes: Sequence[str],
                 path_includes: Sequence[str],
                 pr_comments_enabled: bool,
                 preview_branch_excludes: Sequence[str],
                 preview_branch_includes: Sequence[str],
                 preview_deployment_setting: str,
                 production_branch: str,
                 production_deployments_enabled: bool,
                 repo_name: str):
        pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "path_excludes", path_excludes)
        pulumi.set(__self__, "path_includes", path_includes)
        pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        pulumi.set(__self__, "production_branch", production_branch)
        pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> bool:
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> str:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Sequence[str]:
        return pulumi.get(self, "path_excludes")

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Sequence[str]:
        return pulumi.get(self, "path_includes")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> bool:
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Sequence[str]:
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Sequence[str]:
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> str:
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> str:
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> bool:
        return pulumi.get(self, "production_deployments_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetPagesProjectLatestDeploymentStageResult(dict):
    def __init__(__self__, *,
                 ended_on: str,
                 name: str,
                 started_on: str,
                 status: str):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        pulumi.set(__self__, "ended_on", ended_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "started_on", started_on)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPagesProjectSourceResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetPagesProjectSourceConfigResult',
                 type: str):
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.GetPagesProjectSourceConfigResult':
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPagesProjectSourceConfigResult(dict):
    def __init__(__self__, *,
                 deployments_enabled: bool,
                 owner: str,
                 path_excludes: Sequence[str],
                 path_includes: Sequence[str],
                 pr_comments_enabled: bool,
                 preview_branch_excludes: Sequence[str],
                 preview_branch_includes: Sequence[str],
                 preview_deployment_setting: str,
                 production_branch: str,
                 production_deployments_enabled: bool,
                 repo_name: str):
        pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "path_excludes", path_excludes)
        pulumi.set(__self__, "path_includes", path_includes)
        pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        pulumi.set(__self__, "production_branch", production_branch)
        pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> bool:
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> str:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Sequence[str]:
        return pulumi.get(self, "path_excludes")

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Sequence[str]:
        return pulumi.get(self, "path_includes")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> bool:
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Sequence[str]:
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Sequence[str]:
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> str:
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> str:
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> bool:
        return pulumi.get(self, "production_deployments_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetPagesProjectsResultResult(dict):
    def __init__(__self__, *,
                 aliases: Sequence[str],
                 build_config: 'outputs.GetPagesProjectsResultBuildConfigResult',
                 created_on: str,
                 deployment_trigger: 'outputs.GetPagesProjectsResultDeploymentTriggerResult',
                 env_vars: Mapping[str, 'outputs.GetPagesProjectsResultEnvVarsResult'],
                 environment: str,
                 id: str,
                 is_skipped: bool,
                 latest_stage: 'outputs.GetPagesProjectsResultLatestStageResult',
                 modified_on: str,
                 project_id: str,
                 project_name: str,
                 short_id: str,
                 source: 'outputs.GetPagesProjectsResultSourceResult',
                 stages: Sequence['outputs.GetPagesProjectsResultStageResult'],
                 url: str):
        """
        :param Sequence[str] aliases: A list of alias URLs pointing to this deployment.
        :param 'GetPagesProjectsResultBuildConfigArgs' build_config: Configs for the project build process.
        :param str created_on: When the deployment was created.
        :param 'GetPagesProjectsResultDeploymentTriggerArgs' deployment_trigger: Info about what caused the deployment.
        :param Mapping[str, 'GetPagesProjectsResultEnvVarsArgs'] env_vars: A dict of env variables to build this deploy.
        :param str environment: Type of deploy.
        :param str id: Id of the deployment.
        :param bool is_skipped: If the deployment has been skipped.
        :param 'GetPagesProjectsResultLatestStageArgs' latest_stage: The status of the deployment.
        :param str modified_on: When the deployment was last modified.
        :param str project_id: Id of the project.
        :param str project_name: Name of the project.
        :param str short_id: Short Id (8 character) of the deployment.
        :param Sequence['GetPagesProjectsResultStageArgs'] stages: List of past stages.
        :param str url: The live URL to view this deployment.
        """
        pulumi.set(__self__, "aliases", aliases)
        pulumi.set(__self__, "build_config", build_config)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        pulumi.set(__self__, "env_vars", env_vars)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_skipped", is_skipped)
        pulumi.set(__self__, "latest_stage", latest_stage)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "short_id", short_id)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "stages", stages)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def aliases(self) -> Sequence[str]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> 'outputs.GetPagesProjectsResultBuildConfigResult':
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> 'outputs.GetPagesProjectsResultDeploymentTriggerResult':
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Mapping[str, 'outputs.GetPagesProjectsResultEnvVarsResult']:
        """
        A dict of env variables to build this deploy.
        """
        return pulumi.get(self, "env_vars")

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        Type of deploy.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> bool:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> 'outputs.GetPagesProjectsResultLatestStageResult':
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> str:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.GetPagesProjectsResultSourceResult':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def stages(self) -> Sequence['outputs.GetPagesProjectsResultStageResult']:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetPagesProjectsResultBuildConfigResult(dict):
    def __init__(__self__, *,
                 build_caching: bool,
                 build_command: str,
                 destination_dir: str,
                 root_dir: str,
                 web_analytics_tag: str,
                 web_analytics_token: str):
        """
        :param bool build_caching: Enable build caching for the project.
        :param str build_command: Command used to build project.
        :param str destination_dir: Output directory of the build.
        :param str root_dir: Directory to run the command.
        :param str web_analytics_tag: The classifying tag for analytics.
        :param str web_analytics_token: The auth token for analytics.
        """
        pulumi.set(__self__, "build_caching", build_caching)
        pulumi.set(__self__, "build_command", build_command)
        pulumi.set(__self__, "destination_dir", destination_dir)
        pulumi.set(__self__, "root_dir", root_dir)
        pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> bool:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> str:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> str:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> str:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> str:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> str:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class GetPagesProjectsResultDeploymentTriggerResult(dict):
    def __init__(__self__, *,
                 metadata: 'outputs.GetPagesProjectsResultDeploymentTriggerMetadataResult',
                 type: str):
        """
        :param 'GetPagesProjectsResultDeploymentTriggerMetadataArgs' metadata: Additional info about the trigger.
        :param str type: What caused the deployment.
        """
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetPagesProjectsResultDeploymentTriggerMetadataResult':
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        What caused the deployment.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPagesProjectsResultDeploymentTriggerMetadataResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 commit_hash: str,
                 commit_message: str):
        """
        :param str branch: Where the trigger happened.
        :param str commit_hash: Hash of the deployment trigger commit.
        :param str commit_message: Message of the deployment trigger commit.
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "commit_hash", commit_hash)
        pulumi.set(__self__, "commit_message", commit_message)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> str:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> str:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")


@pulumi.output_type
class GetPagesProjectsResultEnvVarsResult(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: The type of environment variable.
        :param str value: Environment variable value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPagesProjectsResultLatestStageResult(dict):
    def __init__(__self__, *,
                 ended_on: str,
                 name: str,
                 started_on: str,
                 status: str):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        pulumi.set(__self__, "ended_on", ended_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "started_on", started_on)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPagesProjectsResultSourceResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetPagesProjectsResultSourceConfigResult',
                 type: str):
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.GetPagesProjectsResultSourceConfigResult':
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPagesProjectsResultSourceConfigResult(dict):
    def __init__(__self__, *,
                 deployments_enabled: bool,
                 owner: str,
                 path_excludes: Sequence[str],
                 path_includes: Sequence[str],
                 pr_comments_enabled: bool,
                 preview_branch_excludes: Sequence[str],
                 preview_branch_includes: Sequence[str],
                 preview_deployment_setting: str,
                 production_branch: str,
                 production_deployments_enabled: bool,
                 repo_name: str):
        pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "path_excludes", path_excludes)
        pulumi.set(__self__, "path_includes", path_includes)
        pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        pulumi.set(__self__, "production_branch", production_branch)
        pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> bool:
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> str:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Sequence[str]:
        return pulumi.get(self, "path_excludes")

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Sequence[str]:
        return pulumi.get(self, "path_includes")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> bool:
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Sequence[str]:
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Sequence[str]:
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> str:
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> str:
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> bool:
        return pulumi.get(self, "production_deployments_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetPagesProjectsResultStageResult(dict):
    def __init__(__self__, *,
                 ended_on: str,
                 name: str,
                 started_on: str,
                 status: str):
        """
        :param str ended_on: When the stage ended.
        :param str name: The current build stage.
        :param str started_on: When the stage started.
        :param str status: State of the current stage.
        """
        pulumi.set(__self__, "ended_on", ended_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "started_on", started_on)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPermissionGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPermissionGroupsResultResult(dict):
<<<<<<< HEAD
    def __init__(__self__):
        pass
=======
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetPermissionGroupsResultMetaResult',
                 name: str):
        """
        :param str id: Identifier of the group.
        :param 'GetPermissionGroupsResultMetaArgs' meta: Attributes associated to the permission group.
        :param str name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetPermissionGroupsResultMetaResult':
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPermissionGroupsResultMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580


@pulumi.output_type
class GetQueueConsumerResult(dict):
    def __init__(__self__, *,
                 consumer_id: str,
                 created_on: str,
                 queue_id: str,
                 script: str,
                 script_name: str,
                 settings: 'outputs.GetQueueConsumerSettingsResult',
                 type: str):
        """
        :param str consumer_id: A Resource identifier.
        :param str queue_id: A Resource identifier.
        :param str script: Name of a Worker
        :param str script_name: Name of a Worker
        """
        pulumi.set(__self__, "consumer_id", consumer_id)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "script_name", script_name)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="consumerId")
    def consumer_id(self) -> str:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "consumer_id")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> str:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter
    def script(self) -> str:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script")

    @property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> str:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script_name")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetQueueConsumerSettingsResult':
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetQueueConsumerSettingsResult(dict):
    def __init__(__self__, *,
                 batch_size: float,
                 max_concurrency: float,
                 max_retries: float,
                 max_wait_time_ms: float,
                 retry_delay: float,
                 visibility_timeout_ms: float):
        """
        :param float batch_size: The maximum number of messages to include in a batch.
        :param float max_concurrency: Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        :param float max_retries: The maximum number of retries
        :param float max_wait_time_ms: The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        :param float retry_delay: The number of seconds to delay before making the message available for another attempt.
        :param float visibility_timeout_ms: The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "max_wait_time_ms", max_wait_time_ms)
        pulumi.set(__self__, "retry_delay", retry_delay)
        pulumi.set(__self__, "visibility_timeout_ms", visibility_timeout_ms)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> float:
        """
        The maximum number of messages to include in a batch.
        """
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> float:
        """
        Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        """
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> float:
        """
        The maximum number of retries
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="maxWaitTimeMs")
    def max_wait_time_ms(self) -> float:
        """
        The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        """
        return pulumi.get(self, "max_wait_time_ms")

    @property
    @pulumi.getter(name="retryDelay")
    def retry_delay(self) -> float:
        """
        The number of seconds to delay before making the message available for another attempt.
        """
        return pulumi.get(self, "retry_delay")

    @property
    @pulumi.getter(name="visibilityTimeoutMs")
    def visibility_timeout_ms(self) -> float:
        """
        The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        return pulumi.get(self, "visibility_timeout_ms")


@pulumi.output_type
class GetQueueProducerResult(dict):
    def __init__(__self__, *,
                 bucket_name: str,
                 script: str,
                 type: str):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def script(self) -> str:
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetQueueSettingsResult(dict):
    def __init__(__self__, *,
                 delivery_delay: float,
                 message_retention_period: float):
        """
        :param float delivery_delay: Number of seconds to delay delivery of all messages to consumers.
        :param float message_retention_period: Number of seconds after which an unconsumed message will be delayed.
        """
        pulumi.set(__self__, "delivery_delay", delivery_delay)
        pulumi.set(__self__, "message_retention_period", message_retention_period)

    @property
    @pulumi.getter(name="deliveryDelay")
    def delivery_delay(self) -> float:
        """
        Number of seconds to delay delivery of all messages to consumers.
        """
        return pulumi.get(self, "delivery_delay")

    @property
    @pulumi.getter(name="messageRetentionPeriod")
    def message_retention_period(self) -> float:
        """
        Number of seconds after which an unconsumed message will be delayed.
        """
        return pulumi.get(self, "message_retention_period")


@pulumi.output_type
class GetQueuesResultResult(dict):
    def __init__(__self__, *,
                 consumers: Sequence['outputs.GetQueuesResultConsumerResult'],
                 consumers_total_count: float,
                 created_on: str,
                 modified_on: str,
                 producers: Sequence['outputs.GetQueuesResultProducerResult'],
                 producers_total_count: float,
                 queue_id: str,
                 queue_name: str,
                 settings: 'outputs.GetQueuesResultSettingsResult'):
        pulumi.set(__self__, "consumers", consumers)
        pulumi.set(__self__, "consumers_total_count", consumers_total_count)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "producers", producers)
        pulumi.set(__self__, "producers_total_count", producers_total_count)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "queue_name", queue_name)
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def consumers(self) -> Sequence['outputs.GetQueuesResultConsumerResult']:
        return pulumi.get(self, "consumers")

    @property
    @pulumi.getter(name="consumersTotalCount")
    def consumers_total_count(self) -> float:
        return pulumi.get(self, "consumers_total_count")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def producers(self) -> Sequence['outputs.GetQueuesResultProducerResult']:
        return pulumi.get(self, "producers")

    @property
    @pulumi.getter(name="producersTotalCount")
    def producers_total_count(self) -> float:
        return pulumi.get(self, "producers_total_count")

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> str:
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> str:
        return pulumi.get(self, "queue_name")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetQueuesResultSettingsResult':
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetQueuesResultConsumerResult(dict):
    def __init__(__self__, *,
                 consumer_id: str,
                 created_on: str,
                 queue_id: str,
                 script: str,
                 script_name: str,
                 settings: 'outputs.GetQueuesResultConsumerSettingsResult',
                 type: str):
        """
        :param str consumer_id: A Resource identifier.
        :param str queue_id: A Resource identifier.
        :param str script: Name of a Worker
        :param str script_name: Name of a Worker
        """
        pulumi.set(__self__, "consumer_id", consumer_id)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "script_name", script_name)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="consumerId")
    def consumer_id(self) -> str:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "consumer_id")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> str:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter
    def script(self) -> str:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script")

    @property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> str:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script_name")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetQueuesResultConsumerSettingsResult':
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetQueuesResultConsumerSettingsResult(dict):
    def __init__(__self__, *,
                 batch_size: float,
                 max_concurrency: float,
                 max_retries: float,
                 max_wait_time_ms: float,
                 retry_delay: float,
                 visibility_timeout_ms: float):
        """
        :param float batch_size: The maximum number of messages to include in a batch.
        :param float max_concurrency: Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        :param float max_retries: The maximum number of retries
        :param float max_wait_time_ms: The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        :param float retry_delay: The number of seconds to delay before making the message available for another attempt.
        :param float visibility_timeout_ms: The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "max_wait_time_ms", max_wait_time_ms)
        pulumi.set(__self__, "retry_delay", retry_delay)
        pulumi.set(__self__, "visibility_timeout_ms", visibility_timeout_ms)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> float:
        """
        The maximum number of messages to include in a batch.
        """
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> float:
        """
        Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        """
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> float:
        """
        The maximum number of retries
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="maxWaitTimeMs")
    def max_wait_time_ms(self) -> float:
        """
        The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        """
        return pulumi.get(self, "max_wait_time_ms")

    @property
    @pulumi.getter(name="retryDelay")
    def retry_delay(self) -> float:
        """
        The number of seconds to delay before making the message available for another attempt.
        """
        return pulumi.get(self, "retry_delay")

    @property
    @pulumi.getter(name="visibilityTimeoutMs")
    def visibility_timeout_ms(self) -> float:
        """
        The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        return pulumi.get(self, "visibility_timeout_ms")


@pulumi.output_type
class GetQueuesResultProducerResult(dict):
    def __init__(__self__, *,
                 bucket_name: str,
                 script: str,
                 type: str):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def script(self) -> str:
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetQueuesResultSettingsResult(dict):
    def __init__(__self__, *,
                 delivery_delay: float,
                 message_retention_period: float):
        """
        :param float delivery_delay: Number of seconds to delay delivery of all messages to consumers.
        :param float message_retention_period: Number of seconds after which an unconsumed message will be delayed.
        """
        pulumi.set(__self__, "delivery_delay", delivery_delay)
        pulumi.set(__self__, "message_retention_period", message_retention_period)

    @property
    @pulumi.getter(name="deliveryDelay")
    def delivery_delay(self) -> float:
        """
        Number of seconds to delay delivery of all messages to consumers.
        """
        return pulumi.get(self, "delivery_delay")

    @property
    @pulumi.getter(name="messageRetentionPeriod")
    def message_retention_period(self) -> float:
        """
        Number of seconds after which an unconsumed message will be delayed.
        """
        return pulumi.get(self, "message_retention_period")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetR2BucketCorsRuleResult(dict):
    def __init__(__self__, *,
                 allowed: 'outputs.GetR2BucketCorsRuleAllowedResult',
                 expose_headers: Sequence[str],
                 id: str,
                 max_age_seconds: float):
        """
        :param 'GetR2BucketCorsRuleAllowedArgs' allowed: Object specifying allowed origins, methods and headers for this CORS rule.
        :param Sequence[str] expose_headers: Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        :param str id: Identifier for this rule
        :param float max_age_seconds: Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
        pulumi.set(__self__, "allowed", allowed)
        pulumi.set(__self__, "expose_headers", expose_headers)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter
    def allowed(self) -> 'outputs.GetR2BucketCorsRuleAllowedResult':
        """
        Object specifying allowed origins, methods and headers for this CORS rule.
        """
        return pulumi.get(self, "allowed")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Sequence[str]:
        """
        Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier for this rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> float:
        """
        Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class GetR2BucketCorsRuleAllowedResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 methods: Sequence[str],
                 origins: Sequence[str]):
        """
        :param Sequence[str] headers: Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        :param Sequence[str] methods: Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        :param Sequence[str] origins: Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        """
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "origins", origins)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        """
        Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def origins(self) -> Sequence[str]:
        """
        Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        """
        return pulumi.get(self, "origins")


@pulumi.output_type
class GetR2BucketEventNotificationQueueResult(dict):
    def __init__(__self__, *,
                 queue_id: str,
                 queue_name: str,
                 rules: Sequence['outputs.GetR2BucketEventNotificationQueueRuleResult']):
        """
        :param str queue_id: Queue ID
        :param str queue_name: Name of the queue
        """
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "queue_name", queue_name)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> str:
        """
        Queue ID
        """
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> str:
        """
        Name of the queue
        """
        return pulumi.get(self, "queue_name")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetR2BucketEventNotificationQueueRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetR2BucketEventNotificationQueueRuleResult(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 created_at: str,
                 description: str,
                 prefix: str,
                 rule_id: str,
                 suffix: str):
        """
        :param Sequence[str] actions: Array of R2 object actions that will trigger notifications
        :param str created_at: Timestamp when the rule was created
        :param str description: A description that can be used to identify the event notification rule after creation
        :param str prefix: Notifications will be sent only for objects with this prefix
        :param str rule_id: Rule ID
        :param str suffix: Notifications will be sent only for objects with this suffix
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Array of R2 object actions that will trigger notifications
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Timestamp when the rule was created
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description that can be used to identify the event notification rule after creation
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        Notifications will be sent only for objects with this prefix
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Rule ID
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        """
        Notifications will be sent only for objects with this suffix
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetR2BucketLifecycleRuleResult(dict):
    def __init__(__self__, *,
                 abort_multipart_uploads_transition: 'outputs.GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionResult',
                 conditions: 'outputs.GetR2BucketLifecycleRuleConditionsResult',
                 delete_objects_transition: 'outputs.GetR2BucketLifecycleRuleDeleteObjectsTransitionResult',
                 enabled: bool,
                 id: str,
                 storage_class_transitions: Sequence['outputs.GetR2BucketLifecycleRuleStorageClassTransitionResult']):
        """
        :param 'GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs' abort_multipart_uploads_transition: Transition to abort ongoing multipart uploads
        :param 'GetR2BucketLifecycleRuleConditionsArgs' conditions: Conditions that apply to all transitions of this rule
        :param 'GetR2BucketLifecycleRuleDeleteObjectsTransitionArgs' delete_objects_transition: Transition to delete objects
        :param bool enabled: Whether or not this rule is in effect
        :param str id: Unique identifier for this rule
        :param Sequence['GetR2BucketLifecycleRuleStorageClassTransitionArgs'] storage_class_transitions: Transitions to change the storage class of objects
        """
        pulumi.set(__self__, "abort_multipart_uploads_transition", abort_multipart_uploads_transition)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "delete_objects_transition", delete_objects_transition)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "storage_class_transitions", storage_class_transitions)

    @property
    @pulumi.getter(name="abortMultipartUploadsTransition")
    def abort_multipart_uploads_transition(self) -> 'outputs.GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionResult':
        """
        Transition to abort ongoing multipart uploads
        """
        return pulumi.get(self, "abort_multipart_uploads_transition")

    @property
    @pulumi.getter
    def conditions(self) -> 'outputs.GetR2BucketLifecycleRuleConditionsResult':
        """
        Conditions that apply to all transitions of this rule
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="deleteObjectsTransition")
    def delete_objects_transition(self) -> 'outputs.GetR2BucketLifecycleRuleDeleteObjectsTransitionResult':
        """
        Transition to delete objects
        """
        return pulumi.get(self, "delete_objects_transition")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not this rule is in effect
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for this rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="storageClassTransitions")
    def storage_class_transitions(self) -> Sequence['outputs.GetR2BucketLifecycleRuleStorageClassTransitionResult']:
        """
        Transitions to change the storage class of objects
        """
        return pulumi.get(self, "storage_class_transitions")


@pulumi.output_type
class GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionResult(dict):
    def __init__(__self__, *,
                 condition: 'outputs.GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionResult'):
        """
        :param 'GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs' condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionResult':
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionResult(dict):
    def __init__(__self__, *,
                 max_age: int,
                 type: str):
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetR2BucketLifecycleRuleConditionsResult(dict):
    def __init__(__self__, *,
                 prefix: str):
        """
        :param str prefix: Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetR2BucketLifecycleRuleDeleteObjectsTransitionResult(dict):
    def __init__(__self__, *,
                 condition: 'outputs.GetR2BucketLifecycleRuleDeleteObjectsTransitionConditionResult'):
        """
        :param 'GetR2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs' condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.GetR2BucketLifecycleRuleDeleteObjectsTransitionConditionResult':
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetR2BucketLifecycleRuleDeleteObjectsTransitionConditionResult(dict):
    def __init__(__self__, *,
                 date: str,
                 max_age: int,
                 type: str):
        pulumi.set(__self__, "date", date)
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def date(self) -> str:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetR2BucketLifecycleRuleStorageClassTransitionResult(dict):
    def __init__(__self__, *,
                 condition: 'outputs.GetR2BucketLifecycleRuleStorageClassTransitionConditionResult',
                 storage_class: str):
        """
        :param 'GetR2BucketLifecycleRuleStorageClassTransitionConditionArgs' condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.GetR2BucketLifecycleRuleStorageClassTransitionConditionResult':
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class GetR2BucketLifecycleRuleStorageClassTransitionConditionResult(dict):
    def __init__(__self__, *,
                 date: str,
                 max_age: int,
                 type: str):
        pulumi.set(__self__, "date", date)
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def date(self) -> str:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetR2BucketLockRuleResult(dict):
    def __init__(__self__, *,
                 condition: 'outputs.GetR2BucketLockRuleConditionResult',
                 enabled: bool,
                 id: str,
                 prefix: str):
        """
        :param 'GetR2BucketLockRuleConditionArgs' condition: Condition to apply a lock rule to an object for how long in seconds
        :param bool enabled: Whether or not this rule is in effect
        :param str id: Unique identifier for this rule
        :param str prefix: Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.GetR2BucketLockRuleConditionResult':
        """
        Condition to apply a lock rule to an object for how long in seconds
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not this rule is in effect
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for this rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetR2BucketLockRuleConditionResult(dict):
    def __init__(__self__, *,
                 date: str,
                 max_age_seconds: int,
                 type: str):
        pulumi.set(__self__, "date", date)
        pulumi.set(__self__, "max_age_seconds", max_age_seconds)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def date(self) -> str:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> int:
        return pulumi.get(self, "max_age_seconds")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetR2BucketSippyDestinationResult(dict):
    def __init__(__self__, *,
                 access_key_id: str,
                 account: str,
                 bucket: str,
                 provider: str):
        """
        :param str access_key_id: ID of the Cloudflare API token used when writing objects to this
               bucket
        :param str bucket: Name of the bucket on the provider
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        """
        ID of the Cloudflare API token used when writing objects to this
        bucket
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def account(self) -> str:
        return pulumi.get(self, "account")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the bucket on the provider
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")


@pulumi.output_type
class GetR2BucketSippySourceResult(dict):
    def __init__(__self__, *,
                 bucket: str,
                 provider: str,
                 region: str):
        """
        :param str bucket: Name of the bucket on the provider
        :param str region: Region where the bucket resides (AWS only)
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the bucket on the provider
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region where the bucket resides (AWS only)
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetR2CustomDomainStatusResult(dict):
    def __init__(__self__, *,
                 ownership: str,
                 ssl: str):
        """
        :param str ownership: Ownership status of the domain
        :param str ssl: SSL certificate status
        """
        pulumi.set(__self__, "ownership", ownership)
        pulumi.set(__self__, "ssl", ssl)

    @property
    @pulumi.getter
    def ownership(self) -> str:
        """
        Ownership status of the domain
        """
        return pulumi.get(self, "ownership")

    @property
    @pulumi.getter
    def ssl(self) -> str:
        """
        SSL certificate status
        """
        return pulumi.get(self, "ssl")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetRateLimitActionResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 response: 'outputs.GetRateLimitActionResponseResult',
                 timeout: float):
        """
        :param str mode: The action to perform.
        :param 'GetRateLimitActionResponseArgs' response: A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
               Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        :param float timeout: The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
               Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "response", response)
        pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The action to perform.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def response(self) -> 'outputs.GetRateLimitActionResponseResult':
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def timeout(self) -> float:
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetRateLimitActionResponseResult(dict):
    def __init__(__self__, *,
                 body: str,
                 content_type: str):
        """
        :param str body: The response body to return. The value must conform to the configured content type.
        :param str content_type: The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The response body to return. The value must conform to the configured content type.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        return pulumi.get(self, "content_type")


@pulumi.output_type
class GetRateLimitBypassResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str value: The URL to bypass.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The URL to bypass.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRateLimitMatchResult(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.GetRateLimitMatchHeaderResult'],
                 request: 'outputs.GetRateLimitMatchRequestResult',
                 response: 'outputs.GetRateLimitMatchResponseResult'):
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "request", request)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetRateLimitMatchHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def request(self) -> 'outputs.GetRateLimitMatchRequestResult':
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> 'outputs.GetRateLimitMatchResponseResult':
        return pulumi.get(self, "response")


@pulumi.output_type
class GetRateLimitMatchHeaderResult(dict):
    def __init__(__self__, *,
                 name: str,
                 op: str,
                 value: str):
        """
        :param str name: The name of the response header to match.
        :param str op: The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        :param str value: The value of the response header, which must match exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the response header to match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the response header, which must match exactly.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRateLimitMatchRequestResult(dict):
    def __init__(__self__, *,
                 methods: Sequence[str],
                 schemes: Sequence[str],
                 url: str):
        """
        :param Sequence[str] methods: The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        :param Sequence[str] schemes: The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        :param str url: The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "schemes", schemes)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def schemes(self) -> Sequence[str]:
        """
        The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        """
        return pulumi.get(self, "schemes")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetRateLimitMatchResponseResult(dict):
    def __init__(__self__, *,
                 origin_traffic: bool):
        """
        :param bool origin_traffic: When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
               Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        pulumi.set(__self__, "origin_traffic", origin_traffic)

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> bool:
        """
        When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
        Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        return pulumi.get(self, "origin_traffic")


@pulumi.output_type
class GetRateLimitsResultResult(dict):
    def __init__(__self__, *,
                 action: 'outputs.GetRateLimitsResultActionResult',
                 bypasses: Sequence['outputs.GetRateLimitsResultBypassResult'],
                 description: str,
                 disabled: bool,
                 id: str,
                 match: 'outputs.GetRateLimitsResultMatchResult',
                 period: float,
                 threshold: float):
        """
        :param 'GetRateLimitsResultActionArgs' action: The action to perform when the threshold of matched traffic within the configured period is exceeded.
        :param Sequence['GetRateLimitsResultBypassArgs'] bypasses: Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
        :param str description: An informative summary of the rate limit. This value is sanitized and any tags will be removed.
        :param bool disabled: When true, indicates that the rate limit is currently disabled.
        :param str id: The unique identifier of the rate limit.
        :param 'GetRateLimitsResultMatchArgs' match: Determines which traffic the rate limit counts towards the threshold.
        :param float period: The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
        :param float threshold: The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bypasses", bypasses)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.GetRateLimitsResultActionResult':
        """
        The action to perform when the threshold of matched traffic within the configured period is exceeded.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def bypasses(self) -> Sequence['outputs.GetRateLimitsResultBypassResult']:
        """
        Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
        """
        return pulumi.get(self, "bypasses")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative summary of the rate limit. This value is sanitized and any tags will be removed.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        When true, indicates that the rate limit is currently disabled.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the rate limit.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.GetRateLimitsResultMatchResult':
        """
        Determines which traffic the rate limit counts towards the threshold.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def period(self) -> float:
        """
        The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetRateLimitsResultActionResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 response: 'outputs.GetRateLimitsResultActionResponseResult',
                 timeout: float):
        """
        :param str mode: The action to perform.
        :param 'GetRateLimitsResultActionResponseArgs' response: A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
               Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        :param float timeout: The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
               Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "response", response)
        pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The action to perform.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def response(self) -> 'outputs.GetRateLimitsResultActionResponseResult':
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def timeout(self) -> float:
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetRateLimitsResultActionResponseResult(dict):
    def __init__(__self__, *,
                 body: str,
                 content_type: str):
        """
        :param str body: The response body to return. The value must conform to the configured content type.
        :param str content_type: The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The response body to return. The value must conform to the configured content type.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        return pulumi.get(self, "content_type")


@pulumi.output_type
class GetRateLimitsResultBypassResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str value: The URL to bypass.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The URL to bypass.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRateLimitsResultMatchResult(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.GetRateLimitsResultMatchHeaderResult'],
                 request: 'outputs.GetRateLimitsResultMatchRequestResult',
                 response: 'outputs.GetRateLimitsResultMatchResponseResult'):
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "request", request)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetRateLimitsResultMatchHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def request(self) -> 'outputs.GetRateLimitsResultMatchRequestResult':
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> 'outputs.GetRateLimitsResultMatchResponseResult':
        return pulumi.get(self, "response")


@pulumi.output_type
class GetRateLimitsResultMatchHeaderResult(dict):
    def __init__(__self__, *,
                 name: str,
                 op: str,
                 value: str):
        """
        :param str name: The name of the response header to match.
        :param str op: The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        :param str value: The value of the response header, which must match exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the response header to match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the response header, which must match exactly.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRateLimitsResultMatchRequestResult(dict):
    def __init__(__self__, *,
                 methods: Sequence[str],
                 schemes: Sequence[str],
                 url: str):
        """
        :param Sequence[str] methods: The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        :param Sequence[str] schemes: The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        :param str url: The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "schemes", schemes)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def schemes(self) -> Sequence[str]:
        """
        The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        """
        return pulumi.get(self, "schemes")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetRateLimitsResultMatchResponseResult(dict):
    def __init__(__self__, *,
                 origin_traffic: bool):
        """
        :param bool origin_traffic: When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
               Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        pulumi.set(__self__, "origin_traffic", origin_traffic)

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> bool:
        """
        When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
        Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        return pulumi.get(self, "origin_traffic")


@pulumi.output_type
class GetRegionalHostnamesResultResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 hostname: str,
                 region_key: str):
        """
        :param str created_on: When the regional hostname was created
        :param str hostname: DNS hostname to be regionalized, must be a subdomain of the zone. Wildcards are supported for one level, e.g `*.example.com`
        :param str region_key: Identifying key for the region
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "region_key", region_key)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the regional hostname was created
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        DNS hostname to be regionalized, must be a subdomain of the zone. Wildcards are supported for one level, e.g `*.example.com`
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="regionKey")
    def region_key(self) -> str:
        """
        Identifying key for the region
        """
        return pulumi.get(self, "region_key")


@pulumi.output_type
class GetRegistrarDomainsResultResult(dict):
    def __init__(__self__, *,
                 available: bool,
                 can_register: bool,
                 created_at: str,
                 current_registrar: str,
                 expires_at: str,
                 id: str,
                 locked: bool,
                 registrant_contact: 'outputs.GetRegistrarDomainsResultRegistrantContactResult',
                 registry_statuses: str,
                 supported_tld: bool,
                 transfer_in: 'outputs.GetRegistrarDomainsResultTransferInResult',
                 updated_at: str):
        """
        :param bool available: Shows if a domain is available for transferring into Cloudflare Registrar.
        :param bool can_register: Indicates if the domain can be registered as a new domain.
        :param str created_at: Shows time of creation.
        :param str current_registrar: Shows name of current registrar.
        :param str expires_at: Shows when domain name registration expires.
        :param str id: Domain identifier.
        :param bool locked: Shows whether a registrar lock is in place for a domain.
        :param 'GetRegistrarDomainsResultRegistrantContactArgs' registrant_contact: Shows contact information for domain registrant.
        :param str registry_statuses: A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en).
        :param bool supported_tld: Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs.
        :param 'GetRegistrarDomainsResultTransferInArgs' transfer_in: Statuses for domain transfers into Cloudflare Registrar.
        :param str updated_at: Last updated.
        """
        pulumi.set(__self__, "available", available)
        pulumi.set(__self__, "can_register", can_register)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "current_registrar", current_registrar)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "locked", locked)
        pulumi.set(__self__, "registrant_contact", registrant_contact)
        pulumi.set(__self__, "registry_statuses", registry_statuses)
        pulumi.set(__self__, "supported_tld", supported_tld)
        pulumi.set(__self__, "transfer_in", transfer_in)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def available(self) -> bool:
        """
        Shows if a domain is available for transferring into Cloudflare Registrar.
        """
        return pulumi.get(self, "available")

    @property
    @pulumi.getter(name="canRegister")
    def can_register(self) -> bool:
        """
        Indicates if the domain can be registered as a new domain.
        """
        return pulumi.get(self, "can_register")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Shows time of creation.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="currentRegistrar")
    def current_registrar(self) -> str:
        """
        Shows name of current registrar.
        """
        return pulumi.get(self, "current_registrar")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        Shows when domain name registration expires.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Domain identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def locked(self) -> bool:
        """
        Shows whether a registrar lock is in place for a domain.
        """
        return pulumi.get(self, "locked")

    @property
    @pulumi.getter(name="registrantContact")
    def registrant_contact(self) -> 'outputs.GetRegistrarDomainsResultRegistrantContactResult':
        """
        Shows contact information for domain registrant.
        """
        return pulumi.get(self, "registrant_contact")

    @property
    @pulumi.getter(name="registryStatuses")
    def registry_statuses(self) -> str:
        """
        A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en).
        """
        return pulumi.get(self, "registry_statuses")

    @property
    @pulumi.getter(name="supportedTld")
    def supported_tld(self) -> bool:
        """
        Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs.
        """
        return pulumi.get(self, "supported_tld")

    @property
    @pulumi.getter(name="transferIn")
    def transfer_in(self) -> 'outputs.GetRegistrarDomainsResultTransferInResult':
        """
        Statuses for domain transfers into Cloudflare Registrar.
        """
        return pulumi.get(self, "transfer_in")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetRegistrarDomainsResultRegistrantContactResult(dict):
    def __init__(__self__, *,
                 address: str,
                 address2: str,
                 city: str,
                 country: str,
                 email: str,
                 fax: str,
                 first_name: str,
                 id: str,
                 last_name: str,
                 organization: str,
                 phone: str,
                 state: str,
                 zip: str):
        """
        :param str address: Address.
        :param str address2: Optional address line for unit, floor, suite, etc.
        :param str city: City.
        :param str country: The country in which the user lives.
        :param str email: The contact email address of the user.
        :param str fax: Contact fax number.
        :param str first_name: User's first name
        :param str id: Contact Identifier.
        :param str last_name: User's last name
        :param str organization: Name of organization.
        :param str phone: User's telephone number
        :param str state: State.
        :param str zip: The zipcode or postal code where the user lives.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "address2", address2)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "fax", fax)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "zip", zip)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def address2(self) -> str:
        """
        Optional address line for unit, floor, suite, etc.
        """
        return pulumi.get(self, "address2")

    @property
    @pulumi.getter
    def city(self) -> str:
        """
        City.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        The country in which the user lives.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def fax(self) -> str:
        """
        Contact fax number.
        """
        return pulumi.get(self, "fax")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        User's first name
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Contact Identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        User's last name
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        Name of organization.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def phone(self) -> str:
        """
        User's telephone number
        """
        return pulumi.get(self, "phone")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def zip(self) -> str:
        """
        The zipcode or postal code where the user lives.
        """
        return pulumi.get(self, "zip")


@pulumi.output_type
class GetRegistrarDomainsResultTransferInResult(dict):
    def __init__(__self__, *,
                 accept_foa: str,
                 approve_transfer: str,
                 can_cancel_transfer: bool,
                 disable_privacy: str,
                 enter_auth_code: str,
                 unlock_domain: str):
        """
        :param str accept_foa: Form of authorization has been accepted by the registrant.
        :param str approve_transfer: Shows transfer status with the registry.
        :param bool can_cancel_transfer: Indicates if cancellation is still possible.
        :param str disable_privacy: Privacy guards are disabled at the foreign registrar.
        :param str enter_auth_code: Auth code has been entered and verified.
        :param str unlock_domain: Domain is unlocked at the foreign registrar.
        """
        pulumi.set(__self__, "accept_foa", accept_foa)
        pulumi.set(__self__, "approve_transfer", approve_transfer)
        pulumi.set(__self__, "can_cancel_transfer", can_cancel_transfer)
        pulumi.set(__self__, "disable_privacy", disable_privacy)
        pulumi.set(__self__, "enter_auth_code", enter_auth_code)
        pulumi.set(__self__, "unlock_domain", unlock_domain)

    @property
    @pulumi.getter(name="acceptFoa")
    def accept_foa(self) -> str:
        """
        Form of authorization has been accepted by the registrant.
        """
        return pulumi.get(self, "accept_foa")

    @property
    @pulumi.getter(name="approveTransfer")
    def approve_transfer(self) -> str:
        """
        Shows transfer status with the registry.
        """
        return pulumi.get(self, "approve_transfer")

    @property
    @pulumi.getter(name="canCancelTransfer")
    def can_cancel_transfer(self) -> bool:
        """
        Indicates if cancellation is still possible.
        """
        return pulumi.get(self, "can_cancel_transfer")

    @property
    @pulumi.getter(name="disablePrivacy")
    def disable_privacy(self) -> str:
        """
        Privacy guards are disabled at the foreign registrar.
        """
        return pulumi.get(self, "disable_privacy")

    @property
    @pulumi.getter(name="enterAuthCode")
    def enter_auth_code(self) -> str:
        """
        Auth code has been entered and verified.
        """
        return pulumi.get(self, "enter_auth_code")

    @property
    @pulumi.getter(name="unlockDomain")
    def unlock_domain(self) -> str:
        """
        Domain is unlocked at the foreign registrar.
        """
        return pulumi.get(self, "unlock_domain")


@pulumi.output_type
class GetResourceGroupMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResourceGroupScopeResult(dict):
    def __init__(__self__, *,
                 key: str,
                 objects: Sequence['outputs.GetResourceGroupScopeObjectResult']):
        """
        :param str key: This is a combination of pre-defined resource name and identifier (like Account ID etc.)
        :param Sequence['GetResourceGroupScopeObjectArgs'] objects: A list of scope objects for additional context.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "objects", objects)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        This is a combination of pre-defined resource name and identifier (like Account ID etc.)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def objects(self) -> Sequence['outputs.GetResourceGroupScopeObjectResult']:
        """
        A list of scope objects for additional context.
        """
        return pulumi.get(self, "objects")


@pulumi.output_type
class GetResourceGroupScopeObjectResult(dict):
    def __init__(__self__, *,
                 key: str):
        """
        :param str key: This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class GetResourceGroupsResultResult(dict):
<<<<<<< HEAD
    def __init__(__self__):
        pass
=======
    def __init__(__self__, *,
                 id: str,
                 meta: 'outputs.GetResourceGroupsResultMetaResult',
                 name: str,
                 scopes: Sequence['outputs.GetResourceGroupsResultScopeResult']):
        """
        :param str id: Identifier of the group.
        :param 'GetResourceGroupsResultMetaArgs' meta: Attributes associated to the resource group.
        :param str name: Name of the resource group.
        :param Sequence['GetResourceGroupsResultScopeArgs'] scopes: The scope associated to the resource group
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetResourceGroupsResultMetaResult':
        """
        Attributes associated to the resource group.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the resource group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetResourceGroupsResultScopeResult']:
        """
        The scope associated to the resource group
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetResourceGroupsResultMetaResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResourceGroupsResultScopeResult(dict):
    def __init__(__self__, *,
                 key: str,
                 objects: Sequence['outputs.GetResourceGroupsResultScopeObjectResult']):
        """
        :param str key: This is a combination of pre-defined resource name and identifier (like Account ID etc.)
        :param Sequence['GetResourceGroupsResultScopeObjectArgs'] objects: A list of scope objects for additional context.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "objects", objects)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        This is a combination of pre-defined resource name and identifier (like Account ID etc.)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def objects(self) -> Sequence['outputs.GetResourceGroupsResultScopeObjectResult']:
        """
        A list of scope objects for additional context.
        """
        return pulumi.get(self, "objects")


@pulumi.output_type
class GetResourceGroupsResultScopeObjectResult(dict):
    def __init__(__self__, *,
                 key: str):
        """
        :param str key: This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
        """
        return pulumi.get(self, "key")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580


@pulumi.output_type
class GetRulesetRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 action_parameters: 'outputs.GetRulesetRuleActionParametersResult',
                 categories: Sequence[str],
                 description: str,
                 enabled: bool,
                 exposed_credential_check: 'outputs.GetRulesetRuleExposedCredentialCheckResult',
                 expression: str,
                 id: str,
                 logging: 'outputs.GetRulesetRuleLoggingResult',
                 ratelimit: 'outputs.GetRulesetRuleRatelimitResult',
                 ref: str):
        """
        :param str action: The action to perform when the rule matches.
        :param 'GetRulesetRuleActionParametersArgs' action_parameters: The parameters configuring the rule's action.
        :param Sequence[str] categories: The categories of the rule.
        :param str description: An informative description of the rule.
        :param bool enabled: Whether the rule should be executed.
        :param 'GetRulesetRuleExposedCredentialCheckArgs' exposed_credential_check: Configure checks for exposed credentials.
        :param str expression: The expression defining which traffic will match the rule.
        :param str id: The unique ID of the rule.
        :param 'GetRulesetRuleLoggingArgs' logging: An object configuring the rule's logging behavior.
        :param 'GetRulesetRuleRatelimitArgs' ratelimit: An object configuring the rule's ratelimit behavior.
        :param str ref: The reference of the rule (the rule ID by default).
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "action_parameters", action_parameters)
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "logging", logging)
        pulumi.set(__self__, "ratelimit", ratelimit)
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to perform when the rule matches.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> 'outputs.GetRulesetRuleActionParametersResult':
        """
        The parameters configuring the rule's action.
        """
        return pulumi.get(self, "action_parameters")

    @property
    @pulumi.getter
    def categories(self) -> Sequence[str]:
        """
        The categories of the rule.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the rule should be executed.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> 'outputs.GetRulesetRuleExposedCredentialCheckResult':
        """
        Configure checks for exposed credentials.
        """
        return pulumi.get(self, "exposed_credential_check")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression defining which traffic will match the rule.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logging(self) -> 'outputs.GetRulesetRuleLoggingResult':
        """
        An object configuring the rule's logging behavior.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def ratelimit(self) -> 'outputs.GetRulesetRuleRatelimitResult':
        """
        An object configuring the rule's ratelimit behavior.
        """
        return pulumi.get(self, "ratelimit")

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        The reference of the rule (the rule ID by default).
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class GetRulesetRuleActionParametersResult(dict):
    def __init__(__self__, *,
                 additional_cacheable_ports: Sequence[int],
                 algorithms: Sequence['outputs.GetRulesetRuleActionParametersAlgorithmResult'],
                 automatic_https_rewrites: bool,
                 autominify: 'outputs.GetRulesetRuleActionParametersAutominifyResult',
                 bic: bool,
                 browser_ttl: 'outputs.GetRulesetRuleActionParametersBrowserTtlResult',
                 cache: bool,
                 cache_key: 'outputs.GetRulesetRuleActionParametersCacheKeyResult',
                 cache_reserve: 'outputs.GetRulesetRuleActionParametersCacheReserveResult',
                 content: str,
                 content_type: str,
                 cookie_fields: Sequence['outputs.GetRulesetRuleActionParametersCookieFieldResult'],
                 disable_apps: bool,
                 disable_rum: bool,
                 disable_zaraz: bool,
                 edge_ttl: 'outputs.GetRulesetRuleActionParametersEdgeTtlResult',
                 email_obfuscation: bool,
                 fonts: bool,
                 from_list: 'outputs.GetRulesetRuleActionParametersFromListResult',
                 from_value: 'outputs.GetRulesetRuleActionParametersFromValueResult',
                 headers: Mapping[str, 'outputs.GetRulesetRuleActionParametersHeadersResult'],
                 host_header: str,
                 hotlink_protection: bool,
                 id: str,
                 increment: int,
                 matched_data: 'outputs.GetRulesetRuleActionParametersMatchedDataResult',
                 mirage: bool,
                 opportunistic_encryption: bool,
                 origin: 'outputs.GetRulesetRuleActionParametersOriginResult',
                 origin_cache_control: bool,
                 origin_error_page_passthru: bool,
                 overrides: 'outputs.GetRulesetRuleActionParametersOverridesResult',
                 phases: Sequence[str],
                 polish: str,
                 products: Sequence[str],
                 read_timeout: int,
                 request_fields: Sequence['outputs.GetRulesetRuleActionParametersRequestFieldResult'],
                 respect_strong_etags: bool,
                 response: 'outputs.GetRulesetRuleActionParametersResponseResult',
                 response_fields: Sequence['outputs.GetRulesetRuleActionParametersResponseFieldResult'],
                 rocket_loader: bool,
                 rules: Mapping[str, Sequence[str]],
                 ruleset: str,
                 rulesets: Sequence[str],
                 security_level: str,
                 serve_stale: 'outputs.GetRulesetRuleActionParametersServeStaleResult',
                 server_side_excludes: bool,
                 sni: 'outputs.GetRulesetRuleActionParametersSniResult',
                 ssl: str,
                 status_code: float,
                 sxg: bool,
                 uri: 'outputs.GetRulesetRuleActionParametersUriResult'):
        """
        :param Sequence[int] additional_cacheable_ports: List of additional ports that caching can be enabled on.
        :param Sequence['GetRulesetRuleActionParametersAlgorithmArgs'] algorithms: Custom order for compression algorithms.
        :param bool automatic_https_rewrites: Turn on or off Automatic HTTPS Rewrites.
        :param 'GetRulesetRuleActionParametersAutominifyArgs' autominify: Select which file extensions to minify automatically.
        :param bool bic: Turn on or off Browser Integrity Check.
        :param 'GetRulesetRuleActionParametersBrowserTtlArgs' browser_ttl: Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        :param bool cache: Mark whether the request’s response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
        :param 'GetRulesetRuleActionParametersCacheKeyArgs' cache_key: Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
        :param 'GetRulesetRuleActionParametersCacheReserveArgs' cache_reserve: Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        :param str content: Error response content.
        :param str content_type: Content-type header to set with the response.
        :param Sequence['GetRulesetRuleActionParametersCookieFieldArgs'] cookie_fields: The cookie fields to log.
        :param bool disable_apps: Turn off all active Cloudflare Apps.
        :param bool disable_rum: Turn off Real User Monitoring (RUM).
        :param bool disable_zaraz: Turn off Zaraz.
        :param 'GetRulesetRuleActionParametersEdgeTtlArgs' edge_ttl: TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
        :param bool email_obfuscation: Turn on or off Email Obfuscation.
        :param bool fonts: Turn on or off Cloudflare Fonts.
        :param 'GetRulesetRuleActionParametersFromListArgs' from_list: Serve a redirect based on a bulk list lookup.
        :param 'GetRulesetRuleActionParametersFromValueArgs' from_value: Serve a redirect based on the request properties.
        :param Mapping[str, 'GetRulesetRuleActionParametersHeadersArgs'] headers: Map of request headers to modify.
        :param str host_header: Rewrite the HTTP Host header.
        :param bool hotlink_protection: Turn on or off the Hotlink Protection.
        :param str id: The ID of the ruleset to execute.
        :param int increment: Increment contains the delta to change the score and can be either positive or negative.
        :param 'GetRulesetRuleActionParametersMatchedDataArgs' matched_data: The configuration to use for matched data logging.
        :param bool mirage: Turn on or off Mirage.
        :param bool opportunistic_encryption: Turn on or off Opportunistic Encryption.
        :param 'GetRulesetRuleActionParametersOriginArgs' origin: Override the IP/TCP destination.
        :param bool origin_cache_control: When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
        :param bool origin_error_page_passthru: Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
        :param 'GetRulesetRuleActionParametersOverridesArgs' overrides: A set of overrides to apply to the target ruleset.
        :param Sequence[str] phases: A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
        :param str polish: Configure the Polish level.
        :param Sequence[str] products: A list of legacy security products to skip the execution of.
        :param int read_timeout: Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        :param Sequence['GetRulesetRuleActionParametersRequestFieldArgs'] request_fields: The request fields to log.
        :param bool respect_strong_etags: Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
        :param 'GetRulesetRuleActionParametersResponseArgs' response: The response to show when the block is applied.
        :param Sequence['GetRulesetRuleActionParametersResponseFieldArgs'] response_fields: The response fields to log.
        :param bool rocket_loader: Turn on or off Rocket Loader
        :param Mapping[str, Sequence[str]] rules: A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        :param str ruleset: A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
        :param Sequence[str] rulesets: A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        :param str security_level: Configure the Security Level.
        :param 'GetRulesetRuleActionParametersServeStaleArgs' serve_stale: Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
        :param bool server_side_excludes: Turn on or off Server Side Excludes.
        :param 'GetRulesetRuleActionParametersSniArgs' sni: Override the Server Name Indication (SNI).
        :param str ssl: Configure the SSL level.
        :param float status_code: The status code to use for the error.
        :param bool sxg: Turn on or off Signed Exchanges (SXG).
        :param 'GetRulesetRuleActionParametersUriArgs' uri: URI to rewrite the request to.
        """
        pulumi.set(__self__, "additional_cacheable_ports", additional_cacheable_ports)
        pulumi.set(__self__, "algorithms", algorithms)
        pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        pulumi.set(__self__, "autominify", autominify)
        pulumi.set(__self__, "bic", bic)
        pulumi.set(__self__, "browser_ttl", browser_ttl)
        pulumi.set(__self__, "cache", cache)
        pulumi.set(__self__, "cache_key", cache_key)
        pulumi.set(__self__, "cache_reserve", cache_reserve)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "cookie_fields", cookie_fields)
        pulumi.set(__self__, "disable_apps", disable_apps)
        pulumi.set(__self__, "disable_rum", disable_rum)
        pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        pulumi.set(__self__, "edge_ttl", edge_ttl)
        pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        pulumi.set(__self__, "fonts", fonts)
        pulumi.set(__self__, "from_list", from_list)
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "increment", increment)
        pulumi.set(__self__, "matched_data", matched_data)
        pulumi.set(__self__, "mirage", mirage)
        pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "origin_cache_control", origin_cache_control)
        pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        pulumi.set(__self__, "overrides", overrides)
        pulumi.set(__self__, "phases", phases)
        pulumi.set(__self__, "polish", polish)
        pulumi.set(__self__, "products", products)
        pulumi.set(__self__, "read_timeout", read_timeout)
        pulumi.set(__self__, "request_fields", request_fields)
        pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        pulumi.set(__self__, "response", response)
        pulumi.set(__self__, "response_fields", response_fields)
        pulumi.set(__self__, "rocket_loader", rocket_loader)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "ruleset", ruleset)
        pulumi.set(__self__, "rulesets", rulesets)
        pulumi.set(__self__, "security_level", security_level)
        pulumi.set(__self__, "serve_stale", serve_stale)
        pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "sxg", sxg)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="additionalCacheablePorts")
    def additional_cacheable_ports(self) -> Sequence[int]:
        """
        List of additional ports that caching can be enabled on.
        """
        return pulumi.get(self, "additional_cacheable_ports")

    @property
    @pulumi.getter
    def algorithms(self) -> Sequence['outputs.GetRulesetRuleActionParametersAlgorithmResult']:
        """
        Custom order for compression algorithms.
        """
        return pulumi.get(self, "algorithms")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> bool:
        """
        Turn on or off Automatic HTTPS Rewrites.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter
    def autominify(self) -> 'outputs.GetRulesetRuleActionParametersAutominifyResult':
        """
        Select which file extensions to minify automatically.
        """
        return pulumi.get(self, "autominify")

    @property
    @pulumi.getter
    def bic(self) -> bool:
        """
        Turn on or off Browser Integrity Check.
        """
        return pulumi.get(self, "bic")

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> 'outputs.GetRulesetRuleActionParametersBrowserTtlResult':
        """
        Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        """
        return pulumi.get(self, "browser_ttl")

    @property
    @pulumi.getter
    def cache(self) -> bool:
        """
        Mark whether the request’s response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
        """
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyResult':
        """
        Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
        """
        return pulumi.get(self, "cache_key")

    @property
    @pulumi.getter(name="cacheReserve")
    def cache_reserve(self) -> 'outputs.GetRulesetRuleActionParametersCacheReserveResult':
        """
        Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        """
        return pulumi.get(self, "cache_reserve")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Error response content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        Content-type header to set with the response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Sequence['outputs.GetRulesetRuleActionParametersCookieFieldResult']:
        """
        The cookie fields to log.
        """
        return pulumi.get(self, "cookie_fields")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> bool:
        """
        Turn off all active Cloudflare Apps.
        """
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disableRum")
    def disable_rum(self) -> bool:
        """
        Turn off Real User Monitoring (RUM).
        """
        return pulumi.get(self, "disable_rum")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> bool:
        """
        Turn off Zaraz.
        """
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> 'outputs.GetRulesetRuleActionParametersEdgeTtlResult':
        """
        TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
        """
        return pulumi.get(self, "edge_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> bool:
        """
        Turn on or off Email Obfuscation.
        """
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter
    def fonts(self) -> bool:
        """
        Turn on or off Cloudflare Fonts.
        """
        return pulumi.get(self, "fonts")

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> 'outputs.GetRulesetRuleActionParametersFromListResult':
        """
        Serve a redirect based on a bulk list lookup.
        """
        return pulumi.get(self, "from_list")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.GetRulesetRuleActionParametersFromValueResult':
        """
        Serve a redirect based on the request properties.
        """
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, 'outputs.GetRulesetRuleActionParametersHeadersResult']:
        """
        Map of request headers to modify.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        Rewrite the HTTP Host header.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> bool:
        """
        Turn on or off the Hotlink Protection.
        """
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the ruleset to execute.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def increment(self) -> int:
        """
        Increment contains the delta to change the score and can be either positive or negative.
        """
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> 'outputs.GetRulesetRuleActionParametersMatchedDataResult':
        """
        The configuration to use for matched data logging.
        """
        return pulumi.get(self, "matched_data")

    @property
    @pulumi.getter
    def mirage(self) -> bool:
        """
        Turn on or off Mirage.
        """
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> bool:
        """
        Turn on or off Opportunistic Encryption.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter
    def origin(self) -> 'outputs.GetRulesetRuleActionParametersOriginResult':
        """
        Override the IP/TCP destination.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="originCacheControl")
    def origin_cache_control(self) -> bool:
        """
        When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
        """
        return pulumi.get(self, "origin_cache_control")

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> bool:
        """
        Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
        """
        return pulumi.get(self, "origin_error_page_passthru")

    @property
    @pulumi.getter
    def overrides(self) -> 'outputs.GetRulesetRuleActionParametersOverridesResult':
        """
        A set of overrides to apply to the target ruleset.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def phases(self) -> Sequence[str]:
        """
        A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
        """
        return pulumi.get(self, "phases")

    @property
    @pulumi.getter
    def polish(self) -> str:
        """
        Configure the Polish level.
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter
    def products(self) -> Sequence[str]:
        """
        A list of legacy security products to skip the execution of.
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> int:
        """
        Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Sequence['outputs.GetRulesetRuleActionParametersRequestFieldResult']:
        """
        The request fields to log.
        """
        return pulumi.get(self, "request_fields")

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> bool:
        """
        Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
        """
        return pulumi.get(self, "respect_strong_etags")

    @property
    @pulumi.getter
    def response(self) -> 'outputs.GetRulesetRuleActionParametersResponseResult':
        """
        The response to show when the block is applied.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Sequence['outputs.GetRulesetRuleActionParametersResponseFieldResult']:
        """
        The response fields to log.
        """
        return pulumi.get(self, "response_fields")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> bool:
        """
        Turn on or off Rocket Loader
        """
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter
    def rules(self) -> Mapping[str, Sequence[str]]:
        """
        A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def ruleset(self) -> str:
        """
        A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
        """
        return pulumi.get(self, "ruleset")

    @property
    @pulumi.getter
    def rulesets(self) -> Sequence[str]:
        """
        A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        """
        return pulumi.get(self, "rulesets")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> str:
        """
        Configure the Security Level.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> 'outputs.GetRulesetRuleActionParametersServeStaleResult':
        """
        Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        return pulumi.get(self, "serve_stale")

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> bool:
        """
        Turn on or off Server Side Excludes.
        """
        return pulumi.get(self, "server_side_excludes")

    @property
    @pulumi.getter
    def sni(self) -> 'outputs.GetRulesetRuleActionParametersSniResult':
        """
        Override the Server Name Indication (SNI).
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def ssl(self) -> str:
        """
        Configure the SSL level.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> float:
        """
        The status code to use for the error.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def sxg(self) -> bool:
        """
        Turn on or off Signed Exchanges (SXG).
        """
        return pulumi.get(self, "sxg")

    @property
    @pulumi.getter
    def uri(self) -> 'outputs.GetRulesetRuleActionParametersUriResult':
        """
        URI to rewrite the request to.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetRulesetRuleActionParametersAlgorithmResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of compression algorithm to enable.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of compression algorithm to enable.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRulesetRuleActionParametersAutominifyResult(dict):
    def __init__(__self__, *,
                 css: bool,
                 html: bool,
                 js: bool):
        """
        :param bool css: Minify CSS files.
        :param bool html: Minify HTML files.
        :param bool js: Minify JS files.
        """
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> bool:
        """
        Minify CSS files.
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> bool:
        """
        Minify HTML files.
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> bool:
        """
        Minify JS files.
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class GetRulesetRuleActionParametersBrowserTtlResult(dict):
    def __init__(__self__, *,
                 default: int,
                 mode: str):
        """
        :param int default: The TTL (in seconds) if you choose override_origin mode.
        :param str mode: Determines which browser ttl mode to use.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def default(self) -> int:
        """
        The TTL (in seconds) if you choose override_origin mode.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines which browser ttl mode to use.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyResult(dict):
    def __init__(__self__, *,
                 cache_by_device_type: bool,
                 cache_deception_armor: bool,
                 custom_key: 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyResult',
                 ignore_query_strings_order: bool):
        """
        :param bool cache_by_device_type: Separate cached content based on the visitor’s device type
        :param bool cache_deception_armor: Protect from web cache deception attacks while allowing static assets to be cached
        :param 'GetRulesetRuleActionParametersCacheKeyCustomKeyArgs' custom_key: Customize which components of the request are included or excluded from the cache key.
        :param bool ignore_query_strings_order: Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
        """
        pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        pulumi.set(__self__, "custom_key", custom_key)
        pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> bool:
        """
        Separate cached content based on the visitor’s device type
        """
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> bool:
        """
        Protect from web cache deception attacks while allowing static assets to be cached
        """
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyResult':
        """
        Customize which components of the request are included or excluded from the cache key.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> bool:
        """
        Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
        """
        return pulumi.get(self, "ignore_query_strings_order")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyCustomKeyResult(dict):
    def __init__(__self__, *,
                 cookie: 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyCookieResult',
                 header: 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult',
                 host: 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyHostResult',
                 query_string: 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult',
                 user: 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyUserResult'):
        """
        :param 'GetRulesetRuleActionParametersCacheKeyCustomKeyCookieArgs' cookie: The cookies to include in building the cache key.
        :param 'GetRulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs' header: The header names and values to include in building the cache key.
        :param 'GetRulesetRuleActionParametersCacheKeyCustomKeyHostArgs' host: Whether to use the original host or the resolved host in the cache key.
        :param 'GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs' query_string: Use the presence of parameters in the query string to build the cache key.
        :param 'GetRulesetRuleActionParametersCacheKeyCustomKeyUserArgs' user: Characteristics of the request user agent used in building the cache key.
        """
        pulumi.set(__self__, "cookie", cookie)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyCookieResult':
        """
        The cookies to include in building the cache key.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult':
        """
        The header names and values to include in building the cache key.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def host(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyHostResult':
        """
        Whether to use the original host or the resolved host in the cache key.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult':
        """
        Use the presence of parameters in the query string to build the cache key.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyUserResult':
        """
        Characteristics of the request user agent used in building the cache key.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyCustomKeyCookieResult(dict):
    def __init__(__self__, *,
                 check_presences: Sequence[str],
                 includes: Sequence[str]):
        """
        :param Sequence[str] check_presences: Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
        :param Sequence[str] includes: Include these cookies' names and their values.
        """
        pulumi.set(__self__, "check_presences", check_presences)
        pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Sequence[str]:
        """
        Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Sequence[str]:
        """
        Include these cookies' names and their values.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult(dict):
    def __init__(__self__, *,
                 check_presences: Sequence[str],
                 contains: Mapping[str, Sequence[str]],
                 exclude_origin: bool,
                 includes: Sequence[str]):
        """
        :param Sequence[str] check_presences: Checks for the presence of these header names. The presence of these headers is used in building the cache key.
        :param Mapping[str, Sequence[str]] contains: For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
        :param bool exclude_origin: Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
        :param Sequence[str] includes: Include these headers' names and their values.
        """
        pulumi.set(__self__, "check_presences", check_presences)
        pulumi.set(__self__, "contains", contains)
        pulumi.set(__self__, "exclude_origin", exclude_origin)
        pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Sequence[str]:
        """
        Checks for the presence of these header names. The presence of these headers is used in building the cache key.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def contains(self) -> Mapping[str, Sequence[str]]:
        """
        For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> bool:
        """
        Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
        """
        return pulumi.get(self, "exclude_origin")

    @property
    @pulumi.getter
    def includes(self) -> Sequence[str]:
        """
        Include these headers' names and their values.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyCustomKeyHostResult(dict):
    def __init__(__self__, *,
                 resolved: bool):
        """
        :param bool resolved: Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
        """
        pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> bool:
        """
        Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
        """
        return pulumi.get(self, "resolved")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult(dict):
    def __init__(__self__, *,
                 exclude: 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeResult',
                 include: 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeResult'):
        """
        :param 'GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs' exclude: A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
        :param 'GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs' include: A list of query string parameters used to build the cache key.
        """
        pulumi.set(__self__, "exclude", exclude)
        pulumi.set(__self__, "include", include)

    @property
    @pulumi.getter
    def exclude(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeResult':
        """
        A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
        """
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter
    def include(self) -> 'outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeResult':
        """
        A list of query string parameters used to build the cache key.
        """
        return pulumi.get(self, "include")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeResult(dict):
    def __init__(__self__, *,
                 all: bool,
                 lists: Sequence[str]):
        """
        :param bool all: Determines whether to exclude all query string parameters from the cache key.
        """
        pulumi.set(__self__, "all", all)
        pulumi.set(__self__, "lists", lists)

    @property
    @pulumi.getter
    def all(self) -> bool:
        """
        Determines whether to exclude all query string parameters from the cache key.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter
    def lists(self) -> Sequence[str]:
        return pulumi.get(self, "lists")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeResult(dict):
    def __init__(__self__, *,
                 all: bool,
                 lists: Sequence[str]):
        """
        :param bool all: Determines whether to include all query string parameters in the cache key.
        """
        pulumi.set(__self__, "all", all)
        pulumi.set(__self__, "lists", lists)

    @property
    @pulumi.getter
    def all(self) -> bool:
        """
        Determines whether to include all query string parameters in the cache key.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter
    def lists(self) -> Sequence[str]:
        return pulumi.get(self, "lists")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheKeyCustomKeyUserResult(dict):
    def __init__(__self__, *,
                 device_type: bool,
                 geo: bool,
                 lang: bool):
        """
        :param bool device_type: Use the user agent's device type in the cache key.
        :param bool geo: Use the user agents's country in the cache key.
        :param bool lang: Use the user agent's language in the cache key.
        """
        pulumi.set(__self__, "device_type", device_type)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> bool:
        """
        Use the user agent's device type in the cache key.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> bool:
        """
        Use the user agents's country in the cache key.
        """
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> bool:
        """
        Use the user agent's language in the cache key.
        """
        return pulumi.get(self, "lang")


@pulumi.output_type
class GetRulesetRuleActionParametersCacheReserveResult(dict):
    def __init__(__self__, *,
                 eligible: bool,
                 minimum_file_size: int):
        """
        :param bool eligible: Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
        :param int minimum_file_size: The minimum file size eligible for store in cache reserve.
        """
        pulumi.set(__self__, "eligible", eligible)
        pulumi.set(__self__, "minimum_file_size", minimum_file_size)

    @property
    @pulumi.getter
    def eligible(self) -> bool:
        """
        Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
        """
        return pulumi.get(self, "eligible")

    @property
    @pulumi.getter(name="minimumFileSize")
    def minimum_file_size(self) -> int:
        """
        The minimum file size eligible for store in cache reserve.
        """
        return pulumi.get(self, "minimum_file_size")


@pulumi.output_type
class GetRulesetRuleActionParametersCookieFieldResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRulesetRuleActionParametersEdgeTtlResult(dict):
    def __init__(__self__, *,
                 default: int,
                 mode: str,
                 status_code_ttls: Sequence['outputs.GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult']):
        """
        :param int default: The TTL (in seconds) if you choose override_origin mode.
        :param str mode: edge ttl options
        :param Sequence['GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs'] status_code_ttls: List of single status codes, or status code ranges to apply the selected mode
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def default(self) -> int:
        """
        The TTL (in seconds) if you choose override_origin mode.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        edge ttl options
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Sequence['outputs.GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult']:
        """
        List of single status codes, or status code ranges to apply the selected mode
        """
        return pulumi.get(self, "status_code_ttls")


@pulumi.output_type
class GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult(dict):
    def __init__(__self__, *,
                 status_code_range: 'outputs.GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult',
                 status_code_value: int,
                 value: int):
        """
        :param 'GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs' status_code_range: The range of status codes used to apply the selected mode.
        :param int status_code_value: Set the ttl for responses with this specific status code
        :param int value: Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
        """
        pulumi.set(__self__, "status_code_range", status_code_range)
        pulumi.set(__self__, "status_code_value", status_code_value)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> 'outputs.GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult':
        """
        The range of status codes used to apply the selected mode.
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter(name="statusCodeValue")
    def status_code_value(self) -> int:
        """
        Set the ttl for responses with this specific status code
        """
        return pulumi.get(self, "status_code_value")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        """
        :param int from_: response status code lower bound
        :param int to: response status code upper bound
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        """
        response status code lower bound
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        """
        response status code upper bound
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetRulesetRuleActionParametersFromListResult(dict):
    def __init__(__self__, *,
                 key: str,
                 name: str):
        """
        :param str key: Expression that evaluates to the list lookup key.
        :param str name: The name of the list to match against.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Expression that evaluates to the list lookup key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the list to match against.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRulesetRuleActionParametersFromValueResult(dict):
    def __init__(__self__, *,
                 preserve_query_string: bool,
                 status_code: float,
                 target_url: 'outputs.GetRulesetRuleActionParametersFromValueTargetUrlResult'):
        """
        :param bool preserve_query_string: Keep the query string of the original request.
        :param float status_code: The status code to be used for the redirect.
        :param 'GetRulesetRuleActionParametersFromValueTargetUrlArgs' target_url: The URL to redirect the request to.
        """
        pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> bool:
        """
        Keep the query string of the original request.
        """
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> float:
        """
        The status code to be used for the redirect.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> 'outputs.GetRulesetRuleActionParametersFromValueTargetUrlResult':
        """
        The URL to redirect the request to.
        """
        return pulumi.get(self, "target_url")


@pulumi.output_type
class GetRulesetRuleActionParametersFromValueTargetUrlResult(dict):
    def __init__(__self__, *,
                 expression: str,
                 value: str):
        """
        :param str expression: An expression to evaluate to get the URL to redirect the request to.
        :param str value: The URL to redirect the request to.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        An expression to evaluate to get the URL to redirect the request to.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The URL to redirect the request to.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetRuleActionParametersHeadersResult(dict):
    def __init__(__self__, *,
                 expression: str,
                 operation: str,
                 value: str):
        """
        :param str expression: Expression for the header value.
        :param str value: Static value for the header.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Expression for the header value.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Static value for the header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetRuleActionParametersMatchedDataResult(dict):
    def __init__(__self__, *,
                 public_key: str):
        """
        :param str public_key: The public key to encrypt matched data logs with.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The public key to encrypt matched data logs with.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetRulesetRuleActionParametersOriginResult(dict):
    def __init__(__self__, *,
                 host: str,
                 port: float):
        """
        :param str host: Override the resolved hostname.
        :param float port: Override the destination port.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Override the resolved hostname.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        Override the destination port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRulesetRuleActionParametersOverridesResult(dict):
    def __init__(__self__, *,
                 action: str,
                 categories: Sequence['outputs.GetRulesetRuleActionParametersOverridesCategoryResult'],
                 enabled: bool,
                 rules: Sequence['outputs.GetRulesetRuleActionParametersOverridesRuleResult'],
                 sensitivity_level: str):
        """
        :param str action: An action to override all rules with. This option has lower precedence than rule and category overrides.
        :param Sequence['GetRulesetRuleActionParametersOverridesCategoryArgs'] categories: A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        :param bool enabled: Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        :param Sequence['GetRulesetRuleActionParametersOverridesRuleArgs'] rules: A list of rule-level overrides. This option has the highest precedence.
        :param str sensitivity_level: A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        An action to override all rules with. This option has lower precedence than rule and category overrides.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.GetRulesetRuleActionParametersOverridesCategoryResult']:
        """
        A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetRulesetRuleActionParametersOverridesRuleResult']:
        """
        A list of rule-level overrides. This option has the highest precedence.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> str:
        """
        A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class GetRulesetRuleActionParametersOverridesCategoryResult(dict):
    def __init__(__self__, *,
                 action: str,
                 category: str,
                 enabled: bool,
                 sensitivity_level: str):
        """
        :param str action: The action to override rules in the category with.
        :param str category: The name of the category to override.
        :param bool enabled: Whether to enable execution of rules in the category.
        :param str sensitivity_level: The sensitivity level to use for rules in the category.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to override rules in the category with.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The name of the category to override.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable execution of rules in the category.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> str:
        """
        The sensitivity level to use for rules in the category.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class GetRulesetRuleActionParametersOverridesRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 enabled: bool,
                 id: str,
                 score_threshold: int,
                 sensitivity_level: str):
        """
        :param str action: The action to override the rule with.
        :param bool enabled: Whether to enable execution of the rule.
        :param str id: The ID of the rule to override.
        :param int score_threshold: The score threshold to use for the rule.
        :param str sensitivity_level: The sensitivity level to use for the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "score_threshold", score_threshold)
        pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to override the rule with.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable execution of the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the rule to override.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> int:
        """
        The score threshold to use for the rule.
        """
        return pulumi.get(self, "score_threshold")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> str:
        """
        The sensitivity level to use for the rule.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class GetRulesetRuleActionParametersRequestFieldResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRulesetRuleActionParametersResponseResult(dict):
    def __init__(__self__, *,
                 content: str,
                 content_type: str,
                 status_code: int):
        """
        :param str content: The content to return.
        :param str content_type: The type of the content to return.
        :param int status_code: The status code to return.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content to return.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The type of the content to return.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The status code to return.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetRulesetRuleActionParametersResponseFieldResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRulesetRuleActionParametersServeStaleResult(dict):
    def __init__(__self__, *,
                 disable_stale_while_updating: bool):
        """
        :param bool disable_stale_while_updating: Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> bool:
        """
        Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        return pulumi.get(self, "disable_stale_while_updating")


@pulumi.output_type
class GetRulesetRuleActionParametersSniResult(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: The SNI override.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The SNI override.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetRuleActionParametersUriResult(dict):
    def __init__(__self__, *,
                 path: 'outputs.GetRulesetRuleActionParametersUriPathResult',
                 query: 'outputs.GetRulesetRuleActionParametersUriQueryResult'):
        """
        :param 'GetRulesetRuleActionParametersUriPathArgs' path: Path portion rewrite.
        :param 'GetRulesetRuleActionParametersUriQueryArgs' query: Query portion rewrite.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def path(self) -> 'outputs.GetRulesetRuleActionParametersUriPathResult':
        """
        Path portion rewrite.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> 'outputs.GetRulesetRuleActionParametersUriQueryResult':
        """
        Query portion rewrite.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetRulesetRuleActionParametersUriPathResult(dict):
    def __init__(__self__, *,
                 expression: str,
                 value: str):
        """
        :param str expression: Expression to evaluate for the replacement value.
        :param str value: Predefined replacement value.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Expression to evaluate for the replacement value.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Predefined replacement value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetRuleActionParametersUriQueryResult(dict):
    def __init__(__self__, *,
                 expression: str,
                 value: str):
        """
        :param str expression: Expression to evaluate for the replacement value.
        :param str value: Predefined replacement value.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Expression to evaluate for the replacement value.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Predefined replacement value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetRuleExposedCredentialCheckResult(dict):
    def __init__(__self__, *,
                 password_expression: str,
                 username_expression: str):
        """
        :param str password_expression: Expression that selects the password used in the credentials check.
        :param str username_expression: Expression that selects the user ID used in the credentials check.
        """
        pulumi.set(__self__, "password_expression", password_expression)
        pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> str:
        """
        Expression that selects the password used in the credentials check.
        """
        return pulumi.get(self, "password_expression")

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> str:
        """
        Expression that selects the user ID used in the credentials check.
        """
        return pulumi.get(self, "username_expression")


@pulumi.output_type
class GetRulesetRuleLoggingResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether to generate a log when the rule matches.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to generate a log when the rule matches.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetRulesetRuleRatelimitResult(dict):
    def __init__(__self__, *,
                 characteristics: Sequence[str],
                 counting_expression: str,
                 mitigation_timeout: int,
                 period: int,
                 requests_per_period: int,
                 requests_to_origin: bool,
                 score_per_period: int,
                 score_response_header_name: str):
        """
        :param Sequence[str] characteristics: Characteristics of the request on which the ratelimiter counter will be incremented.
        :param str counting_expression: Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
        :param int mitigation_timeout: Period of time in seconds after which the action will be disabled following its first execution.
        :param int period: Period in seconds over which the counter is being incremented.
        :param int requests_per_period: The threshold of requests per period after which the action will be executed for the first time.
        :param bool requests_to_origin: Defines if ratelimit counting is only done when an origin is reached.
        :param int score_per_period: The score threshold per period for which the action will be executed the first time.
        :param str score_response_header_name: The response header name provided by the origin which should contain the score to increment ratelimit counter on.
        """
        pulumi.set(__self__, "characteristics", characteristics)
        pulumi.set(__self__, "counting_expression", counting_expression)
        pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "requests_per_period", requests_per_period)
        pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        pulumi.set(__self__, "score_per_period", score_per_period)
        pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter
    def characteristics(self) -> Sequence[str]:
        """
        Characteristics of the request on which the ratelimiter counter will be incremented.
        """
        return pulumi.get(self, "characteristics")

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> str:
        """
        Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
        """
        return pulumi.get(self, "counting_expression")

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> int:
        """
        Period of time in seconds after which the action will be disabled following its first execution.
        """
        return pulumi.get(self, "mitigation_timeout")

    @property
    @pulumi.getter
    def period(self) -> int:
        """
        Period in seconds over which the counter is being incremented.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> int:
        """
        The threshold of requests per period after which the action will be executed for the first time.
        """
        return pulumi.get(self, "requests_per_period")

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> bool:
        """
        Defines if ratelimit counting is only done when an origin is reached.
        """
        return pulumi.get(self, "requests_to_origin")

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> int:
        """
        The score threshold per period for which the action will be executed the first time.
        """
        return pulumi.get(self, "score_per_period")

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> str:
        """
        The response header name provided by the origin which should contain the score to increment ratelimit counter on.
        """
        return pulumi.get(self, "score_response_header_name")


@pulumi.output_type
class GetRulesetsResultResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 kind: str,
                 name: str,
                 phase: str):
        """
        :param str description: An informative description of the ruleset.
        :param str id: The unique ID of the ruleset.
        :param str kind: The kind of the ruleset.
        :param str name: The human-readable name of the ruleset.
        :param str phase: The phase of the ruleset.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative description of the ruleset.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the ruleset.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The kind of the ruleset.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The human-readable name of the ruleset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def phase(self) -> str:
        """
        The phase of the ruleset.
        """
        return pulumi.get(self, "phase")


@pulumi.output_type
class GetSnippetRulesListResultResult(dict):
    def __init__(__self__, *,
                 description: str,
                 enabled: bool,
                 expression: str,
                 snippet_name: str):
        """
        :param str snippet_name: Snippet identifying name
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "snippet_name", snippet_name)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="snippetName")
    def snippet_name(self) -> str:
        """
        Snippet identifying name
        """
        return pulumi.get(self, "snippet_name")


@pulumi.output_type
class GetSnippetsListResultResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 modified_on: str,
                 snippet_name: str):
        """
        :param str created_on: Creation time of the snippet
        :param str modified_on: Modification time of the snippet
        :param str snippet_name: Snippet identifying name
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "snippet_name", snippet_name)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        Creation time of the snippet
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        Modification time of the snippet
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="snippetName")
    def snippet_name(self) -> str:
        """
        Snippet identifying name
        """
        return pulumi.get(self, "snippet_name")


@pulumi.output_type
class GetSpectrumApplicationDnsResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: The name of the DNS record associated with the application.
        :param str type: The type of DNS record associated with the application.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the DNS record associated with the application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of DNS record associated with the application.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSpectrumApplicationEdgeIpsResult(dict):
    def __init__(__self__, *,
                 connectivity: str,
                 ips: Sequence[str],
                 type: str):
        """
        :param str connectivity: The IP versions supported for inbound connections on Spectrum anycast IPs.
        :param Sequence[str] ips: The array of customer owned IPs we broadcast via anycast for this hostname and application.
        :param str type: The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        """
        pulumi.set(__self__, "connectivity", connectivity)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def connectivity(self) -> str:
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs.
        """
        return pulumi.get(self, "connectivity")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The array of customer owned IPs we broadcast via anycast for this hostname and application.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSpectrumApplicationOriginDnsResult(dict):
    def __init__(__self__, *,
                 name: str,
                 ttl: int,
                 type: str):
        """
        :param str name: The name of the DNS record associated with the origin.
        :param int ttl: The TTL of our resolution of your DNS record in seconds.
        :param str type: The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the DNS record associated with the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The TTL of our resolution of your DNS record in seconds.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSpectrumApplicationsResultResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetStreamInputResult(dict):
    def __init__(__self__, *,
                 height: int,
                 width: int):
        """
        :param int height: The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        :param int width: The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetStreamLiveInputRecordingResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 hide_live_viewer_count: bool,
                 mode: str,
                 require_signed_urls: bool,
                 timeout_seconds: int):
        """
        :param Sequence[str] allowed_origins: Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        :param bool hide_live_viewer_count: Disables reporting the number of live viewers when this property is set to `true`.
        :param str mode: Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        :param bool require_signed_urls: Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        :param int timeout_seconds: Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "hide_live_viewer_count", hide_live_viewer_count)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "require_signed_urls", require_signed_urls)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="hideLiveViewerCount")
    def hide_live_viewer_count(self) -> bool:
        """
        Disables reporting the number of live viewers when this property is set to `true`.
        """
        return pulumi.get(self, "hide_live_viewer_count")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="requireSignedUrls")
    def require_signed_urls(self) -> bool:
        """
        Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        """
        return pulumi.get(self, "require_signed_urls")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> int:
        """
        Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetStreamLiveInputRtmpsResult(dict):
    def __init__(__self__, *,
                 stream_key: str,
                 url: str):
        """
        :param str stream_key: The secret key to use when streaming via RTMPS to a live input.
        :param str url: The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
        pulumi.set(__self__, "stream_key", stream_key)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="streamKey")
    def stream_key(self) -> str:
        """
        The secret key to use when streaming via RTMPS to a live input.
        """
        return pulumi.get(self, "stream_key")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetStreamLiveInputRtmpsPlaybackResult(dict):
    def __init__(__self__, *,
                 stream_key: str,
                 url: str):
        """
        :param str stream_key: The secret key to use for playback via RTMPS.
        :param str url: The URL used to play live video over RTMPS.
        """
        pulumi.set(__self__, "stream_key", stream_key)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="streamKey")
    def stream_key(self) -> str:
        """
        The secret key to use for playback via RTMPS.
        """
        return pulumi.get(self, "stream_key")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL used to play live video over RTMPS.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetStreamLiveInputSrtResult(dict):
    def __init__(__self__, *,
                 passphrase: str,
                 stream_id: str,
                 url: str):
        """
        :param str passphrase: The secret key to use when streaming via SRT to a live input.
        :param str stream_id: The identifier of the live input to use when streaming via SRT.
        :param str url: The SRT URL you provide to the broadcaster, which they stream live video to.
        """
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "stream_id", stream_id)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def passphrase(self) -> str:
        """
        The secret key to use when streaming via SRT to a live input.
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> str:
        """
        The identifier of the live input to use when streaming via SRT.
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The SRT URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetStreamLiveInputSrtPlaybackResult(dict):
    def __init__(__self__, *,
                 passphrase: str,
                 stream_id: str,
                 url: str):
        """
        :param str passphrase: The secret key to use for playback via SRT.
        :param str stream_id: The identifier of the live input to use for playback via SRT.
        :param str url: The URL used to play live video over SRT.
        """
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "stream_id", stream_id)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def passphrase(self) -> str:
        """
        The secret key to use for playback via SRT.
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> str:
        """
        The identifier of the live input to use for playback via SRT.
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL used to play live video over SRT.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetStreamLiveInputWebRtcResult(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetStreamLiveInputWebRtcPlaybackResult(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL used to play live video over WebRTC.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL used to play live video over WebRTC.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetStreamPlaybackResult(dict):
    def __init__(__self__, *,
                 dash: str,
                 hls: str):
        """
        :param str dash: DASH Media Presentation Description for the video.
        :param str hls: The HLS manifest for the video.
        """
        pulumi.set(__self__, "dash", dash)
        pulumi.set(__self__, "hls", hls)

    @property
    @pulumi.getter
    def dash(self) -> str:
        """
        DASH Media Presentation Description for the video.
        """
        return pulumi.get(self, "dash")

    @property
    @pulumi.getter
    def hls(self) -> str:
        """
        The HLS manifest for the video.
        """
        return pulumi.get(self, "hls")


@pulumi.output_type
class GetStreamStatusResult(dict):
    def __init__(__self__, *,
                 error_reason_code: str,
                 error_reason_text: str,
                 pct_complete: str,
                 state: str):
        """
        :param str error_reason_code: Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        :param str error_reason_text: Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        :param str pct_complete: Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        :param str state: Specifies the processing status for all quality levels for a video.
        """
        pulumi.set(__self__, "error_reason_code", error_reason_code)
        pulumi.set(__self__, "error_reason_text", error_reason_text)
        pulumi.set(__self__, "pct_complete", pct_complete)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="errorReasonCode")
    def error_reason_code(self) -> str:
        """
        Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        """
        return pulumi.get(self, "error_reason_code")

    @property
    @pulumi.getter(name="errorReasonText")
    def error_reason_text(self) -> str:
        """
        Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        """
        return pulumi.get(self, "error_reason_text")

    @property
    @pulumi.getter(name="pctComplete")
    def pct_complete(self) -> str:
        """
        Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        """
        return pulumi.get(self, "pct_complete")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Specifies the processing status for all quality levels for a video.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetStreamWatermarkResult(dict):
    def __init__(__self__, *,
                 created: str,
                 downloaded_from: str,
                 height: int,
                 name: str,
                 opacity: float,
                 padding: float,
                 position: str,
                 scale: float,
                 size: float,
                 uid: str,
                 width: int):
        """
        :param str created: The date and a time a watermark profile was created.
        :param str downloaded_from: The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        :param int height: The height of the image in pixels.
        :param str name: A short description of the watermark profile.
        :param float opacity: The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        :param float padding: The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        :param str position: The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        :param float scale: The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        :param float size: The size of the image in bytes.
        :param str uid: The unique identifier for a watermark profile.
        :param int width: The width of the image in pixels.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "downloaded_from", downloaded_from)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "opacity", opacity)
        pulumi.set(__self__, "padding", padding)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "scale", scale)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The date and a time a watermark profile was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="downloadedFrom")
    def downloaded_from(self) -> str:
        """
        The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        """
        return pulumi.get(self, "downloaded_from")

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The height of the image in pixels.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A short description of the watermark profile.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def opacity(self) -> float:
        """
        The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        """
        return pulumi.get(self, "opacity")

    @property
    @pulumi.getter
    def padding(self) -> float:
        """
        The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        """
        return pulumi.get(self, "padding")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        """
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def scale(self) -> float:
        """
        The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        """
        return pulumi.get(self, "scale")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        The size of the image in bytes.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The unique identifier for a watermark profile.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        The width of the image in pixels.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetStreamWatermarksResultResult(dict):
    def __init__(__self__, *,
                 created: str,
                 downloaded_from: str,
                 height: int,
                 name: str,
                 opacity: float,
                 padding: float,
                 position: str,
                 scale: float,
                 size: float,
                 uid: str,
                 width: int):
        """
        :param str created: The date and a time a watermark profile was created.
        :param str downloaded_from: The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        :param int height: The height of the image in pixels.
        :param str name: A short description of the watermark profile.
        :param float opacity: The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        :param float padding: The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        :param str position: The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        :param float scale: The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        :param float size: The size of the image in bytes.
        :param str uid: The unique identifier for a watermark profile.
        :param int width: The width of the image in pixels.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "downloaded_from", downloaded_from)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "opacity", opacity)
        pulumi.set(__self__, "padding", padding)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "scale", scale)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The date and a time a watermark profile was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="downloadedFrom")
    def downloaded_from(self) -> str:
        """
        The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        """
        return pulumi.get(self, "downloaded_from")

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The height of the image in pixels.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A short description of the watermark profile.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def opacity(self) -> float:
        """
        The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        """
        return pulumi.get(self, "opacity")

    @property
    @pulumi.getter
    def padding(self) -> float:
        """
        The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        """
        return pulumi.get(self, "padding")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        """
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def scale(self) -> float:
        """
        The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        """
        return pulumi.get(self, "scale")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        The size of the image in bytes.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The unique identifier for a watermark profile.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        The width of the image in pixels.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetStreamsResultResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 created: str,
                 creator: str,
                 duration: float,
                 input: 'outputs.GetStreamsResultInputResult',
                 live_input: str,
                 max_duration_seconds: int,
                 meta: str,
                 modified: str,
                 playback: 'outputs.GetStreamsResultPlaybackResult',
                 preview: str,
                 ready_to_stream: bool,
                 ready_to_stream_at: str,
                 require_signed_urls: bool,
                 scheduled_deletion: str,
                 size: float,
                 status: 'outputs.GetStreamsResultStatusResult',
                 thumbnail: str,
                 thumbnail_timestamp_pct: float,
                 uid: str,
                 upload_expiry: str,
                 uploaded: str,
                 watermark: 'outputs.GetStreamsResultWatermarkResult'):
        """
        :param Sequence[str] allowed_origins: Lists the origins allowed to display the video. Enter allowed origin domains in an array and use `*` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin.
        :param str created: The date and time the media item was created.
        :param str creator: A user-defined identifier for the media creator.
        :param float duration: The duration of the video in seconds. A value of `-1` means the duration is unknown. The duration becomes available after the upload and before the video is ready.
        :param str live_input: The live input ID used to upload a video with Stream Live.
        :param int max_duration_seconds: The maximum duration in seconds for a video upload. Can be set for a video that is not yet uploaded to limit its duration. Uploads that exceed the specified duration will fail during processing. A value of `-1` means the value is unknown.
        :param str meta: A user modifiable key-value store used to reference other systems of record for managing videos.
        :param str modified: The date and time the media item was last modified.
        :param str preview: The video's preview page URI. This field is omitted until encoding is complete.
        :param bool ready_to_stream: Indicates whether the video is playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
        :param str ready_to_stream_at: Indicates the time at which the video became playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
        :param bool require_signed_urls: Indicates whether the video can be a accessed using the UID. When set to `true`, a signed token must be generated with a signing key to view the video.
        :param str scheduled_deletion: Indicates the date and time at which the video will be deleted. Omit the field to indicate no change, or include with a `null` value to remove an existing scheduled deletion. If specified, must be at least 30 days from upload time.
        :param float size: The size of the media item in bytes.
        :param 'GetStreamsResultStatusArgs' status: Specifies a detailed status for a video. If the `state` is `inprogress` or `error`, the `step` field returns `encoding` or `manifest`. If the `state` is `inprogress`, `pctComplete` returns a number between 0 and 100 to indicate the approximate percent of completion. If the `state` is `error`, `errorReasonCode` and `errorReasonText` provide additional details.
        :param str thumbnail: The media item's thumbnail URI. This field is omitted until encoding is complete.
        :param float thumbnail_timestamp_pct: The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video.
        :param str uid: A Cloudflare-generated unique identifier for a media item.
        :param str upload_expiry: The date and time when the video upload URL is no longer valid for direct user uploads.
        :param str uploaded: The date and time the media item was uploaded.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "live_input", live_input)
        pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "modified", modified)
        pulumi.set(__self__, "playback", playback)
        pulumi.set(__self__, "preview", preview)
        pulumi.set(__self__, "ready_to_stream", ready_to_stream)
        pulumi.set(__self__, "ready_to_stream_at", ready_to_stream_at)
        pulumi.set(__self__, "require_signed_urls", require_signed_urls)
        pulumi.set(__self__, "scheduled_deletion", scheduled_deletion)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "thumbnail", thumbnail)
        pulumi.set(__self__, "thumbnail_timestamp_pct", thumbnail_timestamp_pct)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "upload_expiry", upload_expiry)
        pulumi.set(__self__, "uploaded", uploaded)
        pulumi.set(__self__, "watermark", watermark)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Lists the origins allowed to display the video. Enter allowed origin domains in an array and use `*` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The date and time the media item was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def creator(self) -> str:
        """
        A user-defined identifier for the media creator.
        """
        return pulumi.get(self, "creator")

    @property
    @pulumi.getter
    def duration(self) -> float:
        """
        The duration of the video in seconds. A value of `-1` means the duration is unknown. The duration becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def input(self) -> 'outputs.GetStreamsResultInputResult':
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="liveInput")
    def live_input(self) -> str:
        """
        The live input ID used to upload a video with Stream Live.
        """
        return pulumi.get(self, "live_input")

    @property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> int:
        """
        The maximum duration in seconds for a video upload. Can be set for a video that is not yet uploaded to limit its duration. Uploads that exceed the specified duration will fail during processing. A value of `-1` means the value is unknown.
        """
        return pulumi.get(self, "max_duration_seconds")

    @property
    @pulumi.getter
    def meta(self) -> str:
        """
        A user modifiable key-value store used to reference other systems of record for managing videos.
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def modified(self) -> str:
        """
        The date and time the media item was last modified.
        """
        return pulumi.get(self, "modified")

    @property
    @pulumi.getter
    def playback(self) -> 'outputs.GetStreamsResultPlaybackResult':
        return pulumi.get(self, "playback")

    @property
    @pulumi.getter
    def preview(self) -> str:
        """
        The video's preview page URI. This field is omitted until encoding is complete.
        """
        return pulumi.get(self, "preview")

    @property
    @pulumi.getter(name="readyToStream")
    def ready_to_stream(self) -> bool:
        """
        Indicates whether the video is playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
        """
        return pulumi.get(self, "ready_to_stream")

    @property
    @pulumi.getter(name="readyToStreamAt")
    def ready_to_stream_at(self) -> str:
        """
        Indicates the time at which the video became playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
        """
        return pulumi.get(self, "ready_to_stream_at")

    @property
    @pulumi.getter(name="requireSignedUrls")
    def require_signed_urls(self) -> bool:
        """
        Indicates whether the video can be a accessed using the UID. When set to `true`, a signed token must be generated with a signing key to view the video.
        """
        return pulumi.get(self, "require_signed_urls")

    @property
    @pulumi.getter(name="scheduledDeletion")
    def scheduled_deletion(self) -> str:
        """
        Indicates the date and time at which the video will be deleted. Omit the field to indicate no change, or include with a `null` value to remove an existing scheduled deletion. If specified, must be at least 30 days from upload time.
        """
        return pulumi.get(self, "scheduled_deletion")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        The size of the media item in bytes.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def status(self) -> 'outputs.GetStreamsResultStatusResult':
        """
        Specifies a detailed status for a video. If the `state` is `inprogress` or `error`, the `step` field returns `encoding` or `manifest`. If the `state` is `inprogress`, `pctComplete` returns a number between 0 and 100 to indicate the approximate percent of completion. If the `state` is `error`, `errorReasonCode` and `errorReasonText` provide additional details.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def thumbnail(self) -> str:
        """
        The media item's thumbnail URI. This field is omitted until encoding is complete.
        """
        return pulumi.get(self, "thumbnail")

    @property
    @pulumi.getter(name="thumbnailTimestampPct")
    def thumbnail_timestamp_pct(self) -> float:
        """
        The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video.
        """
        return pulumi.get(self, "thumbnail_timestamp_pct")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        A Cloudflare-generated unique identifier for a media item.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="uploadExpiry")
    def upload_expiry(self) -> str:
        """
        The date and time when the video upload URL is no longer valid for direct user uploads.
        """
        return pulumi.get(self, "upload_expiry")

    @property
    @pulumi.getter
    def uploaded(self) -> str:
        """
        The date and time the media item was uploaded.
        """
        return pulumi.get(self, "uploaded")

    @property
    @pulumi.getter
    def watermark(self) -> 'outputs.GetStreamsResultWatermarkResult':
        return pulumi.get(self, "watermark")


@pulumi.output_type
class GetStreamsResultInputResult(dict):
    def __init__(__self__, *,
                 height: int,
                 width: int):
        """
        :param int height: The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        :param int width: The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetStreamsResultPlaybackResult(dict):
    def __init__(__self__, *,
                 dash: str,
                 hls: str):
        """
        :param str dash: DASH Media Presentation Description for the video.
        :param str hls: The HLS manifest for the video.
        """
        pulumi.set(__self__, "dash", dash)
        pulumi.set(__self__, "hls", hls)

    @property
    @pulumi.getter
    def dash(self) -> str:
        """
        DASH Media Presentation Description for the video.
        """
        return pulumi.get(self, "dash")

    @property
    @pulumi.getter
    def hls(self) -> str:
        """
        The HLS manifest for the video.
        """
        return pulumi.get(self, "hls")


@pulumi.output_type
class GetStreamsResultStatusResult(dict):
    def __init__(__self__, *,
                 error_reason_code: str,
                 error_reason_text: str,
                 pct_complete: str,
                 state: str):
        """
        :param str error_reason_code: Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        :param str error_reason_text: Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        :param str pct_complete: Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        :param str state: Specifies the processing status for all quality levels for a video.
        """
        pulumi.set(__self__, "error_reason_code", error_reason_code)
        pulumi.set(__self__, "error_reason_text", error_reason_text)
        pulumi.set(__self__, "pct_complete", pct_complete)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="errorReasonCode")
    def error_reason_code(self) -> str:
        """
        Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        """
        return pulumi.get(self, "error_reason_code")

    @property
    @pulumi.getter(name="errorReasonText")
    def error_reason_text(self) -> str:
        """
        Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        """
        return pulumi.get(self, "error_reason_text")

    @property
    @pulumi.getter(name="pctComplete")
    def pct_complete(self) -> str:
        """
        Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        """
        return pulumi.get(self, "pct_complete")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Specifies the processing status for all quality levels for a video.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetStreamsResultWatermarkResult(dict):
    def __init__(__self__, *,
                 created: str,
                 downloaded_from: str,
                 height: int,
                 name: str,
                 opacity: float,
                 padding: float,
                 position: str,
                 scale: float,
                 size: float,
                 uid: str,
                 width: int):
        """
        :param str created: The date and a time a watermark profile was created.
        :param str downloaded_from: The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        :param int height: The height of the image in pixels.
        :param str name: A short description of the watermark profile.
        :param float opacity: The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        :param float padding: The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        :param str position: The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        :param float scale: The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        :param float size: The size of the image in bytes.
        :param str uid: The unique identifier for a watermark profile.
        :param int width: The width of the image in pixels.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "downloaded_from", downloaded_from)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "opacity", opacity)
        pulumi.set(__self__, "padding", padding)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "scale", scale)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The date and a time a watermark profile was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="downloadedFrom")
    def downloaded_from(self) -> str:
        """
        The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        """
        return pulumi.get(self, "downloaded_from")

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The height of the image in pixels.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A short description of the watermark profile.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def opacity(self) -> float:
        """
        The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        """
        return pulumi.get(self, "opacity")

    @property
    @pulumi.getter
    def padding(self) -> float:
        """
        The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        """
        return pulumi.get(self, "padding")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        """
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def scale(self) -> float:
        """
        The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        """
        return pulumi.get(self, "scale")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        The size of the image in bytes.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The unique identifier for a watermark profile.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        The width of the image in pixels.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetTurnstileWidgetFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str direction: Direction to order widgets.
        :param str order: Field to order widgets by.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order widgets.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order widgets by.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class GetTurnstileWidgetsResultResult(dict):
    def __init__(__self__, *,
                 bot_fight_mode: bool,
                 clearance_level: str,
                 created_on: str,
                 domains: Sequence[str],
                 ephemeral_id: bool,
                 mode: str,
                 modified_on: str,
                 name: str,
                 offlabel: bool,
                 region: str,
                 sitekey: str):
        """
        :param bool bot_fight_mode: If bot*fight*mode is set to `true`, Cloudflare issues computationally
               expensive challenges in response to malicious bots (ENT only).
        :param str clearance_level: If Turnstile is embedded on a Cloudflare site and the widget should grant challenge clearance,
               this setting can determine the clearance level to be set
        :param str created_on: When the widget was created.
        :param bool ephemeral_id: Return the Ephemeral ID in /siteverify (ENT only).
        :param str mode: Widget Mode
        :param str modified_on: When the widget was modified.
        :param str name: Human readable widget name. Not unique. Cloudflare suggests that you
               set this to a meaningful string to make it easier to identify your
               widget, and where it is used.
        :param bool offlabel: Do not show any Cloudflare branding on the widget (ENT only).
        :param str region: Region where this widget can be used.
        :param str sitekey: Widget item identifier tag.
        """
        pulumi.set(__self__, "bot_fight_mode", bot_fight_mode)
        pulumi.set(__self__, "clearance_level", clearance_level)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "ephemeral_id", ephemeral_id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "offlabel", offlabel)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "sitekey", sitekey)

    @property
    @pulumi.getter(name="botFightMode")
    def bot_fight_mode(self) -> bool:
        """
        If bot*fight*mode is set to `true`, Cloudflare issues computationally
        expensive challenges in response to malicious bots (ENT only).
        """
        return pulumi.get(self, "bot_fight_mode")

    @property
    @pulumi.getter(name="clearanceLevel")
    def clearance_level(self) -> str:
        """
        If Turnstile is embedded on a Cloudflare site and the widget should grant challenge clearance,
        this setting can determine the clearance level to be set
        """
        return pulumi.get(self, "clearance_level")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the widget was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def domains(self) -> Sequence[str]:
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter(name="ephemeralId")
    def ephemeral_id(self) -> bool:
        """
        Return the Ephemeral ID in /siteverify (ENT only).
        """
        return pulumi.get(self, "ephemeral_id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Widget Mode
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the widget was modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Human readable widget name. Not unique. Cloudflare suggests that you
        set this to a meaningful string to make it easier to identify your
        widget, and where it is used.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def offlabel(self) -> bool:
        """
        Do not show any Cloudflare branding on the widget (ENT only).
        """
        return pulumi.get(self, "offlabel")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region where this widget can be used.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def sitekey(self) -> str:
        """
        Widget item identifier tag.
        """
        return pulumi.get(self, "sitekey")


@pulumi.output_type
class GetUserAgentBlockingRulesResultResult(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.GetUserAgentBlockingRulesResultConfigurationResult',
                 description: str,
                 id: str,
                 mode: str,
                 paused: bool):
        """
        :param 'GetUserAgentBlockingRulesResultConfigurationArgs' configuration: The configuration object for the current rule.
        :param str description: An informative summary of the rule.
        :param str id: The unique identifier of the User Agent Blocking rule.
        :param str mode: The action to apply to a matched request.
        :param bool paused: When true, indicates that the rule is currently paused.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "paused", paused)

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.GetUserAgentBlockingRulesResultConfigurationResult':
        """
        The configuration object for the current rule.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative summary of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the User Agent Blocking rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The action to apply to a matched request.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        When true, indicates that the rule is currently paused.
        """
        return pulumi.get(self, "paused")


@pulumi.output_type
class GetUserAgentBlockingRulesResultConfigurationResult(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The configuration target for this rule. You must set the target to `ua` for User Agent Blocking rules.
        :param str value: The exact user agent string to match. This value will be compared to the received `User-Agent` HTTP header value.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The configuration target for this rule. You must set the target to `ua` for User Agent Blocking rules.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The exact user agent string to match. This value will be compared to the received `User-Agent` HTTP header value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWaitingRoomAdditionalRouteResult(dict):
    def __init__(__self__, *,
                 host: str,
                 path: str):
        """
        :param str host: The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        :param str path: Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetWaitingRoomCookieAttributesResult(dict):
    def __init__(__self__, *,
                 samesite: str,
                 secure: str):
        """
        :param str samesite: Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        :param str secure: Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
        pulumi.set(__self__, "samesite", samesite)
        pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def samesite(self) -> str:
        """
        Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> str:
        """
        Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class GetWaitingRoomEventsResultResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 custom_page_html: str,
                 description: str,
                 disable_session_renewal: bool,
                 event_end_time: str,
                 event_start_time: str,
                 id: str,
                 modified_on: str,
                 name: str,
                 new_users_per_minute: int,
                 prequeue_start_time: str,
                 queueing_method: str,
                 session_duration: int,
                 shuffle_at_event_start: bool,
                 suspended: bool,
                 total_active_users: int):
        """
        :param str custom_page_html: If set, the event will override the waiting room's `custom_page_html` property while it is active. If null, the event will inherit it.
        :param str description: A note that you can use to add more details about the event.
        :param bool disable_session_renewal: If set, the event will override the waiting room's `disable_session_renewal` property while it is active. If null, the event will inherit it.
        :param str event_end_time: An ISO 8601 timestamp that marks the end of the event.
        :param str event_start_time: An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `event_end_time`.
        :param str name: A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
        :param int new_users_per_minute: If set, the event will override the waiting room's `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event's `total_active_users` property is also set.
        :param str prequeue_start_time: An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
        :param str queueing_method: If set, the event will override the waiting room's `queueing_method` property while it is active. If null, the event will inherit it.
        :param int session_duration: If set, the event will override the waiting room's `session_duration` property while it is active. If null, the event will inherit it.
        :param bool shuffle_at_event_start: If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
        :param bool suspended: Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
        :param int total_active_users: If set, the event will override the waiting room's `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event's `new_users_per_minute` property is also set.
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "custom_page_html", custom_page_html)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disable_session_renewal", disable_session_renewal)
        pulumi.set(__self__, "event_end_time", event_end_time)
        pulumi.set(__self__, "event_start_time", event_start_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "new_users_per_minute", new_users_per_minute)
        pulumi.set(__self__, "prequeue_start_time", prequeue_start_time)
        pulumi.set(__self__, "queueing_method", queueing_method)
        pulumi.set(__self__, "session_duration", session_duration)
        pulumi.set(__self__, "shuffle_at_event_start", shuffle_at_event_start)
        pulumi.set(__self__, "suspended", suspended)
        pulumi.set(__self__, "total_active_users", total_active_users)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="customPageHtml")
    def custom_page_html(self) -> str:
        """
        If set, the event will override the waiting room's `custom_page_html` property while it is active. If null, the event will inherit it.
        """
        return pulumi.get(self, "custom_page_html")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A note that you can use to add more details about the event.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableSessionRenewal")
    def disable_session_renewal(self) -> bool:
        """
        If set, the event will override the waiting room's `disable_session_renewal` property while it is active. If null, the event will inherit it.
        """
        return pulumi.get(self, "disable_session_renewal")

    @property
    @pulumi.getter(name="eventEndTime")
    def event_end_time(self) -> str:
        """
        An ISO 8601 timestamp that marks the end of the event.
        """
        return pulumi.get(self, "event_end_time")

    @property
    @pulumi.getter(name="eventStartTime")
    def event_start_time(self) -> str:
        """
        An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `event_end_time`.
        """
        return pulumi.get(self, "event_start_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="newUsersPerMinute")
    def new_users_per_minute(self) -> int:
        """
        If set, the event will override the waiting room's `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event's `total_active_users` property is also set.
        """
        return pulumi.get(self, "new_users_per_minute")

    @property
    @pulumi.getter(name="prequeueStartTime")
    def prequeue_start_time(self) -> str:
        """
        An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
        """
        return pulumi.get(self, "prequeue_start_time")

    @property
    @pulumi.getter(name="queueingMethod")
    def queueing_method(self) -> str:
        """
        If set, the event will override the waiting room's `queueing_method` property while it is active. If null, the event will inherit it.
        """
        return pulumi.get(self, "queueing_method")

    @property
    @pulumi.getter(name="sessionDuration")
    def session_duration(self) -> int:
        """
        If set, the event will override the waiting room's `session_duration` property while it is active. If null, the event will inherit it.
        """
        return pulumi.get(self, "session_duration")

    @property
    @pulumi.getter(name="shuffleAtEventStart")
    def shuffle_at_event_start(self) -> bool:
        """
        If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
        """
        return pulumi.get(self, "shuffle_at_event_start")

    @property
    @pulumi.getter
    def suspended(self) -> bool:
        """
        Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter(name="totalActiveUsers")
    def total_active_users(self) -> int:
        """
        If set, the event will override the waiting room's `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event's `new_users_per_minute` property is also set.
        """
        return pulumi.get(self, "total_active_users")


@pulumi.output_type
class GetWaitingRoomsResultResult(dict):
    def __init__(__self__, *,
                 additional_routes: Sequence['outputs.GetWaitingRoomsResultAdditionalRouteResult'],
                 cookie_attributes: 'outputs.GetWaitingRoomsResultCookieAttributesResult',
                 cookie_suffix: str,
                 created_on: str,
                 custom_page_html: str,
                 default_template_language: str,
                 description: str,
                 disable_session_renewal: bool,
                 enabled_origin_commands: Sequence[str],
                 host: str,
                 id: str,
                 json_response_enabled: bool,
                 modified_on: str,
                 name: str,
                 new_users_per_minute: int,
                 next_event_prequeue_start_time: str,
                 next_event_start_time: str,
                 path: str,
                 queue_all: bool,
                 queueing_method: str,
                 queueing_status_code: int,
                 session_duration: int,
                 suspended: bool,
                 total_active_users: int,
                 turnstile_action: str,
                 turnstile_mode: str):
        """
        :param Sequence['GetWaitingRoomsResultAdditionalRouteArgs'] additional_routes: Only available for the Waiting Room Advanced subscription. Additional hostname and path combinations to which this waiting room will be applied. There is an implied wildcard at the end of the path. The hostname and path combination must be unique to this and all other waiting rooms.
        :param 'GetWaitingRoomsResultCookieAttributesArgs' cookie_attributes: Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position.
        :param str cookie_suffix: Appends a '_' + a custom suffix to the end of Cloudflare Waiting Room's cookie name(_*cf*waitingroom). If `cookie_suffix` is "abcd", the cookie name will be `__cf_waitingroom_abcd`. This field is required if using `additional_routes`.
        :param str custom_page_html: Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom*page*html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:
        :param str default_template_language: The language of the default page template. If no default_template_language is provided, then `en-US` (English) will be used.
        :param str description: A note that you can use to add more details about the waiting room.
        :param bool disable_session_renewal: Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If `true`, an accepted user will have session_duration minutes to browse the site. After that, they will have to go through the waiting room again. If `false`, a user's session cookie will be automatically renewed on every request.
        :param Sequence[str] enabled_origin_commands: A list of enabled origin commands.
        :param str host: The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique.
        :param bool json_response_enabled: Only available for the Waiting Room Advanced subscription. If `true`, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object with information on the user's status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property `cfWaitingRoom` which is an object containing the following fields:
               1. `inWaitingRoom`: Boolean indicating if the user is in the waiting room (always **true**).
               2. `waitTimeKnown`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.
               3. `waitTime`: Valid only when `waitTimeKnown` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When `queueingMethod` is **random**, this is set to `waitTime50Percentile`.
               4. `waitTime25Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).
               5. `waitTime50Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before `waitTime50Percentile` and half are expected to be let in after it.
               6. `waitTime75Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).
               7. `waitTimeFormatted`: String displaying the `waitTime` formatted in English for users. If `waitTimeKnown` is **false**, `waitTimeFormatted` will display **unavailable**.
               8. `queueIsFull`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.
               9. `queueAll`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.
               10. `lastUpdated`: String displaying the timestamp as an ISO 8601 string of the user's last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after `refreshIntervalSeconds` past this time. If the user makes a request too soon, it will be ignored and `lastUpdated` will not change.
               11. `refreshIntervalSeconds`: Integer indicating the number of seconds after `lastUpdated` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the `queueingMethod` is `reject`, there is no specified refresh time — it will always be **zero**.
               12. `queueingMethod`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.
               13. `isFIFOQueue`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.
               14. `isRandomQueue`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.
               15. `isPassthroughQueue`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when `queueAll` is **true** or `isEventPrequeueing` is **true** because in all other cases requests will go directly to the origin.
               16. `isRejectQueue`: Boolean indicating if the waiting room uses a reject queue.
               17. `isEventActive`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room's behavior during a specified period of time. For additional information, look at the event properties `prequeue_start_time`, `event_start_time`, and `event_end_time` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.
               18. `isEventPrequeueing`: Valid only when `isEventActive` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.
               19. `timeUntilEventStart`: Valid only when `isEventPrequeueing` is **true**. Integer indicating the number of minutes until the event starts.
               20. `timeUntilEventStartFormatted`: String displaying the `timeUntilEventStart` formatted in English for users. If `isEventPrequeueing` is **false**, `timeUntilEventStartFormatted` will display **unavailable**.
               21. `timeUntilEventEnd`: Valid only when `isEventActive` is **true**. Integer indicating the number of minutes until the event ends.
               22. `timeUntilEventEndFormatted`: String displaying the `timeUntilEventEnd` formatted in English for users. If `isEventActive` is **false**, `timeUntilEventEndFormatted` will display **unavailable**.
               23. `shuffleAtEventStart`: Valid only when `isEventActive` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.
               
               An example cURL to a waiting room could be:
               
               	curl -X GET "https://example.com/waitingroom" \\
               		-H "Accept: application/json"
               
               If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **fifo** and no event is active could be:
               
               	{
               		"cfWaitingRoom": {
               			"inWaitingRoom": true,
               			"waitTimeKnown": true,
               			"waitTime": 10,
               			"waitTime25Percentile": 0,
               			"waitTime50Percentile": 0,
               			"waitTime75Percentile": 0,
               			"waitTimeFormatted": "10 minutes",
               			"queueIsFull": false,
               			"queueAll": false,
               			"lastUpdated": "2020-08-03T23:46:00.000Z",
               			"refreshIntervalSeconds": 20,
               			"queueingMethod": "fifo",
               			"isFIFOQueue": true,
               			"isRandomQueue": false,
               			"isPassthroughQueue": false,
               			"isRejectQueue": false,
               			"isEventActive": false,
               			"isEventPrequeueing": false,
               			"timeUntilEventStart": 0,
               			"timeUntilEventStartFormatted": "unavailable",
               			"timeUntilEventEnd": 0,
               			"timeUntilEventEndFormatted": "unavailable",
               			"shuffleAtEventStart": false
               		}
               	}
               
               If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **random** and an event is active could be:
               
               	{
               		"cfWaitingRoom": {
               			"inWaitingRoom": true,
               			"waitTimeKnown": true,
               			"waitTime": 10,
               			"waitTime25Percentile": 5,
               			"waitTime50Percentile": 10,
               			"waitTime75Percentile": 15,
               			"waitTimeFormatted": "5 minutes to 15 minutes",
               			"queueIsFull": false,
               			"queueAll": false,
               			"lastUpdated": "2020-08-03T23:46:00.000Z",
               			"refreshIntervalSeconds": 20,
               			"queueingMethod": "random",
               			"isFIFOQueue": false,
               			"isRandomQueue": true,
               			"isPassthroughQueue": false,
               			"isRejectQueue": false,
               			"isEventActive": true,
               			"isEventPrequeueing": false,
               			"timeUntilEventStart": 0,
               			"timeUntilEventStartFormatted": "unavailable",
               			"timeUntilEventEnd": 15,
               			"timeUntilEventEndFormatted": "15 minutes",
               			"shuffleAtEventStart": true
               		}
               	}.
        :param str name: A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed.
        :param int new_users_per_minute: Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world.
        :param str next_event_prequeue_start_time: An ISO 8601 timestamp that marks when the next event will begin queueing.
        :param str next_event_start_time: An ISO 8601 timestamp that marks when the next event will start.
        :param str path: Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        :param bool queue_all: If queue_all is `true`, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable.
        :param str queueing_method: Sets the queueing method used by the waiting room. Changing this parameter from the **default** queueing method is only available for the Waiting Room Advanced subscription. Regardless of the queueing method, if `queue_all` is enabled or an event is prequeueing, users in the waiting room will not be accepted to the origin. These users will always see a waiting room page that refreshes automatically. The valid queueing methods are:
               1. `fifo` **(default)**: First-In-First-Out queue where customers gain access in the order they arrived.
               2. `random`: Random queue where customers gain access randomly, regardless of arrival time.
               3. `passthrough`: Users will pass directly through the waiting room and into the origin website. As a result, any configured limits will not be respected while this is enabled. This method can be used as an alternative to disabling a waiting room (with `suspended`) so that analytics are still reported. This can be used if you wish to allow all traffic normally, but want to restrict traffic during a waiting room event, or vice versa.
               4. `reject`: Users will be immediately rejected from the waiting room. As a result, no users will reach the origin website while this is enabled. This can be used if you wish to reject all traffic while performing maintenance, block traffic during a specified period of time (an event), or block traffic while events are not occurring. Consider a waiting room used for vaccine distribution that only allows traffic during sign-up events, and otherwise blocks all traffic. For this case, the waiting room uses `reject`, and its events override this with `fifo`, `random`, or `passthrough`. When this queueing method is enabled and neither `queueAll` is enabled nor an event is prequeueing, the waiting room page **will not refresh automatically**.
        :param int queueing_status_code: HTTP status code returned to a user while in the queue.
        :param int session_duration: Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route.
        :param bool suspended: Suspends or allows traffic going to the waiting room. If set to `true`, the traffic will not go to the waiting room.
        :param int total_active_users: Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world.
        :param str turnstile_action: Which action to take when a bot is detected using Turnstile. `log` will
               have no impact on queueing behavior, simply keeping track of how many
               bots are detected in Waiting Room Analytics. `infinite_queue` will send
               bots to a false queueing state, where they will never reach your
               origin. `infinite_queue` requires Advanced Waiting Room.
        :param str turnstile_mode: Which Turnstile widget type to use for detecting bot traffic. See
               [the Turnstile documentation](https://developers.cloudflare.com/turnstile/concepts/widget/#widget-types)
               for the definitions of these widget types. Set to `off` to disable the
               Turnstile integration entirely. Setting this to anything other than
               `off` or `invisible` requires Advanced Waiting Room.
        """
        pulumi.set(__self__, "additional_routes", additional_routes)
        pulumi.set(__self__, "cookie_attributes", cookie_attributes)
        pulumi.set(__self__, "cookie_suffix", cookie_suffix)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "custom_page_html", custom_page_html)
        pulumi.set(__self__, "default_template_language", default_template_language)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disable_session_renewal", disable_session_renewal)
        pulumi.set(__self__, "enabled_origin_commands", enabled_origin_commands)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "json_response_enabled", json_response_enabled)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "new_users_per_minute", new_users_per_minute)
        pulumi.set(__self__, "next_event_prequeue_start_time", next_event_prequeue_start_time)
        pulumi.set(__self__, "next_event_start_time", next_event_start_time)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "queue_all", queue_all)
        pulumi.set(__self__, "queueing_method", queueing_method)
        pulumi.set(__self__, "queueing_status_code", queueing_status_code)
        pulumi.set(__self__, "session_duration", session_duration)
        pulumi.set(__self__, "suspended", suspended)
        pulumi.set(__self__, "total_active_users", total_active_users)
        pulumi.set(__self__, "turnstile_action", turnstile_action)
        pulumi.set(__self__, "turnstile_mode", turnstile_mode)

    @property
    @pulumi.getter(name="additionalRoutes")
    def additional_routes(self) -> Sequence['outputs.GetWaitingRoomsResultAdditionalRouteResult']:
        """
        Only available for the Waiting Room Advanced subscription. Additional hostname and path combinations to which this waiting room will be applied. There is an implied wildcard at the end of the path. The hostname and path combination must be unique to this and all other waiting rooms.
        """
        return pulumi.get(self, "additional_routes")

    @property
    @pulumi.getter(name="cookieAttributes")
    def cookie_attributes(self) -> 'outputs.GetWaitingRoomsResultCookieAttributesResult':
        """
        Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position.
        """
        return pulumi.get(self, "cookie_attributes")

    @property
    @pulumi.getter(name="cookieSuffix")
    def cookie_suffix(self) -> str:
        """
        Appends a '_' + a custom suffix to the end of Cloudflare Waiting Room's cookie name(_*cf*waitingroom). If `cookie_suffix` is "abcd", the cookie name will be `__cf_waitingroom_abcd`. This field is required if using `additional_routes`.
        """
        return pulumi.get(self, "cookie_suffix")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="customPageHtml")
    def custom_page_html(self) -> str:
        """
        Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom*page*html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:
        """
        return pulumi.get(self, "custom_page_html")

    @property
    @pulumi.getter(name="defaultTemplateLanguage")
    def default_template_language(self) -> str:
        """
        The language of the default page template. If no default_template_language is provided, then `en-US` (English) will be used.
        """
        return pulumi.get(self, "default_template_language")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A note that you can use to add more details about the waiting room.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableSessionRenewal")
    def disable_session_renewal(self) -> bool:
        """
        Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If `true`, an accepted user will have session_duration minutes to browse the site. After that, they will have to go through the waiting room again. If `false`, a user's session cookie will be automatically renewed on every request.
        """
        return pulumi.get(self, "disable_session_renewal")

    @property
    @pulumi.getter(name="enabledOriginCommands")
    def enabled_origin_commands(self) -> Sequence[str]:
        """
        A list of enabled origin commands.
        """
        return pulumi.get(self, "enabled_origin_commands")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="jsonResponseEnabled")
    def json_response_enabled(self) -> bool:
        """
        Only available for the Waiting Room Advanced subscription. If `true`, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object with information on the user's status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property `cfWaitingRoom` which is an object containing the following fields:
        1. `inWaitingRoom`: Boolean indicating if the user is in the waiting room (always **true**).
        2. `waitTimeKnown`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.
        3. `waitTime`: Valid only when `waitTimeKnown` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When `queueingMethod` is **random**, this is set to `waitTime50Percentile`.
        4. `waitTime25Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).
        5. `waitTime50Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before `waitTime50Percentile` and half are expected to be let in after it.
        6. `waitTime75Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).
        7. `waitTimeFormatted`: String displaying the `waitTime` formatted in English for users. If `waitTimeKnown` is **false**, `waitTimeFormatted` will display **unavailable**.
        8. `queueIsFull`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.
        9. `queueAll`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.
        10. `lastUpdated`: String displaying the timestamp as an ISO 8601 string of the user's last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after `refreshIntervalSeconds` past this time. If the user makes a request too soon, it will be ignored and `lastUpdated` will not change.
        11. `refreshIntervalSeconds`: Integer indicating the number of seconds after `lastUpdated` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the `queueingMethod` is `reject`, there is no specified refresh time — it will always be **zero**.
        12. `queueingMethod`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.
        13. `isFIFOQueue`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.
        14. `isRandomQueue`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.
        15. `isPassthroughQueue`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when `queueAll` is **true** or `isEventPrequeueing` is **true** because in all other cases requests will go directly to the origin.
        16. `isRejectQueue`: Boolean indicating if the waiting room uses a reject queue.
        17. `isEventActive`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room's behavior during a specified period of time. For additional information, look at the event properties `prequeue_start_time`, `event_start_time`, and `event_end_time` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.
        18. `isEventPrequeueing`: Valid only when `isEventActive` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.
        19. `timeUntilEventStart`: Valid only when `isEventPrequeueing` is **true**. Integer indicating the number of minutes until the event starts.
        20. `timeUntilEventStartFormatted`: String displaying the `timeUntilEventStart` formatted in English for users. If `isEventPrequeueing` is **false**, `timeUntilEventStartFormatted` will display **unavailable**.
        21. `timeUntilEventEnd`: Valid only when `isEventActive` is **true**. Integer indicating the number of minutes until the event ends.
        22. `timeUntilEventEndFormatted`: String displaying the `timeUntilEventEnd` formatted in English for users. If `isEventActive` is **false**, `timeUntilEventEndFormatted` will display **unavailable**.
        23. `shuffleAtEventStart`: Valid only when `isEventActive` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.

        An example cURL to a waiting room could be:

        	curl -X GET "https://example.com/waitingroom" \\
        		-H "Accept: application/json"

        If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **fifo** and no event is active could be:

        	{
        		"cfWaitingRoom": {
        			"inWaitingRoom": true,
        			"waitTimeKnown": true,
        			"waitTime": 10,
        			"waitTime25Percentile": 0,
        			"waitTime50Percentile": 0,
        			"waitTime75Percentile": 0,
        			"waitTimeFormatted": "10 minutes",
        			"queueIsFull": false,
        			"queueAll": false,
        			"lastUpdated": "2020-08-03T23:46:00.000Z",
        			"refreshIntervalSeconds": 20,
        			"queueingMethod": "fifo",
        			"isFIFOQueue": true,
        			"isRandomQueue": false,
        			"isPassthroughQueue": false,
        			"isRejectQueue": false,
        			"isEventActive": false,
        			"isEventPrequeueing": false,
        			"timeUntilEventStart": 0,
        			"timeUntilEventStartFormatted": "unavailable",
        			"timeUntilEventEnd": 0,
        			"timeUntilEventEndFormatted": "unavailable",
        			"shuffleAtEventStart": false
        		}
        	}

        If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **random** and an event is active could be:

        	{
        		"cfWaitingRoom": {
        			"inWaitingRoom": true,
        			"waitTimeKnown": true,
        			"waitTime": 10,
        			"waitTime25Percentile": 5,
        			"waitTime50Percentile": 10,
        			"waitTime75Percentile": 15,
        			"waitTimeFormatted": "5 minutes to 15 minutes",
        			"queueIsFull": false,
        			"queueAll": false,
        			"lastUpdated": "2020-08-03T23:46:00.000Z",
        			"refreshIntervalSeconds": 20,
        			"queueingMethod": "random",
        			"isFIFOQueue": false,
        			"isRandomQueue": true,
        			"isPassthroughQueue": false,
        			"isRejectQueue": false,
        			"isEventActive": true,
        			"isEventPrequeueing": false,
        			"timeUntilEventStart": 0,
        			"timeUntilEventStartFormatted": "unavailable",
        			"timeUntilEventEnd": 15,
        			"timeUntilEventEndFormatted": "15 minutes",
        			"shuffleAtEventStart": true
        		}
        	}.
        """
        return pulumi.get(self, "json_response_enabled")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="newUsersPerMinute")
    def new_users_per_minute(self) -> int:
        """
        Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world.
        """
        return pulumi.get(self, "new_users_per_minute")

    @property
    @pulumi.getter(name="nextEventPrequeueStartTime")
    def next_event_prequeue_start_time(self) -> str:
        """
        An ISO 8601 timestamp that marks when the next event will begin queueing.
        """
        return pulumi.get(self, "next_event_prequeue_start_time")

    @property
    @pulumi.getter(name="nextEventStartTime")
    def next_event_start_time(self) -> str:
        """
        An ISO 8601 timestamp that marks when the next event will start.
        """
        return pulumi.get(self, "next_event_start_time")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="queueAll")
    def queue_all(self) -> bool:
        """
        If queue_all is `true`, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable.
        """
        return pulumi.get(self, "queue_all")

    @property
    @pulumi.getter(name="queueingMethod")
    def queueing_method(self) -> str:
        """
        Sets the queueing method used by the waiting room. Changing this parameter from the **default** queueing method is only available for the Waiting Room Advanced subscription. Regardless of the queueing method, if `queue_all` is enabled or an event is prequeueing, users in the waiting room will not be accepted to the origin. These users will always see a waiting room page that refreshes automatically. The valid queueing methods are:
        1. `fifo` **(default)**: First-In-First-Out queue where customers gain access in the order they arrived.
        2. `random`: Random queue where customers gain access randomly, regardless of arrival time.
        3. `passthrough`: Users will pass directly through the waiting room and into the origin website. As a result, any configured limits will not be respected while this is enabled. This method can be used as an alternative to disabling a waiting room (with `suspended`) so that analytics are still reported. This can be used if you wish to allow all traffic normally, but want to restrict traffic during a waiting room event, or vice versa.
        4. `reject`: Users will be immediately rejected from the waiting room. As a result, no users will reach the origin website while this is enabled. This can be used if you wish to reject all traffic while performing maintenance, block traffic during a specified period of time (an event), or block traffic while events are not occurring. Consider a waiting room used for vaccine distribution that only allows traffic during sign-up events, and otherwise blocks all traffic. For this case, the waiting room uses `reject`, and its events override this with `fifo`, `random`, or `passthrough`. When this queueing method is enabled and neither `queueAll` is enabled nor an event is prequeueing, the waiting room page **will not refresh automatically**.
        """
        return pulumi.get(self, "queueing_method")

    @property
    @pulumi.getter(name="queueingStatusCode")
    def queueing_status_code(self) -> int:
        """
        HTTP status code returned to a user while in the queue.
        """
        return pulumi.get(self, "queueing_status_code")

    @property
    @pulumi.getter(name="sessionDuration")
    def session_duration(self) -> int:
        """
        Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route.
        """
        return pulumi.get(self, "session_duration")

    @property
    @pulumi.getter
    def suspended(self) -> bool:
        """
        Suspends or allows traffic going to the waiting room. If set to `true`, the traffic will not go to the waiting room.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter(name="totalActiveUsers")
    def total_active_users(self) -> int:
        """
        Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world.
        """
        return pulumi.get(self, "total_active_users")

    @property
    @pulumi.getter(name="turnstileAction")
    def turnstile_action(self) -> str:
        """
        Which action to take when a bot is detected using Turnstile. `log` will
        have no impact on queueing behavior, simply keeping track of how many
        bots are detected in Waiting Room Analytics. `infinite_queue` will send
        bots to a false queueing state, where they will never reach your
        origin. `infinite_queue` requires Advanced Waiting Room.
        """
        return pulumi.get(self, "turnstile_action")

    @property
    @pulumi.getter(name="turnstileMode")
    def turnstile_mode(self) -> str:
        """
        Which Turnstile widget type to use for detecting bot traffic. See
        [the Turnstile documentation](https://developers.cloudflare.com/turnstile/concepts/widget/#widget-types)
        for the definitions of these widget types. Set to `off` to disable the
        Turnstile integration entirely. Setting this to anything other than
        `off` or `invisible` requires Advanced Waiting Room.
        """
        return pulumi.get(self, "turnstile_mode")


@pulumi.output_type
class GetWaitingRoomsResultAdditionalRouteResult(dict):
    def __init__(__self__, *,
                 host: str,
                 path: str):
        """
        :param str host: The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        :param str path: Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetWaitingRoomsResultCookieAttributesResult(dict):
    def __init__(__self__, *,
                 samesite: str,
                 secure: str):
        """
        :param str samesite: Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        :param str secure: Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
        pulumi.set(__self__, "samesite", samesite)
        pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def samesite(self) -> str:
        """
        Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> str:
        """
        Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class GetWeb3HostnamesResultResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 description: str,
                 dnslink: str,
                 id: str,
                 modified_on: str,
                 name: str,
                 status: str,
                 target: str):
        """
        :param str description: An optional description of the hostname.
        :param str dnslink: DNSLink value used if the target is ipfs.
        :param str id: Identifier
        :param str name: The hostname that will point to the target gateway via CNAME.
        :param str status: Status of the hostname's activation.
        :param str target: Target gateway of the hostname.
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dnslink", dnslink)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An optional description of the hostname.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def dnslink(self) -> str:
        """
        DNSLink value used if the target is ipfs.
        """
        return pulumi.get(self, "dnslink")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The hostname that will point to the target gateway via CNAME.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the hostname's activation.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Target gateway of the hostname.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetWebAnalyticsSiteFilterResult(dict):
    def __init__(__self__, *,
                 order_by: Optional[str] = None):
        """
        :param str order_by: The property used to sort the list of results.
        """
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        The property used to sort the list of results.
        """
        return pulumi.get(self, "order_by")


@pulumi.output_type
class GetWebAnalyticsSiteRuleResult(dict):
    def __init__(__self__, *,
                 created: str,
                 host: str,
                 id: str,
                 inclusive: bool,
                 is_paused: bool,
                 paths: Sequence[str],
                 priority: float):
        """
        :param str host: The hostname the rule will be applied to.
        :param str id: The Web Analytics rule identifier.
        :param bool inclusive: Whether the rule includes or excludes traffic from being measured.
        :param bool is_paused: Whether the rule is paused or not.
        :param Sequence[str] paths: The paths the rule will be applied to.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inclusive", inclusive)
        pulumi.set(__self__, "is_paused", is_paused)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname the rule will be applied to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Web Analytics rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def inclusive(self) -> bool:
        """
        Whether the rule includes or excludes traffic from being measured.
        """
        return pulumi.get(self, "inclusive")

    @property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> bool:
        """
        Whether the rule is paused or not.
        """
        return pulumi.get(self, "is_paused")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        The paths the rule will be applied to.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def priority(self) -> float:
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetWebAnalyticsSiteRulesetResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 id: str,
                 zone_name: str,
                 zone_tag: str):
        """
        :param bool enabled: Whether the ruleset is enabled.
        :param str id: The Web Analytics ruleset identifier.
        :param str zone_tag: The zone identifier.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "zone_name", zone_name)
        pulumi.set(__self__, "zone_tag", zone_tag)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the ruleset is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Web Analytics ruleset identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        return pulumi.get(self, "zone_name")

    @property
    @pulumi.getter(name="zoneTag")
    def zone_tag(self) -> str:
        """
        The zone identifier.
        """
        return pulumi.get(self, "zone_tag")


@pulumi.output_type
class GetWebAnalyticsSitesResultResult(dict):
    def __init__(__self__, *,
                 auto_install: bool,
                 created: str,
                 rules: Sequence['outputs.GetWebAnalyticsSitesResultRuleResult'],
                 ruleset: 'outputs.GetWebAnalyticsSitesResultRulesetResult',
                 site_tag: str,
                 site_token: str,
                 snippet: str):
        """
        :param bool auto_install: If enabled, the JavaScript snippet is automatically injected for orange-clouded sites.
        :param Sequence['GetWebAnalyticsSitesResultRuleArgs'] rules: A list of rules.
        :param str site_tag: The Web Analytics site identifier.
        :param str site_token: The Web Analytics site token.
        :param str snippet: Encoded JavaScript snippet.
        """
        pulumi.set(__self__, "auto_install", auto_install)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "ruleset", ruleset)
        pulumi.set(__self__, "site_tag", site_tag)
        pulumi.set(__self__, "site_token", site_token)
        pulumi.set(__self__, "snippet", snippet)

    @property
    @pulumi.getter(name="autoInstall")
    def auto_install(self) -> bool:
        """
        If enabled, the JavaScript snippet is automatically injected for orange-clouded sites.
        """
        return pulumi.get(self, "auto_install")

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetWebAnalyticsSitesResultRuleResult']:
        """
        A list of rules.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def ruleset(self) -> 'outputs.GetWebAnalyticsSitesResultRulesetResult':
        return pulumi.get(self, "ruleset")

    @property
    @pulumi.getter(name="siteTag")
    def site_tag(self) -> str:
        """
        The Web Analytics site identifier.
        """
        return pulumi.get(self, "site_tag")

    @property
    @pulumi.getter(name="siteToken")
    def site_token(self) -> str:
        """
        The Web Analytics site token.
        """
        return pulumi.get(self, "site_token")

    @property
    @pulumi.getter
    def snippet(self) -> str:
        """
        Encoded JavaScript snippet.
        """
        return pulumi.get(self, "snippet")


@pulumi.output_type
class GetWebAnalyticsSitesResultRuleResult(dict):
    def __init__(__self__, *,
                 created: str,
                 host: str,
                 id: str,
                 inclusive: bool,
                 is_paused: bool,
                 paths: Sequence[str],
                 priority: float):
        """
        :param str host: The hostname the rule will be applied to.
        :param str id: The Web Analytics rule identifier.
        :param bool inclusive: Whether the rule includes or excludes traffic from being measured.
        :param bool is_paused: Whether the rule is paused or not.
        :param Sequence[str] paths: The paths the rule will be applied to.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inclusive", inclusive)
        pulumi.set(__self__, "is_paused", is_paused)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname the rule will be applied to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Web Analytics rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def inclusive(self) -> bool:
        """
        Whether the rule includes or excludes traffic from being measured.
        """
        return pulumi.get(self, "inclusive")

    @property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> bool:
        """
        Whether the rule is paused or not.
        """
        return pulumi.get(self, "is_paused")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        The paths the rule will be applied to.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def priority(self) -> float:
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetWebAnalyticsSitesResultRulesetResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 id: str,
                 zone_name: str,
                 zone_tag: str):
        """
        :param bool enabled: Whether the ruleset is enabled.
        :param str id: The Web Analytics ruleset identifier.
        :param str zone_tag: The zone identifier.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "zone_name", zone_name)
        pulumi.set(__self__, "zone_tag", zone_tag)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the ruleset is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Web Analytics ruleset identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        return pulumi.get(self, "zone_name")

    @property
    @pulumi.getter(name="zoneTag")
    def zone_tag(self) -> str:
        """
        The zone identifier.
        """
        return pulumi.get(self, "zone_tag")


@pulumi.output_type
class GetWorkersCronTriggerScheduleResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 cron: str,
                 modified_on: str):
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "modified_on", modified_on)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def cron(self) -> str:
        return pulumi.get(self, "cron")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        return pulumi.get(self, "modified_on")


@pulumi.output_type
class GetWorkersCustomDomainFilterResult(dict):
    def __init__(__self__, *,
                 environment: Optional[str] = None,
                 hostname: Optional[str] = None,
                 service: Optional[str] = None,
                 zone_id: Optional[str] = None,
                 zone_name: Optional[str] = None):
        """
        :param str environment: Worker environment associated with the zone and hostname.
        :param str hostname: Hostname of the Worker Domain.
        :param str service: Worker service associated with the zone and hostname.
        :param str zone_id: Identifier of the zone.
        :param str zone_name: Name of the zone.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Worker environment associated with the zone and hostname.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the Worker Domain.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Worker service associated with the zone and hostname.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        Identifier of the zone.
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name of the zone.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetWorkersCustomDomainsResultResult(dict):
    def __init__(__self__, *,
                 environment: str,
                 hostname: str,
                 id: str,
                 service: str,
                 zone_id: str,
                 zone_name: str):
        """
        :param str environment: Worker environment associated with the zone and hostname.
        :param str hostname: Hostname of the Worker Domain.
        :param str id: Identifer of the Worker Domain.
        :param str service: Worker service associated with the zone and hostname.
        :param str zone_id: Identifier of the zone.
        :param str zone_name: Name of the zone.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "zone_id", zone_id)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        Worker environment associated with the zone and hostname.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Hostname of the Worker Domain.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifer of the Worker Domain.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Worker service associated with the zone and hostname.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        Identifier of the zone.
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Name of the zone.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetWorkersDeploymentDeploymentResult(dict):
    def __init__(__self__, *,
                 annotations: 'outputs.GetWorkersDeploymentDeploymentAnnotationsResult',
                 author_email: str,
                 created_on: str,
                 id: str,
                 source: str,
                 strategy: str,
                 versions: Sequence['outputs.GetWorkersDeploymentDeploymentVersionResult']):
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "author_email", author_email)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def annotations(self) -> 'outputs.GetWorkersDeploymentDeploymentAnnotationsResult':
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> str:
        return pulumi.get(self, "author_email")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def versions(self) -> Sequence['outputs.GetWorkersDeploymentDeploymentVersionResult']:
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetWorkersDeploymentDeploymentAnnotationsResult(dict):
    def __init__(__self__, *,
                 workers_message: str):
        """
        :param str workers_message: Human-readable message about the deployment. Truncated to 100 bytes.
        """
        pulumi.set(__self__, "workers_message", workers_message)

    @property
    @pulumi.getter(name="workersMessage")
    def workers_message(self) -> str:
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
        return pulumi.get(self, "workers_message")


@pulumi.output_type
class GetWorkersDeploymentDeploymentVersionResult(dict):
    def __init__(__self__, *,
                 percentage: float,
                 version_id: str):
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter
    def percentage(self) -> float:
        return pulumi.get(self, "percentage")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        return pulumi.get(self, "version_id")


@pulumi.output_type
class GetWorkersForPlatformsDispatchNamespacesResultResult(dict):
    def __init__(__self__, *,
                 created_by: str,
                 created_on: str,
                 modified_by: str,
                 modified_on: str,
                 namespace_id: str,
                 namespace_name: str,
                 script_count: int):
        """
        :param str created_by: Identifier
        :param str created_on: When the script was created.
        :param str modified_by: Identifier
        :param str modified_on: When the script was last modified.
        :param str namespace_id: API Resource UUID tag.
        :param str namespace_name: Name of the Workers for Platforms dispatch namespace.
        :param int script_count: The current number of scripts in this Dispatch Namespace
        """
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "modified_by", modified_by)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "namespace_name", namespace_name)
        pulumi.set(__self__, "script_count", script_count)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the script was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "modified_by")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the script was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        API Resource UUID tag.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> str:
        """
        Name of the Workers for Platforms dispatch namespace.
        """
        return pulumi.get(self, "namespace_name")

    @property
    @pulumi.getter(name="scriptCount")
    def script_count(self) -> int:
        """
        The current number of scripts in this Dispatch Namespace
        """
        return pulumi.get(self, "script_count")


@pulumi.output_type
class GetWorkersKvNamespaceFilterResult(dict):
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str direction: Direction to order namespaces.
        :param str order: Field to order results by.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order namespaces.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order results by.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class GetWorkersKvNamespacesResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 supports_url_encoding: bool,
                 title: str):
        """
        :param str id: Namespace identifier tag.
        :param bool supports_url_encoding: True if keys written on the URL will be URL-decoded before storing. For example, if set to "true", a key written on the URL as "%3F" will be stored as "?".
        :param str title: A human-readable string name for a Namespace.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "supports_url_encoding", supports_url_encoding)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Namespace identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="supportsUrlEncoding")
    def supports_url_encoding(self) -> bool:
        """
        True if keys written on the URL will be URL-decoded before storing. For example, if set to "true", a key written on the URL as "%3F" will be stored as "?".
        """
        return pulumi.get(self, "supports_url_encoding")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A human-readable string name for a Namespace.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetWorkersRoutesResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 pattern: str,
                 script: str):
        """
        :param str id: Identifier
        :param str script: Name of the script, used in URLs and route configuration.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def script(self) -> str:
        """
        Name of the script, used in URLs and route configuration.
        """
        return pulumi.get(self, "script")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetWorkersScriptsResultResult(dict):
    def __init__(__self__, *,
                 created_on: str,
                 etag: str,
                 has_assets: bool,
                 has_modules: bool,
                 id: str,
                 logpush: bool,
                 modified_on: str,
                 placement: 'outputs.GetWorkersScriptsResultPlacementResult',
                 placement_mode: str,
                 placement_status: str,
                 tail_consumers: Sequence['outputs.GetWorkersScriptsResultTailConsumerResult'],
                 usage_model: str):
        """
        :param str created_on: When the script was created.
        :param str etag: Hashed script content, can be used in a If-None-Match header when updating.
        :param bool has_assets: Whether a Worker contains assets.
        :param bool has_modules: Whether a Worker contains modules.
        :param str id: The id of the script in the Workers system. Usually the script name.
        :param bool logpush: Whether Logpush is turned on for the Worker.
        :param str modified_on: When the script was last modified.
        :param 'GetWorkersScriptsResultPlacementArgs' placement: Configuration for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        :param str placement_mode: Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        :param str placement_status: Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        :param Sequence['GetWorkersScriptsResultTailConsumerArgs'] tail_consumers: List of Workers that will consume logs from the attached Worker.
        :param str usage_model: Usage model for the Worker invocations.
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "has_assets", has_assets)
        pulumi.set(__self__, "has_modules", has_modules)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "logpush", logpush)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "placement", placement)
        pulumi.set(__self__, "placement_mode", placement_mode)
        pulumi.set(__self__, "placement_status", placement_status)
        pulumi.set(__self__, "tail_consumers", tail_consumers)
        pulumi.set(__self__, "usage_model", usage_model)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the script was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        Hashed script content, can be used in a If-None-Match header when updating.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="hasAssets")
    def has_assets(self) -> bool:
        """
        Whether a Worker contains assets.
        """
        return pulumi.get(self, "has_assets")

    @property
    @pulumi.getter(name="hasModules")
    def has_modules(self) -> bool:
        """
        Whether a Worker contains modules.
        """
        return pulumi.get(self, "has_modules")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the script in the Workers system. Usually the script name.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logpush(self) -> bool:
        """
        Whether Logpush is turned on for the Worker.
        """
        return pulumi.get(self, "logpush")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the script was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def placement(self) -> 'outputs.GetWorkersScriptsResultPlacementResult':
        """
        Configuration for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="placementMode")
    def placement_mode(self) -> str:
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "placement_mode")

    @property
    @pulumi.getter(name="placementStatus")
    def placement_status(self) -> str:
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "placement_status")

    @property
    @pulumi.getter(name="tailConsumers")
    def tail_consumers(self) -> Sequence['outputs.GetWorkersScriptsResultTailConsumerResult']:
        """
        List of Workers that will consume logs from the attached Worker.
        """
        return pulumi.get(self, "tail_consumers")

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> str:
        """
        Usage model for the Worker invocations.
        """
        return pulumi.get(self, "usage_model")


@pulumi.output_type
class GetWorkersScriptsResultPlacementResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 status: str):
        """
        :param str mode: Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        :param str status: Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetWorkersScriptsResultTailConsumerResult(dict):
    def __init__(__self__, *,
                 environment: str,
                 namespace: str,
                 service: str):
        """
        :param str environment: Optional environment if the Worker utilizes one.
        :param str namespace: Optional dispatch namespace the script belongs to.
        :param str service: Name of Worker that is to be the consumer.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        Optional environment if the Worker utilizes one.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Optional dispatch namespace the script belongs to.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Name of Worker that is to be the consumer.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetWorkersSecretsResultResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: The name of this secret, this is what will be used to access it inside the Worker.
        :param str type: The type of secret.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this secret, this is what will be used to access it inside the Worker.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of secret.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetZeroTrustAccessApplicationCorsHeadersResult(dict):
    def __init__(__self__, *,
                 allow_all_headers: bool,
                 allow_all_methods: bool,
                 allow_all_origins: bool,
                 allow_credentials: bool,
                 allowed_headers: Sequence[str],
                 allowed_methods: Sequence[str],
                 allowed_origins: Sequence[str],
                 max_age: float):
        """
        :param bool allow_all_headers: Allows all HTTP request headers.
        :param bool allow_all_methods: Allows all HTTP request methods.
        :param bool allow_all_origins: Allows all origins.
        :param bool allow_credentials: When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        :param Sequence[str] allowed_headers: Allowed HTTP request headers.
        :param Sequence[str] allowed_methods: Allowed HTTP request methods.
        :param Sequence[str] allowed_origins: Allowed origins.
        :param float max_age: The maximum number of seconds the results of a preflight request can be cached.
        """
        pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        pulumi.set(__self__, "allow_credentials", allow_credentials)
        pulumi.set(__self__, "allowed_headers", allowed_headers)
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> bool:
        """
        Allows all HTTP request headers.
        """
        return pulumi.get(self, "allow_all_headers")

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> bool:
        """
        Allows all HTTP request methods.
        """
        return pulumi.get(self, "allow_all_methods")

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> bool:
        """
        Allows all origins.
        """
        return pulumi.get(self, "allow_all_origins")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> bool:
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Sequence[str]:
        """
        Allowed HTTP request headers.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        """
        Allowed HTTP request methods.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Allowed origins.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> float:
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetZeroTrustAccessApplicationDestinationResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 hostname: str,
                 l4_protocol: str,
                 port_range: str,
                 type: str,
                 uri: str,
                 vnet_id: str):
        """
        :param str cidr: The CIDR range of the destination. Single IPs will be computed as /32.
        :param str hostname: The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        :param str l4_protocol: The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        :param str port_range: The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        :param str uri: The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        :param str vnet_id: The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "l4_protocol", l4_protocol)
        pulumi.set(__self__, "port_range", port_range)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="l4Protocol")
    def l4_protocol(self) -> str:
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        """
        return pulumi.get(self, "l4_protocol")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> str:
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationFilterResult(dict):
    def __init__(__self__, *,
                 aud: Optional[str] = None,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str aud: The aud of the app.
        :param str domain: The domain of the app.
        :param str name: The name of the app.
        :param str search: Search for apps by other listed query parameters.
        """
        if aud is not None:
            pulumi.set(__self__, "aud", aud)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def aud(self) -> Optional[str]:
        """
        The aud of the app.
        """
        return pulumi.get(self, "aud")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The domain of the app.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the app.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Search for apps by other listed query parameters.
        """
        return pulumi.get(self, "search")


@pulumi.output_type
class GetZeroTrustAccessApplicationFooterLinkResult(dict):
    def __init__(__self__, *,
                 name: str,
                 url: str):
        """
        :param str name: The hypertext in the footer link.
        :param str url: the hyperlink in the footer link.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The hypertext in the footer link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        the hyperlink in the footer link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetZeroTrustAccessApplicationLandingPageDesignResult(dict):
    def __init__(__self__, *,
                 button_color: str,
                 button_text_color: str,
                 image_url: str,
                 message: str,
                 title: str):
        """
        :param str button_color: The background color of the log in button on the landing page.
        :param str button_text_color: The color of the text in the log in button on the landing page.
        :param str image_url: The URL of the image shown on the landing page.
        :param str message: The message shown on the landing page.
        :param str title: The title shown on the landing page.
        """
        pulumi.set(__self__, "button_color", button_color)
        pulumi.set(__self__, "button_text_color", button_text_color)
        pulumi.set(__self__, "image_url", image_url)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> str:
        """
        The background color of the log in button on the landing page.
        """
        return pulumi.get(self, "button_color")

    @property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> str:
        """
        The color of the text in the log in button on the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> str:
        """
        The URL of the image shown on the landing page.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The message shown on the landing page.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The title shown on the landing page.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyResult(dict):
    def __init__(__self__, *,
                 approval_groups: Sequence['outputs.GetZeroTrustAccessApplicationPolicyApprovalGroupResult'],
                 approval_required: bool,
                 connection_rules: 'outputs.GetZeroTrustAccessApplicationPolicyConnectionRulesResult',
                 created_at: str,
                 decision: str,
                 excludes: Sequence['outputs.GetZeroTrustAccessApplicationPolicyExcludeResult'],
                 id: str,
                 includes: Sequence['outputs.GetZeroTrustAccessApplicationPolicyIncludeResult'],
                 isolation_required: bool,
                 name: str,
                 precedence: int,
                 purpose_justification_prompt: str,
                 purpose_justification_required: bool,
                 requires: Sequence['outputs.GetZeroTrustAccessApplicationPolicyRequireResult'],
                 session_duration: str,
                 updated_at: str):
        """
        :param Sequence['GetZeroTrustAccessApplicationPolicyApprovalGroupArgs'] approval_groups: Administrators who can approve a temporary authentication request.
        :param bool approval_required: Requires the user to request access from an administrator at the start of each session.
        :param 'GetZeroTrustAccessApplicationPolicyConnectionRulesArgs' connection_rules: The rules that define how users may connect to the targets secured by your application.
        :param str decision: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        :param Sequence['GetZeroTrustAccessApplicationPolicyExcludeArgs'] excludes: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        :param str id: The UUID of the policy
        :param Sequence['GetZeroTrustAccessApplicationPolicyIncludeArgs'] includes: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        :param bool isolation_required: Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
        :param str name: The name of the Access policy.
        :param int precedence: The order of execution for this policy. Must be unique for each policy within an app.
        :param str purpose_justification_prompt: A custom message that will appear on the purpose justification screen.
        :param bool purpose_justification_required: Require users to enter a justification when they log in to the application.
        :param Sequence['GetZeroTrustAccessApplicationPolicyRequireArgs'] requires: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        :param str session_duration: The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
        """
        pulumi.set(__self__, "approval_groups", approval_groups)
        pulumi.set(__self__, "approval_required", approval_required)
        pulumi.set(__self__, "connection_rules", connection_rules)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "decision", decision)
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "includes", includes)
        pulumi.set(__self__, "isolation_required", isolation_required)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "precedence", precedence)
        pulumi.set(__self__, "purpose_justification_prompt", purpose_justification_prompt)
        pulumi.set(__self__, "purpose_justification_required", purpose_justification_required)
        pulumi.set(__self__, "requires", requires)
        pulumi.set(__self__, "session_duration", session_duration)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="approvalGroups")
    def approval_groups(self) -> Sequence['outputs.GetZeroTrustAccessApplicationPolicyApprovalGroupResult']:
        """
        Administrators who can approve a temporary authentication request.
        """
        return pulumi.get(self, "approval_groups")

    @property
    @pulumi.getter(name="approvalRequired")
    def approval_required(self) -> bool:
        """
        Requires the user to request access from an administrator at the start of each session.
        """
        return pulumi.get(self, "approval_required")

    @property
    @pulumi.getter(name="connectionRules")
    def connection_rules(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyConnectionRulesResult':
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "connection_rules")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def decision(self) -> str:
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        """
        return pulumi.get(self, "decision")

    @property
    @pulumi.getter
    def excludes(self) -> Sequence['outputs.GetZeroTrustAccessApplicationPolicyExcludeResult']:
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID of the policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def includes(self) -> Sequence['outputs.GetZeroTrustAccessApplicationPolicyIncludeResult']:
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        return pulumi.get(self, "includes")

    @property
    @pulumi.getter(name="isolationRequired")
    def isolation_required(self) -> bool:
        """
        Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
        """
        return pulumi.get(self, "isolation_required")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Access policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def precedence(self) -> int:
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        return pulumi.get(self, "precedence")

    @property
    @pulumi.getter(name="purposeJustificationPrompt")
    def purpose_justification_prompt(self) -> str:
        """
        A custom message that will appear on the purpose justification screen.
        """
        return pulumi.get(self, "purpose_justification_prompt")

    @property
    @pulumi.getter(name="purposeJustificationRequired")
    def purpose_justification_required(self) -> bool:
        """
        Require users to enter a justification when they log in to the application.
        """
        return pulumi.get(self, "purpose_justification_required")

    @property
    @pulumi.getter
    def requires(self) -> Sequence['outputs.GetZeroTrustAccessApplicationPolicyRequireResult']:
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "requires")

    @property
    @pulumi.getter(name="sessionDuration")
    def session_duration(self) -> str:
        """
        The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
        """
        return pulumi.get(self, "session_duration")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyApprovalGroupResult(dict):
    def __init__(__self__, *,
                 approvals_needed: float,
                 email_addresses: Sequence[str],
                 email_list_uuid: str):
        """
        :param float approvals_needed: The number of approvals needed to obtain access.
        :param Sequence[str] email_addresses: A list of emails that can approve the access request.
        :param str email_list_uuid: The UUID of an re-usable email list.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        pulumi.set(__self__, "email_addresses", email_addresses)
        pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> float:
        """
        The number of approvals needed to obtain access.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Sequence[str]:
        """
        A list of emails that can approve the access request.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> str:
        """
        The UUID of an re-usable email list.
        """
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyConnectionRulesResult(dict):
    def __init__(__self__, *,
                 ssh: 'outputs.GetZeroTrustAccessApplicationPolicyConnectionRulesSshResult'):
        """
        :param 'GetZeroTrustAccessApplicationPolicyConnectionRulesSshArgs' ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def ssh(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyConnectionRulesSshResult':
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyConnectionRulesSshResult(dict):
    def __init__(__self__, *,
                 allow_email_alias: bool,
                 usernames: Sequence[str]):
        """
        :param bool allow_email_alias: Enables using Identity Provider email alias as SSH username.
        :param Sequence[str] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        """
        pulumi.set(__self__, "allow_email_alias", allow_email_alias)
        pulumi.set(__self__, "usernames", usernames)

    @property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> bool:
        """
        Enables using Identity Provider email alias as SSH username.
        """
        return pulumi.get(self, "allow_email_alias")

    @property
    @pulumi.getter
    def usernames(self) -> Sequence[str]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessApplicationPolicyExcludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessApplicationPolicyExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyExcludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessApplicationPolicyExcludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessApplicationPolicyExcludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyExcludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessApplicationPolicyIncludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessApplicationPolicyIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyIncludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessApplicationPolicyIncludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessApplicationPolicyIncludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyIncludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessApplicationPolicyRequireAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessApplicationPolicyRequireAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessApplicationPolicyRequireAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessApplicationPolicyRequireCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessApplicationPolicyRequireCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessApplicationPolicyRequireDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessApplicationPolicyRequireEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessApplicationPolicyRequireEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessApplicationPolicyRequireEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessApplicationPolicyRequireEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessApplicationPolicyRequireExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessApplicationPolicyRequireGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessApplicationPolicyRequireGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessApplicationPolicyRequireGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessApplicationPolicyRequireGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessApplicationPolicyRequireIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessApplicationPolicyRequireIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessApplicationPolicyRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessApplicationPolicyRequireOktaResult',
                 saml: 'outputs.GetZeroTrustAccessApplicationPolicyRequireSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessApplicationPolicyRequireServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessApplicationPolicyRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessApplicationPolicyRequireServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessApplicationPolicyRequireLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessApplicationPolicyRequireOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationPolicyRequireServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationSaasAppResult(dict):
    def __init__(__self__, *,
                 access_token_lifetime: str,
                 allow_pkce_without_client_secret: bool,
                 app_launcher_url: str,
                 auth_type: str,
                 client_id: str,
                 client_secret: str,
                 consumer_service_url: str,
                 created_at: str,
                 custom_attributes: Sequence['outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeResult'],
                 custom_claims: Sequence['outputs.GetZeroTrustAccessApplicationSaasAppCustomClaimResult'],
                 default_relay_state: str,
                 grant_types: Sequence[str],
                 group_filter_regex: str,
                 hybrid_and_implicit_options: 'outputs.GetZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsResult',
                 idp_entity_id: str,
                 name_id_format: str,
                 name_id_transform_jsonata: str,
                 public_key: str,
                 redirect_uris: Sequence[str],
                 refresh_token_options: 'outputs.GetZeroTrustAccessApplicationSaasAppRefreshTokenOptionsResult',
                 saml_attribute_transform_jsonata: str,
                 scopes: Sequence[str],
                 sp_entity_id: str,
                 sso_endpoint: str,
                 updated_at: str):
        """
        :param str access_token_lifetime: The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        :param bool allow_pkce_without_client_secret: If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        :param str app_launcher_url: The URL where this applications tile redirects users
        :param str auth_type: Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        :param str client_id: The application client id
        :param str client_secret: The application client secret, only returned on POST request.
        :param str consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param str default_relay_state: The URL that the user will be redirected to after a successful login for IDP initiated logins.
        :param Sequence[str] grant_types: The OIDC flows supported by this application
        :param str group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        :param str idp_entity_id: The unique identifier for your SaaS application.
        :param str name_id_format: The format of the name identifier sent to the SaaS application.
        :param str name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param str public_key: The Access public certificate that will be used to verify your identity.
        :param Sequence[str] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        :param str saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param Sequence[str] scopes: Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        :param str sp_entity_id: A globally unique name for an identity or service provider.
        :param str sso_endpoint: The endpoint where your SaaS application will send login requests.
        """
        pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_attributes", custom_attributes)
        pulumi.set(__self__, "custom_claims", custom_claims)
        pulumi.set(__self__, "default_relay_state", default_relay_state)
        pulumi.set(__self__, "grant_types", grant_types)
        pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        pulumi.set(__self__, "name_id_format", name_id_format)
        pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "redirect_uris", redirect_uris)
        pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        pulumi.set(__self__, "sso_endpoint", sso_endpoint)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> str:
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> bool:
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> str:
        """
        The URL where this applications tile redirects users
        """
        return pulumi.get(self, "app_launcher_url")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The application client id
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The application client secret, only returned on POST request.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> str:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Sequence['outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeResult']:
        return pulumi.get(self, "custom_attributes")

    @property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Sequence['outputs.GetZeroTrustAccessApplicationSaasAppCustomClaimResult']:
        return pulumi.get(self, "custom_claims")

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> str:
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        return pulumi.get(self, "default_relay_state")

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Sequence[str]:
        """
        The OIDC flows supported by this application
        """
        return pulumi.get(self, "grant_types")

    @property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> str:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        return pulumi.get(self, "group_filter_regex")

    @property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> 'outputs.GetZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsResult':
        return pulumi.get(self, "hybrid_and_implicit_options")

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> str:
        """
        The unique identifier for your SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> str:
        """
        The format of the name identifier sent to the SaaS application.
        """
        return pulumi.get(self, "name_id_format")

    @property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> str:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The Access public certificate that will be used to verify your identity.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Sequence[str]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> 'outputs.GetZeroTrustAccessApplicationSaasAppRefreshTokenOptionsResult':
        return pulumi.get(self, "refresh_token_options")

    @property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> str:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> str:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> str:
        """
        The endpoint where your SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessApplicationSaasAppCustomAttributeResult(dict):
    def __init__(__self__, *,
                 friendly_name: str,
                 name: str,
                 name_format: str,
                 required: bool,
                 source: 'outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceResult'):
        """
        :param str friendly_name: The SAML FriendlyName of the attribute.
        :param str name: The name of the attribute.
        :param str name_format: A globally unique name for an identity or service provider.
        :param bool required: If the attribute is required when building a SAML assertion.
        """
        pulumi.set(__self__, "friendly_name", friendly_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_format", name_format)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> str:
        """
        The SAML FriendlyName of the attribute.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> str:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        If the attribute is required when building a SAML assertion.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceResult':
        return pulumi.get(self, "source")


@pulumi.output_type
class GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceResult(dict):
    def __init__(__self__, *,
                 name: str,
<<<<<<< HEAD
                 name_by_idp: Mapping[str, str]):
        """
        :param str name: The name of the IdP attribute.
        :param Mapping[str, str] name_by_idp: A mapping from IdP ID to attribute name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_by_idp", name_by_idp)
=======
                 name_by_idps: Sequence['outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpResult']):
        """
        :param str name: The name of the IdP attribute.
        :param Sequence['GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs'] name_by_idps: A mapping from IdP ID to attribute name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_by_idps", name_by_idps)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IdP attribute.
        """
        return pulumi.get(self, "name")

    @property
<<<<<<< HEAD
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Mapping[str, str]:
        """
        A mapping from IdP ID to attribute name.
        """
        return pulumi.get(self, "name_by_idp")
=======
    @pulumi.getter(name="nameByIdps")
    def name_by_idps(self) -> Sequence['outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpResult']:
        """
        A mapping from IdP ID to attribute name.
        """
        return pulumi.get(self, "name_by_idps")


@pulumi.output_type
class GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpResult(dict):
    def __init__(__self__, *,
                 idp_id: str,
                 source_name: str):
        """
        :param str idp_id: The UID of the IdP.
        :param str source_name: The name of the IdP provided attribute.
        """
        pulumi.set(__self__, "idp_id", idp_id)
        pulumi.set(__self__, "source_name", source_name)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> str:
        """
        The UID of the IdP.
        """
        return pulumi.get(self, "idp_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the IdP provided attribute.
        """
        return pulumi.get(self, "source_name")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580


@pulumi.output_type
class GetZeroTrustAccessApplicationSaasAppCustomClaimResult(dict):
    def __init__(__self__, *,
                 name: str,
                 required: bool,
                 scope: str,
                 source: 'outputs.GetZeroTrustAccessApplicationSaasAppCustomClaimSourceResult'):
        """
        :param str name: The name of the claim.
        :param bool required: If the claim is required when building an OIDC token.
        :param str scope: The scope of the claim.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the claim.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        If the claim is required when building an OIDC token.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        The scope of the claim.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.GetZeroTrustAccessApplicationSaasAppCustomClaimSourceResult':
        return pulumi.get(self, "source")


@pulumi.output_type
class GetZeroTrustAccessApplicationSaasAppCustomClaimSourceResult(dict):
    def __init__(__self__, *,
                 name: str,
                 name_by_idp: Mapping[str, str]):
        """
        :param str name: The name of the IdP claim.
        :param Mapping[str, str] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IdP claim.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Mapping[str, str]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")


@pulumi.output_type
class GetZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsResult(dict):
    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: bool,
                 return_id_token_from_authorization_endpoint: bool):
        """
        :param bool return_access_token_from_authorization_endpoint: If an Access Token should be returned from the OIDC Authorization endpoint
        :param bool return_id_token_from_authorization_endpoint: If an ID Token should be returned from the OIDC Authorization endpoint
        """
        pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> bool:
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> bool:
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")


@pulumi.output_type
class GetZeroTrustAccessApplicationSaasAppRefreshTokenOptionsResult(dict):
    def __init__(__self__, *,
                 lifetime: str):
        """
        :param str lifetime: How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        pulumi.set(__self__, "lifetime", lifetime)

    @property
    @pulumi.getter
    def lifetime(self) -> str:
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")


@pulumi.output_type
class GetZeroTrustAccessApplicationScimConfigResult(dict):
    def __init__(__self__, *,
                 authentication: 'outputs.GetZeroTrustAccessApplicationScimConfigAuthenticationResult',
                 deactivate_on_delete: bool,
                 enabled: bool,
                 idp_uid: str,
                 mappings: Sequence['outputs.GetZeroTrustAccessApplicationScimConfigMappingResult'],
                 remote_uri: str):
        """
        :param 'GetZeroTrustAccessApplicationScimConfigAuthenticationArgs' authentication: Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        :param bool deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param bool enabled: Whether SCIM provisioning is turned on for this application.
        :param str idp_uid: The UID of the IdP to use as the source for SCIM resources to provision to this application.
        :param Sequence['GetZeroTrustAccessApplicationScimConfigMappingArgs'] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        :param str remote_uri: The base URI for the application's SCIM-compatible API.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "mappings", mappings)
        pulumi.set(__self__, "remote_uri", remote_uri)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.GetZeroTrustAccessApplicationScimConfigAuthenticationResult':
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> bool:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> str:
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @property
    @pulumi.getter
    def mappings(self) -> Sequence['outputs.GetZeroTrustAccessApplicationScimConfigMappingResult']:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")

    @property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> str:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")


@pulumi.output_type
class GetZeroTrustAccessApplicationScimConfigAuthenticationResult(dict):
    def __init__(__self__, *,
                 authorization_url: str,
                 client_id: str,
                 client_secret: str,
                 password: str,
                 scheme: str,
                 scopes: Sequence[str],
                 token: str,
                 token_url: str,
                 user: str):
        """
        :param str authorization_url: URL used to generate the auth code used during token generation.
        :param str client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        :param str client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        :param str password: Password used to authenticate with the remote SCIM service.
        :param str scheme: The authentication scheme to use when making SCIM requests to this application.
        :param Sequence[str] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        :param str token: Token used to authenticate with the remote SCIM service.
        :param str token_url: URL used to generate the token used to authenticate with the remote SCIM service.
        :param str user: User name used to authenticate with the remote SCIM service.
        """
        pulumi.set(__self__, "authorization_url", authorization_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> str:
        """
        URL used to generate the auth code used during token generation.
        """
        return pulumi.get(self, "authorization_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        User name used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetZeroTrustAccessApplicationScimConfigMappingResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 filter: str,
                 operations: 'outputs.GetZeroTrustAccessApplicationScimConfigMappingOperationsResult',
                 schema: str,
                 strictness: str,
                 transform_jsonata: str):
        """
        :param bool enabled: Whether or not this mapping is enabled.
        :param str filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param 'GetZeroTrustAccessApplicationScimConfigMappingOperationsArgs' operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param str schema: Which SCIM resource type this mapping applies to.
        :param str strictness: The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
        :param str transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "strictness", strictness)
        pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def operations(self) -> 'outputs.GetZeroTrustAccessApplicationScimConfigMappingOperationsResult':
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def schema(self) -> str:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def strictness(self) -> str:
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
        """
        return pulumi.get(self, "strictness")

    @property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> str:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")


@pulumi.output_type
class GetZeroTrustAccessApplicationScimConfigMappingOperationsResult(dict):
    def __init__(__self__, *,
                 create: bool,
                 delete: bool,
                 update: bool):
        """
        :param bool create: Whether or not this mapping applies to create (POST) operations.
        :param bool delete: Whether or not this mapping applies to DELETE operations.
        :param bool update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        pulumi.set(__self__, "create", create)
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> bool:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> bool:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> bool:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GetZeroTrustAccessApplicationTargetCriteriaResult(dict):
    def __init__(__self__, *,
                 port: int,
                 protocol: str,
                 target_attributes: Mapping[str, Sequence[str]]):
        """
        :param int port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param str protocol: The communication protocol your application secures.
        :param Mapping[str, Sequence[str]] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The communication protocol your application secures.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> Mapping[str, Sequence[str]]:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultResult(dict):
    def __init__(__self__, *,
                 allow_authenticate_via_warp: bool,
                 allowed_idps: Sequence[str],
                 app_launcher_logo_url: str,
                 app_launcher_visible: bool,
                 aud: str,
                 auto_redirect_to_identity: bool,
                 bg_color: str,
                 cors_headers: 'outputs.GetZeroTrustAccessApplicationsResultCorsHeadersResult',
                 created_at: str,
                 custom_deny_message: str,
                 custom_deny_url: str,
                 custom_non_identity_deny_url: str,
                 custom_pages: Sequence[str],
                 destinations: Sequence['outputs.GetZeroTrustAccessApplicationsResultDestinationResult'],
                 domain: str,
                 enable_binding_cookie: bool,
                 footer_links: Sequence['outputs.GetZeroTrustAccessApplicationsResultFooterLinkResult'],
                 header_bg_color: str,
                 http_only_cookie_attribute: bool,
                 id: str,
                 landing_page_design: 'outputs.GetZeroTrustAccessApplicationsResultLandingPageDesignResult',
                 logo_url: str,
                 name: str,
                 options_preflight_bypass: bool,
                 path_cookie_attribute: bool,
                 policies: Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyResult'],
                 saas_app: 'outputs.GetZeroTrustAccessApplicationsResultSaasAppResult',
                 same_site_cookie_attribute: str,
                 scim_config: 'outputs.GetZeroTrustAccessApplicationsResultScimConfigResult',
                 self_hosted_domains: Sequence[str],
                 service_auth401_redirect: bool,
                 session_duration: str,
                 skip_app_launcher_login_page: bool,
                 skip_interstitial: bool,
                 tags: Sequence[str],
                 target_criterias: Sequence['outputs.GetZeroTrustAccessApplicationsResultTargetCriteriaResult'],
                 type: str,
                 updated_at: str):
        """
        :param bool allow_authenticate_via_warp: When set to true, users can authenticate to this application using their WARP session.  When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
        :param Sequence[str] allowed_idps: The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account.
        :param str app_launcher_logo_url: The image URL of the logo shown in the App Launcher header.
        :param bool app_launcher_visible: Displays the application in the App Launcher.
        :param str aud: Audience tag.
        :param bool auto_redirect_to_identity: When set to `true`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps.
        :param str bg_color: The background color of the App Launcher page.
        :param str custom_deny_message: The custom error message shown to a user when they are denied access to the application.
        :param str custom_deny_url: The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules.
        :param str custom_non_identity_deny_url: The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules.
        :param Sequence[str] custom_pages: The custom pages that will be displayed when applicable for this application
        :param Sequence['GetZeroTrustAccessApplicationsResultDestinationArgs'] destinations: List of destinations secured by Access. This supersedes `self_hosted_domains` to allow for more flexibility in defining different types of domains. If `destinations` are provided, then `self_hosted_domains` will be ignored.
        :param str domain: The primary hostname and path secured by Access. This domain will be displayed if the app is visible in the App Launcher.
        :param bool enable_binding_cookie: Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks.
        :param Sequence['GetZeroTrustAccessApplicationsResultFooterLinkArgs'] footer_links: The links in the App Launcher footer.
        :param str header_bg_color: The background color of the App Launcher header.
        :param bool http_only_cookie_attribute: Enables the HttpOnly cookie attribute, which increases security against XSS attacks.
        :param str id: UUID
        :param 'GetZeroTrustAccessApplicationsResultLandingPageDesignArgs' landing_page_design: The design of the App Launcher landing page shown to users when they log in.
        :param str logo_url: The image URL for the logo shown in the App Launcher dashboard.
        :param str name: The name of the application.
        :param bool options_preflight_bypass: Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set.
        :param bool path_cookie_attribute: Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default
        :param str same_site_cookie_attribute: Sets the SameSite cookie setting, which provides increased security against CSRF attacks.
        :param 'GetZeroTrustAccessApplicationsResultScimConfigArgs' scim_config: Configuration for provisioning to this application via SCIM. This is currently in closed beta.
        :param Sequence[str] self_hosted_domains: List of public domains that Access will secure. This field is deprecated in favor of `destinations` and will be supported until **November 21, 2025.** If `destinations` are provided, then `self_hosted_domains` will be ignored.
        :param bool service_auth401_redirect: Returns a 401 status code when the request is blocked by a Service Auth policy.
        :param str session_duration: The amount of time that tokens issued for this application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
        :param bool skip_app_launcher_login_page: Determines when to skip the App Launcher landing page.
        :param bool skip_interstitial: Enables automatic authentication through cloudflared.
        :param Sequence[str] tags: The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard.
        :param str type: The application type.
        """
        pulumi.set(__self__, "allow_authenticate_via_warp", allow_authenticate_via_warp)
        pulumi.set(__self__, "allowed_idps", allowed_idps)
        pulumi.set(__self__, "app_launcher_logo_url", app_launcher_logo_url)
        pulumi.set(__self__, "app_launcher_visible", app_launcher_visible)
        pulumi.set(__self__, "aud", aud)
        pulumi.set(__self__, "auto_redirect_to_identity", auto_redirect_to_identity)
        pulumi.set(__self__, "bg_color", bg_color)
        pulumi.set(__self__, "cors_headers", cors_headers)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_deny_message", custom_deny_message)
        pulumi.set(__self__, "custom_deny_url", custom_deny_url)
        pulumi.set(__self__, "custom_non_identity_deny_url", custom_non_identity_deny_url)
        pulumi.set(__self__, "custom_pages", custom_pages)
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "enable_binding_cookie", enable_binding_cookie)
        pulumi.set(__self__, "footer_links", footer_links)
        pulumi.set(__self__, "header_bg_color", header_bg_color)
        pulumi.set(__self__, "http_only_cookie_attribute", http_only_cookie_attribute)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "landing_page_design", landing_page_design)
        pulumi.set(__self__, "logo_url", logo_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "options_preflight_bypass", options_preflight_bypass)
        pulumi.set(__self__, "path_cookie_attribute", path_cookie_attribute)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "saas_app", saas_app)
        pulumi.set(__self__, "same_site_cookie_attribute", same_site_cookie_attribute)
        pulumi.set(__self__, "scim_config", scim_config)
        pulumi.set(__self__, "self_hosted_domains", self_hosted_domains)
        pulumi.set(__self__, "service_auth401_redirect", service_auth401_redirect)
        pulumi.set(__self__, "session_duration", session_duration)
        pulumi.set(__self__, "skip_app_launcher_login_page", skip_app_launcher_login_page)
        pulumi.set(__self__, "skip_interstitial", skip_interstitial)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "target_criterias", target_criterias)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="allowAuthenticateViaWarp")
    def allow_authenticate_via_warp(self) -> bool:
        """
        When set to true, users can authenticate to this application using their WARP session.  When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
        """
        return pulumi.get(self, "allow_authenticate_via_warp")

    @property
    @pulumi.getter(name="allowedIdps")
    def allowed_idps(self) -> Sequence[str]:
        """
        The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account.
        """
        return pulumi.get(self, "allowed_idps")

    @property
    @pulumi.getter(name="appLauncherLogoUrl")
    def app_launcher_logo_url(self) -> str:
        """
        The image URL of the logo shown in the App Launcher header.
        """
        return pulumi.get(self, "app_launcher_logo_url")

    @property
    @pulumi.getter(name="appLauncherVisible")
    def app_launcher_visible(self) -> bool:
        """
        Displays the application in the App Launcher.
        """
        return pulumi.get(self, "app_launcher_visible")

    @property
    @pulumi.getter
    def aud(self) -> str:
        """
        Audience tag.
        """
        return pulumi.get(self, "aud")

    @property
    @pulumi.getter(name="autoRedirectToIdentity")
    def auto_redirect_to_identity(self) -> bool:
        """
        When set to `true`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps.
        """
        return pulumi.get(self, "auto_redirect_to_identity")

    @property
    @pulumi.getter(name="bgColor")
    def bg_color(self) -> str:
        """
        The background color of the App Launcher page.
        """
        return pulumi.get(self, "bg_color")

    @property
    @pulumi.getter(name="corsHeaders")
    def cors_headers(self) -> 'outputs.GetZeroTrustAccessApplicationsResultCorsHeadersResult':
        return pulumi.get(self, "cors_headers")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customDenyMessage")
    def custom_deny_message(self) -> str:
        """
        The custom error message shown to a user when they are denied access to the application.
        """
        return pulumi.get(self, "custom_deny_message")

    @property
    @pulumi.getter(name="customDenyUrl")
    def custom_deny_url(self) -> str:
        """
        The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules.
        """
        return pulumi.get(self, "custom_deny_url")

    @property
    @pulumi.getter(name="customNonIdentityDenyUrl")
    def custom_non_identity_deny_url(self) -> str:
        """
        The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules.
        """
        return pulumi.get(self, "custom_non_identity_deny_url")

    @property
    @pulumi.getter(name="customPages")
    def custom_pages(self) -> Sequence[str]:
        """
        The custom pages that will be displayed when applicable for this application
        """
        return pulumi.get(self, "custom_pages")

    @property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultDestinationResult']:
        """
        List of destinations secured by Access. This supersedes `self_hosted_domains` to allow for more flexibility in defining different types of domains. If `destinations` are provided, then `self_hosted_domains` will be ignored.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The primary hostname and path secured by Access. This domain will be displayed if the app is visible in the App Launcher.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="enableBindingCookie")
    def enable_binding_cookie(self) -> bool:
        """
        Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks.
        """
        return pulumi.get(self, "enable_binding_cookie")

    @property
    @pulumi.getter(name="footerLinks")
    def footer_links(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultFooterLinkResult']:
        """
        The links in the App Launcher footer.
        """
        return pulumi.get(self, "footer_links")

    @property
    @pulumi.getter(name="headerBgColor")
    def header_bg_color(self) -> str:
        """
        The background color of the App Launcher header.
        """
        return pulumi.get(self, "header_bg_color")

    @property
    @pulumi.getter(name="httpOnlyCookieAttribute")
    def http_only_cookie_attribute(self) -> bool:
        """
        Enables the HttpOnly cookie attribute, which increases security against XSS attacks.
        """
        return pulumi.get(self, "http_only_cookie_attribute")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="landingPageDesign")
    def landing_page_design(self) -> 'outputs.GetZeroTrustAccessApplicationsResultLandingPageDesignResult':
        """
        The design of the App Launcher landing page shown to users when they log in.
        """
        return pulumi.get(self, "landing_page_design")

    @property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> str:
        """
        The image URL for the logo shown in the App Launcher dashboard.
        """
        return pulumi.get(self, "logo_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="optionsPreflightBypass")
    def options_preflight_bypass(self) -> bool:
        """
        Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set.
        """
        return pulumi.get(self, "options_preflight_bypass")

    @property
    @pulumi.getter(name="pathCookieAttribute")
    def path_cookie_attribute(self) -> bool:
        """
        Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default
        """
        return pulumi.get(self, "path_cookie_attribute")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="saasApp")
    def saas_app(self) -> 'outputs.GetZeroTrustAccessApplicationsResultSaasAppResult':
        return pulumi.get(self, "saas_app")

    @property
    @pulumi.getter(name="sameSiteCookieAttribute")
    def same_site_cookie_attribute(self) -> str:
        """
        Sets the SameSite cookie setting, which provides increased security against CSRF attacks.
        """
        return pulumi.get(self, "same_site_cookie_attribute")

    @property
    @pulumi.getter(name="scimConfig")
    def scim_config(self) -> 'outputs.GetZeroTrustAccessApplicationsResultScimConfigResult':
        """
        Configuration for provisioning to this application via SCIM. This is currently in closed beta.
        """
        return pulumi.get(self, "scim_config")

    @property
    @pulumi.getter(name="selfHostedDomains")
    def self_hosted_domains(self) -> Sequence[str]:
        """
        List of public domains that Access will secure. This field is deprecated in favor of `destinations` and will be supported until **November 21, 2025.** If `destinations` are provided, then `self_hosted_domains` will be ignored.
        """
        return pulumi.get(self, "self_hosted_domains")

    @property
    @pulumi.getter(name="serviceAuth401Redirect")
    def service_auth401_redirect(self) -> bool:
        """
        Returns a 401 status code when the request is blocked by a Service Auth policy.
        """
        return pulumi.get(self, "service_auth401_redirect")

    @property
    @pulumi.getter(name="sessionDuration")
    def session_duration(self) -> str:
        """
        The amount of time that tokens issued for this application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
        """
        return pulumi.get(self, "session_duration")

    @property
    @pulumi.getter(name="skipAppLauncherLoginPage")
    def skip_app_launcher_login_page(self) -> bool:
        """
        Determines when to skip the App Launcher landing page.
        """
        return pulumi.get(self, "skip_app_launcher_login_page")

    @property
    @pulumi.getter(name="skipInterstitial")
    def skip_interstitial(self) -> bool:
        """
        Enables automatic authentication through cloudflared.
        """
        return pulumi.get(self, "skip_interstitial")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="targetCriterias")
    def target_criterias(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultTargetCriteriaResult']:
        return pulumi.get(self, "target_criterias")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The application type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultCorsHeadersResult(dict):
    def __init__(__self__, *,
                 allow_all_headers: bool,
                 allow_all_methods: bool,
                 allow_all_origins: bool,
                 allow_credentials: bool,
                 allowed_headers: Sequence[str],
                 allowed_methods: Sequence[str],
                 allowed_origins: Sequence[str],
                 max_age: float):
        """
        :param bool allow_all_headers: Allows all HTTP request headers.
        :param bool allow_all_methods: Allows all HTTP request methods.
        :param bool allow_all_origins: Allows all origins.
        :param bool allow_credentials: When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        :param Sequence[str] allowed_headers: Allowed HTTP request headers.
        :param Sequence[str] allowed_methods: Allowed HTTP request methods.
        :param Sequence[str] allowed_origins: Allowed origins.
        :param float max_age: The maximum number of seconds the results of a preflight request can be cached.
        """
        pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        pulumi.set(__self__, "allow_credentials", allow_credentials)
        pulumi.set(__self__, "allowed_headers", allowed_headers)
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> bool:
        """
        Allows all HTTP request headers.
        """
        return pulumi.get(self, "allow_all_headers")

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> bool:
        """
        Allows all HTTP request methods.
        """
        return pulumi.get(self, "allow_all_methods")

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> bool:
        """
        Allows all origins.
        """
        return pulumi.get(self, "allow_all_origins")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> bool:
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Sequence[str]:
        """
        Allowed HTTP request headers.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        """
        Allowed HTTP request methods.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Allowed origins.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> float:
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultDestinationResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 hostname: str,
                 l4_protocol: str,
                 port_range: str,
                 type: str,
                 uri: str,
                 vnet_id: str):
        """
        :param str cidr: The CIDR range of the destination. Single IPs will be computed as /32.
        :param str hostname: The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        :param str l4_protocol: The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        :param str port_range: The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        :param str uri: The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        :param str vnet_id: The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "l4_protocol", l4_protocol)
        pulumi.set(__self__, "port_range", port_range)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="l4Protocol")
    def l4_protocol(self) -> str:
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        """
        return pulumi.get(self, "l4_protocol")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> str:
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultFooterLinkResult(dict):
    def __init__(__self__, *,
                 name: str,
                 url: str):
        """
        :param str name: The hypertext in the footer link.
        :param str url: the hyperlink in the footer link.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The hypertext in the footer link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        the hyperlink in the footer link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultLandingPageDesignResult(dict):
    def __init__(__self__, *,
                 button_color: str,
                 button_text_color: str,
                 image_url: str,
                 message: str,
                 title: str):
        """
        :param str button_color: The background color of the log in button on the landing page.
        :param str button_text_color: The color of the text in the log in button on the landing page.
        :param str image_url: The URL of the image shown on the landing page.
        :param str message: The message shown on the landing page.
        :param str title: The title shown on the landing page.
        """
        pulumi.set(__self__, "button_color", button_color)
        pulumi.set(__self__, "button_text_color", button_text_color)
        pulumi.set(__self__, "image_url", image_url)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> str:
        """
        The background color of the log in button on the landing page.
        """
        return pulumi.get(self, "button_color")

    @property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> str:
        """
        The color of the text in the log in button on the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> str:
        """
        The URL of the image shown on the landing page.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The message shown on the landing page.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The title shown on the landing page.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyResult(dict):
    def __init__(__self__, *,
                 approval_groups: Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyApprovalGroupResult'],
                 approval_required: bool,
                 connection_rules: 'outputs.GetZeroTrustAccessApplicationsResultPolicyConnectionRulesResult',
                 created_at: str,
                 decision: str,
                 excludes: Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeResult'],
                 id: str,
                 includes: Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeResult'],
                 isolation_required: bool,
                 name: str,
                 precedence: int,
                 purpose_justification_prompt: str,
                 purpose_justification_required: bool,
                 requires: Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyRequireResult'],
                 session_duration: str,
                 updated_at: str):
        """
        :param Sequence['GetZeroTrustAccessApplicationsResultPolicyApprovalGroupArgs'] approval_groups: Administrators who can approve a temporary authentication request.
        :param bool approval_required: Requires the user to request access from an administrator at the start of each session.
        :param 'GetZeroTrustAccessApplicationsResultPolicyConnectionRulesArgs' connection_rules: The rules that define how users may connect to the targets secured by your application.
        :param str decision: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        :param Sequence['GetZeroTrustAccessApplicationsResultPolicyExcludeArgs'] excludes: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        :param str id: The UUID of the policy
        :param Sequence['GetZeroTrustAccessApplicationsResultPolicyIncludeArgs'] includes: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        :param bool isolation_required: Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
        :param str name: The name of the Access policy.
        :param int precedence: The order of execution for this policy. Must be unique for each policy within an app.
        :param str purpose_justification_prompt: A custom message that will appear on the purpose justification screen.
        :param bool purpose_justification_required: Require users to enter a justification when they log in to the application.
        :param Sequence['GetZeroTrustAccessApplicationsResultPolicyRequireArgs'] requires: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        :param str session_duration: The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
        """
        pulumi.set(__self__, "approval_groups", approval_groups)
        pulumi.set(__self__, "approval_required", approval_required)
        pulumi.set(__self__, "connection_rules", connection_rules)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "decision", decision)
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "includes", includes)
        pulumi.set(__self__, "isolation_required", isolation_required)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "precedence", precedence)
        pulumi.set(__self__, "purpose_justification_prompt", purpose_justification_prompt)
        pulumi.set(__self__, "purpose_justification_required", purpose_justification_required)
        pulumi.set(__self__, "requires", requires)
        pulumi.set(__self__, "session_duration", session_duration)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="approvalGroups")
    def approval_groups(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyApprovalGroupResult']:
        """
        Administrators who can approve a temporary authentication request.
        """
        return pulumi.get(self, "approval_groups")

    @property
    @pulumi.getter(name="approvalRequired")
    def approval_required(self) -> bool:
        """
        Requires the user to request access from an administrator at the start of each session.
        """
        return pulumi.get(self, "approval_required")

    @property
    @pulumi.getter(name="connectionRules")
    def connection_rules(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyConnectionRulesResult':
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "connection_rules")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def decision(self) -> str:
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        """
        return pulumi.get(self, "decision")

    @property
    @pulumi.getter
    def excludes(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeResult']:
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID of the policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def includes(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeResult']:
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        return pulumi.get(self, "includes")

    @property
    @pulumi.getter(name="isolationRequired")
    def isolation_required(self) -> bool:
        """
        Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
        """
        return pulumi.get(self, "isolation_required")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Access policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def precedence(self) -> int:
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        return pulumi.get(self, "precedence")

    @property
    @pulumi.getter(name="purposeJustificationPrompt")
    def purpose_justification_prompt(self) -> str:
        """
        A custom message that will appear on the purpose justification screen.
        """
        return pulumi.get(self, "purpose_justification_prompt")

    @property
    @pulumi.getter(name="purposeJustificationRequired")
    def purpose_justification_required(self) -> bool:
        """
        Require users to enter a justification when they log in to the application.
        """
        return pulumi.get(self, "purpose_justification_required")

    @property
    @pulumi.getter
    def requires(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultPolicyRequireResult']:
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "requires")

    @property
    @pulumi.getter(name="sessionDuration")
    def session_duration(self) -> str:
        """
        The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
        """
        return pulumi.get(self, "session_duration")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyApprovalGroupResult(dict):
    def __init__(__self__, *,
                 approvals_needed: float,
                 email_addresses: Sequence[str],
                 email_list_uuid: str):
        """
        :param float approvals_needed: The number of approvals needed to obtain access.
        :param Sequence[str] email_addresses: A list of emails that can approve the access request.
        :param str email_list_uuid: The UUID of an re-usable email list.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        pulumi.set(__self__, "email_addresses", email_addresses)
        pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> float:
        """
        The number of approvals needed to obtain access.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Sequence[str]:
        """
        A list of emails that can approve the access request.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> str:
        """
        The UUID of an re-usable email list.
        """
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyConnectionRulesResult(dict):
    def __init__(__self__, *,
                 ssh: 'outputs.GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSshResult'):
        """
        :param 'GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSshArgs' ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def ssh(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSshResult':
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSshResult(dict):
    def __init__(__self__, *,
                 allow_email_alias: bool,
                 usernames: Sequence[str]):
        """
        :param bool allow_email_alias: Enables using Identity Provider email alias as SSH username.
        :param Sequence[str] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        """
        pulumi.set(__self__, "allow_email_alias", allow_email_alias)
        pulumi.set(__self__, "usernames", usernames)

    @property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> bool:
        """
        Enables using Identity Provider email alias as SSH username.
        """
        return pulumi.get(self, "allow_email_alias")

    @property
    @pulumi.getter
    def usernames(self) -> Sequence[str]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessApplicationsResultPolicyExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessApplicationsResultPolicyExcludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessApplicationsResultPolicyExcludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyExcludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessApplicationsResultPolicyIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessApplicationsResultPolicyIncludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessApplicationsResultPolicyIncludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyIncludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireOktaResult',
                 saml: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessApplicationsResultPolicyRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessApplicationsResultPolicyRequireServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessApplicationsResultPolicyRequireLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessApplicationsResultPolicyRequireOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultPolicyRequireServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultSaasAppResult(dict):
    def __init__(__self__, *,
                 access_token_lifetime: str,
                 allow_pkce_without_client_secret: bool,
                 app_launcher_url: str,
                 auth_type: str,
                 client_id: str,
                 client_secret: str,
                 consumer_service_url: str,
                 created_at: str,
                 custom_attributes: Sequence['outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeResult'],
                 custom_claims: Sequence['outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomClaimResult'],
                 default_relay_state: str,
                 grant_types: Sequence[str],
                 group_filter_regex: str,
                 hybrid_and_implicit_options: 'outputs.GetZeroTrustAccessApplicationsResultSaasAppHybridAndImplicitOptionsResult',
                 idp_entity_id: str,
                 name_id_format: str,
                 name_id_transform_jsonata: str,
                 public_key: str,
                 redirect_uris: Sequence[str],
                 refresh_token_options: 'outputs.GetZeroTrustAccessApplicationsResultSaasAppRefreshTokenOptionsResult',
                 saml_attribute_transform_jsonata: str,
                 scopes: Sequence[str],
                 sp_entity_id: str,
                 sso_endpoint: str,
                 updated_at: str):
        """
        :param str access_token_lifetime: The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        :param bool allow_pkce_without_client_secret: If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        :param str app_launcher_url: The URL where this applications tile redirects users
        :param str auth_type: Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        :param str client_id: The application client id
        :param str client_secret: The application client secret, only returned on POST request.
        :param str consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param str default_relay_state: The URL that the user will be redirected to after a successful login for IDP initiated logins.
        :param Sequence[str] grant_types: The OIDC flows supported by this application
        :param str group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        :param str idp_entity_id: The unique identifier for your SaaS application.
        :param str name_id_format: The format of the name identifier sent to the SaaS application.
        :param str name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param str public_key: The Access public certificate that will be used to verify your identity.
        :param Sequence[str] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        :param str saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param Sequence[str] scopes: Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        :param str sp_entity_id: A globally unique name for an identity or service provider.
        :param str sso_endpoint: The endpoint where your SaaS application will send login requests.
        """
        pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_attributes", custom_attributes)
        pulumi.set(__self__, "custom_claims", custom_claims)
        pulumi.set(__self__, "default_relay_state", default_relay_state)
        pulumi.set(__self__, "grant_types", grant_types)
        pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        pulumi.set(__self__, "name_id_format", name_id_format)
        pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "redirect_uris", redirect_uris)
        pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        pulumi.set(__self__, "sso_endpoint", sso_endpoint)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> str:
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> bool:
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> str:
        """
        The URL where this applications tile redirects users
        """
        return pulumi.get(self, "app_launcher_url")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The application client id
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The application client secret, only returned on POST request.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> str:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeResult']:
        return pulumi.get(self, "custom_attributes")

    @property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomClaimResult']:
        return pulumi.get(self, "custom_claims")

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> str:
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        return pulumi.get(self, "default_relay_state")

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Sequence[str]:
        """
        The OIDC flows supported by this application
        """
        return pulumi.get(self, "grant_types")

    @property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> str:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        return pulumi.get(self, "group_filter_regex")

    @property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> 'outputs.GetZeroTrustAccessApplicationsResultSaasAppHybridAndImplicitOptionsResult':
        return pulumi.get(self, "hybrid_and_implicit_options")

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> str:
        """
        The unique identifier for your SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> str:
        """
        The format of the name identifier sent to the SaaS application.
        """
        return pulumi.get(self, "name_id_format")

    @property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> str:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The Access public certificate that will be used to verify your identity.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Sequence[str]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> 'outputs.GetZeroTrustAccessApplicationsResultSaasAppRefreshTokenOptionsResult':
        return pulumi.get(self, "refresh_token_options")

    @property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> str:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> str:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> str:
        """
        The endpoint where your SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeResult(dict):
    def __init__(__self__, *,
                 friendly_name: str,
                 name: str,
                 name_format: str,
                 required: bool,
                 source: 'outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceResult'):
        """
        :param str friendly_name: The SAML FriendlyName of the attribute.
        :param str name: The name of the attribute.
        :param str name_format: A globally unique name for an identity or service provider.
        :param bool required: If the attribute is required when building a SAML assertion.
        """
        pulumi.set(__self__, "friendly_name", friendly_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_format", name_format)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> str:
        """
        The SAML FriendlyName of the attribute.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> str:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        If the attribute is required when building a SAML assertion.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceResult':
        return pulumi.get(self, "source")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceResult(dict):
    def __init__(__self__, *,
                 name: str,
<<<<<<< HEAD
                 name_by_idp: Mapping[str, str]):
        """
        :param str name: The name of the IdP attribute.
        :param Mapping[str, str] name_by_idp: A mapping from IdP ID to attribute name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_by_idp", name_by_idp)
=======
                 name_by_idps: Sequence['outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdpResult']):
        """
        :param str name: The name of the IdP attribute.
        :param Sequence['GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdpArgs'] name_by_idps: A mapping from IdP ID to attribute name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_by_idps", name_by_idps)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IdP attribute.
        """
        return pulumi.get(self, "name")

    @property
<<<<<<< HEAD
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Mapping[str, str]:
        """
        A mapping from IdP ID to attribute name.
        """
        return pulumi.get(self, "name_by_idp")
=======
    @pulumi.getter(name="nameByIdps")
    def name_by_idps(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdpResult']:
        """
        A mapping from IdP ID to attribute name.
        """
        return pulumi.get(self, "name_by_idps")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdpResult(dict):
    def __init__(__self__, *,
                 idp_id: str,
                 source_name: str):
        """
        :param str idp_id: The UID of the IdP.
        :param str source_name: The name of the IdP provided attribute.
        """
        pulumi.set(__self__, "idp_id", idp_id)
        pulumi.set(__self__, "source_name", source_name)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> str:
        """
        The UID of the IdP.
        """
        return pulumi.get(self, "idp_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the IdP provided attribute.
        """
        return pulumi.get(self, "source_name")
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultSaasAppCustomClaimResult(dict):
    def __init__(__self__, *,
                 name: str,
                 required: bool,
                 scope: str,
                 source: 'outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomClaimSourceResult'):
        """
        :param str name: The name of the claim.
        :param bool required: If the claim is required when building an OIDC token.
        :param str scope: The scope of the claim.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the claim.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        If the claim is required when building an OIDC token.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        The scope of the claim.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomClaimSourceResult':
        return pulumi.get(self, "source")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultSaasAppCustomClaimSourceResult(dict):
    def __init__(__self__, *,
                 name: str,
                 name_by_idp: Mapping[str, str]):
        """
        :param str name: The name of the IdP claim.
        :param Mapping[str, str] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IdP claim.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Mapping[str, str]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultSaasAppHybridAndImplicitOptionsResult(dict):
    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: bool,
                 return_id_token_from_authorization_endpoint: bool):
        """
        :param bool return_access_token_from_authorization_endpoint: If an Access Token should be returned from the OIDC Authorization endpoint
        :param bool return_id_token_from_authorization_endpoint: If an ID Token should be returned from the OIDC Authorization endpoint
        """
        pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> bool:
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> bool:
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultSaasAppRefreshTokenOptionsResult(dict):
    def __init__(__self__, *,
                 lifetime: str):
        """
        :param str lifetime: How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        pulumi.set(__self__, "lifetime", lifetime)

    @property
    @pulumi.getter
    def lifetime(self) -> str:
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultScimConfigResult(dict):
    def __init__(__self__, *,
                 authentication: 'outputs.GetZeroTrustAccessApplicationsResultScimConfigAuthenticationResult',
                 deactivate_on_delete: bool,
                 enabled: bool,
                 idp_uid: str,
                 mappings: Sequence['outputs.GetZeroTrustAccessApplicationsResultScimConfigMappingResult'],
                 remote_uri: str):
        """
        :param 'GetZeroTrustAccessApplicationsResultScimConfigAuthenticationArgs' authentication: Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        :param bool deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param bool enabled: Whether SCIM provisioning is turned on for this application.
        :param str idp_uid: The UID of the IdP to use as the source for SCIM resources to provision to this application.
        :param Sequence['GetZeroTrustAccessApplicationsResultScimConfigMappingArgs'] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        :param str remote_uri: The base URI for the application's SCIM-compatible API.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "mappings", mappings)
        pulumi.set(__self__, "remote_uri", remote_uri)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.GetZeroTrustAccessApplicationsResultScimConfigAuthenticationResult':
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> bool:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> str:
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @property
    @pulumi.getter
    def mappings(self) -> Sequence['outputs.GetZeroTrustAccessApplicationsResultScimConfigMappingResult']:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")

    @property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> str:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultScimConfigAuthenticationResult(dict):
    def __init__(__self__, *,
                 authorization_url: str,
                 client_id: str,
                 client_secret: str,
                 password: str,
                 scheme: str,
                 scopes: Sequence[str],
                 token: str,
                 token_url: str,
                 user: str):
        """
        :param str authorization_url: URL used to generate the auth code used during token generation.
        :param str client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        :param str client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        :param str password: Password used to authenticate with the remote SCIM service.
        :param str scheme: The authentication scheme to use when making SCIM requests to this application.
        :param Sequence[str] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        :param str token: Token used to authenticate with the remote SCIM service.
        :param str token_url: URL used to generate the token used to authenticate with the remote SCIM service.
        :param str user: User name used to authenticate with the remote SCIM service.
        """
        pulumi.set(__self__, "authorization_url", authorization_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> str:
        """
        URL used to generate the auth code used during token generation.
        """
        return pulumi.get(self, "authorization_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        User name used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultScimConfigMappingResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 filter: str,
                 operations: 'outputs.GetZeroTrustAccessApplicationsResultScimConfigMappingOperationsResult',
                 schema: str,
                 strictness: str,
                 transform_jsonata: str):
        """
        :param bool enabled: Whether or not this mapping is enabled.
        :param str filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param 'GetZeroTrustAccessApplicationsResultScimConfigMappingOperationsArgs' operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param str schema: Which SCIM resource type this mapping applies to.
        :param str strictness: The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
        :param str transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "strictness", strictness)
        pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def operations(self) -> 'outputs.GetZeroTrustAccessApplicationsResultScimConfigMappingOperationsResult':
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def schema(self) -> str:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def strictness(self) -> str:
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
        """
        return pulumi.get(self, "strictness")

    @property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> str:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultScimConfigMappingOperationsResult(dict):
    def __init__(__self__, *,
                 create: bool,
                 delete: bool,
                 update: bool):
        """
        :param bool create: Whether or not this mapping applies to create (POST) operations.
        :param bool delete: Whether or not this mapping applies to DELETE operations.
        :param bool update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        pulumi.set(__self__, "create", create)
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> bool:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> bool:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> bool:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GetZeroTrustAccessApplicationsResultTargetCriteriaResult(dict):
    def __init__(__self__, *,
                 port: int,
                 protocol: str,
                 target_attributes: Mapping[str, Sequence[str]]):
        """
        :param int port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param str protocol: The communication protocol your application secures.
        :param Mapping[str, Sequence[str]] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The communication protocol your application secures.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> Mapping[str, Sequence[str]]:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")


@pulumi.output_type
class GetZeroTrustAccessCustomPagesResultResult(dict):
    def __init__(__self__, *,
                 app_count: int,
                 created_at: str,
                 name: str,
                 type: str,
                 uid: str,
                 updated_at: str):
        """
        :param int app_count: Number of apps the custom page is assigned to.
        :param str name: Custom page name.
        :param str type: Custom page type.
        :param str uid: UUID
        """
        pulumi.set(__self__, "app_count", app_count)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="appCount")
    def app_count(self) -> int:
        """
        Number of apps the custom page is assigned to.
        """
        return pulumi.get(self, "app_count")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Custom page name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Custom page type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessGroupExcludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessGroupExcludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessGroupExcludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessGroupExcludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessGroupExcludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessGroupExcludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessGroupExcludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessGroupExcludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessGroupExcludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessGroupExcludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessGroupExcludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessGroupExcludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessGroupExcludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessGroupExcludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessGroupExcludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessGroupExcludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessGroupExcludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessGroupExcludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessGroupExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessGroupExcludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessGroupExcludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessGroupExcludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessGroupExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessGroupExcludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessGroupExcludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessGroupExcludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessGroupExcludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessGroupExcludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessGroupExcludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessGroupExcludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessGroupExcludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessGroupExcludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessGroupExcludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessGroupExcludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessGroupExcludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessGroupExcludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessGroupExcludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessGroupExcludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessGroupExcludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessGroupExcludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessGroupExcludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessGroupExcludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessGroupExcludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessGroupExcludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessGroupExcludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessGroupExcludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessGroupExcludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupExcludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str name: The name of the group.
        :param str search: Search for groups by other listed query parameters.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Search for groups by other listed query parameters.
        """
        return pulumi.get(self, "search")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessGroupIncludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessGroupIncludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessGroupIncludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessGroupIncludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessGroupIncludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessGroupIncludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessGroupIncludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessGroupIncludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessGroupIncludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessGroupIncludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessGroupIncludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessGroupIncludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessGroupIncludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessGroupIncludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessGroupIncludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessGroupIncludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessGroupIncludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessGroupIncludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessGroupIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessGroupIncludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessGroupIncludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessGroupIncludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessGroupIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessGroupIncludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessGroupIncludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessGroupIncludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessGroupIncludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessGroupIncludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessGroupIncludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessGroupIncludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessGroupIncludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessGroupIncludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessGroupIncludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessGroupIncludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessGroupIncludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessGroupIncludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessGroupIncludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessGroupIncludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessGroupIncludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessGroupIncludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessGroupIncludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessGroupIncludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessGroupIncludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessGroupIncludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessGroupIncludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessGroupIncludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessGroupIncludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIncludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessGroupIsDefaultAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessGroupIsDefaultAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessGroupIsDefaultAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessGroupIsDefaultAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessGroupIsDefaultCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessGroupIsDefaultCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessGroupIsDefaultDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessGroupIsDefaultEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessGroupIsDefaultEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessGroupIsDefaultEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessGroupIsDefaultEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessGroupIsDefaultExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessGroupIsDefaultGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessGroupIsDefaultGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessGroupIsDefaultGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessGroupIsDefaultGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessGroupIsDefaultIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessGroupIsDefaultIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessGroupIsDefaultLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessGroupIsDefaultOktaResult',
                 saml: 'outputs.GetZeroTrustAccessGroupIsDefaultSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessGroupIsDefaultServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessGroupIsDefaultAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessGroupIsDefaultEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessGroupIsDefaultServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessGroupIsDefaultLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessGroupIsDefaultOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupIsDefaultServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessGroupRequireAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessGroupRequireAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessGroupRequireAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessGroupRequireAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessGroupRequireCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessGroupRequireCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessGroupRequireDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessGroupRequireEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessGroupRequireEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessGroupRequireEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessGroupRequireEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessGroupRequireExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessGroupRequireGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessGroupRequireGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessGroupRequireGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessGroupRequireGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessGroupRequireIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessGroupRequireIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessGroupRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessGroupRequireOktaResult',
                 saml: 'outputs.GetZeroTrustAccessGroupRequireSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessGroupRequireServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessGroupRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessGroupRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessGroupRequireAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessGroupRequireAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessGroupRequireAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessGroupRequireAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessGroupRequireCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessGroupRequireCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessGroupRequireDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessGroupRequireEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessGroupRequireEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessGroupRequireEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessGroupRequireEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessGroupRequireExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessGroupRequireGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessGroupRequireGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessGroupRequireGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessGroupRequireGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessGroupRequireIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessGroupRequireIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessGroupRequireLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessGroupRequireOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessGroupRequireSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessGroupRequireServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupRequireAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupRequireCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupRequireExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessGroupRequireLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessGroupRequireOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupRequireServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 excludes: Sequence['outputs.GetZeroTrustAccessGroupsResultExcludeResult'],
                 id: str,
                 includes: Sequence['outputs.GetZeroTrustAccessGroupsResultIncludeResult'],
                 is_defaults: Sequence['outputs.GetZeroTrustAccessGroupsResultIsDefaultResult'],
                 name: str,
                 requires: Sequence['outputs.GetZeroTrustAccessGroupsResultRequireResult'],
                 updated_at: str):
        """
        :param Sequence['GetZeroTrustAccessGroupsResultExcludeArgs'] excludes: Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules.
        :param str id: UUID
        :param Sequence['GetZeroTrustAccessGroupsResultIncludeArgs'] includes: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        :param Sequence['GetZeroTrustAccessGroupsResultIsDefaultArgs'] is_defaults: Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
        :param str name: The name of the Access group.
        :param Sequence['GetZeroTrustAccessGroupsResultRequireArgs'] requires: Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "includes", includes)
        pulumi.set(__self__, "is_defaults", is_defaults)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "requires", requires)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def excludes(self) -> Sequence['outputs.GetZeroTrustAccessGroupsResultExcludeResult']:
        """
        Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def includes(self) -> Sequence['outputs.GetZeroTrustAccessGroupsResultIncludeResult']:
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        return pulumi.get(self, "includes")

    @property
    @pulumi.getter(name="isDefaults")
    def is_defaults(self) -> Sequence['outputs.GetZeroTrustAccessGroupsResultIsDefaultResult']:
        """
        Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "is_defaults")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Access group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def requires(self) -> Sequence['outputs.GetZeroTrustAccessGroupsResultRequireResult']:
        """
        Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "requires")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessGroupsResultExcludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessGroupsResultExcludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessGroupsResultExcludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessGroupsResultExcludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessGroupsResultExcludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessGroupsResultExcludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessGroupsResultExcludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessGroupsResultExcludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessGroupsResultExcludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessGroupsResultExcludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessGroupsResultExcludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessGroupsResultExcludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessGroupsResultExcludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessGroupsResultExcludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessGroupsResultExcludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessGroupsResultExcludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessGroupsResultExcludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessGroupsResultExcludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessGroupsResultExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessGroupsResultExcludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessGroupsResultExcludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessGroupsResultExcludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessGroupsResultExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessGroupsResultExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessGroupsResultExcludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessGroupsResultExcludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessGroupsResultExcludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultExcludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessGroupsResultIncludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessGroupsResultIncludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessGroupsResultIncludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessGroupsResultIncludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessGroupsResultIncludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessGroupsResultIncludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessGroupsResultIncludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessGroupsResultIncludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessGroupsResultIncludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessGroupsResultIncludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessGroupsResultIncludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessGroupsResultIncludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessGroupsResultIncludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessGroupsResultIncludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessGroupsResultIncludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessGroupsResultIncludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessGroupsResultIncludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessGroupsResultIncludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessGroupsResultIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessGroupsResultIncludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessGroupsResultIncludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessGroupsResultIncludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessGroupsResultIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessGroupsResultIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessGroupsResultIncludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessGroupsResultIncludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessGroupsResultIncludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIncludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultOktaResult',
                 saml: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessGroupsResultIsDefaultServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessGroupsResultIsDefaultEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessGroupsResultIsDefaultServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessGroupsResultIsDefaultLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessGroupsResultIsDefaultOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultIsDefaultServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessGroupsResultRequireAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessGroupsResultRequireAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessGroupsResultRequireAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessGroupsResultRequireAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessGroupsResultRequireCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessGroupsResultRequireCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessGroupsResultRequireDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessGroupsResultRequireEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessGroupsResultRequireEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessGroupsResultRequireEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessGroupsResultRequireEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessGroupsResultRequireExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessGroupsResultRequireGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessGroupsResultRequireGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessGroupsResultRequireGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessGroupsResultRequireGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessGroupsResultRequireIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessGroupsResultRequireIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessGroupsResultRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessGroupsResultRequireOktaResult',
                 saml: 'outputs.GetZeroTrustAccessGroupsResultRequireSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessGroupsResultRequireServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessGroupsResultRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessGroupsResultRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessGroupsResultRequireServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessGroupsResultRequireLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessGroupsResultRequireOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessGroupsResultRequireServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessIdentityProviderConfigResult(dict):
    def __init__(__self__, *,
                 apps_domain: str,
                 attributes: Sequence[str],
                 auth_url: str,
                 authorization_server_id: str,
                 centrify_account: str,
                 centrify_app_id: str,
                 certs_url: str,
                 claims: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 conditional_access_enabled: bool,
                 directory_id: str,
                 email_attribute_name: str,
                 email_claim_name: str,
                 header_attributes: Sequence['outputs.GetZeroTrustAccessIdentityProviderConfigHeaderAttributeResult'],
                 idp_public_certs: Sequence[str],
                 issuer_url: str,
                 okta_account: str,
                 onelogin_account: str,
                 ping_env_id: str,
                 pkce_enabled: bool,
                 prompt: str,
                 redirect_url: str,
                 scopes: Sequence[str],
                 sign_request: bool,
                 sso_target_url: str,
                 support_groups: bool,
                 token_url: str):
        """
        :param str apps_domain: Your companies TLD
        :param Sequence[str] attributes: A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        :param str auth_url: The authorization_endpoint URL of your IdP
        :param str authorization_server_id: Your okta authorization server id
        :param str centrify_account: Your centrify account url
        :param str centrify_app_id: Your centrify app id
        :param str certs_url: The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        :param Sequence[str] claims: Custom claims
        :param str client_id: Your OAuth Client ID
        :param str client_secret: Your OAuth Client Secret
        :param bool conditional_access_enabled: Should Cloudflare try to load authentication contexts from your account
        :param str directory_id: Your Azure directory uuid
        :param str email_attribute_name: The attribute name for email in the SAML response.
        :param str email_claim_name: The claim name for email in the id_token response.
        :param Sequence['GetZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs'] header_attributes: Add a list of attribute names that will be returned in the response header from the Access callback.
        :param Sequence[str] idp_public_certs: X509 certificate to verify the signature in the SAML authentication response
        :param str issuer_url: IdP Entity ID or Issuer URL
        :param str okta_account: Your okta account url
        :param str onelogin_account: Your OneLogin account url
        :param str ping_env_id: Your PingOne environment identifier
        :param bool pkce_enabled: Enable Proof Key for Code Exchange (PKCE)
        :param str prompt: Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        :param Sequence[str] scopes: OAuth scopes
        :param bool sign_request: Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        :param str sso_target_url: URL to send the SAML authentication requests to
        :param bool support_groups: Should Cloudflare try to load groups from your account
        :param str token_url: The token_endpoint URL of your IdP
        """
        pulumi.set(__self__, "apps_domain", apps_domain)
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        pulumi.set(__self__, "centrify_account", centrify_account)
        pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        pulumi.set(__self__, "certs_url", certs_url)
        pulumi.set(__self__, "claims", claims)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        pulumi.set(__self__, "directory_id", directory_id)
        pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        pulumi.set(__self__, "email_claim_name", email_claim_name)
        pulumi.set(__self__, "header_attributes", header_attributes)
        pulumi.set(__self__, "idp_public_certs", idp_public_certs)
        pulumi.set(__self__, "issuer_url", issuer_url)
        pulumi.set(__self__, "okta_account", okta_account)
        pulumi.set(__self__, "onelogin_account", onelogin_account)
        pulumi.set(__self__, "ping_env_id", ping_env_id)
        pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        pulumi.set(__self__, "prompt", prompt)
        pulumi.set(__self__, "redirect_url", redirect_url)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "sign_request", sign_request)
        pulumi.set(__self__, "sso_target_url", sso_target_url)
        pulumi.set(__self__, "support_groups", support_groups)
        pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> str:
        """
        Your companies TLD
        """
        return pulumi.get(self, "apps_domain")

    @property
    @pulumi.getter
    def attributes(self) -> Sequence[str]:
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        The authorization_endpoint URL of your IdP
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> str:
        """
        Your okta authorization server id
        """
        return pulumi.get(self, "authorization_server_id")

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> str:
        """
        Your centrify account url
        """
        return pulumi.get(self, "centrify_account")

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> str:
        """
        Your centrify app id
        """
        return pulumi.get(self, "centrify_app_id")

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> str:
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        return pulumi.get(self, "certs_url")

    @property
    @pulumi.getter
    def claims(self) -> Sequence[str]:
        """
        Custom claims
        """
        return pulumi.get(self, "claims")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Your OAuth Client ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Your OAuth Client Secret
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> bool:
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        return pulumi.get(self, "conditional_access_enabled")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> str:
        """
        Your Azure directory uuid
        """
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> str:
        """
        The attribute name for email in the SAML response.
        """
        return pulumi.get(self, "email_attribute_name")

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> str:
        """
        The claim name for email in the id_token response.
        """
        return pulumi.get(self, "email_claim_name")

    @property
    @pulumi.getter(name="headerAttributes")
    def header_attributes(self) -> Sequence['outputs.GetZeroTrustAccessIdentityProviderConfigHeaderAttributeResult']:
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        return pulumi.get(self, "header_attributes")

    @property
    @pulumi.getter(name="idpPublicCerts")
    def idp_public_certs(self) -> Sequence[str]:
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        return pulumi.get(self, "idp_public_certs")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        IdP Entity ID or Issuer URL
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> str:
        """
        Your okta account url
        """
        return pulumi.get(self, "okta_account")

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> str:
        """
        Your OneLogin account url
        """
        return pulumi.get(self, "onelogin_account")

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> str:
        """
        Your PingOne environment identifier
        """
        return pulumi.get(self, "ping_env_id")

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> bool:
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        return pulumi.get(self, "pkce_enabled")

    @property
    @pulumi.getter
    def prompt(self) -> str:
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        """
        return pulumi.get(self, "prompt")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> str:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        OAuth scopes
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> bool:
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        return pulumi.get(self, "sign_request")

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> str:
        """
        URL to send the SAML authentication requests to
        """
        return pulumi.get(self, "sso_target_url")

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> bool:
        """
        Should Cloudflare try to load groups from your account
        """
        return pulumi.get(self, "support_groups")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        The token_endpoint URL of your IdP
        """
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetZeroTrustAccessIdentityProviderConfigHeaderAttributeResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 header_name: str):
        """
        :param str attribute_name: attribute name from the IDP
        :param str header_name: header that will be added on the request to the origin
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        attribute name from the IDP
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        header that will be added on the request to the origin
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class GetZeroTrustAccessIdentityProviderFilterResult(dict):
    def __init__(__self__, *,
                 scim_enabled: Optional[str] = None):
        """
        :param str scim_enabled: Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
        """
        if scim_enabled is not None:
            pulumi.set(__self__, "scim_enabled", scim_enabled)

    @property
    @pulumi.getter(name="scimEnabled")
    def scim_enabled(self) -> Optional[str]:
        """
        Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
        """
        return pulumi.get(self, "scim_enabled")


@pulumi.output_type
class GetZeroTrustAccessIdentityProviderScimConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 identity_update_behavior: str,
                 scim_base_url: str,
                 seat_deprovision: bool,
                 secret: str,
                 user_deprovision: bool):
        """
        :param bool enabled: A flag to enable or disable SCIM for the identity provider.
        :param str identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        :param str scim_base_url: The base URL of Cloudflare's SCIM V2.0 API endpoint.
        :param bool seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param str secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        :param bool user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        pulumi.set(__self__, "scim_base_url", scim_base_url)
        pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> str:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        return pulumi.get(self, "identity_update_behavior")

    @property
    @pulumi.getter(name="scimBaseUrl")
    def scim_base_url(self) -> str:
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        return pulumi.get(self, "scim_base_url")

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> bool:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> bool:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")


@pulumi.output_type
class GetZeroTrustAccessIdentityProvidersResultResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetZeroTrustAccessIdentityProvidersResultConfigResult',
                 id: str,
                 name: str,
                 scim_config: 'outputs.GetZeroTrustAccessIdentityProvidersResultScimConfigResult',
                 type: str):
        """
        :param 'GetZeroTrustAccessIdentityProvidersResultConfigArgs' config: The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
        :param str id: UUID
        :param str name: The name of the identity provider, shown to users on the login page.
        :param 'GetZeroTrustAccessIdentityProvidersResultScimConfigArgs' scim_config: The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
        :param str type: The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scim_config", scim_config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.GetZeroTrustAccessIdentityProvidersResultConfigResult':
        """
        The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the identity provider, shown to users on the login page.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="scimConfig")
    def scim_config(self) -> 'outputs.GetZeroTrustAccessIdentityProvidersResultScimConfigResult':
        """
        The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
        """
        return pulumi.get(self, "scim_config")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetZeroTrustAccessIdentityProvidersResultConfigResult(dict):
    def __init__(__self__, *,
                 apps_domain: str,
                 attributes: Sequence[str],
                 auth_url: str,
                 authorization_server_id: str,
                 centrify_account: str,
                 centrify_app_id: str,
                 certs_url: str,
                 claims: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 conditional_access_enabled: bool,
                 directory_id: str,
                 email_attribute_name: str,
                 email_claim_name: str,
                 header_attributes: Sequence['outputs.GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttributeResult'],
                 idp_public_certs: Sequence[str],
                 issuer_url: str,
                 okta_account: str,
                 onelogin_account: str,
                 ping_env_id: str,
                 pkce_enabled: bool,
                 prompt: str,
                 scopes: Sequence[str],
                 sign_request: bool,
                 sso_target_url: str,
                 support_groups: bool,
                 token_url: str):
        """
        :param str apps_domain: Your companies TLD
        :param Sequence[str] attributes: A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        :param str auth_url: The authorization_endpoint URL of your IdP
        :param str authorization_server_id: Your okta authorization server id
        :param str centrify_account: Your centrify account url
        :param str centrify_app_id: Your centrify app id
        :param str certs_url: The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        :param Sequence[str] claims: Custom claims
        :param str client_id: Your OAuth Client ID
        :param str client_secret: Your OAuth Client Secret
        :param bool conditional_access_enabled: Should Cloudflare try to load authentication contexts from your account
        :param str directory_id: Your Azure directory uuid
        :param str email_attribute_name: The attribute name for email in the SAML response.
        :param str email_claim_name: The claim name for email in the id_token response.
        :param Sequence['GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttributeArgs'] header_attributes: Add a list of attribute names that will be returned in the response header from the Access callback.
        :param Sequence[str] idp_public_certs: X509 certificate to verify the signature in the SAML authentication response
        :param str issuer_url: IdP Entity ID or Issuer URL
        :param str okta_account: Your okta account url
        :param str onelogin_account: Your OneLogin account url
        :param str ping_env_id: Your PingOne environment identifier
        :param bool pkce_enabled: Enable Proof Key for Code Exchange (PKCE)
        :param str prompt: Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        :param Sequence[str] scopes: OAuth scopes
        :param bool sign_request: Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        :param str sso_target_url: URL to send the SAML authentication requests to
        :param bool support_groups: Should Cloudflare try to load groups from your account
        :param str token_url: The token_endpoint URL of your IdP
        """
        pulumi.set(__self__, "apps_domain", apps_domain)
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        pulumi.set(__self__, "centrify_account", centrify_account)
        pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        pulumi.set(__self__, "certs_url", certs_url)
        pulumi.set(__self__, "claims", claims)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        pulumi.set(__self__, "directory_id", directory_id)
        pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        pulumi.set(__self__, "email_claim_name", email_claim_name)
        pulumi.set(__self__, "header_attributes", header_attributes)
        pulumi.set(__self__, "idp_public_certs", idp_public_certs)
        pulumi.set(__self__, "issuer_url", issuer_url)
        pulumi.set(__self__, "okta_account", okta_account)
        pulumi.set(__self__, "onelogin_account", onelogin_account)
        pulumi.set(__self__, "ping_env_id", ping_env_id)
        pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        pulumi.set(__self__, "prompt", prompt)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "sign_request", sign_request)
        pulumi.set(__self__, "sso_target_url", sso_target_url)
        pulumi.set(__self__, "support_groups", support_groups)
        pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> str:
        """
        Your companies TLD
        """
        return pulumi.get(self, "apps_domain")

    @property
    @pulumi.getter
    def attributes(self) -> Sequence[str]:
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        The authorization_endpoint URL of your IdP
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> str:
        """
        Your okta authorization server id
        """
        return pulumi.get(self, "authorization_server_id")

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> str:
        """
        Your centrify account url
        """
        return pulumi.get(self, "centrify_account")

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> str:
        """
        Your centrify app id
        """
        return pulumi.get(self, "centrify_app_id")

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> str:
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        return pulumi.get(self, "certs_url")

    @property
    @pulumi.getter
    def claims(self) -> Sequence[str]:
        """
        Custom claims
        """
        return pulumi.get(self, "claims")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Your OAuth Client ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Your OAuth Client Secret
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> bool:
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        return pulumi.get(self, "conditional_access_enabled")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> str:
        """
        Your Azure directory uuid
        """
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> str:
        """
        The attribute name for email in the SAML response.
        """
        return pulumi.get(self, "email_attribute_name")

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> str:
        """
        The claim name for email in the id_token response.
        """
        return pulumi.get(self, "email_claim_name")

    @property
    @pulumi.getter(name="headerAttributes")
    def header_attributes(self) -> Sequence['outputs.GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttributeResult']:
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        return pulumi.get(self, "header_attributes")

    @property
    @pulumi.getter(name="idpPublicCerts")
    def idp_public_certs(self) -> Sequence[str]:
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        return pulumi.get(self, "idp_public_certs")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        IdP Entity ID or Issuer URL
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> str:
        """
        Your okta account url
        """
        return pulumi.get(self, "okta_account")

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> str:
        """
        Your OneLogin account url
        """
        return pulumi.get(self, "onelogin_account")

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> str:
        """
        Your PingOne environment identifier
        """
        return pulumi.get(self, "ping_env_id")

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> bool:
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        return pulumi.get(self, "pkce_enabled")

    @property
    @pulumi.getter
    def prompt(self) -> str:
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        """
        return pulumi.get(self, "prompt")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        OAuth scopes
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> bool:
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        return pulumi.get(self, "sign_request")

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> str:
        """
        URL to send the SAML authentication requests to
        """
        return pulumi.get(self, "sso_target_url")

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> bool:
        """
        Should Cloudflare try to load groups from your account
        """
        return pulumi.get(self, "support_groups")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        The token_endpoint URL of your IdP
        """
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttributeResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 header_name: str):
        """
        :param str attribute_name: attribute name from the IDP
        :param str header_name: header that will be added on the request to the origin
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        attribute name from the IDP
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        header that will be added on the request to the origin
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class GetZeroTrustAccessIdentityProvidersResultScimConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 identity_update_behavior: str,
                 scim_base_url: str,
                 seat_deprovision: bool,
                 secret: str,
                 user_deprovision: bool):
        """
        :param bool enabled: A flag to enable or disable SCIM for the identity provider.
        :param str identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        :param str scim_base_url: The base URL of Cloudflare's SCIM V2.0 API endpoint.
        :param bool seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param str secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        :param bool user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        pulumi.set(__self__, "scim_base_url", scim_base_url)
        pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> str:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        return pulumi.get(self, "identity_update_behavior")

    @property
    @pulumi.getter(name="scimBaseUrl")
    def scim_base_url(self) -> str:
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        return pulumi.get(self, "scim_base_url")

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> bool:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> bool:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")


@pulumi.output_type
class GetZeroTrustAccessInfrastructureTargetFilterResult(dict):
    def __init__(__self__, *,
                 created_after: Optional[str] = None,
                 created_before: Optional[str] = None,
                 direction: Optional[str] = None,
                 hostname: Optional[str] = None,
                 hostname_contains: Optional[str] = None,
<<<<<<< HEAD
                 ip_v4: Optional[str] = None,
                 ip_v6: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 modified_after: Optional[str] = None,
                 modified_before: Optional[str] = None,
                 order: Optional[str] = None,
=======
                 ip_like: Optional[str] = None,
                 ip_v4: Optional[str] = None,
                 ip_v6: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 ipv4_end: Optional[str] = None,
                 ipv4_start: Optional[str] = None,
                 ipv6_end: Optional[str] = None,
                 ipv6_start: Optional[str] = None,
                 modified_after: Optional[str] = None,
                 modified_before: Optional[str] = None,
                 order: Optional[str] = None,
                 target_ids: Optional[Sequence[str]] = None,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 virtual_network_id: Optional[str] = None):
        """
        :param str created_after: Date and time at which the target was created after (inclusive)
        :param str created_before: Date and time at which the target was created before (inclusive)
        :param str direction: The sorting direction.
        :param str hostname: Hostname of a target
        :param str hostname_contains: Partial match to the hostname of a target
<<<<<<< HEAD
=======
        :param str ip_like: Filters for targets whose IP addresses look like the specified string.
               Supports `*` as a wildcard character
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        :param str ip_v4: IPv4 address of the target
        :param str ip_v6: IPv6 address of the target
        :param Sequence[str] ips: Filters for targets that have any of the following IP addresses. Specify
               `ips` multiple times in query parameter to build list of candidates.
<<<<<<< HEAD
        :param str modified_after: Date and time at which the target was modified after (inclusive)
        :param str modified_before: Date and time at which the target was modified before (inclusive)
        :param str order: The field to sort by.
=======
        :param str ipv4_end: Defines an IPv4 filter range's ending value (inclusive). Requires
               `ipv4_start` to be specified as well.
        :param str ipv4_start: Defines an IPv4 filter range's starting value (inclusive). Requires
               `ipv4_end` to be specified as well.
        :param str ipv6_end: Defines an IPv6 filter range's ending value (inclusive). Requires
               `ipv6_start` to be specified as well.
        :param str ipv6_start: Defines an IPv6 filter range's starting value (inclusive). Requires
               `ipv6_end` to be specified as well.
        :param str modified_after: Date and time at which the target was modified after (inclusive)
        :param str modified_before: Date and time at which the target was modified before (inclusive)
        :param str order: The field to sort by.
        :param Sequence[str] target_ids: Filters for targets that have any of the following UUIDs. Specify
               `target_ids` multiple times in query parameter to build list of
               candidates.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        :param str virtual_network_id: Private virtual network identifier of the target
        """
        if created_after is not None:
            pulumi.set(__self__, "created_after", created_after)
        if created_before is not None:
            pulumi.set(__self__, "created_before", created_before)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if hostname_contains is not None:
            pulumi.set(__self__, "hostname_contains", hostname_contains)
<<<<<<< HEAD
=======
        if ip_like is not None:
            pulumi.set(__self__, "ip_like", ip_like)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if ip_v4 is not None:
            pulumi.set(__self__, "ip_v4", ip_v4)
        if ip_v6 is not None:
            pulumi.set(__self__, "ip_v6", ip_v6)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
<<<<<<< HEAD
=======
        if ipv4_end is not None:
            pulumi.set(__self__, "ipv4_end", ipv4_end)
        if ipv4_start is not None:
            pulumi.set(__self__, "ipv4_start", ipv4_start)
        if ipv6_end is not None:
            pulumi.set(__self__, "ipv6_end", ipv6_end)
        if ipv6_start is not None:
            pulumi.set(__self__, "ipv6_start", ipv6_start)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if modified_after is not None:
            pulumi.set(__self__, "modified_after", modified_after)
        if modified_before is not None:
            pulumi.set(__self__, "modified_before", modified_before)
        if order is not None:
            pulumi.set(__self__, "order", order)
<<<<<<< HEAD
=======
        if target_ids is not None:
            pulumi.set(__self__, "target_ids", target_ids)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="createdAfter")
    def created_after(self) -> Optional[str]:
        """
        Date and time at which the target was created after (inclusive)
        """
        return pulumi.get(self, "created_after")

    @property
    @pulumi.getter(name="createdBefore")
    def created_before(self) -> Optional[str]:
        """
        Date and time at which the target was created before (inclusive)
        """
        return pulumi.get(self, "created_before")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sorting direction.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of a target
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="hostnameContains")
    def hostname_contains(self) -> Optional[str]:
        """
        Partial match to the hostname of a target
        """
        return pulumi.get(self, "hostname_contains")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="ipLike")
    def ip_like(self) -> Optional[str]:
        """
        Filters for targets whose IP addresses look like the specified string.
        Supports `*` as a wildcard character
        """
        return pulumi.get(self, "ip_like")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter(name="ipV4")
    def ip_v4(self) -> Optional[str]:
        """
        IPv4 address of the target
        """
        return pulumi.get(self, "ip_v4")

    @property
    @pulumi.getter(name="ipV6")
    def ip_v6(self) -> Optional[str]:
        """
        IPv6 address of the target
        """
        return pulumi.get(self, "ip_v6")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        Filters for targets that have any of the following IP addresses. Specify
        `ips` multiple times in query parameter to build list of candidates.
        """
        return pulumi.get(self, "ips")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="ipv4End")
    def ipv4_end(self) -> Optional[str]:
        """
        Defines an IPv4 filter range's ending value (inclusive). Requires
        `ipv4_start` to be specified as well.
        """
        return pulumi.get(self, "ipv4_end")

    @property
    @pulumi.getter(name="ipv4Start")
    def ipv4_start(self) -> Optional[str]:
        """
        Defines an IPv4 filter range's starting value (inclusive). Requires
        `ipv4_end` to be specified as well.
        """
        return pulumi.get(self, "ipv4_start")

    @property
    @pulumi.getter(name="ipv6End")
    def ipv6_end(self) -> Optional[str]:
        """
        Defines an IPv6 filter range's ending value (inclusive). Requires
        `ipv6_start` to be specified as well.
        """
        return pulumi.get(self, "ipv6_end")

    @property
    @pulumi.getter(name="ipv6Start")
    def ipv6_start(self) -> Optional[str]:
        """
        Defines an IPv6 filter range's starting value (inclusive). Requires
        `ipv6_end` to be specified as well.
        """
        return pulumi.get(self, "ipv6_start")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter(name="modifiedAfter")
    def modified_after(self) -> Optional[str]:
        """
        Date and time at which the target was modified after (inclusive)
        """
        return pulumi.get(self, "modified_after")

    @property
    @pulumi.getter(name="modifiedBefore")
    def modified_before(self) -> Optional[str]:
        """
        Date and time at which the target was modified before (inclusive)
        """
        return pulumi.get(self, "modified_before")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field to sort by.
        """
        return pulumi.get(self, "order")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Optional[Sequence[str]]:
        """
        Filters for targets that have any of the following UUIDs. Specify
        `target_ids` multiple times in query parameter to build list of
        candidates.
        """
        return pulumi.get(self, "target_ids")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        Private virtual network identifier of the target
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetZeroTrustAccessInfrastructureTargetIpResult(dict):
    def __init__(__self__, *,
                 ipv4: 'outputs.GetZeroTrustAccessInfrastructureTargetIpIpv4Result',
                 ipv6: 'outputs.GetZeroTrustAccessInfrastructureTargetIpIpv6Result'):
        """
        :param 'GetZeroTrustAccessInfrastructureTargetIpIpv4Args' ipv4: The target's IPv4 address
        :param 'GetZeroTrustAccessInfrastructureTargetIpIpv6Args' ipv6: The target's IPv6 address
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetZeroTrustAccessInfrastructureTargetIpIpv4Result':
        """
        The target's IPv4 address
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> 'outputs.GetZeroTrustAccessInfrastructureTargetIpIpv6Result':
        """
        The target's IPv6 address
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class GetZeroTrustAccessInfrastructureTargetIpIpv4Result(dict):
    def __init__(__self__, *,
                 ip_addr: str,
                 virtual_network_id: str):
        """
        :param str ip_addr: IP address of the target
        :param str virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> str:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> str:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetZeroTrustAccessInfrastructureTargetIpIpv6Result(dict):
    def __init__(__self__, *,
                 ip_addr: str,
                 virtual_network_id: str):
        """
        :param str ip_addr: IP address of the target
        :param str virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> str:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> str:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetZeroTrustAccessInfrastructureTargetsResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 hostname: str,
                 id: str,
                 ip: 'outputs.GetZeroTrustAccessInfrastructureTargetsResultIpResult',
                 modified_at: str):
        """
        :param str created_at: Date and time at which the target was created
        :param str hostname: A non-unique field that refers to a target
        :param str id: Target identifier
        :param 'GetZeroTrustAccessInfrastructureTargetsResultIpArgs' ip: The IPv4/IPv6 address that identifies where to reach a target
        :param str modified_at: Date and time at which the target was modified
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "modified_at", modified_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date and time at which the target was created
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        A non-unique field that refers to a target
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Target identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessInfrastructureTargetsResultIpResult':
        """
        The IPv4/IPv6 address that identifies where to reach a target
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="modifiedAt")
    def modified_at(self) -> str:
        """
        Date and time at which the target was modified
        """
        return pulumi.get(self, "modified_at")


@pulumi.output_type
class GetZeroTrustAccessInfrastructureTargetsResultIpResult(dict):
    def __init__(__self__, *,
                 ipv4: 'outputs.GetZeroTrustAccessInfrastructureTargetsResultIpIpv4Result',
                 ipv6: 'outputs.GetZeroTrustAccessInfrastructureTargetsResultIpIpv6Result'):
        """
        :param 'GetZeroTrustAccessInfrastructureTargetsResultIpIpv4Args' ipv4: The target's IPv4 address
        :param 'GetZeroTrustAccessInfrastructureTargetsResultIpIpv6Args' ipv6: The target's IPv6 address
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetZeroTrustAccessInfrastructureTargetsResultIpIpv4Result':
        """
        The target's IPv4 address
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> 'outputs.GetZeroTrustAccessInfrastructureTargetsResultIpIpv6Result':
        """
        The target's IPv6 address
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class GetZeroTrustAccessInfrastructureTargetsResultIpIpv4Result(dict):
    def __init__(__self__, *,
                 ip_addr: str,
                 virtual_network_id: str):
        """
        :param str ip_addr: IP address of the target
        :param str virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> str:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> str:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetZeroTrustAccessInfrastructureTargetsResultIpIpv6Result(dict):
    def __init__(__self__, *,
                 ip_addr: str,
                 virtual_network_id: str):
        """
        :param str ip_addr: IP address of the target
        :param str virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> str:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> str:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetZeroTrustAccessMtlsCertificatesResultResult(dict):
    def __init__(__self__, *,
                 associated_hostnames: Sequence[str],
                 created_at: str,
                 expires_on: str,
                 fingerprint: str,
                 id: str,
                 name: str,
                 updated_at: str):
        """
        :param Sequence[str] associated_hostnames: The hostnames of the applications that will use this certificate.
        :param str fingerprint: The MD5 fingerprint of the certificate.
        :param str id: The ID of the application that will use this certificate.
        :param str name: The name of the certificate.
        """
        pulumi.set(__self__, "associated_hostnames", associated_hostnames)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="associatedHostnames")
    def associated_hostnames(self) -> Sequence[str]:
        """
        The hostnames of the applications that will use this certificate.
        """
        return pulumi.get(self, "associated_hostnames")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        """
        The MD5 fingerprint of the certificate.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the application that will use this certificate.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultResult(dict):
    def __init__(__self__, *,
                 app_count: int,
                 approval_groups: Sequence['outputs.GetZeroTrustAccessPoliciesResultApprovalGroupResult'],
                 approval_required: bool,
                 created_at: str,
                 decision: str,
                 excludes: Sequence['outputs.GetZeroTrustAccessPoliciesResultExcludeResult'],
                 id: str,
                 includes: Sequence['outputs.GetZeroTrustAccessPoliciesResultIncludeResult'],
                 isolation_required: bool,
                 name: str,
                 purpose_justification_prompt: str,
                 purpose_justification_required: bool,
                 requires: Sequence['outputs.GetZeroTrustAccessPoliciesResultRequireResult'],
                 reusable: bool,
                 session_duration: str,
                 updated_at: str):
        """
        :param int app_count: Number of access applications currently using this policy.
        :param Sequence['GetZeroTrustAccessPoliciesResultApprovalGroupArgs'] approval_groups: Administrators who can approve a temporary authentication request.
        :param bool approval_required: Requires the user to request access from an administrator at the start of each session.
        :param str decision: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        :param Sequence['GetZeroTrustAccessPoliciesResultExcludeArgs'] excludes: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        :param str id: The UUID of the policy
        :param Sequence['GetZeroTrustAccessPoliciesResultIncludeArgs'] includes: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        :param bool isolation_required: Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
        :param str name: The name of the Access policy.
        :param str purpose_justification_prompt: A custom message that will appear on the purpose justification screen.
        :param bool purpose_justification_required: Require users to enter a justification when they log in to the application.
        :param Sequence['GetZeroTrustAccessPoliciesResultRequireArgs'] requires: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        :param str session_duration: The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
        """
        pulumi.set(__self__, "app_count", app_count)
        pulumi.set(__self__, "approval_groups", approval_groups)
        pulumi.set(__self__, "approval_required", approval_required)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "decision", decision)
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "includes", includes)
        pulumi.set(__self__, "isolation_required", isolation_required)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "purpose_justification_prompt", purpose_justification_prompt)
        pulumi.set(__self__, "purpose_justification_required", purpose_justification_required)
        pulumi.set(__self__, "requires", requires)
        pulumi.set(__self__, "reusable", reusable)
        pulumi.set(__self__, "session_duration", session_duration)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="appCount")
    def app_count(self) -> int:
        """
        Number of access applications currently using this policy.
        """
        return pulumi.get(self, "app_count")

    @property
    @pulumi.getter(name="approvalGroups")
    def approval_groups(self) -> Sequence['outputs.GetZeroTrustAccessPoliciesResultApprovalGroupResult']:
        """
        Administrators who can approve a temporary authentication request.
        """
        return pulumi.get(self, "approval_groups")

    @property
    @pulumi.getter(name="approvalRequired")
    def approval_required(self) -> bool:
        """
        Requires the user to request access from an administrator at the start of each session.
        """
        return pulumi.get(self, "approval_required")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def decision(self) -> str:
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        """
        return pulumi.get(self, "decision")

    @property
    @pulumi.getter
    def excludes(self) -> Sequence['outputs.GetZeroTrustAccessPoliciesResultExcludeResult']:
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID of the policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def includes(self) -> Sequence['outputs.GetZeroTrustAccessPoliciesResultIncludeResult']:
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        return pulumi.get(self, "includes")

    @property
    @pulumi.getter(name="isolationRequired")
    def isolation_required(self) -> bool:
        """
        Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
        """
        return pulumi.get(self, "isolation_required")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Access policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="purposeJustificationPrompt")
    def purpose_justification_prompt(self) -> str:
        """
        A custom message that will appear on the purpose justification screen.
        """
        return pulumi.get(self, "purpose_justification_prompt")

    @property
    @pulumi.getter(name="purposeJustificationRequired")
    def purpose_justification_required(self) -> bool:
        """
        Require users to enter a justification when they log in to the application.
        """
        return pulumi.get(self, "purpose_justification_required")

    @property
    @pulumi.getter
    def requires(self) -> Sequence['outputs.GetZeroTrustAccessPoliciesResultRequireResult']:
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "requires")

    @property
    @pulumi.getter
    def reusable(self) -> bool:
        return pulumi.get(self, "reusable")

    @property
    @pulumi.getter(name="sessionDuration")
    def session_duration(self) -> str:
        """
        The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
        """
        return pulumi.get(self, "session_duration")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultApprovalGroupResult(dict):
    def __init__(__self__, *,
                 approvals_needed: float,
                 email_addresses: Sequence[str],
                 email_list_uuid: str):
        """
        :param float approvals_needed: The number of approvals needed to obtain access.
        :param Sequence[str] email_addresses: A list of emails that can approve the access request.
        :param str email_list_uuid: The UUID of an re-usable email list.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        pulumi.set(__self__, "email_addresses", email_addresses)
        pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> float:
        """
        The number of approvals needed to obtain access.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Sequence[str]:
        """
        A list of emails that can approve the access request.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> str:
        """
        The UUID of an re-usable email list.
        """
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessPoliciesResultExcludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessPoliciesResultExcludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessPoliciesResultExcludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessPoliciesResultExcludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessPoliciesResultExcludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessPoliciesResultExcludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessPoliciesResultExcludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessPoliciesResultExcludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessPoliciesResultExcludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessPoliciesResultExcludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessPoliciesResultExcludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessPoliciesResultExcludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessPoliciesResultExcludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessPoliciesResultExcludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessPoliciesResultExcludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessPoliciesResultExcludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessPoliciesResultExcludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessPoliciesResultExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessPoliciesResultExcludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessPoliciesResultExcludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessPoliciesResultExcludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessPoliciesResultExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessPoliciesResultExcludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessPoliciesResultExcludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessPoliciesResultExcludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultExcludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessPoliciesResultIncludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessPoliciesResultIncludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessPoliciesResultIncludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessPoliciesResultIncludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessPoliciesResultIncludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessPoliciesResultIncludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessPoliciesResultIncludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessPoliciesResultIncludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessPoliciesResultIncludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessPoliciesResultIncludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessPoliciesResultIncludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessPoliciesResultIncludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessPoliciesResultIncludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessPoliciesResultIncludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessPoliciesResultIncludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessPoliciesResultIncludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessPoliciesResultIncludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessPoliciesResultIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessPoliciesResultIncludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessPoliciesResultIncludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessPoliciesResultIncludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessPoliciesResultIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessPoliciesResultIncludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessPoliciesResultIncludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessPoliciesResultIncludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultIncludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessPoliciesResultRequireAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessPoliciesResultRequireAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessPoliciesResultRequireAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessPoliciesResultRequireAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessPoliciesResultRequireCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessPoliciesResultRequireCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessPoliciesResultRequireDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessPoliciesResultRequireEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessPoliciesResultRequireEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessPoliciesResultRequireEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessPoliciesResultRequireEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessPoliciesResultRequireExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessPoliciesResultRequireGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessPoliciesResultRequireGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessPoliciesResultRequireGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessPoliciesResultRequireGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessPoliciesResultRequireIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessPoliciesResultRequireIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessPoliciesResultRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessPoliciesResultRequireOktaResult',
                 saml: 'outputs.GetZeroTrustAccessPoliciesResultRequireSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessPoliciesResultRequireServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessPoliciesResultRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessPoliciesResultRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessPoliciesResultRequireServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessPoliciesResultRequireLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessPoliciesResultRequireOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPoliciesResultRequireServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyApprovalGroupResult(dict):
    def __init__(__self__, *,
                 approvals_needed: float,
                 email_addresses: Sequence[str],
                 email_list_uuid: str):
        """
        :param float approvals_needed: The number of approvals needed to obtain access.
        :param Sequence[str] email_addresses: A list of emails that can approve the access request.
        :param str email_list_uuid: The UUID of an re-usable email list.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        pulumi.set(__self__, "email_addresses", email_addresses)
        pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> float:
        """
        The number of approvals needed to obtain access.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Sequence[str]:
        """
        A list of emails that can approve the access request.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> str:
        """
        The UUID of an re-usable email list.
        """
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessPolicyExcludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessPolicyExcludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessPolicyExcludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessPolicyExcludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessPolicyExcludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessPolicyExcludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessPolicyExcludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessPolicyExcludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessPolicyExcludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessPolicyExcludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessPolicyExcludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessPolicyExcludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessPolicyExcludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessPolicyExcludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessPolicyExcludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessPolicyExcludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessPolicyExcludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessPolicyExcludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessPolicyExcludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessPolicyExcludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessPolicyExcludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessPolicyExcludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessPolicyExcludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessPolicyExcludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessPolicyExcludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessPolicyExcludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyExcludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessPolicyIncludeAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessPolicyIncludeAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessPolicyIncludeAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessPolicyIncludeAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessPolicyIncludeCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessPolicyIncludeCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessPolicyIncludeDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessPolicyIncludeEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessPolicyIncludeEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessPolicyIncludeEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessPolicyIncludeEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessPolicyIncludeExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessPolicyIncludeGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessPolicyIncludeGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessPolicyIncludeGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessPolicyIncludeGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessPolicyIncludeIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessPolicyIncludeIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessPolicyIncludeLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessPolicyIncludeOktaResult',
                 saml: 'outputs.GetZeroTrustAccessPolicyIncludeSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessPolicyIncludeServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessPolicyIncludeEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessPolicyIncludeServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessPolicyIncludeLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessPolicyIncludeOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyIncludeServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireResult(dict):
    def __init__(__self__, *,
                 any_valid_service_token: 'outputs.GetZeroTrustAccessPolicyRequireAnyValidServiceTokenResult',
                 auth_context: 'outputs.GetZeroTrustAccessPolicyRequireAuthContextResult',
                 auth_method: 'outputs.GetZeroTrustAccessPolicyRequireAuthMethodResult',
                 azure_ad: 'outputs.GetZeroTrustAccessPolicyRequireAzureAdResult',
                 certificate: 'outputs.GetZeroTrustAccessPolicyRequireCertificateResult',
                 common_name: 'outputs.GetZeroTrustAccessPolicyRequireCommonNameResult',
                 device_posture: 'outputs.GetZeroTrustAccessPolicyRequireDevicePostureResult',
                 email: 'outputs.GetZeroTrustAccessPolicyRequireEmailResult',
                 email_domain: 'outputs.GetZeroTrustAccessPolicyRequireEmailDomainResult',
                 email_list: 'outputs.GetZeroTrustAccessPolicyRequireEmailListResult',
                 everyone: 'outputs.GetZeroTrustAccessPolicyRequireEveryoneResult',
                 external_evaluation: 'outputs.GetZeroTrustAccessPolicyRequireExternalEvaluationResult',
                 geo: 'outputs.GetZeroTrustAccessPolicyRequireGeoResult',
                 github_organization: 'outputs.GetZeroTrustAccessPolicyRequireGithubOrganizationResult',
                 group: 'outputs.GetZeroTrustAccessPolicyRequireGroupResult',
                 gsuite: 'outputs.GetZeroTrustAccessPolicyRequireGsuiteResult',
                 ip: 'outputs.GetZeroTrustAccessPolicyRequireIpResult',
                 ip_list: 'outputs.GetZeroTrustAccessPolicyRequireIpListResult',
<<<<<<< HEAD
=======
                 login_method: 'outputs.GetZeroTrustAccessPolicyRequireLoginMethodResult',
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 okta: 'outputs.GetZeroTrustAccessPolicyRequireOktaResult',
                 saml: 'outputs.GetZeroTrustAccessPolicyRequireSamlResult',
                 service_token: 'outputs.GetZeroTrustAccessPolicyRequireServiceTokenResult'):
        """
        :param 'GetZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs' any_valid_service_token: An empty object which matches on all service tokens.
        :param 'GetZeroTrustAccessPolicyRequireEveryoneArgs' everyone: An empty object which matches on all users.
        """
        pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        pulumi.set(__self__, "auth_context", auth_context)
        pulumi.set(__self__, "auth_method", auth_method)
        pulumi.set(__self__, "azure_ad", azure_ad)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "email_domain", email_domain)
        pulumi.set(__self__, "email_list", email_list)
        pulumi.set(__self__, "everyone", everyone)
        pulumi.set(__self__, "external_evaluation", external_evaluation)
        pulumi.set(__self__, "geo", geo)
        pulumi.set(__self__, "github_organization", github_organization)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "gsuite", gsuite)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_list", ip_list)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "login_method", login_method)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        pulumi.set(__self__, "okta", okta)
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> 'outputs.GetZeroTrustAccessPolicyRequireAnyValidServiceTokenResult':
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> 'outputs.GetZeroTrustAccessPolicyRequireAuthContextResult':
        return pulumi.get(self, "auth_context")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> 'outputs.GetZeroTrustAccessPolicyRequireAuthMethodResult':
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> 'outputs.GetZeroTrustAccessPolicyRequireAzureAdResult':
        return pulumi.get(self, "azure_ad")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustAccessPolicyRequireCertificateResult':
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.GetZeroTrustAccessPolicyRequireCommonNameResult':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> 'outputs.GetZeroTrustAccessPolicyRequireDevicePostureResult':
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def email(self) -> 'outputs.GetZeroTrustAccessPolicyRequireEmailResult':
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> 'outputs.GetZeroTrustAccessPolicyRequireEmailDomainResult':
        return pulumi.get(self, "email_domain")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> 'outputs.GetZeroTrustAccessPolicyRequireEmailListResult':
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def everyone(self) -> 'outputs.GetZeroTrustAccessPolicyRequireEveryoneResult':
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> 'outputs.GetZeroTrustAccessPolicyRequireExternalEvaluationResult':
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geo(self) -> 'outputs.GetZeroTrustAccessPolicyRequireGeoResult':
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> 'outputs.GetZeroTrustAccessPolicyRequireGithubOrganizationResult':
        return pulumi.get(self, "github_organization")

    @property
    @pulumi.getter
    def group(self) -> 'outputs.GetZeroTrustAccessPolicyRequireGroupResult':
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def gsuite(self) -> 'outputs.GetZeroTrustAccessPolicyRequireGsuiteResult':
        return pulumi.get(self, "gsuite")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustAccessPolicyRequireIpResult':
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> 'outputs.GetZeroTrustAccessPolicyRequireIpListResult':
        return pulumi.get(self, "ip_list")

    @property
<<<<<<< HEAD
=======
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> 'outputs.GetZeroTrustAccessPolicyRequireLoginMethodResult':
        return pulumi.get(self, "login_method")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def okta(self) -> 'outputs.GetZeroTrustAccessPolicyRequireOktaResult':
        return pulumi.get(self, "okta")

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.GetZeroTrustAccessPolicyRequireSamlResult':
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> 'outputs.GetZeroTrustAccessPolicyRequireServiceTokenResult':
        return pulumi.get(self, "service_token")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireAnyValidServiceTokenResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireAuthContextResult(dict):
    def __init__(__self__, *,
                 ac_id: str,
                 id: str,
                 identity_provider_id: str):
        """
        :param str ac_id: The ACID of an Authentication context.
        :param str id: The ID of an Authentication context.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> str:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireAuthMethodResult(dict):
    def __init__(__self__, *,
                 auth_method: str):
        """
        :param str auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> str:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireAzureAdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 identity_provider_id: str):
        """
        :param str id: The ID of an Azure group.
        :param str identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireCertificateResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireCommonNameResult(dict):
    def __init__(__self__, *,
                 common_name: str):
        """
        :param str common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireDevicePostureResult(dict):
    def __init__(__self__, *,
                 integration_uid: str):
        """
        :param str integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> str:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireEmailResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireEmailDomainResult(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireEmailListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireEveryoneResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireExternalEvaluationResult(dict):
    def __init__(__self__, *,
                 evaluate_url: str,
                 keys_url: str):
        """
        :param str evaluate_url: The API endpoint containing your business logic.
        :param str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> str:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> str:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireGeoResult(dict):
    def __init__(__self__, *,
                 country_code: str):
        """
        :param str country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireGithubOrganizationResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str,
                 team: str):
        """
        :param str identity_provider_id: The ID of your Github identity provider.
        :param str name: The name of the organization.
        :param str team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def team(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireGsuiteResult(dict):
    def __init__(__self__, *,
                 email: str,
                 identity_provider_id: str):
        """
        :param str email: The email of the Google Workspace group.
        :param str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireIpResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireIpListResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustAccessPolicyRequireLoginMethodResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustAccessPolicyRequireOktaResult(dict):
    def __init__(__self__, *,
                 identity_provider_id: str,
                 name: str):
        """
        :param str identity_provider_id: The ID of your Okta identity provider.
        :param str name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireSamlResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_value: str,
                 identity_provider_id: str):
        """
        :param str attribute_name: The name of the SAML attribute.
        :param str attribute_value: The SAML attribute value to look for.
        :param str identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> str:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class GetZeroTrustAccessPolicyRequireServiceTokenResult(dict):
    def __init__(__self__, *,
                 token_id: str):
        """
        :param str token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> str:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")


@pulumi.output_type
class GetZeroTrustAccessServiceTokenFilterResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str name: The name of the service token.
        :param str search: Search for service tokens by other listed query parameters.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the service token.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Search for service tokens by other listed query parameters.
        """
        return pulumi.get(self, "search")


@pulumi.output_type
class GetZeroTrustAccessServiceTokensResultResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 created_at: str,
                 duration: str,
                 expires_at: str,
                 id: str,
                 last_seen_at: str,
                 name: str,
                 updated_at: str):
        """
        :param str client_id: The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header.
        :param str duration: The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h. The default is 1 year in hours (8760h).
        :param str id: The ID of the service token.
        :param str name: The name of the service token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_seen_at", last_seen_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h. The default is 1 year in hours (8760h).
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the service token.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastSeenAt")
    def last_seen_at(self) -> str:
        return pulumi.get(self, "last_seen_at")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the service token.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustAccessShortLivedCertificatesResultResult(dict):
    def __init__(__self__, *,
                 aud: str,
                 id: str,
                 public_key: str):
        """
        :param str aud: The Application Audience (AUD) tag. Identifies the application associated with the CA.
        :param str id: The ID of the CA.
        :param str public_key: The public key to add to your SSH server configuration.
        """
        pulumi.set(__self__, "aud", aud)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter
    def aud(self) -> str:
        """
        The Application Audience (AUD) tag. Identifies the application associated with the CA.
        """
        return pulumi.get(self, "aud")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the CA.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The public key to add to your SSH server configuration.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetZeroTrustAccessTagsResultResult(dict):
    def __init__(__self__, *,
                 app_count: int,
                 created_at: str,
                 name: str,
                 updated_at: str):
        """
        :param int app_count: The number of applications that have this tag
        :param str name: The name of the tag
        """
        pulumi.set(__self__, "app_count", app_count)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="appCount")
    def app_count(self) -> int:
        """
        The number of applications that have this tag
        """
        return pulumi.get(self, "app_count")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the tag
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfileExcludeResult(dict):
    def __init__(__self__, *,
                 address: str,
                 description: str,
                 host: str):
        """
        :param str address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param str description: A description of the Split Tunnel item, displayed in the client UI.
        :param str host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfileFallbackDomainResult(dict):
    def __init__(__self__, *,
                 description: str,
                 dns_servers: Sequence[str],
                 suffix: str):
        """
        :param str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[str] dns_servers: A list of IP addresses to handle domain resolution.
        :param str suffix: The domain suffix to match when resolving locally.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfileIncludeResult(dict):
    def __init__(__self__, *,
                 address: str,
                 description: str,
                 host: str):
        """
        :param str address: The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        :param str description: A description of the split tunnel item, displayed in the client UI.
        :param str host: The domain name to include in the tunnel. If host is present, address must not be present.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfileServiceModeV2Result(dict):
    def __init__(__self__, *,
                 mode: str,
                 port: float):
        """
        :param str mode: The mode to run the WARP client under.
        :param float port: The port number when used with proxy mode.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfileTargetTestResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: The id of the DEX test targeting this policy
        :param str name: The name of the DEX test targeting this policy
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the DEX test targeting this policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the DEX test targeting this policy
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfilesResultResult(dict):
    def __init__(__self__, *,
                 allow_mode_switch: bool,
                 allow_updates: bool,
                 allowed_to_leave: bool,
                 auto_connect: float,
                 captive_portal: float,
                 default: bool,
                 description: str,
                 disable_auto_fallback: bool,
                 enabled: bool,
                 exclude_office_ips: bool,
                 excludes: Sequence['outputs.GetZeroTrustDeviceCustomProfilesResultExcludeResult'],
                 fallback_domains: Sequence['outputs.GetZeroTrustDeviceCustomProfilesResultFallbackDomainResult'],
                 gateway_unique_id: str,
                 includes: Sequence['outputs.GetZeroTrustDeviceCustomProfilesResultIncludeResult'],
                 lan_allow_minutes: float,
                 lan_allow_subnet_size: float,
                 match: str,
                 name: str,
                 policy_id: str,
                 precedence: float,
                 service_mode_v2: 'outputs.GetZeroTrustDeviceCustomProfilesResultServiceModeV2Result',
                 support_url: str,
                 switch_locked: bool,
                 target_tests: Sequence['outputs.GetZeroTrustDeviceCustomProfilesResultTargetTestResult'],
                 tunnel_protocol: str):
        """
        :param bool allow_mode_switch: Whether to allow the user to switch WARP between modes.
        :param bool allow_updates: Whether to receive update notifications when a new version of the client is available.
        :param bool allowed_to_leave: Whether to allow devices to leave the organization.
        :param float auto_connect: The amount of time in seconds to reconnect after having been disabled.
        :param float captive_portal: Turn on the captive portal after the specified amount of time.
        :param bool default: Whether the policy is the default policy for an account.
        :param str description: A description of the policy.
        :param bool disable_auto_fallback: If the `dns_server` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`.
        :param bool enabled: Whether the policy will be applied to matching devices.
        :param bool exclude_office_ips: Whether to add Microsoft IPs to Split Tunnel exclusions.
        :param float lan_allow_minutes: The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset.
        :param float lan_allow_subnet_size: The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset.
        :param str match: The wirefilter expression to match devices.
        :param str name: The name of the device settings profile.
        :param str policy_id: Device ID.
        :param float precedence: The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field.
        :param str support_url: The URL to launch when the Send Feedback button is clicked.
        :param bool switch_locked: Whether to allow the user to turn off the WARP switch and disconnect the client.
        :param str tunnel_protocol: Determines which tunnel protocol to use.
        """
        pulumi.set(__self__, "allow_mode_switch", allow_mode_switch)
        pulumi.set(__self__, "allow_updates", allow_updates)
        pulumi.set(__self__, "allowed_to_leave", allowed_to_leave)
        pulumi.set(__self__, "auto_connect", auto_connect)
        pulumi.set(__self__, "captive_portal", captive_portal)
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disable_auto_fallback", disable_auto_fallback)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exclude_office_ips", exclude_office_ips)
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "fallback_domains", fallback_domains)
        pulumi.set(__self__, "gateway_unique_id", gateway_unique_id)
        pulumi.set(__self__, "includes", includes)
        pulumi.set(__self__, "lan_allow_minutes", lan_allow_minutes)
        pulumi.set(__self__, "lan_allow_subnet_size", lan_allow_subnet_size)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "precedence", precedence)
        pulumi.set(__self__, "service_mode_v2", service_mode_v2)
        pulumi.set(__self__, "support_url", support_url)
        pulumi.set(__self__, "switch_locked", switch_locked)
        pulumi.set(__self__, "target_tests", target_tests)
        pulumi.set(__self__, "tunnel_protocol", tunnel_protocol)

    @property
    @pulumi.getter(name="allowModeSwitch")
    def allow_mode_switch(self) -> bool:
        """
        Whether to allow the user to switch WARP between modes.
        """
        return pulumi.get(self, "allow_mode_switch")

    @property
    @pulumi.getter(name="allowUpdates")
    def allow_updates(self) -> bool:
        """
        Whether to receive update notifications when a new version of the client is available.
        """
        return pulumi.get(self, "allow_updates")

    @property
    @pulumi.getter(name="allowedToLeave")
    def allowed_to_leave(self) -> bool:
        """
        Whether to allow devices to leave the organization.
        """
        return pulumi.get(self, "allowed_to_leave")

    @property
    @pulumi.getter(name="autoConnect")
    def auto_connect(self) -> float:
        """
        The amount of time in seconds to reconnect after having been disabled.
        """
        return pulumi.get(self, "auto_connect")

    @property
    @pulumi.getter(name="captivePortal")
    def captive_portal(self) -> float:
        """
        Turn on the captive portal after the specified amount of time.
        """
        return pulumi.get(self, "captive_portal")

    @property
    @pulumi.getter
    def default(self) -> bool:
        """
        Whether the policy is the default policy for an account.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the policy.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableAutoFallback")
    def disable_auto_fallback(self) -> bool:
        """
        If the `dns_server` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`.
        """
        return pulumi.get(self, "disable_auto_fallback")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the policy will be applied to matching devices.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="excludeOfficeIps")
    def exclude_office_ips(self) -> bool:
        """
        Whether to add Microsoft IPs to Split Tunnel exclusions.
        """
        return pulumi.get(self, "exclude_office_ips")

    @property
    @pulumi.getter
    def excludes(self) -> Sequence['outputs.GetZeroTrustDeviceCustomProfilesResultExcludeResult']:
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter(name="fallbackDomains")
    def fallback_domains(self) -> Sequence['outputs.GetZeroTrustDeviceCustomProfilesResultFallbackDomainResult']:
        return pulumi.get(self, "fallback_domains")

    @property
    @pulumi.getter(name="gatewayUniqueId")
    def gateway_unique_id(self) -> str:
        return pulumi.get(self, "gateway_unique_id")

    @property
    @pulumi.getter
    def includes(self) -> Sequence['outputs.GetZeroTrustDeviceCustomProfilesResultIncludeResult']:
        return pulumi.get(self, "includes")

    @property
    @pulumi.getter(name="lanAllowMinutes")
    def lan_allow_minutes(self) -> float:
        """
        The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset.
        """
        return pulumi.get(self, "lan_allow_minutes")

    @property
    @pulumi.getter(name="lanAllowSubnetSize")
    def lan_allow_subnet_size(self) -> float:
        """
        The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset.
        """
        return pulumi.get(self, "lan_allow_subnet_size")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        The wirefilter expression to match devices.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the device settings profile.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        Device ID.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter
    def precedence(self) -> float:
        """
        The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field.
        """
        return pulumi.get(self, "precedence")

    @property
    @pulumi.getter(name="serviceModeV2")
    def service_mode_v2(self) -> 'outputs.GetZeroTrustDeviceCustomProfilesResultServiceModeV2Result':
        return pulumi.get(self, "service_mode_v2")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> str:
        """
        The URL to launch when the Send Feedback button is clicked.
        """
        return pulumi.get(self, "support_url")

    @property
    @pulumi.getter(name="switchLocked")
    def switch_locked(self) -> bool:
        """
        Whether to allow the user to turn off the WARP switch and disconnect the client.
        """
        return pulumi.get(self, "switch_locked")

    @property
    @pulumi.getter(name="targetTests")
    def target_tests(self) -> Sequence['outputs.GetZeroTrustDeviceCustomProfilesResultTargetTestResult']:
        return pulumi.get(self, "target_tests")

    @property
    @pulumi.getter(name="tunnelProtocol")
    def tunnel_protocol(self) -> str:
        """
        Determines which tunnel protocol to use.
        """
        return pulumi.get(self, "tunnel_protocol")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfilesResultExcludeResult(dict):
    def __init__(__self__, *,
                 address: str,
                 description: str,
                 host: str):
        """
        :param str address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param str description: A description of the Split Tunnel item, displayed in the client UI.
        :param str host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfilesResultFallbackDomainResult(dict):
    def __init__(__self__, *,
                 description: str,
                 dns_servers: Sequence[str],
                 suffix: str):
        """
        :param str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[str] dns_servers: A list of IP addresses to handle domain resolution.
        :param str suffix: The domain suffix to match when resolving locally.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfilesResultIncludeResult(dict):
    def __init__(__self__, *,
                 address: str,
                 description: str,
                 host: str):
        """
        :param str address: The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        :param str description: A description of the split tunnel item, displayed in the client UI.
        :param str host: The domain name to include in the tunnel. If host is present, address must not be present.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfilesResultServiceModeV2Result(dict):
    def __init__(__self__, *,
                 mode: str,
                 port: float):
        """
        :param str mode: The mode to run the WARP client under.
        :param float port: The port number when used with proxy mode.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetZeroTrustDeviceCustomProfilesResultTargetTestResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: The id of the DEX test targeting this policy
        :param str name: The name of the DEX test targeting this policy
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the DEX test targeting this policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the DEX test targeting this policy
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustDeviceDefaultProfileExcludeResult(dict):
    def __init__(__self__, *,
                 address: str,
                 description: str,
                 host: str):
        """
        :param str address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param str description: A description of the Split Tunnel item, displayed in the client UI.
        :param str host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class GetZeroTrustDeviceDefaultProfileFallbackDomainResult(dict):
    def __init__(__self__, *,
                 description: str,
                 dns_servers: Sequence[str],
                 suffix: str):
        """
        :param str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[str] dns_servers: A list of IP addresses to handle domain resolution.
        :param str suffix: The domain suffix to match when resolving locally.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetZeroTrustDeviceDefaultProfileIncludeResult(dict):
    def __init__(__self__, *,
                 address: str,
                 description: str,
                 host: str):
        """
        :param str address: The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        :param str description: A description of the split tunnel item, displayed in the client UI.
        :param str host: The domain name to include in the tunnel. If host is present, address must not be present.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class GetZeroTrustDeviceDefaultProfileServiceModeV2Result(dict):
    def __init__(__self__, *,
                 mode: str,
                 port: float):
        """
        :param str mode: The mode to run the WARP client under.
        :param float port: The port number when used with proxy mode.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetZeroTrustDeviceManagedNetworksConfigResult(dict):
    def __init__(__self__, *,
                 sha256: str,
                 tls_sockaddr: str):
        """
        :param str sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        :param str tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)

    @property
    @pulumi.getter
    def sha256(self) -> str:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> str:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")


@pulumi.output_type
class GetZeroTrustDeviceManagedNetworksListResultResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetZeroTrustDeviceManagedNetworksListResultConfigResult',
                 name: str,
                 network_id: str,
                 type: str):
        """
        :param 'GetZeroTrustDeviceManagedNetworksListResultConfigArgs' config: The configuration object containing information for the WARP client to detect the managed network.
        :param str name: The name of the device managed network. This name must be unique.
        :param str network_id: API UUID.
        :param str type: The type of device managed network.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.GetZeroTrustDeviceManagedNetworksListResultConfigResult':
        """
        The configuration object containing information for the WARP client to detect the managed network.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the device managed network. This name must be unique.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        API UUID.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of device managed network.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetZeroTrustDeviceManagedNetworksListResultConfigResult(dict):
    def __init__(__self__, *,
                 sha256: str,
                 tls_sockaddr: str):
        """
        :param str sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        :param str tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)

    @property
    @pulumi.getter
    def sha256(self) -> str:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> str:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")


@pulumi.output_type
class GetZeroTrustDevicePostureIntegrationConfigResult(dict):
    def __init__(__self__, *,
                 api_url: str,
                 auth_url: str,
                 client_id: str):
        """
        :param str api_url: The Workspace One API URL provided in the Workspace One Admin Dashboard.
        :param str auth_url: The Workspace One Authorization URL depending on your region.
        :param str client_id: The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> str:
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        The Workspace One Authorization URL depending on your region.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetZeroTrustDevicePostureIntegrationsResultResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetZeroTrustDevicePostureIntegrationsResultConfigResult',
                 id: str,
                 interval: str,
                 name: str,
                 type: str):
        """
<<<<<<< HEAD
        :param 'GetZeroTrustDevicePostureIntegrationsResultConfigArgs' config: The Workspace One Config Response.
=======
        :param 'GetZeroTrustDevicePostureIntegrationsResultConfigArgs' config: The configuration object containing third-party integration information.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        :param str id: API UUID.
        :param str interval: The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`).
        :param str name: The name of the device posture integration.
        :param str type: The type of device posture integration.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.GetZeroTrustDevicePostureIntegrationsResultConfigResult':
        """
<<<<<<< HEAD
        The Workspace One Config Response.
=======
        The configuration object containing third-party integration information.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        API UUID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the device posture integration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of device posture integration.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetZeroTrustDevicePostureIntegrationsResultConfigResult(dict):
    def __init__(__self__, *,
                 api_url: str,
                 auth_url: str,
                 client_id: str):
        """
        :param str api_url: The Workspace One API URL provided in the Workspace One Admin Dashboard.
        :param str auth_url: The Workspace One Authorization URL depending on your region.
        :param str client_id: The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> str:
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        The Workspace One Authorization URL depending on your region.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetZeroTrustDevicePostureRuleInputResult(dict):
    def __init__(__self__, *,
                 active_threats: float,
                 certificate_id: str,
                 check_disks: Sequence[str],
                 check_private_key: bool,
                 cn: str,
                 compliance_status: str,
                 connection_id: str,
                 count_operator: str,
                 domain: str,
                 eid_last_seen: str,
                 enabled: bool,
                 exists: bool,
                 extended_key_usages: Sequence[str],
                 id: str,
                 infected: bool,
                 is_active: bool,
                 issue_count: str,
                 last_seen: str,
                 locations: 'outputs.GetZeroTrustDevicePostureRuleInputLocationsResult',
                 network_status: str,
                 operating_system: str,
                 operational_state: str,
                 operator: str,
                 os: str,
                 os_distro_name: str,
                 os_distro_revision: str,
                 os_version_extra: str,
                 overall: str,
                 path: str,
                 require_all: bool,
                 risk_level: str,
                 score: float,
                 score_operator: str,
                 sensor_config: str,
                 sha256: str,
                 state: str,
                 thumbprint: str,
                 total_score: float,
                 version: str,
                 version_operator: str):
        """
        :param float active_threats: The Number of active threats.
        :param str certificate_id: UUID of Cloudflare managed certificate.
        :param Sequence[str] check_disks: List of volume names to be checked for encryption.
        :param bool check_private_key: Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        :param str cn: Common Name that is protected by the certificate
        :param str compliance_status: Compliance Status
        :param str connection_id: Posture Integration ID.
        :param str count_operator: Count Operator
        :param str domain: Domain
        :param str eid_last_seen: For more details on eid last seen, refer to the Tanium documentation.
        :param bool enabled: Enabled
        :param bool exists: Whether or not file exists
        :param Sequence[str] extended_key_usages: List of values indicating purposes for which the certificate public key can be used
        :param str id: List ID.
        :param bool infected: Whether device is infected.
        :param bool is_active: Whether device is active.
        :param str issue_count: The Number of Issues.
        :param str last_seen: For more details on last seen, please refer to the Crowdstrike documentation.
        :param str network_status: Network status of device.
        :param str operating_system: Operating system
        :param str operational_state: Agent operational state.
        :param str operator: operator
        :param str os: Os Version
        :param str os_distro_name: Operating System Distribution Name (linux only)
        :param str os_distro_revision: Version of OS Distribution (linux only)
        :param str os_version_extra: Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        :param str overall: overall
        :param str path: File path.
        :param bool require_all: Whether to check all disks for encryption.
        :param str risk_level: For more details on risk level, refer to the Tanium documentation.
        :param float score: A value between 0-100 assigned to devices set by the 3rd party posture provider.
        :param str score_operator: Score Operator
        :param str sensor_config: SensorConfig
        :param str sha256: SHA-256.
        :param str state: For more details on state, please refer to the Crowdstrike documentation.
        :param str thumbprint: Signing certificate thumbprint.
        :param float total_score: For more details on total score, refer to the Tanium documentation.
        :param str version: Version of OS
        :param str version_operator: Version Operator
        """
        pulumi.set(__self__, "active_threats", active_threats)
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "check_disks", check_disks)
        pulumi.set(__self__, "check_private_key", check_private_key)
        pulumi.set(__self__, "cn", cn)
        pulumi.set(__self__, "compliance_status", compliance_status)
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "count_operator", count_operator)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exists", exists)
        pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "infected", infected)
        pulumi.set(__self__, "is_active", is_active)
        pulumi.set(__self__, "issue_count", issue_count)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "locations", locations)
        pulumi.set(__self__, "network_status", network_status)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "operational_state", operational_state)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "os_distro_name", os_distro_name)
        pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        pulumi.set(__self__, "os_version_extra", os_version_extra)
        pulumi.set(__self__, "overall", overall)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "require_all", require_all)
        pulumi.set(__self__, "risk_level", risk_level)
        pulumi.set(__self__, "score", score)
        pulumi.set(__self__, "score_operator", score_operator)
        pulumi.set(__self__, "sensor_config", sensor_config)
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "thumbprint", thumbprint)
        pulumi.set(__self__, "total_score", total_score)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> float:
        """
        The Number of active threats.
        """
        return pulumi.get(self, "active_threats")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> str:
        """
        UUID of Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Sequence[str]:
        """
        List of volume names to be checked for encryption.
        """
        return pulumi.get(self, "check_disks")

    @property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> bool:
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        return pulumi.get(self, "check_private_key")

    @property
    @pulumi.getter
    def cn(self) -> str:
        """
        Common Name that is protected by the certificate
        """
        return pulumi.get(self, "cn")

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> str:
        """
        Compliance Status
        """
        return pulumi.get(self, "compliance_status")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> str:
        """
        Posture Integration ID.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> str:
        """
        Count Operator
        """
        return pulumi.get(self, "count_operator")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> str:
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        return pulumi.get(self, "eid_last_seen")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exists(self) -> bool:
        """
        Whether or not file exists
        """
        return pulumi.get(self, "exists")

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Sequence[str]:
        """
        List of values indicating purposes for which the certificate public key can be used
        """
        return pulumi.get(self, "extended_key_usages")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        List ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def infected(self) -> bool:
        """
        Whether device is infected.
        """
        return pulumi.get(self, "infected")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> bool:
        """
        Whether device is active.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> str:
        """
        The Number of Issues.
        """
        return pulumi.get(self, "issue_count")

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> str:
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "last_seen")

    @property
    @pulumi.getter
    def locations(self) -> 'outputs.GetZeroTrustDevicePostureRuleInputLocationsResult':
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> str:
        """
        Network status of device.
        """
        return pulumi.get(self, "network_status")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        """
        Operating system
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> str:
        """
        Agent operational state.
        """
        return pulumi.get(self, "operational_state")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def os(self) -> str:
        """
        Os Version
        """
        return pulumi.get(self, "os")

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> str:
        """
        Operating System Distribution Name (linux only)
        """
        return pulumi.get(self, "os_distro_name")

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> str:
        """
        Version of OS Distribution (linux only)
        """
        return pulumi.get(self, "os_distro_revision")

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> str:
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        """
        return pulumi.get(self, "os_version_extra")

    @property
    @pulumi.getter
    def overall(self) -> str:
        """
        overall
        """
        return pulumi.get(self, "overall")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        File path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> bool:
        """
        Whether to check all disks for encryption.
        """
        return pulumi.get(self, "require_all")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        For more details on risk level, refer to the Tanium documentation.
        """
        return pulumi.get(self, "risk_level")

    @property
    @pulumi.getter
    def score(self) -> float:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter(name="scoreOperator")
    def score_operator(self) -> str:
        """
        Score Operator
        """
        return pulumi.get(self, "score_operator")

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> str:
        """
        SensorConfig
        """
        return pulumi.get(self, "sensor_config")

    @property
    @pulumi.getter
    def sha256(self) -> str:
        """
        SHA-256.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        For more details on state, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        Signing certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> float:
        """
        For more details on total score, refer to the Tanium documentation.
        """
        return pulumi.get(self, "total_score")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of OS
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> str:
        """
        Version Operator
        """
        return pulumi.get(self, "version_operator")


@pulumi.output_type
class GetZeroTrustDevicePostureRuleInputLocationsResult(dict):
    def __init__(__self__, *,
                 paths: Sequence[str],
                 trust_stores: Sequence[str]):
        """
        :param Sequence[str] paths: List of paths to check for client certificate on linux.
        :param Sequence[str] trust_stores: List of trust stores to check for client certificate.
        """
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "trust_stores", trust_stores)

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        List of paths to check for client certificate on linux.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Sequence[str]:
        """
        List of trust stores to check for client certificate.
        """
        return pulumi.get(self, "trust_stores")


@pulumi.output_type
class GetZeroTrustDevicePostureRuleMatchResult(dict):
    def __init__(__self__, *,
                 platform: str):
        pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> str:
        return pulumi.get(self, "platform")


@pulumi.output_type
class GetZeroTrustDevicePostureRulesResultResult(dict):
    def __init__(__self__, *,
                 description: str,
                 expiration: str,
                 id: str,
                 input: 'outputs.GetZeroTrustDevicePostureRulesResultInputResult',
                 matches: Sequence['outputs.GetZeroTrustDevicePostureRulesResultMatchResult'],
                 name: str,
                 schedule: str,
                 type: str):
        """
        :param str description: The description of the device posture rule.
        :param str expiration: Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client.
        :param str id: API UUID.
        :param 'GetZeroTrustDevicePostureRulesResultInputArgs' input: The value to be checked against.
        :param Sequence['GetZeroTrustDevicePostureRulesResultMatchArgs'] matches: The conditions that the client must match to run the rule.
        :param str name: The name of the device posture rule.
        :param str schedule: Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`.
        :param str type: The type of device posture rule.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "matches", matches)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the device posture rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expiration(self) -> str:
        """
        Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        API UUID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def input(self) -> 'outputs.GetZeroTrustDevicePostureRulesResultInputResult':
        """
        The value to be checked against.
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetZeroTrustDevicePostureRulesResultMatchResult']:
        """
        The conditions that the client must match to run the rule.
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the device posture rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of device posture rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetZeroTrustDevicePostureRulesResultInputResult(dict):
    def __init__(__self__, *,
                 active_threats: float,
                 certificate_id: str,
                 check_disks: Sequence[str],
                 check_private_key: bool,
                 cn: str,
                 compliance_status: str,
                 connection_id: str,
                 count_operator: str,
                 domain: str,
                 eid_last_seen: str,
                 enabled: bool,
                 exists: bool,
                 extended_key_usages: Sequence[str],
                 id: str,
                 infected: bool,
                 is_active: bool,
                 issue_count: str,
                 last_seen: str,
                 locations: 'outputs.GetZeroTrustDevicePostureRulesResultInputLocationsResult',
                 network_status: str,
                 operating_system: str,
                 operational_state: str,
                 operator: str,
                 os: str,
                 os_distro_name: str,
                 os_distro_revision: str,
                 os_version_extra: str,
                 overall: str,
                 path: str,
                 require_all: bool,
                 risk_level: str,
                 score: float,
                 score_operator: str,
                 sensor_config: str,
                 sha256: str,
                 state: str,
                 thumbprint: str,
                 total_score: float,
                 version: str,
                 version_operator: str):
        """
        :param float active_threats: The Number of active threats.
        :param str certificate_id: UUID of Cloudflare managed certificate.
        :param Sequence[str] check_disks: List of volume names to be checked for encryption.
        :param bool check_private_key: Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        :param str cn: Common Name that is protected by the certificate
        :param str compliance_status: Compliance Status
        :param str connection_id: Posture Integration ID.
        :param str count_operator: Count Operator
        :param str domain: Domain
        :param str eid_last_seen: For more details on eid last seen, refer to the Tanium documentation.
        :param bool enabled: Enabled
        :param bool exists: Whether or not file exists
        :param Sequence[str] extended_key_usages: List of values indicating purposes for which the certificate public key can be used
        :param str id: List ID.
        :param bool infected: Whether device is infected.
        :param bool is_active: Whether device is active.
        :param str issue_count: The Number of Issues.
        :param str last_seen: For more details on last seen, please refer to the Crowdstrike documentation.
        :param str network_status: Network status of device.
        :param str operating_system: Operating system
        :param str operational_state: Agent operational state.
        :param str operator: operator
        :param str os: Os Version
        :param str os_distro_name: Operating System Distribution Name (linux only)
        :param str os_distro_revision: Version of OS Distribution (linux only)
        :param str os_version_extra: Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        :param str overall: overall
        :param str path: File path.
        :param bool require_all: Whether to check all disks for encryption.
        :param str risk_level: For more details on risk level, refer to the Tanium documentation.
        :param float score: A value between 0-100 assigned to devices set by the 3rd party posture provider.
        :param str score_operator: Score Operator
        :param str sensor_config: SensorConfig
        :param str sha256: SHA-256.
        :param str state: For more details on state, please refer to the Crowdstrike documentation.
        :param str thumbprint: Signing certificate thumbprint.
        :param float total_score: For more details on total score, refer to the Tanium documentation.
        :param str version: Version of OS
        :param str version_operator: Version Operator
        """
        pulumi.set(__self__, "active_threats", active_threats)
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "check_disks", check_disks)
        pulumi.set(__self__, "check_private_key", check_private_key)
        pulumi.set(__self__, "cn", cn)
        pulumi.set(__self__, "compliance_status", compliance_status)
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "count_operator", count_operator)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exists", exists)
        pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "infected", infected)
        pulumi.set(__self__, "is_active", is_active)
        pulumi.set(__self__, "issue_count", issue_count)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "locations", locations)
        pulumi.set(__self__, "network_status", network_status)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "operational_state", operational_state)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "os_distro_name", os_distro_name)
        pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        pulumi.set(__self__, "os_version_extra", os_version_extra)
        pulumi.set(__self__, "overall", overall)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "require_all", require_all)
        pulumi.set(__self__, "risk_level", risk_level)
        pulumi.set(__self__, "score", score)
        pulumi.set(__self__, "score_operator", score_operator)
        pulumi.set(__self__, "sensor_config", sensor_config)
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "thumbprint", thumbprint)
        pulumi.set(__self__, "total_score", total_score)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> float:
        """
        The Number of active threats.
        """
        return pulumi.get(self, "active_threats")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> str:
        """
        UUID of Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Sequence[str]:
        """
        List of volume names to be checked for encryption.
        """
        return pulumi.get(self, "check_disks")

    @property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> bool:
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        return pulumi.get(self, "check_private_key")

    @property
    @pulumi.getter
    def cn(self) -> str:
        """
        Common Name that is protected by the certificate
        """
        return pulumi.get(self, "cn")

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> str:
        """
        Compliance Status
        """
        return pulumi.get(self, "compliance_status")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> str:
        """
        Posture Integration ID.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> str:
        """
        Count Operator
        """
        return pulumi.get(self, "count_operator")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> str:
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        return pulumi.get(self, "eid_last_seen")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exists(self) -> bool:
        """
        Whether or not file exists
        """
        return pulumi.get(self, "exists")

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Sequence[str]:
        """
        List of values indicating purposes for which the certificate public key can be used
        """
        return pulumi.get(self, "extended_key_usages")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        List ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def infected(self) -> bool:
        """
        Whether device is infected.
        """
        return pulumi.get(self, "infected")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> bool:
        """
        Whether device is active.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> str:
        """
        The Number of Issues.
        """
        return pulumi.get(self, "issue_count")

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> str:
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "last_seen")

    @property
    @pulumi.getter
    def locations(self) -> 'outputs.GetZeroTrustDevicePostureRulesResultInputLocationsResult':
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> str:
        """
        Network status of device.
        """
        return pulumi.get(self, "network_status")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        """
        Operating system
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> str:
        """
        Agent operational state.
        """
        return pulumi.get(self, "operational_state")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def os(self) -> str:
        """
        Os Version
        """
        return pulumi.get(self, "os")

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> str:
        """
        Operating System Distribution Name (linux only)
        """
        return pulumi.get(self, "os_distro_name")

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> str:
        """
        Version of OS Distribution (linux only)
        """
        return pulumi.get(self, "os_distro_revision")

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> str:
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        """
        return pulumi.get(self, "os_version_extra")

    @property
    @pulumi.getter
    def overall(self) -> str:
        """
        overall
        """
        return pulumi.get(self, "overall")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        File path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> bool:
        """
        Whether to check all disks for encryption.
        """
        return pulumi.get(self, "require_all")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        For more details on risk level, refer to the Tanium documentation.
        """
        return pulumi.get(self, "risk_level")

    @property
    @pulumi.getter
    def score(self) -> float:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter(name="scoreOperator")
    def score_operator(self) -> str:
        """
        Score Operator
        """
        return pulumi.get(self, "score_operator")

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> str:
        """
        SensorConfig
        """
        return pulumi.get(self, "sensor_config")

    @property
    @pulumi.getter
    def sha256(self) -> str:
        """
        SHA-256.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        For more details on state, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        Signing certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> float:
        """
        For more details on total score, refer to the Tanium documentation.
        """
        return pulumi.get(self, "total_score")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of OS
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> str:
        """
        Version Operator
        """
        return pulumi.get(self, "version_operator")


@pulumi.output_type
class GetZeroTrustDevicePostureRulesResultInputLocationsResult(dict):
    def __init__(__self__, *,
                 paths: Sequence[str],
                 trust_stores: Sequence[str]):
        """
        :param Sequence[str] paths: List of paths to check for client certificate on linux.
        :param Sequence[str] trust_stores: List of trust stores to check for client certificate.
        """
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "trust_stores", trust_stores)

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        List of paths to check for client certificate on linux.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Sequence[str]:
        """
        List of trust stores to check for client certificate.
        """
        return pulumi.get(self, "trust_stores")


@pulumi.output_type
class GetZeroTrustDevicePostureRulesResultMatchResult(dict):
    def __init__(__self__, *,
                 platform: str):
        pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> str:
        return pulumi.get(self, "platform")


@pulumi.output_type
class GetZeroTrustDexTestDataResult(dict):
    def __init__(__self__, *,
                 host: str,
                 kind: str,
                 method: str):
        """
        :param str host: The desired endpoint to test.
        :param str kind: The type of test.
        :param str method: The HTTP request method type.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The desired endpoint to test.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type of test.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP request method type.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class GetZeroTrustDexTestTargetPolicyResult(dict):
    def __init__(__self__, *,
                 default: bool,
                 id: str,
                 name: str):
        """
        :param bool default: Whether the profile is the account default
        :param str id: The id of the device settings profile
        :param str name: The name of the device settings profile
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> bool:
        """
        Whether the profile is the account default
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the device settings profile
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the device settings profile
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustDexTestsResultResult(dict):
    def __init__(__self__, *,
                 data: 'outputs.GetZeroTrustDexTestsResultDataResult',
                 description: str,
                 enabled: bool,
                 interval: str,
                 name: str,
                 target_policies: Sequence['outputs.GetZeroTrustDexTestsResultTargetPolicyResult'],
                 targeted: bool,
                 test_id: str):
        """
        :param 'GetZeroTrustDexTestsResultDataArgs' data: The configuration object which contains the details for the WARP client to conduct the test.
        :param str description: Additional details about the test.
        :param bool enabled: Determines whether or not the test is active.
        :param str interval: How often the test will run.
        :param str name: The name of the DEX test. Must be unique.
        :param Sequence['GetZeroTrustDexTestsResultTargetPolicyArgs'] target_policies: Device settings profiles targeted by this test
        :param str test_id: The unique identifier for the test.
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_policies", target_policies)
        pulumi.set(__self__, "targeted", targeted)
        pulumi.set(__self__, "test_id", test_id)

    @property
    @pulumi.getter
    def data(self) -> 'outputs.GetZeroTrustDexTestsResultDataResult':
        """
        The configuration object which contains the details for the WARP client to conduct the test.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Additional details about the test.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Determines whether or not the test is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        How often the test will run.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the DEX test. Must be unique.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetPolicies")
    def target_policies(self) -> Sequence['outputs.GetZeroTrustDexTestsResultTargetPolicyResult']:
        """
        Device settings profiles targeted by this test
        """
        return pulumi.get(self, "target_policies")

    @property
    @pulumi.getter
    def targeted(self) -> bool:
        return pulumi.get(self, "targeted")

    @property
    @pulumi.getter(name="testId")
    def test_id(self) -> str:
        """
        The unique identifier for the test.
        """
        return pulumi.get(self, "test_id")


@pulumi.output_type
class GetZeroTrustDexTestsResultDataResult(dict):
    def __init__(__self__, *,
                 host: str,
                 kind: str,
                 method: str):
        """
        :param str host: The desired endpoint to test.
        :param str kind: The type of test.
        :param str method: The HTTP request method type.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The desired endpoint to test.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type of test.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP request method type.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class GetZeroTrustDexTestsResultTargetPolicyResult(dict):
    def __init__(__self__, *,
                 default: bool,
                 id: str,
                 name: str):
        """
        :param bool default: Whether the profile is the account default
        :param str id: The id of the device settings profile
        :param str name: The name of the device settings profile
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> bool:
        """
        Whether the profile is the account default
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the device settings profile
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the device settings profile
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustDlpCustomProfileContextAwarenessResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 skip: 'outputs.GetZeroTrustDlpCustomProfileContextAwarenessSkipResult'):
        """
        :param bool enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param 'GetZeroTrustDlpCustomProfileContextAwarenessSkipArgs' skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def skip(self) -> 'outputs.GetZeroTrustDlpCustomProfileContextAwarenessSkipResult':
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")


@pulumi.output_type
class GetZeroTrustDlpCustomProfileContextAwarenessSkipResult(dict):
    def __init__(__self__, *,
                 files: bool):
        """
        :param bool files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> bool:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class GetZeroTrustDlpCustomProfileEntryResult(dict):
    def __init__(__self__, *,
                 confidence: 'outputs.GetZeroTrustDlpCustomProfileEntryConfidenceResult',
                 created_at: str,
                 enabled: bool,
                 id: str,
                 name: str,
                 pattern: 'outputs.GetZeroTrustDlpCustomProfileEntryPatternResult',
                 profile_id: str,
                 secret: bool,
                 type: str,
                 updated_at: str,
                 word_list: str):
        pulumi.set(__self__, "confidence", confidence)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "profile_id", profile_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter
    def confidence(self) -> 'outputs.GetZeroTrustDlpCustomProfileEntryConfidenceResult':
        return pulumi.get(self, "confidence")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pattern(self) -> 'outputs.GetZeroTrustDlpCustomProfileEntryPatternResult':
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> str:
        return pulumi.get(self, "profile_id")

    @property
    @pulumi.getter
    def secret(self) -> bool:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> str:
        return pulumi.get(self, "word_list")


@pulumi.output_type
class GetZeroTrustDlpCustomProfileEntryConfidenceResult(dict):
    def __init__(__self__, *,
<<<<<<< HEAD
=======
                 ai_context_available: bool,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 available: bool):
        """
        :param bool available: Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
               Profiles that use an entry with `available` set to true can use confidence thresholds
        """
<<<<<<< HEAD
        pulumi.set(__self__, "available", available)

    @property
=======
        pulumi.set(__self__, "ai_context_available", ai_context_available)
        pulumi.set(__self__, "available", available)

    @property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> bool:
        return pulumi.get(self, "ai_context_available")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def available(self) -> bool:
        """
        Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
        Profiles that use an entry with `available` set to true can use confidence thresholds
        """
        return pulumi.get(self, "available")


@pulumi.output_type
class GetZeroTrustDlpCustomProfileEntryPatternResult(dict):
    def __init__(__self__, *,
                 regex: str,
                 validation: str):
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> str:
        return pulumi.get(self, "validation")


@pulumi.output_type
class GetZeroTrustDlpDatasetColumnResult(dict):
    def __init__(__self__, *,
                 entry_id: str,
                 header_name: str,
                 num_cells: int,
                 upload_status: str):
        pulumi.set(__self__, "entry_id", entry_id)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "num_cells", num_cells)
        pulumi.set(__self__, "upload_status", upload_status)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> str:
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> int:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter(name="uploadStatus")
    def upload_status(self) -> str:
        return pulumi.get(self, "upload_status")


@pulumi.output_type
class GetZeroTrustDlpDatasetUploadResult(dict):
    def __init__(__self__, *,
                 num_cells: int,
                 status: str,
                 version: int):
        pulumi.set(__self__, "num_cells", num_cells)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> int:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> int:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetZeroTrustDlpDatasetsResultResult(dict):
    def __init__(__self__, *,
                 columns: Sequence['outputs.GetZeroTrustDlpDatasetsResultColumnResult'],
                 created_at: str,
                 description: str,
                 encoding_version: int,
                 id: str,
                 name: str,
                 num_cells: int,
                 secret: bool,
                 status: str,
                 updated_at: str,
                 uploads: Sequence['outputs.GetZeroTrustDlpDatasetsResultUploadResult']):
        """
        :param str description: The description of the dataset
        :param str updated_at: When the dataset was last updated.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "encoding_version", encoding_version)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "num_cells", num_cells)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uploads", uploads)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.GetZeroTrustDlpDatasetsResultColumnResult']:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the dataset
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encodingVersion")
    def encoding_version(self) -> int:
        return pulumi.get(self, "encoding_version")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> int:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter
    def secret(self) -> bool:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        When the dataset was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def uploads(self) -> Sequence['outputs.GetZeroTrustDlpDatasetsResultUploadResult']:
        return pulumi.get(self, "uploads")


@pulumi.output_type
class GetZeroTrustDlpDatasetsResultColumnResult(dict):
    def __init__(__self__, *,
                 entry_id: str,
                 header_name: str,
                 num_cells: int,
                 upload_status: str):
        pulumi.set(__self__, "entry_id", entry_id)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "num_cells", num_cells)
        pulumi.set(__self__, "upload_status", upload_status)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> str:
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> int:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter(name="uploadStatus")
    def upload_status(self) -> str:
        return pulumi.get(self, "upload_status")


@pulumi.output_type
class GetZeroTrustDlpDatasetsResultUploadResult(dict):
    def __init__(__self__, *,
                 num_cells: int,
                 status: str,
                 version: int):
        pulumi.set(__self__, "num_cells", num_cells)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> int:
        return pulumi.get(self, "num_cells")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> int:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetZeroTrustDlpEntriesResultResult(dict):
    def __init__(__self__, *,
                 confidence: 'outputs.GetZeroTrustDlpEntriesResultConfidenceResult',
                 created_at: str,
                 enabled: bool,
                 id: str,
                 name: str,
                 pattern: 'outputs.GetZeroTrustDlpEntriesResultPatternResult',
                 profile_id: str,
                 secret: bool,
                 type: str,
                 updated_at: str,
                 word_list: str):
        pulumi.set(__self__, "confidence", confidence)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "profile_id", profile_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter
    def confidence(self) -> 'outputs.GetZeroTrustDlpEntriesResultConfidenceResult':
        return pulumi.get(self, "confidence")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pattern(self) -> 'outputs.GetZeroTrustDlpEntriesResultPatternResult':
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> str:
        return pulumi.get(self, "profile_id")

    @property
    @pulumi.getter
    def secret(self) -> bool:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> str:
        return pulumi.get(self, "word_list")


@pulumi.output_type
class GetZeroTrustDlpEntriesResultConfidenceResult(dict):
    def __init__(__self__, *,
<<<<<<< HEAD
=======
                 ai_context_available: bool,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 available: bool):
        """
        :param bool available: Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
               Profiles that use an entry with `available` set to true can use confidence thresholds
        """
<<<<<<< HEAD
        pulumi.set(__self__, "available", available)

    @property
=======
        pulumi.set(__self__, "ai_context_available", ai_context_available)
        pulumi.set(__self__, "available", available)

    @property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> bool:
        return pulumi.get(self, "ai_context_available")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def available(self) -> bool:
        """
        Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
        Profiles that use an entry with `available` set to true can use confidence thresholds
        """
        return pulumi.get(self, "available")


@pulumi.output_type
class GetZeroTrustDlpEntriesResultPatternResult(dict):
    def __init__(__self__, *,
                 regex: str,
                 validation: str):
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> str:
        return pulumi.get(self, "validation")


@pulumi.output_type
class GetZeroTrustDlpEntryConfidenceResult(dict):
    def __init__(__self__, *,
<<<<<<< HEAD
=======
                 ai_context_available: bool,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 available: bool):
        """
        :param bool available: Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
               Profiles that use an entry with `available` set to true can use confidence thresholds
        """
<<<<<<< HEAD
        pulumi.set(__self__, "available", available)

    @property
=======
        pulumi.set(__self__, "ai_context_available", ai_context_available)
        pulumi.set(__self__, "available", available)

    @property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> bool:
        return pulumi.get(self, "ai_context_available")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def available(self) -> bool:
        """
        Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
        Profiles that use an entry with `available` set to true can use confidence thresholds
        """
        return pulumi.get(self, "available")


@pulumi.output_type
class GetZeroTrustDlpEntryPatternResult(dict):
    def __init__(__self__, *,
                 regex: str,
                 validation: str):
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> str:
        return pulumi.get(self, "validation")


@pulumi.output_type
class GetZeroTrustDlpPredefinedProfileContextAwarenessResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 skip: 'outputs.GetZeroTrustDlpPredefinedProfileContextAwarenessSkipResult'):
        """
        :param bool enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param 'GetZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs' skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def skip(self) -> 'outputs.GetZeroTrustDlpPredefinedProfileContextAwarenessSkipResult':
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")


@pulumi.output_type
class GetZeroTrustDlpPredefinedProfileContextAwarenessSkipResult(dict):
    def __init__(__self__, *,
                 files: bool):
        """
        :param bool files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> bool:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class GetZeroTrustDlpPredefinedProfileEntryResult(dict):
    def __init__(__self__, *,
                 confidence: 'outputs.GetZeroTrustDlpPredefinedProfileEntryConfidenceResult',
                 created_at: str,
                 enabled: bool,
                 id: str,
                 name: str,
                 pattern: 'outputs.GetZeroTrustDlpPredefinedProfileEntryPatternResult',
                 profile_id: str,
                 secret: bool,
                 type: str,
                 updated_at: str,
                 word_list: str):
        pulumi.set(__self__, "confidence", confidence)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "profile_id", profile_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter
    def confidence(self) -> 'outputs.GetZeroTrustDlpPredefinedProfileEntryConfidenceResult':
        return pulumi.get(self, "confidence")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pattern(self) -> 'outputs.GetZeroTrustDlpPredefinedProfileEntryPatternResult':
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> str:
        return pulumi.get(self, "profile_id")

    @property
    @pulumi.getter
    def secret(self) -> bool:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> str:
        return pulumi.get(self, "word_list")


@pulumi.output_type
class GetZeroTrustDlpPredefinedProfileEntryConfidenceResult(dict):
    def __init__(__self__, *,
<<<<<<< HEAD
=======
                 ai_context_available: bool,
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
                 available: bool):
        """
        :param bool available: Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
               Profiles that use an entry with `available` set to true can use confidence thresholds
        """
<<<<<<< HEAD
        pulumi.set(__self__, "available", available)

    @property
=======
        pulumi.set(__self__, "ai_context_available", ai_context_available)
        pulumi.set(__self__, "available", available)

    @property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> bool:
        return pulumi.get(self, "ai_context_available")

    @property
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    @pulumi.getter
    def available(self) -> bool:
        """
        Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
        Profiles that use an entry with `available` set to true can use confidence thresholds
        """
        return pulumi.get(self, "available")


@pulumi.output_type
class GetZeroTrustDlpPredefinedProfileEntryPatternResult(dict):
    def __init__(__self__, *,
                 regex: str,
                 validation: str):
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> str:
        return pulumi.get(self, "validation")


@pulumi.output_type
class GetZeroTrustDnsLocationEndpointsResult(dict):
    def __init__(__self__, *,
                 doh: 'outputs.GetZeroTrustDnsLocationEndpointsDohResult',
                 dot: 'outputs.GetZeroTrustDnsLocationEndpointsDotResult',
                 ipv4: 'outputs.GetZeroTrustDnsLocationEndpointsIpv4Result',
                 ipv6: 'outputs.GetZeroTrustDnsLocationEndpointsIpv6Result'):
        pulumi.set(__self__, "doh", doh)
        pulumi.set(__self__, "dot", dot)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def doh(self) -> 'outputs.GetZeroTrustDnsLocationEndpointsDohResult':
        return pulumi.get(self, "doh")

    @property
    @pulumi.getter
    def dot(self) -> 'outputs.GetZeroTrustDnsLocationEndpointsDotResult':
        return pulumi.get(self, "dot")

    @property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetZeroTrustDnsLocationEndpointsIpv4Result':
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> 'outputs.GetZeroTrustDnsLocationEndpointsIpv6Result':
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class GetZeroTrustDnsLocationEndpointsDohResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 networks: Sequence['outputs.GetZeroTrustDnsLocationEndpointsDohNetworkResult'],
                 require_token: bool):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['GetZeroTrustDnsLocationEndpointsDohNetworkArgs'] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        :param bool require_token: True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "require_token", require_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetZeroTrustDnsLocationEndpointsDohNetworkResult']:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> bool:
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        return pulumi.get(self, "require_token")


@pulumi.output_type
class GetZeroTrustDnsLocationEndpointsDohNetworkResult(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetZeroTrustDnsLocationEndpointsDotResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 networks: Sequence['outputs.GetZeroTrustDnsLocationEndpointsDotNetworkResult']):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['GetZeroTrustDnsLocationEndpointsDotNetworkArgs'] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetZeroTrustDnsLocationEndpointsDotNetworkResult']:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class GetZeroTrustDnsLocationEndpointsDotNetworkResult(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetZeroTrustDnsLocationEndpointsIpv4Result(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustDnsLocationEndpointsIpv6Result(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 networks: Sequence['outputs.GetZeroTrustDnsLocationEndpointsIpv6NetworkResult']):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['GetZeroTrustDnsLocationEndpointsIpv6NetworkArgs'] networks: A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetZeroTrustDnsLocationEndpointsIpv6NetworkResult']:
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class GetZeroTrustDnsLocationEndpointsIpv6NetworkResult(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IPv6 address or IPv6 CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IPv6 address or IPv6 CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetZeroTrustDnsLocationNetworkResult(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultResult(dict):
    def __init__(__self__, *,
                 client_default: bool,
                 created_at: str,
                 dns_destination_ips_id: str,
                 dns_destination_ipv6_block_id: str,
                 doh_subdomain: str,
                 ecs_support: bool,
                 endpoints: 'outputs.GetZeroTrustDnsLocationsResultEndpointsResult',
                 id: str,
                 ip: str,
                 ipv4_destination: str,
                 ipv4_destination_backup: str,
                 name: str,
                 networks: Sequence['outputs.GetZeroTrustDnsLocationsResultNetworkResult'],
                 updated_at: str):
        """
        :param bool client_default: True if the location is the default location.
        :param str dns_destination_ips_id: The identifier of the pair of IPv4 addresses assigned to this location.
        :param str dns_destination_ipv6_block_id: The uuid identifier of the IPv6 block brought to the gateway, so that this location's IPv6 address is allocated from the Bring Your Own Ipv6(BYOIPv6) block and not from the standard CloudFlare IPv6 block.
        :param str doh_subdomain: The DNS over HTTPS domain to send DNS requests to. This field is auto-generated by Gateway.
        :param bool ecs_support: True if the location needs to resolve EDNS queries.
        :param 'GetZeroTrustDnsLocationsResultEndpointsArgs' endpoints: The destination endpoints configured for this location. When updating a location, if this field is absent or set with null, the endpoints configuration remains unchanged.
        :param str ip: IPV6 destination ip assigned to this location. DNS requests sent to this IP will counted as the request under this location. This field is auto-generated by Gateway.
        :param str ipv4_destination: The primary destination IPv4 address from the pair identified by the dns*destination*ips_id. This field is read-only.
        :param str ipv4_destination_backup: The backup destination IPv4 address from the pair identified by the dns*destination*ips_id. This field is read-only.
        :param str name: The name of the location.
        :param Sequence['GetZeroTrustDnsLocationsResultNetworkArgs'] networks: A list of network ranges that requests from this location would originate from. A non-empty list is only effective if the ipv4 endpoint is enabled for this location.
        """
        pulumi.set(__self__, "client_default", client_default)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "dns_destination_ips_id", dns_destination_ips_id)
        pulumi.set(__self__, "dns_destination_ipv6_block_id", dns_destination_ipv6_block_id)
        pulumi.set(__self__, "doh_subdomain", doh_subdomain)
        pulumi.set(__self__, "ecs_support", ecs_support)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ipv4_destination", ipv4_destination)
        pulumi.set(__self__, "ipv4_destination_backup", ipv4_destination_backup)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="clientDefault")
    def client_default(self) -> bool:
        """
        True if the location is the default location.
        """
        return pulumi.get(self, "client_default")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="dnsDestinationIpsId")
    def dns_destination_ips_id(self) -> str:
        """
        The identifier of the pair of IPv4 addresses assigned to this location.
        """
        return pulumi.get(self, "dns_destination_ips_id")

    @property
    @pulumi.getter(name="dnsDestinationIpv6BlockId")
    def dns_destination_ipv6_block_id(self) -> str:
        """
        The uuid identifier of the IPv6 block brought to the gateway, so that this location's IPv6 address is allocated from the Bring Your Own Ipv6(BYOIPv6) block and not from the standard CloudFlare IPv6 block.
        """
        return pulumi.get(self, "dns_destination_ipv6_block_id")

    @property
    @pulumi.getter(name="dohSubdomain")
    def doh_subdomain(self) -> str:
        """
        The DNS over HTTPS domain to send DNS requests to. This field is auto-generated by Gateway.
        """
        return pulumi.get(self, "doh_subdomain")

    @property
    @pulumi.getter(name="ecsSupport")
    def ecs_support(self) -> bool:
        """
        True if the location needs to resolve EDNS queries.
        """
        return pulumi.get(self, "ecs_support")

    @property
    @pulumi.getter
    def endpoints(self) -> 'outputs.GetZeroTrustDnsLocationsResultEndpointsResult':
        """
        The destination endpoints configured for this location. When updating a location, if this field is absent or set with null, the endpoints configuration remains unchanged.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPV6 destination ip assigned to this location. DNS requests sent to this IP will counted as the request under this location. This field is auto-generated by Gateway.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipv4Destination")
    def ipv4_destination(self) -> str:
        """
        The primary destination IPv4 address from the pair identified by the dns*destination*ips_id. This field is read-only.
        """
        return pulumi.get(self, "ipv4_destination")

    @property
    @pulumi.getter(name="ipv4DestinationBackup")
    def ipv4_destination_backup(self) -> str:
        """
        The backup destination IPv4 address from the pair identified by the dns*destination*ips_id. This field is read-only.
        """
        return pulumi.get(self, "ipv4_destination_backup")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetZeroTrustDnsLocationsResultNetworkResult']:
        """
        A list of network ranges that requests from this location would originate from. A non-empty list is only effective if the ipv4 endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultEndpointsResult(dict):
    def __init__(__self__, *,
                 doh: 'outputs.GetZeroTrustDnsLocationsResultEndpointsDohResult',
                 dot: 'outputs.GetZeroTrustDnsLocationsResultEndpointsDotResult',
                 ipv4: 'outputs.GetZeroTrustDnsLocationsResultEndpointsIpv4Result',
                 ipv6: 'outputs.GetZeroTrustDnsLocationsResultEndpointsIpv6Result'):
        pulumi.set(__self__, "doh", doh)
        pulumi.set(__self__, "dot", dot)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def doh(self) -> 'outputs.GetZeroTrustDnsLocationsResultEndpointsDohResult':
        return pulumi.get(self, "doh")

    @property
    @pulumi.getter
    def dot(self) -> 'outputs.GetZeroTrustDnsLocationsResultEndpointsDotResult':
        return pulumi.get(self, "dot")

    @property
    @pulumi.getter
    def ipv4(self) -> 'outputs.GetZeroTrustDnsLocationsResultEndpointsIpv4Result':
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> 'outputs.GetZeroTrustDnsLocationsResultEndpointsIpv6Result':
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultEndpointsDohResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 networks: Sequence['outputs.GetZeroTrustDnsLocationsResultEndpointsDohNetworkResult'],
                 require_token: bool):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['GetZeroTrustDnsLocationsResultEndpointsDohNetworkArgs'] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        :param bool require_token: True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "require_token", require_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetZeroTrustDnsLocationsResultEndpointsDohNetworkResult']:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> bool:
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        return pulumi.get(self, "require_token")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultEndpointsDohNetworkResult(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultEndpointsDotResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 networks: Sequence['outputs.GetZeroTrustDnsLocationsResultEndpointsDotNetworkResult']):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['GetZeroTrustDnsLocationsResultEndpointsDotNetworkArgs'] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetZeroTrustDnsLocationsResultEndpointsDotNetworkResult']:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultEndpointsDotNetworkResult(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultEndpointsIpv4Result(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultEndpointsIpv6Result(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 networks: Sequence['outputs.GetZeroTrustDnsLocationsResultEndpointsIpv6NetworkResult']):
        """
        :param bool enabled: True if the endpoint is enabled for this location.
        :param Sequence['GetZeroTrustDnsLocationsResultEndpointsIpv6NetworkArgs'] networks: A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetZeroTrustDnsLocationsResultEndpointsIpv6NetworkResult']:
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultEndpointsIpv6NetworkResult(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IPv6 address or IPv6 CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IPv6 address or IPv6 CIDR.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetZeroTrustDnsLocationsResultNetworkResult(dict):
    def __init__(__self__, *,
                 network: str):
        """
        :param str network: The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetZeroTrustGatewayAppTypesListResultResult(dict):
    def __init__(__self__, *,
                 application_type_id: int,
                 created_at: str,
                 description: str,
                 id: int,
                 name: str):
        """
        :param int application_type_id: The identifier for the type of this application. There can be many applications with the same type. This refers to the `id` of a returned application type.
        :param str description: A short summary of applications with this type.
        :param int id: The identifier for this application. There is only one application per ID.
        :param str name: The name of the application or application type.
        """
        pulumi.set(__self__, "application_type_id", application_type_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="applicationTypeId")
    def application_type_id(self) -> int:
        """
        The identifier for the type of this application. There can be many applications with the same type. This refers to the `id` of a returned application type.
        """
        return pulumi.get(self, "application_type_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A short summary of applications with this type.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The identifier for this application. There is only one application per ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the application or application type.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustGatewayCategoriesListResultResult(dict):
    def __init__(__self__, *,
                 beta: bool,
                 class_: str,
                 description: str,
                 id: int,
                 name: str,
                 subcategories: Sequence['outputs.GetZeroTrustGatewayCategoriesListResultSubcategoryResult']):
        """
        :param bool beta: True if the category is in beta and subject to change.
        :param str class_: Which account types are allowed to create policies based on this category. `blocked` categories are blocked unconditionally for all accounts. `removalPending` categories can be removed from policies but not added. `noBlock` categories cannot be blocked.
        :param str description: A short summary of domains in the category.
        :param int id: The identifier for this category. There is only one category per ID.
        :param str name: The name of the category.
        :param Sequence['GetZeroTrustGatewayCategoriesListResultSubcategoryArgs'] subcategories: All subcategories for this category.
        """
        pulumi.set(__self__, "beta", beta)
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subcategories", subcategories)

    @property
    @pulumi.getter
    def beta(self) -> bool:
        """
        True if the category is in beta and subject to change.
        """
        return pulumi.get(self, "beta")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> str:
        """
        Which account types are allowed to create policies based on this category. `blocked` categories are blocked unconditionally for all accounts. `removalPending` categories can be removed from policies but not added. `noBlock` categories cannot be blocked.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A short summary of domains in the category.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The identifier for this category. There is only one category per ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the category.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subcategories(self) -> Sequence['outputs.GetZeroTrustGatewayCategoriesListResultSubcategoryResult']:
        """
        All subcategories for this category.
        """
        return pulumi.get(self, "subcategories")


@pulumi.output_type
class GetZeroTrustGatewayCategoriesListResultSubcategoryResult(dict):
    def __init__(__self__, *,
                 beta: bool,
                 class_: str,
                 description: str,
                 id: int,
                 name: str):
        """
        :param bool beta: True if the category is in beta and subject to change.
        :param str class_: Which account types are allowed to create policies based on this category. `blocked` categories are blocked unconditionally for all accounts. `removalPending` categories can be removed from policies but not added. `noBlock` categories cannot be blocked.
        :param str description: A short summary of domains in the category.
        :param int id: The identifier for this category. There is only one category per ID.
        :param str name: The name of the category.
        """
        pulumi.set(__self__, "beta", beta)
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def beta(self) -> bool:
        """
        True if the category is in beta and subject to change.
        """
        return pulumi.get(self, "beta")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> str:
        """
        Which account types are allowed to create policies based on this category. `blocked` categories are blocked unconditionally for all accounts. `removalPending` categories can be removed from policies but not added. `noBlock` categories cannot be blocked.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A short summary of domains in the category.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The identifier for this category. There is only one category per ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the category.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustGatewayCertificatesResultResult(dict):
    def __init__(__self__, *,
                 binding_status: str,
                 certificate: str,
                 created_at: str,
                 expires_on: str,
                 fingerprint: str,
                 id: str,
                 in_use: bool,
                 issuer_org: str,
                 issuer_raw: str,
                 type: str,
                 updated_at: str,
                 uploaded_on: str):
        """
        :param str binding_status: The deployment status of the certificate on Cloudflare's edge. Certificates in the 'available' (previously called 'active') state may be used for Gateway TLS interception.
        :param str certificate: The CA certificate
        :param str fingerprint: The SHA256 fingerprint of the certificate.
        :param str id: Certificate UUID tag.
        :param bool in_use: Use this certificate for Gateway TLS interception
        :param str issuer_org: The organization that issued the certificate.
        :param str issuer_raw: The entire issuer field of the certificate.
        :param str type: The type of certificate, either BYO-PKI (custom) or Gateway-managed.
        """
        pulumi.set(__self__, "binding_status", binding_status)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "in_use", in_use)
        pulumi.set(__self__, "issuer_org", issuer_org)
        pulumi.set(__self__, "issuer_raw", issuer_raw)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uploaded_on", uploaded_on)

    @property
    @pulumi.getter(name="bindingStatus")
    def binding_status(self) -> str:
        """
        The deployment status of the certificate on Cloudflare's edge. Certificates in the 'available' (previously called 'active') state may be used for Gateway TLS interception.
        """
        return pulumi.get(self, "binding_status")

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The CA certificate
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> str:
        return pulumi.get(self, "expires_on")

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        """
        The SHA256 fingerprint of the certificate.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Certificate UUID tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="inUse")
    def in_use(self) -> bool:
        """
        Use this certificate for Gateway TLS interception
        """
        return pulumi.get(self, "in_use")

    @property
    @pulumi.getter(name="issuerOrg")
    def issuer_org(self) -> str:
        """
        The organization that issued the certificate.
        """
        return pulumi.get(self, "issuer_org")

    @property
    @pulumi.getter(name="issuerRaw")
    def issuer_raw(self) -> str:
        """
        The entire issuer field of the certificate.
        """
        return pulumi.get(self, "issuer_raw")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of certificate, either BYO-PKI (custom) or Gateway-managed.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="uploadedOn")
    def uploaded_on(self) -> str:
        return pulumi.get(self, "uploaded_on")


@pulumi.output_type
<<<<<<< HEAD
=======
class GetZeroTrustGatewayLoggingSettingsByRuleTypeResult(dict):
    def __init__(__self__, *,
                 dns: str,
                 http: str,
                 l4: str):
        """
        :param str dns: Logging settings for DNS firewall.
        :param str http: Logging settings for HTTP/HTTPS firewall.
        :param str l4: Logging settings for Network firewall.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "http", http)
        pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> str:
        """
        Logging settings for DNS firewall.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def http(self) -> str:
        """
        Logging settings for HTTP/HTTPS firewall.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def l4(self) -> str:
        """
        Logging settings for Network firewall.
        """
        return pulumi.get(self, "l4")


@pulumi.output_type
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
class GetZeroTrustGatewayPoliciesResultResult(dict):
    def __init__(__self__, *,
                 action: str,
                 created_at: str,
                 deleted_at: str,
                 description: str,
                 device_posture: str,
                 enabled: bool,
                 expiration: 'outputs.GetZeroTrustGatewayPoliciesResultExpirationResult',
                 filters: Sequence[str],
                 id: str,
                 identity: str,
                 name: str,
                 precedence: int,
                 rule_settings: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsResult',
                 schedule: 'outputs.GetZeroTrustGatewayPoliciesResultScheduleResult',
                 traffic: str,
                 updated_at: str,
                 version: int):
        """
        :param str action: The action to preform when the associated traffic, identity, and device posture expressions are either absent or evaluate to `true`.
        :param str deleted_at: Date of deletion, if any.
        :param str description: The description of the rule.
        :param str device_posture: The wirefilter expression used for device posture check matching.
        :param bool enabled: True if the rule is enabled.
        :param 'GetZeroTrustGatewayPoliciesResultExpirationArgs' expiration: The expiration time stamp and default duration of a DNS policy. Takes
               precedence over the policy's `schedule` configuration, if any.
        :param Sequence[str] filters: The protocol or layer to evaluate the traffic, identity, and device posture expressions.
        :param str id: The API resource UUID.
        :param str identity: The wirefilter expression used for identity matching.
        :param str name: The name of the rule.
        :param int precedence: Precedence sets the order of your rules. Lower values indicate higher precedence. At each processing phase, applicable rules are evaluated in ascending order of this value.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsArgs' rule_settings: Additional settings that modify the rule's action.
        :param 'GetZeroTrustGatewayPoliciesResultScheduleArgs' schedule: The schedule for activating DNS policies. This does not apply to HTTP or network policies.
        :param str traffic: The wirefilter expression used for traffic matching.
        :param int version: version number of the rule
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "device_posture", device_posture)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity", identity)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "precedence", precedence)
        pulumi.set(__self__, "rule_settings", rule_settings)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "traffic", traffic)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to preform when the associated traffic, identity, and device posture expressions are either absent or evaluate to `true`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> str:
        """
        Date of deletion, if any.
        """
        return pulumi.get(self, "deleted_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> str:
        """
        The wirefilter expression used for device posture check matching.
        """
        return pulumi.get(self, "device_posture")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if the rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expiration(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultExpirationResult':
        """
        The expiration time stamp and default duration of a DNS policy. Takes
        precedence over the policy's `schedule` configuration, if any.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        The protocol or layer to evaluate the traffic, identity, and device posture expressions.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The API resource UUID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def identity(self) -> str:
        """
        The wirefilter expression used for identity matching.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def precedence(self) -> int:
        """
        Precedence sets the order of your rules. Lower values indicate higher precedence. At each processing phase, applicable rules are evaluated in ascending order of this value.
        """
        return pulumi.get(self, "precedence")

    @property
    @pulumi.getter(name="ruleSettings")
    def rule_settings(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsResult':
        """
        Additional settings that modify the rule's action.
        """
        return pulumi.get(self, "rule_settings")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultScheduleResult':
        """
        The schedule for activating DNS policies. This does not apply to HTTP or network policies.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def traffic(self) -> str:
        """
        The wirefilter expression used for traffic matching.
        """
        return pulumi.get(self, "traffic")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        version number of the rule
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultExpirationResult(dict):
    def __init__(__self__, *,
                 duration: int,
                 expired: bool,
                 expires_at: str):
        """
        :param int duration: The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        :param bool expired: Whether the policy has expired.
        :param str expires_at: The time stamp at which the policy will expire and cease to be
               applied.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "expired", expired)
        pulumi.set(__self__, "expires_at", expires_at)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def expired(self) -> bool:
        """
        Whether the policy has expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        return pulumi.get(self, "expires_at")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsResult(dict):
    def __init__(__self__, *,
                 add_headers: Mapping[str, str],
                 allow_child_bypass: bool,
                 audit_ssh: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSshResult',
                 biso_admin_controls: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControlsResult',
                 block_page_enabled: bool,
                 block_reason: str,
                 bypass_parent_rule: bool,
                 check_session: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSessionResult',
                 dns_resolvers: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversResult',
                 egress: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsEgressResult',
                 ignore_cname_category_matches: bool,
                 insecure_disable_dnssec_validation: bool,
                 ip_categories: bool,
                 ip_indicator_feeds: bool,
                 l4override: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsL4overrideResult',
                 notification_settings: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettingsResult',
                 override_host: str,
                 override_ips: Sequence[str],
                 payload_log: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLogResult',
                 quarantine: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantineResult',
                 resolve_dns_internally: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternallyResult',
                 resolve_dns_through_cloudflare: bool,
                 untrusted_cert: 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCertResult'):
        """
        :param Mapping[str, str] add_headers: Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        :param bool allow_child_bypass: Set by parent MSP accounts to enable their children to bypass this rule.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSshArgs' audit_ssh: Settings for the Audit SSH action.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControlsArgs' biso_admin_controls: Configure how browser isolation behaves.
        :param bool block_page_enabled: Enable the custom block page.
        :param str block_reason: The text describing why this block occurred, displayed on the custom block page (if enabled).
        :param bool bypass_parent_rule: Set by children MSP accounts to bypass their parent's rules.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSessionArgs' check_session: Configure how session check behaves.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversArgs' dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsEgressArgs' egress: Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        :param bool ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        :param bool insecure_disable_dnssec_validation: INSECURE - disable DNSSEC validation (for Allow actions).
        :param bool ip_categories: Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        :param bool ip_indicator_feeds: Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsL4overrideArgs' l4override: Send matching traffic to the supplied destination IP address and port.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettingsArgs' notification_settings: Configure a notification to display on the user's device when this rule is matched.
        :param str override_host: Override matching DNS queries with a hostname.
        :param Sequence[str] override_ips: Override matching DNS queries with an IP or set of IPs.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLogArgs' payload_log: Configure DLP payload logging.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantineArgs' quarantine: Settings that apply to quarantine rules
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternallyArgs' resolve_dns_internally: Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        :param bool resolve_dns_through_cloudflare: Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        :param 'GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCertArgs' untrusted_cert: Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        pulumi.set(__self__, "add_headers", add_headers)
        pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        pulumi.set(__self__, "audit_ssh", audit_ssh)
        pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        pulumi.set(__self__, "block_reason", block_reason)
        pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        pulumi.set(__self__, "check_session", check_session)
        pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        pulumi.set(__self__, "ip_categories", ip_categories)
        pulumi.set(__self__, "ip_indicator_feeds", ip_indicator_feeds)
        pulumi.set(__self__, "l4override", l4override)
        pulumi.set(__self__, "notification_settings", notification_settings)
        pulumi.set(__self__, "override_host", override_host)
        pulumi.set(__self__, "override_ips", override_ips)
        pulumi.set(__self__, "payload_log", payload_log)
        pulumi.set(__self__, "quarantine", quarantine)
        pulumi.set(__self__, "resolve_dns_internally", resolve_dns_internally)
        pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Mapping[str, str]:
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        return pulumi.get(self, "add_headers")

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> bool:
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        return pulumi.get(self, "allow_child_bypass")

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSshResult':
        """
        Settings for the Audit SSH action.
        """
        return pulumi.get(self, "audit_ssh")

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControlsResult':
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> bool:
        """
        Enable the custom block page.
        """
        return pulumi.get(self, "block_page_enabled")

    @property
    @pulumi.getter(name="blockReason")
    def block_reason(self) -> str:
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        return pulumi.get(self, "block_reason")

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> bool:
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSessionResult':
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversResult':
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "dns_resolvers")

    @property
    @pulumi.getter
    def egress(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsEgressResult':
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> bool:
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> bool:
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> bool:
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        return pulumi.get(self, "ip_categories")

    @property
    @pulumi.getter(name="ipIndicatorFeeds")
    def ip_indicator_feeds(self) -> bool:
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        return pulumi.get(self, "ip_indicator_feeds")

    @property
    @pulumi.getter
    def l4override(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsL4overrideResult':
        """
        Send matching traffic to the supplied destination IP address and port.
        """
        return pulumi.get(self, "l4override")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettingsResult':
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        return pulumi.get(self, "notification_settings")

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> str:
        """
        Override matching DNS queries with a hostname.
        """
        return pulumi.get(self, "override_host")

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Sequence[str]:
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        return pulumi.get(self, "override_ips")

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLogResult':
        """
        Configure DLP payload logging.
        """
        return pulumi.get(self, "payload_log")

    @property
    @pulumi.getter
    def quarantine(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantineResult':
        """
        Settings that apply to quarantine rules
        """
        return pulumi.get(self, "quarantine")

    @property
    @pulumi.getter(name="resolveDnsInternally")
    def resolve_dns_internally(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternallyResult':
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_internally")

    @property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> bool:
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> 'outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCertResult':
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        return pulumi.get(self, "untrusted_cert")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSshResult(dict):
    def __init__(__self__, *,
                 command_logging: bool):
        """
        :param bool command_logging: Enable to turn on SSH command logging.
        """
        pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> bool:
        """
        Enable to turn on SSH command logging.
        """
        return pulumi.get(self, "command_logging")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControlsResult(dict):
    def __init__(__self__, *,
                 copy: str,
                 dcp: bool,
                 dd: bool,
                 dk: bool,
                 download: str,
                 dp: bool,
                 du: bool,
                 keyboard: str,
                 paste: str,
                 printing: str,
                 upload: str,
                 version: str):
        """
        :param str copy: Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        :param bool dcp: Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        :param bool dd: Set to false to enable downloading. Only applies when `version == "v1"`.
        :param bool dk: Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        :param str download: Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        :param bool dp: Set to false to enable printing. Only applies when `version == "v1"`.
        :param bool du: Set to false to enable uploading. Only applies when `version == "v1"`.
        :param str keyboard: Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        :param str paste: Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        :param str printing: Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        :param str upload: Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        :param str version: Indicates which version of the browser isolation controls should apply.
        """
        pulumi.set(__self__, "copy", copy)
        pulumi.set(__self__, "dcp", dcp)
        pulumi.set(__self__, "dd", dd)
        pulumi.set(__self__, "dk", dk)
        pulumi.set(__self__, "download", download)
        pulumi.set(__self__, "dp", dp)
        pulumi.set(__self__, "du", du)
        pulumi.set(__self__, "keyboard", keyboard)
        pulumi.set(__self__, "paste", paste)
        pulumi.set(__self__, "printing", printing)
        pulumi.set(__self__, "upload", upload)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def copy(self) -> str:
        """
        Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "copy")

    @property
    @pulumi.getter
    def dcp(self) -> bool:
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dcp")

    @property
    @pulumi.getter
    def dd(self) -> bool:
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dd")

    @property
    @pulumi.getter
    def dk(self) -> bool:
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dk")

    @property
    @pulumi.getter
    def download(self) -> str:
        """
        Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "download")

    @property
    @pulumi.getter
    def dp(self) -> bool:
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dp")

    @property
    @pulumi.getter
    def du(self) -> bool:
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "du")

    @property
    @pulumi.getter
    def keyboard(self) -> str:
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "keyboard")

    @property
    @pulumi.getter
    def paste(self) -> str:
        """
        Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "paste")

    @property
    @pulumi.getter
    def printing(self) -> str:
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "printing")

    @property
    @pulumi.getter
    def upload(self) -> str:
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "upload")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Indicates which version of the browser isolation controls should apply.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSessionResult(dict):
    def __init__(__self__, *,
                 duration: str,
                 enforce: bool):
        """
        :param str duration: Configure how fresh the session needs to be to be considered valid.
        :param bool enforce: Set to true to enable session enforcement.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enforce(self) -> bool:
        """
        Set to true to enable session enforcement.
        """
        return pulumi.get(self, "enforce")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversResult(dict):
    def __init__(__self__, *,
                 ipv4s: Sequence['outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv4Result'],
                 ipv6s: Sequence['outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv6Result']):
        pulumi.set(__self__, "ipv4s", ipv4s)
        pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Sequence['outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv4Result']:
        return pulumi.get(self, "ipv4s")

    @property
    @pulumi.getter
    def ipv6s(self) -> Sequence['outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv6Result']:
        return pulumi.get(self, "ipv6s")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv4Result(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int,
                 route_through_private_network: bool,
                 vnet_id: str):
        """
        :param str ip: IPv4 address of upstream resolver.
        :param int port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param str vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> bool:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv6Result(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int,
                 route_through_private_network: bool,
                 vnet_id: str):
        """
        :param str ip: IPv6 address of upstream resolver.
        :param int port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param str vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv6 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> bool:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsEgressResult(dict):
    def __init__(__self__, *,
                 ipv4: str,
                 ipv4_fallback: str,
                 ipv6: str):
        """
        :param str ipv4: The IPv4 address to be used for egress.
        :param str ipv4_fallback: The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        :param str ipv6: The IPv6 range to be used for egress.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)
        pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> str:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> str:
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @property
    @pulumi.getter
    def ipv6(self) -> str:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsL4overrideResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int):
        """
        :param str ip: IPv4 or IPv6 address.
        :param int port: A port number to use for TCP/UDP overrides.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        A port number to use for TCP/UDP overrides.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettingsResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 msg: str,
                 support_url: str):
        """
        :param bool enabled: Set notification on
        :param str msg: Customize the message shown in the notification.
        :param str support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "msg", msg)
        pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Set notification on
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def msg(self) -> str:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> str:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLogResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Set to true to enable DLP payload logging for this rule.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Set to true to enable DLP payload logging for this rule.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantineResult(dict):
    def __init__(__self__, *,
                 file_types: Sequence[str]):
        """
        :param Sequence[str] file_types: Types of files to sandbox.
        """
        pulumi.set(__self__, "file_types", file_types)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Sequence[str]:
        """
        Types of files to sandbox.
        """
        return pulumi.get(self, "file_types")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternallyResult(dict):
    def __init__(__self__, *,
                 fallback: str,
                 view_id: str):
        """
        :param str fallback: The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        :param str view_id: The internal DNS view identifier that's passed to the internal DNS service.
        """
        pulumi.set(__self__, "fallback", fallback)
        pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter
    def fallback(self) -> str:
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        """
        return pulumi.get(self, "fallback")

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> str:
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
        return pulumi.get(self, "view_id")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCertResult(dict):
    def __init__(__self__, *,
                 action: str):
        """
        :param str action: The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class GetZeroTrustGatewayPoliciesResultScheduleResult(dict):
    def __init__(__self__, *,
                 fri: str,
                 mon: str,
                 sat: str,
                 sun: str,
                 thu: str,
                 time_zone: str,
                 tue: str,
                 wed: str):
        """
        :param str fri: The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        :param str mon: The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        :param str sat: The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        :param str sun: The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        :param str thu: The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        :param str time_zone: The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        :param str tue: The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        :param str wed: The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        pulumi.set(__self__, "fri", fri)
        pulumi.set(__self__, "mon", mon)
        pulumi.set(__self__, "sat", sat)
        pulumi.set(__self__, "sun", sun)
        pulumi.set(__self__, "thu", thu)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "tue", tue)
        pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> str:
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        return pulumi.get(self, "fri")

    @property
    @pulumi.getter
    def mon(self) -> str:
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        return pulumi.get(self, "mon")

    @property
    @pulumi.getter
    def sat(self) -> str:
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        return pulumi.get(self, "sat")

    @property
    @pulumi.getter
    def sun(self) -> str:
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        return pulumi.get(self, "sun")

    @property
    @pulumi.getter
    def thu(self) -> str:
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        return pulumi.get(self, "thu")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def tue(self) -> str:
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        return pulumi.get(self, "tue")

    @property
    @pulumi.getter
    def wed(self) -> str:
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        return pulumi.get(self, "wed")


@pulumi.output_type
class GetZeroTrustGatewayPolicyExpirationResult(dict):
    def __init__(__self__, *,
                 duration: int,
                 expired: bool,
                 expires_at: str):
        """
        :param int duration: The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        :param bool expired: Whether the policy has expired.
        :param str expires_at: The time stamp at which the policy will expire and cease to be
               applied.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "expired", expired)
        pulumi.set(__self__, "expires_at", expires_at)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def expired(self) -> bool:
        """
        Whether the policy has expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        return pulumi.get(self, "expires_at")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsResult(dict):
    def __init__(__self__, *,
                 add_headers: Mapping[str, str],
                 allow_child_bypass: bool,
                 audit_ssh: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsAuditSshResult',
                 biso_admin_controls: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsResult',
                 block_page_enabled: bool,
                 block_reason: str,
                 bypass_parent_rule: bool,
                 check_session: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsCheckSessionResult',
                 dns_resolvers: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversResult',
                 egress: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsEgressResult',
                 ignore_cname_category_matches: bool,
                 insecure_disable_dnssec_validation: bool,
                 ip_categories: bool,
                 ip_indicator_feeds: bool,
                 l4override: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsL4overrideResult',
                 notification_settings: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsNotificationSettingsResult',
                 override_host: str,
                 override_ips: Sequence[str],
                 payload_log: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsPayloadLogResult',
                 quarantine: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsQuarantineResult',
                 resolve_dns_internally: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyResult',
                 resolve_dns_through_cloudflare: bool,
                 untrusted_cert: 'outputs.GetZeroTrustGatewayPolicyRuleSettingsUntrustedCertResult'):
        """
        :param Mapping[str, str] add_headers: Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        :param bool allow_child_bypass: Set by parent MSP accounts to enable their children to bypass this rule.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsAuditSshArgs' audit_ssh: Settings for the Audit SSH action.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs' biso_admin_controls: Configure how browser isolation behaves.
        :param bool block_page_enabled: Enable the custom block page.
        :param str block_reason: The text describing why this block occurred, displayed on the custom block page (if enabled).
        :param bool bypass_parent_rule: Set by children MSP accounts to bypass their parent's rules.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs' check_session: Configure how session check behaves.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs' dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsEgressArgs' egress: Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        :param bool ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        :param bool insecure_disable_dnssec_validation: INSECURE - disable DNSSEC validation (for Allow actions).
        :param bool ip_categories: Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        :param bool ip_indicator_feeds: Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsL4overrideArgs' l4override: Send matching traffic to the supplied destination IP address and port.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs' notification_settings: Configure a notification to display on the user's device when this rule is matched.
        :param str override_host: Override matching DNS queries with a hostname.
        :param Sequence[str] override_ips: Override matching DNS queries with an IP or set of IPs.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs' payload_log: Configure DLP payload logging.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsQuarantineArgs' quarantine: Settings that apply to quarantine rules
        :param 'GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs' resolve_dns_internally: Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        :param bool resolve_dns_through_cloudflare: Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        :param 'GetZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs' untrusted_cert: Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        pulumi.set(__self__, "add_headers", add_headers)
        pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        pulumi.set(__self__, "audit_ssh", audit_ssh)
        pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        pulumi.set(__self__, "block_reason", block_reason)
        pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        pulumi.set(__self__, "check_session", check_session)
        pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        pulumi.set(__self__, "ip_categories", ip_categories)
        pulumi.set(__self__, "ip_indicator_feeds", ip_indicator_feeds)
        pulumi.set(__self__, "l4override", l4override)
        pulumi.set(__self__, "notification_settings", notification_settings)
        pulumi.set(__self__, "override_host", override_host)
        pulumi.set(__self__, "override_ips", override_ips)
        pulumi.set(__self__, "payload_log", payload_log)
        pulumi.set(__self__, "quarantine", quarantine)
        pulumi.set(__self__, "resolve_dns_internally", resolve_dns_internally)
        pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Mapping[str, str]:
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        return pulumi.get(self, "add_headers")

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> bool:
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        return pulumi.get(self, "allow_child_bypass")

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsAuditSshResult':
        """
        Settings for the Audit SSH action.
        """
        return pulumi.get(self, "audit_ssh")

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsResult':
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> bool:
        """
        Enable the custom block page.
        """
        return pulumi.get(self, "block_page_enabled")

    @property
    @pulumi.getter(name="blockReason")
    def block_reason(self) -> str:
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        return pulumi.get(self, "block_reason")

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> bool:
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsCheckSessionResult':
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversResult':
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "dns_resolvers")

    @property
    @pulumi.getter
    def egress(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsEgressResult':
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> bool:
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> bool:
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> bool:
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        return pulumi.get(self, "ip_categories")

    @property
    @pulumi.getter(name="ipIndicatorFeeds")
    def ip_indicator_feeds(self) -> bool:
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        return pulumi.get(self, "ip_indicator_feeds")

    @property
    @pulumi.getter
    def l4override(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsL4overrideResult':
        """
        Send matching traffic to the supplied destination IP address and port.
        """
        return pulumi.get(self, "l4override")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsNotificationSettingsResult':
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        return pulumi.get(self, "notification_settings")

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> str:
        """
        Override matching DNS queries with a hostname.
        """
        return pulumi.get(self, "override_host")

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Sequence[str]:
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        return pulumi.get(self, "override_ips")

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsPayloadLogResult':
        """
        Configure DLP payload logging.
        """
        return pulumi.get(self, "payload_log")

    @property
    @pulumi.getter
    def quarantine(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsQuarantineResult':
        """
        Settings that apply to quarantine rules
        """
        return pulumi.get(self, "quarantine")

    @property
    @pulumi.getter(name="resolveDnsInternally")
    def resolve_dns_internally(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyResult':
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_internally")

    @property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> bool:
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> 'outputs.GetZeroTrustGatewayPolicyRuleSettingsUntrustedCertResult':
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        return pulumi.get(self, "untrusted_cert")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsAuditSshResult(dict):
    def __init__(__self__, *,
                 command_logging: bool):
        """
        :param bool command_logging: Enable to turn on SSH command logging.
        """
        pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> bool:
        """
        Enable to turn on SSH command logging.
        """
        return pulumi.get(self, "command_logging")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsResult(dict):
    def __init__(__self__, *,
                 copy: str,
                 dcp: bool,
                 dd: bool,
                 dk: bool,
                 download: str,
                 dp: bool,
                 du: bool,
                 keyboard: str,
                 paste: str,
                 printing: str,
                 upload: str,
                 version: str):
        """
        :param str copy: Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        :param bool dcp: Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        :param bool dd: Set to false to enable downloading. Only applies when `version == "v1"`.
        :param bool dk: Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        :param str download: Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        :param bool dp: Set to false to enable printing. Only applies when `version == "v1"`.
        :param bool du: Set to false to enable uploading. Only applies when `version == "v1"`.
        :param str keyboard: Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        :param str paste: Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        :param str printing: Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        :param str upload: Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        :param str version: Indicates which version of the browser isolation controls should apply.
        """
        pulumi.set(__self__, "copy", copy)
        pulumi.set(__self__, "dcp", dcp)
        pulumi.set(__self__, "dd", dd)
        pulumi.set(__self__, "dk", dk)
        pulumi.set(__self__, "download", download)
        pulumi.set(__self__, "dp", dp)
        pulumi.set(__self__, "du", du)
        pulumi.set(__self__, "keyboard", keyboard)
        pulumi.set(__self__, "paste", paste)
        pulumi.set(__self__, "printing", printing)
        pulumi.set(__self__, "upload", upload)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def copy(self) -> str:
        """
        Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "copy")

    @property
    @pulumi.getter
    def dcp(self) -> bool:
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dcp")

    @property
    @pulumi.getter
    def dd(self) -> bool:
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dd")

    @property
    @pulumi.getter
    def dk(self) -> bool:
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dk")

    @property
    @pulumi.getter
    def download(self) -> str:
        """
        Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "download")

    @property
    @pulumi.getter
    def dp(self) -> bool:
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dp")

    @property
    @pulumi.getter
    def du(self) -> bool:
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "du")

    @property
    @pulumi.getter
    def keyboard(self) -> str:
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "keyboard")

    @property
    @pulumi.getter
    def paste(self) -> str:
        """
        Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "paste")

    @property
    @pulumi.getter
    def printing(self) -> str:
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "printing")

    @property
    @pulumi.getter
    def upload(self) -> str:
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "upload")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Indicates which version of the browser isolation controls should apply.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsCheckSessionResult(dict):
    def __init__(__self__, *,
                 duration: str,
                 enforce: bool):
        """
        :param str duration: Configure how fresh the session needs to be to be considered valid.
        :param bool enforce: Set to true to enable session enforcement.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enforce(self) -> bool:
        """
        Set to true to enable session enforcement.
        """
        return pulumi.get(self, "enforce")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsDnsResolversResult(dict):
    def __init__(__self__, *,
                 ipv4s: Sequence['outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Result'],
                 ipv6s: Sequence['outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Result']):
        pulumi.set(__self__, "ipv4s", ipv4s)
        pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Sequence['outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Result']:
        return pulumi.get(self, "ipv4s")

    @property
    @pulumi.getter
    def ipv6s(self) -> Sequence['outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Result']:
        return pulumi.get(self, "ipv6s")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Result(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int,
                 route_through_private_network: bool,
                 vnet_id: str):
        """
        :param str ip: IPv4 address of upstream resolver.
        :param int port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param str vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> bool:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Result(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int,
                 route_through_private_network: bool,
                 vnet_id: str):
        """
        :param str ip: IPv6 address of upstream resolver.
        :param int port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param str vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv6 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> bool:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsEgressResult(dict):
    def __init__(__self__, *,
                 ipv4: str,
                 ipv4_fallback: str,
                 ipv6: str):
        """
        :param str ipv4: The IPv4 address to be used for egress.
        :param str ipv4_fallback: The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        :param str ipv6: The IPv6 range to be used for egress.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)
        pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> str:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> str:
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @property
    @pulumi.getter
    def ipv6(self) -> str:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsL4overrideResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int):
        """
        :param str ip: IPv4 or IPv6 address.
        :param int port: A port number to use for TCP/UDP overrides.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        A port number to use for TCP/UDP overrides.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsNotificationSettingsResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 msg: str,
                 support_url: str):
        """
        :param bool enabled: Set notification on
        :param str msg: Customize the message shown in the notification.
        :param str support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "msg", msg)
        pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Set notification on
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def msg(self) -> str:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> str:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsPayloadLogResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Set to true to enable DLP payload logging for this rule.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Set to true to enable DLP payload logging for this rule.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsQuarantineResult(dict):
    def __init__(__self__, *,
                 file_types: Sequence[str]):
        """
        :param Sequence[str] file_types: Types of files to sandbox.
        """
        pulumi.set(__self__, "file_types", file_types)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Sequence[str]:
        """
        Types of files to sandbox.
        """
        return pulumi.get(self, "file_types")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyResult(dict):
    def __init__(__self__, *,
                 fallback: str,
                 view_id: str):
        """
        :param str fallback: The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        :param str view_id: The internal DNS view identifier that's passed to the internal DNS service.
        """
        pulumi.set(__self__, "fallback", fallback)
        pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter
    def fallback(self) -> str:
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        """
        return pulumi.get(self, "fallback")

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> str:
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
        return pulumi.get(self, "view_id")


@pulumi.output_type
class GetZeroTrustGatewayPolicyRuleSettingsUntrustedCertResult(dict):
    def __init__(__self__, *,
                 action: str):
        """
        :param str action: The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class GetZeroTrustGatewayPolicyScheduleResult(dict):
    def __init__(__self__, *,
                 fri: str,
                 mon: str,
                 sat: str,
                 sun: str,
                 thu: str,
                 time_zone: str,
                 tue: str,
                 wed: str):
        """
        :param str fri: The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        :param str mon: The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        :param str sat: The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        :param str sun: The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        :param str thu: The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        :param str time_zone: The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        :param str tue: The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        :param str wed: The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        pulumi.set(__self__, "fri", fri)
        pulumi.set(__self__, "mon", mon)
        pulumi.set(__self__, "sat", sat)
        pulumi.set(__self__, "sun", sun)
        pulumi.set(__self__, "thu", thu)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "tue", tue)
        pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> str:
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        return pulumi.get(self, "fri")

    @property
    @pulumi.getter
    def mon(self) -> str:
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        return pulumi.get(self, "mon")

    @property
    @pulumi.getter
    def sat(self) -> str:
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        return pulumi.get(self, "sat")

    @property
    @pulumi.getter
    def sun(self) -> str:
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        return pulumi.get(self, "sun")

    @property
    @pulumi.getter
    def thu(self) -> str:
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        return pulumi.get(self, "thu")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def tue(self) -> str:
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        return pulumi.get(self, "tue")

    @property
    @pulumi.getter
    def wed(self) -> str:
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        return pulumi.get(self, "wed")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsResult(dict):
    def __init__(__self__, *,
                 activity_log: 'outputs.GetZeroTrustGatewaySettingsSettingsActivityLogResult',
                 antivirus: 'outputs.GetZeroTrustGatewaySettingsSettingsAntivirusResult',
                 block_page: 'outputs.GetZeroTrustGatewaySettingsSettingsBlockPageResult',
                 body_scanning: 'outputs.GetZeroTrustGatewaySettingsSettingsBodyScanningResult',
                 browser_isolation: 'outputs.GetZeroTrustGatewaySettingsSettingsBrowserIsolationResult',
                 certificate: 'outputs.GetZeroTrustGatewaySettingsSettingsCertificateResult',
                 custom_certificate: 'outputs.GetZeroTrustGatewaySettingsSettingsCustomCertificateResult',
                 extended_email_matching: 'outputs.GetZeroTrustGatewaySettingsSettingsExtendedEmailMatchingResult',
                 fips: 'outputs.GetZeroTrustGatewaySettingsSettingsFipsResult',
                 protocol_detection: 'outputs.GetZeroTrustGatewaySettingsSettingsProtocolDetectionResult',
                 sandbox: 'outputs.GetZeroTrustGatewaySettingsSettingsSandboxResult',
                 tls_decrypt: 'outputs.GetZeroTrustGatewaySettingsSettingsTlsDecryptResult'):
        """
        :param 'GetZeroTrustGatewaySettingsSettingsActivityLogArgs' activity_log: Activity log settings.
        :param 'GetZeroTrustGatewaySettingsSettingsAntivirusArgs' antivirus: Anti-virus settings.
        :param 'GetZeroTrustGatewaySettingsSettingsBlockPageArgs' block_page: Block page layout settings.
        :param 'GetZeroTrustGatewaySettingsSettingsBodyScanningArgs' body_scanning: DLP body scanning settings.
        :param 'GetZeroTrustGatewaySettingsSettingsBrowserIsolationArgs' browser_isolation: Browser isolation settings.
        :param 'GetZeroTrustGatewaySettingsSettingsCertificateArgs' certificate: Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        :param 'GetZeroTrustGatewaySettingsSettingsCustomCertificateArgs' custom_certificate: Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
        :param 'GetZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs' extended_email_matching: Extended e-mail matching settings.
        :param 'GetZeroTrustGatewaySettingsSettingsFipsArgs' fips: FIPS settings.
        :param 'GetZeroTrustGatewaySettingsSettingsProtocolDetectionArgs' protocol_detection: Protocol Detection settings.
        :param 'GetZeroTrustGatewaySettingsSettingsSandboxArgs' sandbox: Sandbox settings.
        :param 'GetZeroTrustGatewaySettingsSettingsTlsDecryptArgs' tls_decrypt: TLS interception settings.
        """
        pulumi.set(__self__, "activity_log", activity_log)
        pulumi.set(__self__, "antivirus", antivirus)
        pulumi.set(__self__, "block_page", block_page)
        pulumi.set(__self__, "body_scanning", body_scanning)
        pulumi.set(__self__, "browser_isolation", browser_isolation)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "custom_certificate", custom_certificate)
        pulumi.set(__self__, "extended_email_matching", extended_email_matching)
        pulumi.set(__self__, "fips", fips)
        pulumi.set(__self__, "protocol_detection", protocol_detection)
        pulumi.set(__self__, "sandbox", sandbox)
        pulumi.set(__self__, "tls_decrypt", tls_decrypt)

    @property
    @pulumi.getter(name="activityLog")
    def activity_log(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsActivityLogResult':
        """
        Activity log settings.
        """
        return pulumi.get(self, "activity_log")

    @property
    @pulumi.getter
    def antivirus(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsAntivirusResult':
        """
        Anti-virus settings.
        """
        return pulumi.get(self, "antivirus")

    @property
    @pulumi.getter(name="blockPage")
    def block_page(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsBlockPageResult':
        """
        Block page layout settings.
        """
        return pulumi.get(self, "block_page")

    @property
    @pulumi.getter(name="bodyScanning")
    def body_scanning(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsBodyScanningResult':
        """
        DLP body scanning settings.
        """
        return pulumi.get(self, "body_scanning")

    @property
    @pulumi.getter(name="browserIsolation")
    def browser_isolation(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsBrowserIsolationResult':
        """
        Browser isolation settings.
        """
        return pulumi.get(self, "browser_isolation")

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsCertificateResult':
        """
        Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsCustomCertificateResult':
        """
        Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="extendedEmailMatching")
    def extended_email_matching(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsExtendedEmailMatchingResult':
        """
        Extended e-mail matching settings.
        """
        return pulumi.get(self, "extended_email_matching")

    @property
    @pulumi.getter
    def fips(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsFipsResult':
        """
        FIPS settings.
        """
        return pulumi.get(self, "fips")

    @property
    @pulumi.getter(name="protocolDetection")
    def protocol_detection(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsProtocolDetectionResult':
        """
        Protocol Detection settings.
        """
        return pulumi.get(self, "protocol_detection")

    @property
    @pulumi.getter
    def sandbox(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsSandboxResult':
        """
        Sandbox settings.
        """
        return pulumi.get(self, "sandbox")

    @property
    @pulumi.getter(name="tlsDecrypt")
    def tls_decrypt(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsTlsDecryptResult':
        """
        TLS interception settings.
        """
        return pulumi.get(self, "tls_decrypt")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsActivityLogResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Enable activity logging.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable activity logging.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsAntivirusResult(dict):
    def __init__(__self__, *,
                 enabled_download_phase: bool,
                 enabled_upload_phase: bool,
                 fail_closed: bool,
                 notification_settings: 'outputs.GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsResult'):
        """
        :param bool enabled_download_phase: Enable anti-virus scanning on downloads.
        :param bool enabled_upload_phase: Enable anti-virus scanning on uploads.
        :param bool fail_closed: Block requests for files that cannot be scanned.
        :param 'GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs' notification_settings: Configure a message to display on the user's device when an antivirus search is performed.
        """
        pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        pulumi.set(__self__, "fail_closed", fail_closed)
        pulumi.set(__self__, "notification_settings", notification_settings)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> bool:
        """
        Enable anti-virus scanning on downloads.
        """
        return pulumi.get(self, "enabled_download_phase")

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> bool:
        """
        Enable anti-virus scanning on uploads.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> bool:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> 'outputs.GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsResult':
        """
        Configure a message to display on the user's device when an antivirus search is performed.
        """
        return pulumi.get(self, "notification_settings")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 msg: str,
                 support_url: str):
        """
        :param bool enabled: Set notification on
        :param str msg: Customize the message shown in the notification.
        :param str support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "msg", msg)
        pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Set notification on
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def msg(self) -> str:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> str:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsBlockPageResult(dict):
    def __init__(__self__, *,
                 background_color: str,
                 enabled: bool,
                 footer_text: str,
                 header_text: str,
                 logo_path: str,
                 mailto_address: str,
                 mailto_subject: str,
                 name: str,
                 suppress_footer: bool):
        """
        :param str background_color: Block page background color in #rrggbb format.
        :param bool enabled: Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        :param str footer_text: Block page footer text.
        :param str header_text: Block page header text.
        :param str logo_path: Full URL to the logo file.
        :param str mailto_address: Admin email for users to contact.
        :param str mailto_subject: Subject line for emails created from block page.
        :param str name: Block page title.
        :param bool suppress_footer: Suppress detailed info at the bottom of the block page.
        """
        pulumi.set(__self__, "background_color", background_color)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "footer_text", footer_text)
        pulumi.set(__self__, "header_text", header_text)
        pulumi.set(__self__, "logo_path", logo_path)
        pulumi.set(__self__, "mailto_address", mailto_address)
        pulumi.set(__self__, "mailto_subject", mailto_subject)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "suppress_footer", suppress_footer)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> str:
        """
        Block page background color in #rrggbb format.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> str:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> str:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> str:
        """
        Full URL to the logo file.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> str:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> str:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Block page title.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="suppressFooter")
    def suppress_footer(self) -> bool:
        """
        Suppress detailed info at the bottom of the block page.
        """
        return pulumi.get(self, "suppress_footer")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsBodyScanningResult(dict):
    def __init__(__self__, *,
                 inspection_mode: str):
        """
        :param str inspection_mode: Set the inspection mode to either `deep` or `shallow`.
        """
        pulumi.set(__self__, "inspection_mode", inspection_mode)

    @property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> str:
        """
        Set the inspection mode to either `deep` or `shallow`.
        """
        return pulumi.get(self, "inspection_mode")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsBrowserIsolationResult(dict):
    def __init__(__self__, *,
                 non_identity_enabled: bool,
                 url_browser_isolation_enabled: bool):
        """
        :param bool non_identity_enabled: Enable non-identity onramp support for Browser Isolation.
        :param bool url_browser_isolation_enabled: Enable Clientless Browser Isolation.
        """
        pulumi.set(__self__, "non_identity_enabled", non_identity_enabled)
        pulumi.set(__self__, "url_browser_isolation_enabled", url_browser_isolation_enabled)

    @property
    @pulumi.getter(name="nonIdentityEnabled")
    def non_identity_enabled(self) -> bool:
        """
        Enable non-identity onramp support for Browser Isolation.
        """
        return pulumi.get(self, "non_identity_enabled")

    @property
    @pulumi.getter(name="urlBrowserIsolationEnabled")
    def url_browser_isolation_enabled(self) -> bool:
        """
        Enable Clientless Browser Isolation.
        """
        return pulumi.get(self, "url_browser_isolation_enabled")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsCertificateResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsCustomCertificateResult(dict):
    def __init__(__self__, *,
                 binding_status: str,
                 enabled: bool,
                 id: str,
                 updated_at: str):
        """
        :param str binding_status: Certificate status (internal).
        :param bool enabled: Enable use of custom certificate authority for signing Gateway traffic.
        :param str id: UUID of certificate (ID from MTLS certificate store).
        """
        pulumi.set(__self__, "binding_status", binding_status)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="bindingStatus")
    def binding_status(self) -> str:
        """
        Certificate status (internal).
        """
        return pulumi.get(self, "binding_status")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable use of custom certificate authority for signing Gateway traffic.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of certificate (ID from MTLS certificate store).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsExtendedEmailMatchingResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsFipsResult(dict):
    def __init__(__self__, *,
                 tls: bool):
        """
        :param bool tls: Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> bool:
        """
        Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsProtocolDetectionResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Enable detecting protocol on initial bytes of client traffic.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable detecting protocol on initial bytes of client traffic.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsSandboxResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 fallback_action: str):
        """
        :param bool enabled: Enable sandbox.
        :param str fallback_action: Action to take when the file cannot be scanned.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "fallback_action", fallback_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable sandbox.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> str:
        """
        Action to take when the file cannot be scanned.
        """
        return pulumi.get(self, "fallback_action")


@pulumi.output_type
class GetZeroTrustGatewaySettingsSettingsTlsDecryptResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Enable inspecting encrypted HTTP traffic.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable inspecting encrypted HTTP traffic.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustListFilterResult(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: The type of list.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of list.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetZeroTrustListsResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 description: str,
                 id: str,
                 list_count: float,
                 name: str,
                 type: str,
                 updated_at: str):
        """
        :param str description: The description of the list.
        :param str id: API Resource UUID tag.
        :param float list_count: The number of items in the list.
        :param str name: The name of the list.
        :param str type: The type of list.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "list_count", list_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the list.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        API Resource UUID tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="listCount")
    def list_count(self) -> float:
        """
        The number of items in the list.
        """
        return pulumi.get(self, "list_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the list.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of list.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetZeroTrustOrganizationCustomPagesResult(dict):
    def __init__(__self__, *,
                 forbidden: str,
                 identity_denied: str):
        """
        :param str forbidden: The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        :param str identity_denied: The uid of the custom page to use when a user is denied access.
        """
        pulumi.set(__self__, "forbidden", forbidden)
        pulumi.set(__self__, "identity_denied", identity_denied)

    @property
    @pulumi.getter
    def forbidden(self) -> str:
        """
        The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        """
        return pulumi.get(self, "forbidden")

    @property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> str:
        """
        The uid of the custom page to use when a user is denied access.
        """
        return pulumi.get(self, "identity_denied")


@pulumi.output_type
class GetZeroTrustOrganizationLoginDesignResult(dict):
    def __init__(__self__, *,
                 background_color: str,
                 footer_text: str,
                 header_text: str,
                 logo_path: str,
                 text_color: str):
        """
        :param str background_color: The background color on your login page.
        :param str footer_text: The text at the bottom of your login page.
        :param str header_text: The text at the top of your login page.
        :param str logo_path: The URL of the logo on your login page.
        :param str text_color: The text color on your login page.
        """
        pulumi.set(__self__, "background_color", background_color)
        pulumi.set(__self__, "footer_text", footer_text)
        pulumi.set(__self__, "header_text", header_text)
        pulumi.set(__self__, "logo_path", logo_path)
        pulumi.set(__self__, "text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> str:
        """
        The background color on your login page.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> str:
        """
        The text at the bottom of your login page.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> str:
        """
        The text at the top of your login page.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> str:
        """
        The URL of the logo on your login page.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> str:
        """
        The text color on your login page.
        """
        return pulumi.get(self, "text_color")


@pulumi.output_type
class GetZeroTrustRiskBehaviorBehaviorsResult(dict):
    def __init__(__self__, *,
                 description: str,
                 enabled: bool,
                 name: str,
                 risk_level: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetZeroTrustRiskScoringIntegrationsResultResult(dict):
    def __init__(__self__, *,
                 account_tag: str,
                 active: bool,
                 created_at: str,
                 id: str,
                 integration_type: str,
                 reference_id: str,
                 tenant_url: str,
                 well_known_url: str):
        """
        :param str account_tag: The Cloudflare account tag.
        :param bool active: Whether this integration is enabled and should export changes in risk score.
        :param str created_at: When the integration was created in RFC3339 format.
        :param str id: The id of the integration, a UUIDv4.
        :param str reference_id: A reference ID defined by the client.
               Should be set to the Access-Okta IDP integration ID.
               Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that ID.
        :param str tenant_url: The base URL for the tenant. E.g. "https://tenant.okta.com"
        :param str well_known_url: The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration*uuid}/". https://openid.net/specs/openid-sse-framework-1*0.html#rfc.section.6.2.1
        """
        pulumi.set(__self__, "account_tag", account_tag)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "reference_id", reference_id)
        pulumi.set(__self__, "tenant_url", tenant_url)
        pulumi.set(__self__, "well_known_url", well_known_url)

    @property
    @pulumi.getter(name="accountTag")
    def account_tag(self) -> str:
        """
        The Cloudflare account tag.
        """
        return pulumi.get(self, "account_tag")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Whether this integration is enabled and should export changes in risk score.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        When the integration was created in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the integration, a UUIDv4.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> str:
        """
        A reference ID defined by the client.
        Should be set to the Access-Okta IDP integration ID.
        Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that ID.
        """
        return pulumi.get(self, "reference_id")

    @property
    @pulumi.getter(name="tenantUrl")
    def tenant_url(self) -> str:
        """
        The base URL for the tenant. E.g. "https://tenant.okta.com"
        """
        return pulumi.get(self, "tenant_url")

    @property
    @pulumi.getter(name="wellKnownUrl")
    def well_known_url(self) -> str:
        """
        The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration*uuid}/". https://openid.net/specs/openid-sse-framework-1*0.html#rfc.section.6.2.1
        """
        return pulumi.get(self, "well_known_url")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredConfigConfigResult(dict):
    def __init__(__self__, *,
                 ingresses: Sequence['outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressResult'],
                 origin_request: 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestResult',
                 warp_routing: 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigWarpRoutingResult'):
        """
        :param Sequence['GetZeroTrustTunnelCloudflaredConfigConfigIngressArgs'] ingresses: List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        :param 'GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs' origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param 'GetZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs' warp_routing: Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        pulumi.set(__self__, "ingresses", ingresses)
        pulumi.set(__self__, "origin_request", origin_request)
        pulumi.set(__self__, "warp_routing", warp_routing)

    @property
    @pulumi.getter
    def ingresses(self) -> Sequence['outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressResult']:
        """
        List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        """
        return pulumi.get(self, "ingresses")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestResult':
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigWarpRoutingResult':
        """
        Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        return pulumi.get(self, "warp_routing")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredConfigConfigIngressResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 origin_request: 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestResult',
                 path: str,
                 service: str):
        """
        :param str hostname: Public hostname for this service.
        :param 'GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs' origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param str path: Requests with this path route to this public hostname.
        :param str service: Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "origin_request", origin_request)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Public hostname for this service.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestResult':
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Requests with this path route to this public hostname.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestResult(dict):
    def __init__(__self__, *,
                 access: 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessResult',
                 ca_pool: str,
                 connect_timeout: int,
                 disable_chunked_encoding: bool,
                 http2_origin: bool,
                 http_host_header: str,
                 keep_alive_connections: int,
                 keep_alive_timeout: int,
                 no_happy_eyeballs: bool,
                 no_tls_verify: bool,
                 origin_server_name: str,
                 proxy_type: str,
                 tcp_keep_alive: int,
                 tls_timeout: int):
        """
        :param 'GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs' access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param str ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param int connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param bool disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param bool http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param str http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param int keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param int keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param bool no_happy_eyeballs: Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param bool no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param str origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param str proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param int tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param int tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "ca_pool", ca_pool)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        pulumi.set(__self__, "http2_origin", http2_origin)
        pulumi.set(__self__, "http_host_header", http_host_header)
        pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        pulumi.set(__self__, "origin_server_name", origin_server_name)
        pulumi.set(__self__, "proxy_type", proxy_type)
        pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessResult':
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> str:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> bool:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> bool:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> str:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> int:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> int:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> bool:
        """
        Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> bool:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> str:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> str:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> int:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> int:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessResult(dict):
    def __init__(__self__, *,
                 aud_tags: Sequence[str],
                 required: bool,
                 team_name: str):
        """
        :param Sequence[str] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param bool required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Sequence[str]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        return pulumi.get(self, "team_name")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestResult(dict):
    def __init__(__self__, *,
                 access: 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessResult',
                 ca_pool: str,
                 connect_timeout: int,
                 disable_chunked_encoding: bool,
                 http2_origin: bool,
                 http_host_header: str,
                 keep_alive_connections: int,
                 keep_alive_timeout: int,
                 no_happy_eyeballs: bool,
                 no_tls_verify: bool,
                 origin_server_name: str,
                 proxy_type: str,
                 tcp_keep_alive: int,
                 tls_timeout: int):
        """
        :param 'GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs' access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param str ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param int connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param bool disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param bool http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param str http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param int keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param int keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param bool no_happy_eyeballs: Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param bool no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param str origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param str proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param int tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param int tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "ca_pool", ca_pool)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        pulumi.set(__self__, "http2_origin", http2_origin)
        pulumi.set(__self__, "http_host_header", http_host_header)
        pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        pulumi.set(__self__, "origin_server_name", origin_server_name)
        pulumi.set(__self__, "proxy_type", proxy_type)
        pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> 'outputs.GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessResult':
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> str:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> bool:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> bool:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> str:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> int:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> int:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> bool:
        """
        Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> bool:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> str:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> str:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> int:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> int:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessResult(dict):
    def __init__(__self__, *,
                 aud_tags: Sequence[str],
                 required: bool,
                 team_name: str):
        """
        :param Sequence[str] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param bool required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Sequence[str]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        return pulumi.get(self, "team_name")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredConfigConfigWarpRoutingResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredConnectionResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_version: str,
                 colo_name: str,
                 id: str,
                 is_pending_reconnect: bool,
                 opened_at: str,
                 origin_ip: str,
                 uuid: str):
        """
        :param str client_id: UUID of the Cloudflare Tunnel connector.
        :param str client_version: The cloudflared version used to establish this connection.
        :param str colo_name: The Cloudflare data center used for this connection.
        :param str id: UUID of the Cloudflare Tunnel connection.
        :param bool is_pending_reconnect: Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        :param str opened_at: Timestamp of when the connection was established.
        :param str origin_ip: The public IP address of the host running cloudflared.
        :param str uuid: UUID of the Cloudflare Tunnel connection.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_version", client_version)
        pulumi.set(__self__, "colo_name", colo_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_pending_reconnect", is_pending_reconnect)
        pulumi.set(__self__, "opened_at", opened_at)
        pulumi.set(__self__, "origin_ip", origin_ip)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        UUID of the Cloudflare Tunnel connector.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientVersion")
    def client_version(self) -> str:
        """
        The cloudflared version used to establish this connection.
        """
        return pulumi.get(self, "client_version")

    @property
    @pulumi.getter(name="coloName")
    def colo_name(self) -> str:
        """
        The Cloudflare data center used for this connection.
        """
        return pulumi.get(self, "colo_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPendingReconnect")
    def is_pending_reconnect(self) -> bool:
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        return pulumi.get(self, "is_pending_reconnect")

    @property
    @pulumi.getter(name="openedAt")
    def opened_at(self) -> str:
        """
        Timestamp of when the connection was established.
        """
        return pulumi.get(self, "opened_at")

    @property
    @pulumi.getter(name="originIp")
    def origin_ip(self) -> str:
        """
        The public IP address of the host running cloudflared.
        """
        return pulumi.get(self, "origin_ip")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredFilterResult(dict):
    def __init__(__self__, *,
                 exclude_prefix: Optional[str] = None,
                 existed_at: Optional[str] = None,
                 include_prefix: Optional[str] = None,
                 is_deleted: Optional[bool] = None,
                 name: Optional[str] = None,
                 status: Optional[str] = None,
                 uuid: Optional[str] = None,
                 was_active_at: Optional[str] = None,
                 was_inactive_at: Optional[str] = None):
        """
        :param str existed_at: If provided, include only tunnels that were created (and not deleted) before this time.
        :param bool is_deleted: If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        :param str name: A user-friendly name for a tunnel.
        :param str status: The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        :param str uuid: UUID of the tunnel.
        """
        if exclude_prefix is not None:
            pulumi.set(__self__, "exclude_prefix", exclude_prefix)
        if existed_at is not None:
            pulumi.set(__self__, "existed_at", existed_at)
        if include_prefix is not None:
            pulumi.set(__self__, "include_prefix", include_prefix)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if was_active_at is not None:
            pulumi.set(__self__, "was_active_at", was_active_at)
        if was_inactive_at is not None:
            pulumi.set(__self__, "was_inactive_at", was_inactive_at)

    @property
    @pulumi.getter(name="excludePrefix")
    def exclude_prefix(self) -> Optional[str]:
        return pulumi.get(self, "exclude_prefix")

    @property
    @pulumi.getter(name="existedAt")
    def existed_at(self) -> Optional[str]:
        """
        If provided, include only tunnels that were created (and not deleted) before this time.
        """
        return pulumi.get(self, "existed_at")

    @property
    @pulumi.getter(name="includePrefix")
    def include_prefix(self) -> Optional[str]:
        return pulumi.get(self, "include_prefix")

    @property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[bool]:
        """
        If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        """
        return pulumi.get(self, "is_deleted")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A user-friendly name for a tunnel.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter(name="wasActiveAt")
    def was_active_at(self) -> Optional[str]:
        return pulumi.get(self, "was_active_at")

    @property
    @pulumi.getter(name="wasInactiveAt")
    def was_inactive_at(self) -> Optional[str]:
        return pulumi.get(self, "was_inactive_at")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredRouteFilterResult(dict):
    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 existed_at: Optional[str] = None,
                 is_deleted: Optional[bool] = None,
                 network_subset: Optional[str] = None,
                 network_superset: Optional[str] = None,
                 route_id: Optional[str] = None,
                 tun_types: Optional[str] = None,
                 tunnel_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str comment: Optional remark describing the route.
        :param str existed_at: If provided, include only tunnels that were created (and not deleted) before this time.
        :param bool is_deleted: If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
        :param str network_subset: If set, only list routes that are contained within this IP range.
        :param str network_superset: If set, only list routes that contain this IP range.
        :param str route_id: UUID of the route.
        :param str tun_types: The types of tunnels to filter separated by a comma.
        :param str tunnel_id: UUID of the tunnel.
        :param str virtual_network_id: UUID of the virtual network.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if existed_at is not None:
            pulumi.set(__self__, "existed_at", existed_at)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if network_subset is not None:
            pulumi.set(__self__, "network_subset", network_subset)
        if network_superset is not None:
            pulumi.set(__self__, "network_superset", network_superset)
        if route_id is not None:
            pulumi.set(__self__, "route_id", route_id)
        if tun_types is not None:
            pulumi.set(__self__, "tun_types", tun_types)
        if tunnel_id is not None:
            pulumi.set(__self__, "tunnel_id", tunnel_id)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Optional remark describing the route.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="existedAt")
    def existed_at(self) -> Optional[str]:
        """
        If provided, include only tunnels that were created (and not deleted) before this time.
        """
        return pulumi.get(self, "existed_at")

    @property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[bool]:
        """
        If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
        """
        return pulumi.get(self, "is_deleted")

    @property
    @pulumi.getter(name="networkSubset")
    def network_subset(self) -> Optional[str]:
        """
        If set, only list routes that are contained within this IP range.
        """
        return pulumi.get(self, "network_subset")

    @property
    @pulumi.getter(name="networkSuperset")
    def network_superset(self) -> Optional[str]:
        """
        If set, only list routes that contain this IP range.
        """
        return pulumi.get(self, "network_superset")

    @property
    @pulumi.getter(name="routeId")
    def route_id(self) -> Optional[str]:
        """
        UUID of the route.
        """
        return pulumi.get(self, "route_id")

    @property
    @pulumi.getter(name="tunTypes")
    def tun_types(self) -> Optional[str]:
        """
        The types of tunnels to filter separated by a comma.
        """
        return pulumi.get(self, "tun_types")

    @property
    @pulumi.getter(name="tunnelId")
    def tunnel_id(self) -> Optional[str]:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "tunnel_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        UUID of the virtual network.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredRoutesResultResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 created_at: str,
                 deleted_at: str,
                 id: str,
                 network: str,
                 tun_type: str,
                 tunnel_id: str,
                 tunnel_name: str,
                 virtual_network_id: str,
                 virtual_network_name: str):
        """
        :param str comment: Optional remark describing the route.
        :param str created_at: Timestamp of when the resource was created.
        :param str deleted_at: Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
        :param str id: UUID of the route.
        :param str network: The private IPv4 or IPv6 range connected by the route, in CIDR notation.
        :param str tun_type: The type of tunnel.
        :param str tunnel_id: UUID of the tunnel.
        :param str tunnel_name: A user-friendly name for a tunnel.
        :param str virtual_network_id: UUID of the virtual network.
        :param str virtual_network_name: A user-friendly name for the virtual network.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "tun_type", tun_type)
        pulumi.set(__self__, "tunnel_id", tunnel_id)
        pulumi.set(__self__, "tunnel_name", tunnel_name)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        pulumi.set(__self__, "virtual_network_name", virtual_network_name)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Optional remark describing the route.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Timestamp of when the resource was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> str:
        """
        Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
        """
        return pulumi.get(self, "deleted_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of the route.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The private IPv4 or IPv6 range connected by the route, in CIDR notation.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="tunType")
    def tun_type(self) -> str:
        """
        The type of tunnel.
        """
        return pulumi.get(self, "tun_type")

    @property
    @pulumi.getter(name="tunnelId")
    def tunnel_id(self) -> str:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "tunnel_id")

    @property
    @pulumi.getter(name="tunnelName")
    def tunnel_name(self) -> str:
        """
        A user-friendly name for a tunnel.
        """
        return pulumi.get(self, "tunnel_name")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> str:
        """
        UUID of the virtual network.
        """
        return pulumi.get(self, "virtual_network_id")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> str:
        """
        A user-friendly name for the virtual network.
        """
        return pulumi.get(self, "virtual_network_name")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredVirtualNetworkFilterResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 is_default: Optional[bool] = None,
                 is_deleted: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str id: UUID of the virtual network.
        :param bool is_default: If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        :param bool is_deleted: If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
        :param str name: A user-friendly name for the virtual network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID of the virtual network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[bool]:
        """
        If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
        """
        return pulumi.get(self, "is_deleted")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A user-friendly name for the virtual network.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredVirtualNetworksResultResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 created_at: str,
                 deleted_at: str,
                 id: str,
                 is_default_network: bool,
                 name: str):
        """
        :param str comment: Optional remark describing the virtual network.
        :param str created_at: Timestamp of when the resource was created.
        :param str deleted_at: Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
        :param str id: UUID of the virtual network.
        :param bool is_default_network: If `true`, this virtual network is the default for the account.
        :param str name: A user-friendly name for the virtual network.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default_network", is_default_network)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Optional remark describing the virtual network.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Timestamp of when the resource was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> str:
        """
        Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
        """
        return pulumi.get(self, "deleted_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of the virtual network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefaultNetwork")
    def is_default_network(self) -> bool:
        """
        If `true`, this virtual network is the default for the account.
        """
        return pulumi.get(self, "is_default_network")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-friendly name for the virtual network.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredsResultResult(dict):
    def __init__(__self__, *,
                 account_tag: str,
                 connections: Sequence['outputs.GetZeroTrustTunnelCloudflaredsResultConnectionResult'],
                 conns_active_at: str,
                 conns_inactive_at: str,
                 created_at: str,
                 deleted_at: str,
                 id: str,
                 metadata: str,
                 name: str,
                 remote_config: bool,
                 status: str,
                 tun_type: str):
        """
        :param str account_tag: Cloudflare account ID
        :param Sequence['GetZeroTrustTunnelCloudflaredsResultConnectionArgs'] connections: The Cloudflare Tunnel connections between your origin and Cloudflare's edge.
        :param str conns_active_at: Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive.
        :param str conns_inactive_at: Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active.
        :param str created_at: Timestamp of when the resource was created.
        :param str deleted_at: Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
        :param str id: UUID of the tunnel.
        :param str metadata: Metadata associated with the tunnel.
        :param str name: A user-friendly name for a tunnel.
        :param bool remote_config: If `true`, the tunnel can be configured remotely from the Zero Trust dashboard. If `false`, the tunnel must be configured locally on the origin machine.
        :param str status: The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        :param str tun_type: The type of tunnel.
        """
        pulumi.set(__self__, "account_tag", account_tag)
        pulumi.set(__self__, "connections", connections)
        pulumi.set(__self__, "conns_active_at", conns_active_at)
        pulumi.set(__self__, "conns_inactive_at", conns_inactive_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remote_config", remote_config)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tun_type", tun_type)

    @property
    @pulumi.getter(name="accountTag")
    def account_tag(self) -> str:
        """
        Cloudflare account ID
        """
        return pulumi.get(self, "account_tag")

    @property
    @pulumi.getter
    def connections(self) -> Sequence['outputs.GetZeroTrustTunnelCloudflaredsResultConnectionResult']:
        """
        The Cloudflare Tunnel connections between your origin and Cloudflare's edge.
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter(name="connsActiveAt")
    def conns_active_at(self) -> str:
        """
        Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive.
        """
        return pulumi.get(self, "conns_active_at")

    @property
    @pulumi.getter(name="connsInactiveAt")
    def conns_inactive_at(self) -> str:
        """
        Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active.
        """
        return pulumi.get(self, "conns_inactive_at")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Timestamp of when the resource was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> str:
        """
        Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
        """
        return pulumi.get(self, "deleted_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        Metadata associated with the tunnel.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-friendly name for a tunnel.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="remoteConfig")
    def remote_config(self) -> bool:
        """
        If `true`, the tunnel can be configured remotely from the Zero Trust dashboard. If `false`, the tunnel must be configured locally on the origin machine.
        """
        return pulumi.get(self, "remote_config")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tunType")
    def tun_type(self) -> str:
        """
        The type of tunnel.
        """
        return pulumi.get(self, "tun_type")


@pulumi.output_type
class GetZeroTrustTunnelCloudflaredsResultConnectionResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_version: str,
                 colo_name: str,
                 id: str,
                 is_pending_reconnect: bool,
                 opened_at: str,
                 origin_ip: str,
                 uuid: str):
        """
        :param str client_id: UUID of the Cloudflare Tunnel connector.
        :param str client_version: The cloudflared version used to establish this connection.
        :param str colo_name: The Cloudflare data center used for this connection.
        :param str id: UUID of the Cloudflare Tunnel connection.
        :param bool is_pending_reconnect: Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        :param str opened_at: Timestamp of when the connection was established.
        :param str origin_ip: The public IP address of the host running cloudflared.
        :param str uuid: UUID of the Cloudflare Tunnel connection.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_version", client_version)
        pulumi.set(__self__, "colo_name", colo_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_pending_reconnect", is_pending_reconnect)
        pulumi.set(__self__, "opened_at", opened_at)
        pulumi.set(__self__, "origin_ip", origin_ip)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        UUID of the Cloudflare Tunnel connector.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientVersion")
    def client_version(self) -> str:
        """
        The cloudflared version used to establish this connection.
        """
        return pulumi.get(self, "client_version")

    @property
    @pulumi.getter(name="coloName")
    def colo_name(self) -> str:
        """
        The Cloudflare data center used for this connection.
        """
        return pulumi.get(self, "colo_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPendingReconnect")
    def is_pending_reconnect(self) -> bool:
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        return pulumi.get(self, "is_pending_reconnect")

    @property
    @pulumi.getter(name="openedAt")
    def opened_at(self) -> str:
        """
        Timestamp of when the connection was established.
        """
        return pulumi.get(self, "opened_at")

    @property
    @pulumi.getter(name="originIp")
    def origin_ip(self) -> str:
        """
        The public IP address of the host running cloudflared.
        """
        return pulumi.get(self, "origin_ip")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetZoneAccountResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: Identifier
        :param str name: The name of the account
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the account
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZoneFilterResult(dict):
    def __init__(__self__, *,
                 match: str,
                 account: Optional['outputs.GetZoneFilterAccountResult'] = None,
                 direction: Optional[str] = None,
                 name: Optional[str] = None,
                 order: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str match: Whether to match all search requirements or at least one (any).
        :param str direction: Direction to order zones.
        :param str name: A domain name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        :param str order: Field to order zones by.
        :param str status: A zone status
        """
        pulumi.set(__self__, "match", match)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        Whether to match all search requirements or at least one (any).
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def account(self) -> Optional['outputs.GetZoneFilterAccountResult']:
        return pulumi.get(self, "account")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order zones.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A domain name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order zones by.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        A zone status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetZoneFilterAccountResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: An account ID
        :param str name: An account Name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        An account ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZoneLockdownConfigurationResult(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        :param str value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetZoneLockdownFilterResult(dict):
    def __init__(__self__, *,
                 created_on: Optional[str] = None,
                 description: Optional[str] = None,
                 description_search: Optional[str] = None,
                 ip: Optional[str] = None,
                 ip_range_search: Optional[str] = None,
                 ip_search: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 priority: Optional[float] = None,
                 uri_search: Optional[str] = None):
        """
        :param str created_on: The timestamp of when the rule was created.
        :param str description: A string to search for in the description of existing rules.
        :param str description_search: A string to search for in the description of existing rules.
        :param str ip: A single IP address to search for in existing rules.
        :param str ip_range_search: A single IP address range to search for in existing rules.
        :param str ip_search: A single IP address to search for in existing rules.
        :param str modified_on: The timestamp of when the rule was last modified.
        :param float priority: The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
        :param str uri_search: A single URI to search for in the list of URLs of existing rules.
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if description_search is not None:
            pulumi.set(__self__, "description_search", description_search)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range_search is not None:
            pulumi.set(__self__, "ip_range_search", ip_range_search)
        if ip_search is not None:
            pulumi.set(__self__, "ip_search", ip_search)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if uri_search is not None:
            pulumi.set(__self__, "uri_search", uri_search)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        The timestamp of when the rule was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A string to search for in the description of existing rules.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="descriptionSearch")
    def description_search(self) -> Optional[str]:
        """
        A string to search for in the description of existing rules.
        """
        return pulumi.get(self, "description_search")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        A single IP address to search for in existing rules.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRangeSearch")
    def ip_range_search(self) -> Optional[str]:
        """
        A single IP address range to search for in existing rules.
        """
        return pulumi.get(self, "ip_range_search")

    @property
    @pulumi.getter(name="ipSearch")
    def ip_search(self) -> Optional[str]:
        """
        A single IP address to search for in existing rules.
        """
        return pulumi.get(self, "ip_search")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        The timestamp of when the rule was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="uriSearch")
    def uri_search(self) -> Optional[str]:
        """
        A single URI to search for in the list of URLs of existing rules.
        """
        return pulumi.get(self, "uri_search")


@pulumi.output_type
class GetZoneLockdownsResultResult(dict):
    def __init__(__self__, *,
                 configurations: Sequence['outputs.GetZoneLockdownsResultConfigurationResult'],
                 created_on: str,
                 description: str,
                 id: str,
                 modified_on: str,
                 paused: bool,
                 urls: Sequence[str]):
        """
        :param Sequence['GetZoneLockdownsResultConfigurationArgs'] configurations: A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ip_range` configurations.
        :param str created_on: The timestamp of when the rule was created.
        :param str description: An informative summary of the rule.
        :param str id: The unique identifier of the Zone Lockdown rule.
        :param str modified_on: The timestamp of when the rule was last modified.
        :param bool paused: When true, indicates that the rule is currently paused.
        :param Sequence[str] urls: The URLs to include in the rule definition. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
        """
        pulumi.set(__self__, "configurations", configurations)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetZoneLockdownsResultConfigurationResult']:
        """
        A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ip_range` configurations.
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The timestamp of when the rule was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An informative summary of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the Zone Lockdown rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The timestamp of when the rule was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        When true, indicates that the rule is currently paused.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        """
        The URLs to include in the rule definition. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetZoneLockdownsResultConfigurationResult(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        :param str value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetZoneMetaResult(dict):
    def __init__(__self__, *,
                 cdn_only: bool,
                 custom_certificate_quota: int,
                 dns_only: bool,
                 foundation_dns: bool,
                 page_rule_quota: int,
                 phishing_detected: bool,
                 step: int):
        """
        :param bool cdn_only: The zone is only configured for CDN
        :param int custom_certificate_quota: Number of Custom Certificates the zone can have
        :param bool dns_only: The zone is only configured for DNS
        :param bool foundation_dns: The zone is setup with Foundation DNS
        :param int page_rule_quota: Number of Page Rules a zone can have
        :param bool phishing_detected: The zone has been flagged for phishing
        """
        pulumi.set(__self__, "cdn_only", cdn_only)
        pulumi.set(__self__, "custom_certificate_quota", custom_certificate_quota)
        pulumi.set(__self__, "dns_only", dns_only)
        pulumi.set(__self__, "foundation_dns", foundation_dns)
        pulumi.set(__self__, "page_rule_quota", page_rule_quota)
        pulumi.set(__self__, "phishing_detected", phishing_detected)
        pulumi.set(__self__, "step", step)

    @property
    @pulumi.getter(name="cdnOnly")
    def cdn_only(self) -> bool:
        """
        The zone is only configured for CDN
        """
        return pulumi.get(self, "cdn_only")

    @property
    @pulumi.getter(name="customCertificateQuota")
    def custom_certificate_quota(self) -> int:
        """
        Number of Custom Certificates the zone can have
        """
        return pulumi.get(self, "custom_certificate_quota")

    @property
    @pulumi.getter(name="dnsOnly")
    def dns_only(self) -> bool:
        """
        The zone is only configured for DNS
        """
        return pulumi.get(self, "dns_only")

    @property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> bool:
        """
        The zone is setup with Foundation DNS
        """
        return pulumi.get(self, "foundation_dns")

    @property
    @pulumi.getter(name="pageRuleQuota")
    def page_rule_quota(self) -> int:
        """
        Number of Page Rules a zone can have
        """
        return pulumi.get(self, "page_rule_quota")

    @property
    @pulumi.getter(name="phishingDetected")
    def phishing_detected(self) -> bool:
        """
        The zone has been flagged for phishing
        """
        return pulumi.get(self, "phishing_detected")

    @property
    @pulumi.getter
    def step(self) -> int:
        return pulumi.get(self, "step")


@pulumi.output_type
class GetZoneOwnerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: Identifier
        :param str name: Name of the owner
        :param str type: The type of owner
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the owner
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of owner
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetZonesAccountResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: An account ID
        :param str name: An account Name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        An account ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZonesResultResult(dict):
    def __init__(__self__, *,
                 account: 'outputs.GetZonesResultAccountResult',
                 activated_on: str,
                 created_on: str,
                 development_mode: float,
                 id: str,
                 meta: 'outputs.GetZonesResultMetaResult',
                 modified_on: str,
                 name: str,
                 name_servers: Sequence[str],
                 original_dnshost: str,
                 original_name_servers: Sequence[str],
                 original_registrar: str,
                 owner: 'outputs.GetZonesResultOwnerResult',
                 paused: bool,
                 status: str,
                 type: str,
<<<<<<< HEAD
                 vanity_name_servers: Sequence[str]):
=======
                 vanity_name_servers: Sequence[str],
                 verification_key: str):
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        """
        :param 'GetZonesResultAccountArgs' account: The account the zone belongs to
        :param str activated_on: The last time proof of ownership was detected and the zone was made
               active
        :param str created_on: When the zone was created
        :param float development_mode: The interval (in seconds) from when development mode expires
               (positive integer) or last expired (negative integer) for the
               domain. If development mode has never been enabled, this value is 0.
        :param str id: Identifier
        :param 'GetZonesResultMetaArgs' meta: Metadata about the zone
        :param str modified_on: When the zone was last modified
        :param str name: The domain name
        :param Sequence[str] name_servers: The name servers Cloudflare assigns to a zone
        :param str original_dnshost: DNS host at the time of switching to Cloudflare
        :param Sequence[str] original_name_servers: Original name servers before moving to Cloudflare
        :param str original_registrar: Registrar for the domain at the time of switching to Cloudflare
        :param 'GetZonesResultOwnerArgs' owner: The owner of the zone
        :param bool paused: Indicates whether the zone is only using Cloudflare DNS services. A
               true value means the zone will not receive security or performance
               benefits.
        :param str status: The zone status on Cloudflare.
        :param str type: A full zone implies that DNS is hosted with Cloudflare. A partial zone is
               typically a partner-hosted zone or a CNAME setup.
        :param Sequence[str] vanity_name_servers: An array of domains used for custom name servers. This is only available for Business and Enterprise plans.
<<<<<<< HEAD
=======
        :param str verification_key: Verification key for partial zone setup.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "activated_on", activated_on)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "development_mode", development_mode)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_servers", name_servers)
        pulumi.set(__self__, "original_dnshost", original_dnshost)
        pulumi.set(__self__, "original_name_servers", original_name_servers)
        pulumi.set(__self__, "original_registrar", original_registrar)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vanity_name_servers", vanity_name_servers)
<<<<<<< HEAD
=======
        pulumi.set(__self__, "verification_key", verification_key)
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

    @property
    @pulumi.getter
    def account(self) -> 'outputs.GetZonesResultAccountResult':
        """
        The account the zone belongs to
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="activatedOn")
    def activated_on(self) -> str:
        """
        The last time proof of ownership was detected and the zone was made
        active
        """
        return pulumi.get(self, "activated_on")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        When the zone was created
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> float:
        """
        The interval (in seconds) from when development mode expires
        (positive integer) or last expired (negative integer) for the
        domain. If development mode has never been enabled, this value is 0.
        """
        return pulumi.get(self, "development_mode")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetZonesResultMetaResult':
        """
        Metadata about the zone
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        When the zone was last modified
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The domain name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameServers")
    def name_servers(self) -> Sequence[str]:
        """
        The name servers Cloudflare assigns to a zone
        """
        return pulumi.get(self, "name_servers")

    @property
    @pulumi.getter(name="originalDnshost")
    def original_dnshost(self) -> str:
        """
        DNS host at the time of switching to Cloudflare
        """
        return pulumi.get(self, "original_dnshost")

    @property
    @pulumi.getter(name="originalNameServers")
    def original_name_servers(self) -> Sequence[str]:
        """
        Original name servers before moving to Cloudflare
        """
        return pulumi.get(self, "original_name_servers")

    @property
    @pulumi.getter(name="originalRegistrar")
    def original_registrar(self) -> str:
        """
        Registrar for the domain at the time of switching to Cloudflare
        """
        return pulumi.get(self, "original_registrar")

    @property
    @pulumi.getter
    def owner(self) -> 'outputs.GetZonesResultOwnerResult':
        """
        The owner of the zone
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Indicates whether the zone is only using Cloudflare DNS services. A
        true value means the zone will not receive security or performance
        benefits.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The zone status on Cloudflare.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A full zone implies that DNS is hosted with Cloudflare. A partial zone is
        typically a partner-hosted zone or a CNAME setup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vanityNameServers")
    def vanity_name_servers(self) -> Sequence[str]:
        """
        An array of domains used for custom name servers. This is only available for Business and Enterprise plans.
        """
        return pulumi.get(self, "vanity_name_servers")

<<<<<<< HEAD
=======
    @property
    @pulumi.getter(name="verificationKey")
    def verification_key(self) -> str:
        """
        Verification key for partial zone setup.
        """
        return pulumi.get(self, "verification_key")

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

@pulumi.output_type
class GetZonesResultAccountResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: Identifier
        :param str name: The name of the account
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the account
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZonesResultMetaResult(dict):
    def __init__(__self__, *,
                 cdn_only: bool,
                 custom_certificate_quota: int,
                 dns_only: bool,
                 foundation_dns: bool,
                 page_rule_quota: int,
                 phishing_detected: bool,
                 step: int):
        """
        :param bool cdn_only: The zone is only configured for CDN
        :param int custom_certificate_quota: Number of Custom Certificates the zone can have
        :param bool dns_only: The zone is only configured for DNS
        :param bool foundation_dns: The zone is setup with Foundation DNS
        :param int page_rule_quota: Number of Page Rules a zone can have
        :param bool phishing_detected: The zone has been flagged for phishing
        """
        pulumi.set(__self__, "cdn_only", cdn_only)
        pulumi.set(__self__, "custom_certificate_quota", custom_certificate_quota)
        pulumi.set(__self__, "dns_only", dns_only)
        pulumi.set(__self__, "foundation_dns", foundation_dns)
        pulumi.set(__self__, "page_rule_quota", page_rule_quota)
        pulumi.set(__self__, "phishing_detected", phishing_detected)
        pulumi.set(__self__, "step", step)

    @property
    @pulumi.getter(name="cdnOnly")
    def cdn_only(self) -> bool:
        """
        The zone is only configured for CDN
        """
        return pulumi.get(self, "cdn_only")

    @property
    @pulumi.getter(name="customCertificateQuota")
    def custom_certificate_quota(self) -> int:
        """
        Number of Custom Certificates the zone can have
        """
        return pulumi.get(self, "custom_certificate_quota")

    @property
    @pulumi.getter(name="dnsOnly")
    def dns_only(self) -> bool:
        """
        The zone is only configured for DNS
        """
        return pulumi.get(self, "dns_only")

    @property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> bool:
        """
        The zone is setup with Foundation DNS
        """
        return pulumi.get(self, "foundation_dns")

    @property
    @pulumi.getter(name="pageRuleQuota")
    def page_rule_quota(self) -> int:
        """
        Number of Page Rules a zone can have
        """
        return pulumi.get(self, "page_rule_quota")

    @property
    @pulumi.getter(name="phishingDetected")
    def phishing_detected(self) -> bool:
        """
        The zone has been flagged for phishing
        """
        return pulumi.get(self, "phishing_detected")

    @property
    @pulumi.getter
    def step(self) -> int:
        return pulumi.get(self, "step")


@pulumi.output_type
class GetZonesResultOwnerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: Identifier
        :param str name: Name of the owner
        :param str type: The type of owner
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the owner
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of owner
        """
        return pulumi.get(self, "type")


