# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AccessApplicationCorsHeader',
    'AccessApplicationSaasApp',
    'AccessGroupExclude',
    'AccessGroupExcludeAzure',
    'AccessGroupExcludeExternalEvaluation',
    'AccessGroupExcludeGithub',
    'AccessGroupExcludeGsuite',
    'AccessGroupExcludeOkta',
    'AccessGroupExcludeSaml',
    'AccessGroupInclude',
    'AccessGroupIncludeAzure',
    'AccessGroupIncludeExternalEvaluation',
    'AccessGroupIncludeGithub',
    'AccessGroupIncludeGsuite',
    'AccessGroupIncludeOkta',
    'AccessGroupIncludeSaml',
    'AccessGroupRequire',
    'AccessGroupRequireAzure',
    'AccessGroupRequireExternalEvaluation',
    'AccessGroupRequireGithub',
    'AccessGroupRequireGsuite',
    'AccessGroupRequireOkta',
    'AccessGroupRequireSaml',
    'AccessIdentityProviderConfig',
    'AccessIdentityProviderScimConfig',
    'AccessOrganizationLoginDesign',
    'AccessPolicyApprovalGroup',
    'AccessPolicyExclude',
    'AccessPolicyExcludeAzure',
    'AccessPolicyExcludeExternalEvaluation',
    'AccessPolicyExcludeGithub',
    'AccessPolicyExcludeGsuite',
    'AccessPolicyExcludeOkta',
    'AccessPolicyExcludeSaml',
    'AccessPolicyInclude',
    'AccessPolicyIncludeAzure',
    'AccessPolicyIncludeExternalEvaluation',
    'AccessPolicyIncludeGithub',
    'AccessPolicyIncludeGsuite',
    'AccessPolicyIncludeOkta',
    'AccessPolicyIncludeSaml',
    'AccessPolicyRequire',
    'AccessPolicyRequireAzure',
    'AccessPolicyRequireExternalEvaluation',
    'AccessPolicyRequireGithub',
    'AccessPolicyRequireGsuite',
    'AccessPolicyRequireOkta',
    'AccessPolicyRequireSaml',
    'AccessRuleConfiguration',
    'AddressMapIp',
    'AddressMapMembership',
    'ApiShieldAuthIdCharacteristic',
    'ApiTokenCondition',
    'ApiTokenConditionRequestIp',
    'ApiTokenPolicy',
    'CertificatePackValidationError',
    'CertificatePackValidationRecord',
    'CustomHostnameSsl',
    'CustomHostnameSslSetting',
    'CustomHostnameSslValidationError',
    'CustomHostnameSslValidationRecord',
    'CustomSslCustomSslOptions',
    'CustomSslCustomSslPriority',
    'DeviceDexTestData',
    'DeviceManagedNetworksConfig',
    'DevicePostureIntegrationConfig',
    'DevicePostureRuleInput',
    'DevicePostureRuleMatch',
    'DlpProfileEntry',
    'DlpProfileEntryPattern',
    'EmailRoutingCatchAllAction',
    'EmailRoutingCatchAllMatcher',
    'EmailRoutingRuleAction',
    'EmailRoutingRuleMatcher',
    'FallbackDomainDomain',
    'HealthcheckHeader',
    'ListItem',
    'ListItemHostname',
    'ListItemRedirect',
    'ListItemValue',
    'ListItemValueHostname',
    'ListItemValueRedirect',
    'LoadBalancerAdaptiveRouting',
    'LoadBalancerCountryPool',
    'LoadBalancerLocationStrategy',
    'LoadBalancerMonitorHeader',
    'LoadBalancerPoolLoadShedding',
    'LoadBalancerPoolOrigin',
    'LoadBalancerPoolOriginHeader',
    'LoadBalancerPoolOriginSteering',
    'LoadBalancerPopPool',
    'LoadBalancerRandomSteering',
    'LoadBalancerRegionPool',
    'LoadBalancerRule',
    'LoadBalancerRuleFixedResponse',
    'LoadBalancerRuleOverride',
    'LoadBalancerRuleOverrideAdaptiveRouting',
    'LoadBalancerRuleOverrideCountryPool',
    'LoadBalancerRuleOverrideLocationStrategy',
    'LoadBalancerRuleOverridePopPool',
    'LoadBalancerRuleOverrideRandomSteering',
    'LoadBalancerRuleOverrideRegionPool',
    'LoadBalancerRuleOverrideSessionAffinityAttribute',
    'LoadBalancerSessionAffinityAttribute',
    'ManagedHeadersManagedRequestHeader',
    'ManagedHeadersManagedResponseHeader',
    'NotificationPolicyEmailIntegration',
    'NotificationPolicyFilters',
    'NotificationPolicyPagerdutyIntegration',
    'NotificationPolicyWebhooksIntegration',
    'PageRuleActions',
    'PageRuleActionsCacheKeyFields',
    'PageRuleActionsCacheKeyFieldsCookie',
    'PageRuleActionsCacheKeyFieldsHeader',
    'PageRuleActionsCacheKeyFieldsHost',
    'PageRuleActionsCacheKeyFieldsQueryString',
    'PageRuleActionsCacheKeyFieldsUser',
    'PageRuleActionsCacheTtlByStatus',
    'PageRuleActionsForwardingUrl',
    'PageRuleActionsMinify',
    'PagesProjectBuildConfig',
    'PagesProjectDeploymentConfigs',
    'PagesProjectDeploymentConfigsPreview',
    'PagesProjectDeploymentConfigsPreviewPlacement',
    'PagesProjectDeploymentConfigsPreviewServiceBinding',
    'PagesProjectDeploymentConfigsProduction',
    'PagesProjectDeploymentConfigsProductionPlacement',
    'PagesProjectDeploymentConfigsProductionServiceBinding',
    'PagesProjectSource',
    'PagesProjectSourceConfig',
    'RateLimitAction',
    'RateLimitActionResponse',
    'RateLimitCorrelate',
    'RateLimitMatch',
    'RateLimitMatchRequest',
    'RateLimitMatchResponse',
    'RecordData',
    'RulesetRule',
    'RulesetRuleActionParameters',
    'RulesetRuleActionParametersAlgorithm',
    'RulesetRuleActionParametersAutominify',
    'RulesetRuleActionParametersBrowserTtl',
    'RulesetRuleActionParametersCacheKey',
    'RulesetRuleActionParametersCacheKeyCustomKey',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookie',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeader',
    'RulesetRuleActionParametersCacheKeyCustomKeyHost',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryString',
    'RulesetRuleActionParametersCacheKeyCustomKeyUser',
    'RulesetRuleActionParametersEdgeTtl',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtl',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange',
    'RulesetRuleActionParametersFromList',
    'RulesetRuleActionParametersFromValue',
    'RulesetRuleActionParametersFromValueTargetUrl',
    'RulesetRuleActionParametersHeader',
    'RulesetRuleActionParametersMatchedData',
    'RulesetRuleActionParametersOrigin',
    'RulesetRuleActionParametersOverrides',
    'RulesetRuleActionParametersOverridesCategory',
    'RulesetRuleActionParametersOverridesRule',
    'RulesetRuleActionParametersResponse',
    'RulesetRuleActionParametersServeStale',
    'RulesetRuleActionParametersSni',
    'RulesetRuleActionParametersUri',
    'RulesetRuleActionParametersUriPath',
    'RulesetRuleActionParametersUriQuery',
    'RulesetRuleExposedCredentialCheck',
    'RulesetRuleLogging',
    'RulesetRuleRatelimit',
    'SpectrumApplicationDns',
    'SpectrumApplicationEdgeIps',
    'SpectrumApplicationOriginDns',
    'SpectrumApplicationOriginPortRange',
    'SplitTunnelTunnel',
    'TeamsAccountAntivirus',
    'TeamsAccountBlockPage',
    'TeamsAccountFips',
    'TeamsAccountLogging',
    'TeamsAccountLoggingSettingsByRuleType',
    'TeamsAccountLoggingSettingsByRuleTypeDns',
    'TeamsAccountLoggingSettingsByRuleTypeHttp',
    'TeamsAccountLoggingSettingsByRuleTypeL4',
    'TeamsAccountPayloadLog',
    'TeamsAccountProxy',
    'TeamsLocationNetwork',
    'TeamsRuleRuleSettings',
    'TeamsRuleRuleSettingsAuditSsh',
    'TeamsRuleRuleSettingsBisoAdminControls',
    'TeamsRuleRuleSettingsCheckSession',
    'TeamsRuleRuleSettingsEgress',
    'TeamsRuleRuleSettingsL4override',
    'TeamsRuleRuleSettingsPayloadLog',
    'TeamsRuleRuleSettingsUntrustedCert',
    'TunnelConfigConfig',
    'TunnelConfigConfigIngressRule',
    'TunnelConfigConfigIngressRuleOriginRequest',
    'TunnelConfigConfigIngressRuleOriginRequestAccess',
    'TunnelConfigConfigIngressRuleOriginRequestIpRule',
    'TunnelConfigConfigOriginRequest',
    'TunnelConfigConfigOriginRequestAccess',
    'TunnelConfigConfigOriginRequestIpRule',
    'TunnelConfigConfigWarpRouting',
    'UserAgentBlockingRuleConfiguration',
    'WaitingRoomAdditionalRoute',
    'WaitingRoomRulesRule',
    'WorkerScriptAnalyticsEngineBinding',
    'WorkerScriptKvNamespaceBinding',
    'WorkerScriptPlainTextBinding',
    'WorkerScriptQueueBinding',
    'WorkerScriptR2BucketBinding',
    'WorkerScriptSecretTextBinding',
    'WorkerScriptServiceBinding',
    'WorkerScriptWebassemblyBinding',
    'ZoneLockdownConfiguration',
    'ZoneSettingsOverrideInitialSetting',
    'ZoneSettingsOverrideInitialSettingMinify',
    'ZoneSettingsOverrideInitialSettingMobileRedirect',
    'ZoneSettingsOverrideInitialSettingSecurityHeader',
    'ZoneSettingsOverrideSettings',
    'ZoneSettingsOverrideSettingsMinify',
    'ZoneSettingsOverrideSettingsMobileRedirect',
    'ZoneSettingsOverrideSettingsSecurityHeader',
    'GetAccountRolesRoleResult',
    'GetAccountsAccountResult',
    'GetDevicesDeviceResult',
    'GetListsListResult',
    'GetLoadBalancerPoolsFilterResult',
    'GetLoadBalancerPoolsPoolResult',
    'GetLoadBalancerPoolsPoolLoadSheddingResult',
    'GetLoadBalancerPoolsPoolOriginResult',
    'GetLoadBalancerPoolsPoolOriginHeaderResult',
    'GetRulesetsFilterResult',
    'GetRulesetsRulesetResult',
    'GetRulesetsRulesetRuleResult',
    'GetRulesetsRulesetRuleActionParametersResult',
    'GetRulesetsRulesetRuleActionParametersAutominifyResult',
    'GetRulesetsRulesetRuleActionParametersBrowserTtlResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserResult',
    'GetRulesetsRulesetRuleActionParametersEdgeTtlResult',
    'GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult',
    'GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult',
    'GetRulesetsRulesetRuleActionParametersFromListResult',
    'GetRulesetsRulesetRuleActionParametersFromValueResult',
    'GetRulesetsRulesetRuleActionParametersFromValueTargetUrlResult',
    'GetRulesetsRulesetRuleActionParametersHeaderResult',
    'GetRulesetsRulesetRuleActionParametersMatchedDataResult',
    'GetRulesetsRulesetRuleActionParametersOriginResult',
    'GetRulesetsRulesetRuleActionParametersOverridesResult',
    'GetRulesetsRulesetRuleActionParametersOverridesCategoryResult',
    'GetRulesetsRulesetRuleActionParametersOverridesRuleResult',
    'GetRulesetsRulesetRuleActionParametersResponseResult',
    'GetRulesetsRulesetRuleActionParametersServeStaleResult',
    'GetRulesetsRulesetRuleActionParametersSniResult',
    'GetRulesetsRulesetRuleActionParametersUriResult',
    'GetRulesetsRulesetRuleActionParametersUriPathResult',
    'GetRulesetsRulesetRuleActionParametersUriQueryResult',
    'GetRulesetsRulesetRuleExposedCredentialCheckResult',
    'GetRulesetsRulesetRuleLoggingResult',
    'GetRulesetsRulesetRuleRatelimitResult',
    'GetZonesFilterResult',
    'GetZonesZoneResult',
]

@pulumi.output_type
class AccessApplicationCorsHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllHeaders":
            suggest = "allow_all_headers"
        elif key == "allowAllMethods":
            suggest = "allow_all_methods"
        elif key == "allowAllOrigins":
            suggest = "allow_all_origins"
        elif key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationCorsHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationCorsHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationCorsHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_headers: Optional[bool] = None,
                 allow_all_methods: Optional[bool] = None,
                 allow_all_origins: Optional[bool] = None,
                 allow_credentials: Optional[bool] = None,
                 allowed_headers: Optional[Sequence[str]] = None,
                 allowed_methods: Optional[Sequence[str]] = None,
                 allowed_origins: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool allow_all_headers: Value to determine whether all HTTP headers are exposed.
        :param bool allow_all_methods: Value to determine whether all methods are exposed.
        :param bool allow_all_origins: Value to determine whether all origins are permitted to make CORS requests.
        :param bool allow_credentials: Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        :param Sequence[str] allowed_headers: List of HTTP headers to expose via CORS.
        :param Sequence[str] allowed_methods: List of methods to expose via CORS.
        :param Sequence[str] allowed_origins: List of origins permitted to make CORS requests.
        :param int max_age: The maximum time a preflight request will be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[bool]:
        """
        Value to determine whether all HTTP headers are exposed.
        """
        return pulumi.get(self, "allow_all_headers")

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[bool]:
        """
        Value to determine whether all methods are exposed.
        """
        return pulumi.get(self, "allow_all_methods")

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[bool]:
        """
        Value to determine whether all origins are permitted to make CORS requests.
        """
        return pulumi.get(self, "allow_all_origins")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[str]]:
        """
        List of HTTP headers to expose via CORS.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[str]]:
        """
        List of methods to expose via CORS.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        List of origins permitted to make CORS requests.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        The maximum time a preflight request will be cached.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class AccessApplicationSaasApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerServiceUrl":
            suggest = "consumer_service_url"
        elif key == "spEntityId":
            suggest = "sp_entity_id"
        elif key == "nameIdFormat":
            suggest = "name_id_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationSaasApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationSaasApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationSaasApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_service_url: str,
                 sp_entity_id: str,
                 name_id_format: Optional[str] = None):
        """
        :param str consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param str sp_entity_id: A globally unique name for an identity or service provider.
        :param str name_id_format: The format of the name identifier sent to the SaaS application. Defaults to `email`.
        """
        pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> str:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> str:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[str]:
        """
        The format of the name identifier sent to the SaaS application. Defaults to `email`.
        """
        return pulumi.get(self, "name_id_format")


@pulumi.output_type
class AccessGroupExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupExcludeAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 external_evaluation: Optional['outputs.AccessGroupExcludeExternalEvaluation'] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupExcludeGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupExcludeGsuite']] = None,
                 ip_lists: Optional[Sequence[str]] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupExcludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupExcludeSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupExcludeAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessGroupExcludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupExcludeGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupExcludeGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupExcludeOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupExcludeSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupExcludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ids: The ID of this resource.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[str] = None,
                 keys_url: Optional[str] = None):
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[str]:
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[str]:
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessGroupExcludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupIncludeAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 external_evaluation: Optional['outputs.AccessGroupIncludeExternalEvaluation'] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupIncludeGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupIncludeGsuite']] = None,
                 ip_lists: Optional[Sequence[str]] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupIncludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupIncludeSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupIncludeAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessGroupIncludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupIncludeGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupIncludeGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupIncludeOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupIncludeSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupIncludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ids: The ID of this resource.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[str] = None,
                 keys_url: Optional[str] = None):
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[str]:
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[str]:
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessGroupIncludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupRequireAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 external_evaluation: Optional['outputs.AccessGroupRequireExternalEvaluation'] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupRequireGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupRequireGsuite']] = None,
                 ip_lists: Optional[Sequence[str]] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupRequireOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupRequireSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupRequireAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessGroupRequireExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupRequireGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupRequireGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupRequireOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupRequireSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupRequireAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ids: The ID of this resource.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[str] = None,
                 keys_url: Optional[str] = None):
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[str]:
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[str]:
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessGroupRequireGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessIdentityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "appsDomain":
            suggest = "apps_domain"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "centrifyAccount":
            suggest = "centrify_account"
        elif key == "centrifyAppId":
            suggest = "centrify_app_id"
        elif key == "certsUrl":
            suggest = "certs_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "directoryId":
            suggest = "directory_id"
        elif key == "emailAttributeName":
            suggest = "email_attribute_name"
        elif key == "idpPublicCert":
            suggest = "idp_public_cert"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "oktaAccount":
            suggest = "okta_account"
        elif key == "oneloginAccount":
            suggest = "onelogin_account"
        elif key == "pkceEnabled":
            suggest = "pkce_enabled"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "signRequest":
            suggest = "sign_request"
        elif key == "ssoTargetUrl":
            suggest = "sso_target_url"
        elif key == "supportGroups":
            suggest = "support_groups"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessIdentityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessIdentityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessIdentityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional[str] = None,
                 apps_domain: Optional[str] = None,
                 attributes: Optional[Sequence[str]] = None,
                 auth_url: Optional[str] = None,
                 centrify_account: Optional[str] = None,
                 centrify_app_id: Optional[str] = None,
                 certs_url: Optional[str] = None,
                 claims: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 directory_id: Optional[str] = None,
                 email_attribute_name: Optional[str] = None,
                 idp_public_cert: Optional[str] = None,
                 issuer_url: Optional[str] = None,
                 okta_account: Optional[str] = None,
                 onelogin_account: Optional[str] = None,
                 pkce_enabled: Optional[bool] = None,
                 redirect_url: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 sign_request: Optional[bool] = None,
                 sso_target_url: Optional[str] = None,
                 support_groups: Optional[bool] = None,
                 token_url: Optional[str] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if idp_public_cert is not None:
            pulumi.set(__self__, "idp_public_cert", idp_public_cert)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[str]:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[str]:
        return pulumi.get(self, "apps_domain")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[str]:
        return pulumi.get(self, "centrify_account")

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[str]:
        return pulumi.get(self, "centrify_app_id")

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[str]:
        return pulumi.get(self, "certs_url")

    @property
    @pulumi.getter
    def claims(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "claims")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[str]:
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "email_attribute_name")

    @property
    @pulumi.getter(name="idpPublicCert")
    def idp_public_cert(self) -> Optional[str]:
        return pulumi.get(self, "idp_public_cert")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[str]:
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[str]:
        return pulumi.get(self, "okta_account")

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[str]:
        return pulumi.get(self, "onelogin_account")

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "pkce_enabled")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[bool]:
        return pulumi.get(self, "sign_request")

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[str]:
        return pulumi.get(self, "sso_target_url")

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[bool]:
        return pulumi.get(self, "support_groups")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class AccessIdentityProviderScimConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupMemberDeprovision":
            suggest = "group_member_deprovision"
        elif key == "seatDeprovision":
            suggest = "seat_deprovision"
        elif key == "userDeprovision":
            suggest = "user_deprovision"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessIdentityProviderScimConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessIdentityProviderScimConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessIdentityProviderScimConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 group_member_deprovision: Optional[bool] = None,
                 seat_deprovision: Optional[bool] = None,
                 secret: Optional[str] = None,
                 user_deprovision: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group_member_deprovision is not None:
            pulumi.set(__self__, "group_member_deprovision", group_member_deprovision)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="groupMemberDeprovision")
    def group_member_deprovision(self) -> Optional[bool]:
        return pulumi.get(self, "group_member_deprovision")

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[bool]:
        return pulumi.get(self, "seat_deprovision")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[bool]:
        return pulumi.get(self, "user_deprovision")


@pulumi.output_type
class AccessOrganizationLoginDesign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessOrganizationLoginDesign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessOrganizationLoginDesign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessOrganizationLoginDesign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 footer_text: Optional[str] = None,
                 header_text: Optional[str] = None,
                 logo_path: Optional[str] = None,
                 text_color: Optional[str] = None):
        """
        :param str background_color: The background color on the login page.
        :param str footer_text: The text at the bottom of the login page.
        :param str header_text: The text at the top of the login page.
        :param str logo_path: The URL of the logo on the login page.
        :param str text_color: The text color on the login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color on the login page.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[str]:
        """
        The text at the bottom of the login page.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[str]:
        """
        The text at the top of the login page.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[str]:
        """
        The URL of the logo on the login page.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[str]:
        """
        The text color on the login page.
        """
        return pulumi.get(self, "text_color")


@pulumi.output_type
class AccessPolicyApprovalGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalsNeeded":
            suggest = "approvals_needed"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailListUuid":
            suggest = "email_list_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyApprovalGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyApprovalGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyApprovalGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approvals_needed: int,
                 email_addresses: Optional[Sequence[str]] = None,
                 email_list_uuid: Optional[str] = None):
        """
        :param int approvals_needed: Number of approvals needed.
        :param Sequence[str] email_addresses: List of emails to request approval from.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> int:
        """
        Number of approvals needed.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[str]]:
        """
        List of emails to request approval from.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[str]:
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class AccessPolicyExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyExcludeAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 external_evaluation: Optional['outputs.AccessPolicyExcludeExternalEvaluation'] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyExcludeGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyExcludeGsuite']] = None,
                 ip_lists: Optional[Sequence[str]] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyExcludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyExcludeSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyExcludeAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessPolicyExcludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyExcludeGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyExcludeGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyExcludeOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyExcludeSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyExcludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ids: The ID of this resource.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[str] = None,
                 keys_url: Optional[str] = None):
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[str]:
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[str]:
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessPolicyExcludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Policy.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Policy.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Policy.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyIncludeAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 external_evaluation: Optional['outputs.AccessPolicyIncludeExternalEvaluation'] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyIncludeGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyIncludeGsuite']] = None,
                 ip_lists: Optional[Sequence[str]] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyIncludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyIncludeSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyIncludeAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessPolicyIncludeExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyIncludeGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyIncludeGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyIncludeOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyIncludeSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyIncludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ids: The ID of this resource.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[str] = None,
                 keys_url: Optional[str] = None):
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[str]:
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[str]:
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessPolicyIncludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Policy.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Policy.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Policy.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyRequireAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 external_evaluation: Optional['outputs.AccessPolicyRequireExternalEvaluation'] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyRequireGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyRequireGsuite']] = None,
                 ip_lists: Optional[Sequence[str]] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyRequireOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyRequireSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyRequireAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessPolicyRequireExternalEvaluation']:
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyRequireGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyRequireGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyRequireOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyRequireSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyRequireAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ids: The ID of this resource.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[str] = None,
                 keys_url: Optional[str] = None):
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[str]:
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[str]:
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessPolicyRequireGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Policy.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Policy.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Policy.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessRuleConfiguration(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        :param str value: The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AddressMapIp(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: An IPv4 or IPv6 address.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        An IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class AddressMapMembership(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canDelete":
            suggest = "can_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddressMapMembership. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddressMapMembership.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddressMapMembership.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifier: str,
                 kind: str,
                 can_delete: Optional[bool] = None):
        """
        :param str identifier: Identifier of the account or zone.
        :param str kind: The type of the membership.
        :param bool can_delete: Controls whether the membership can be deleted via the API or not.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "kind", kind)
        if can_delete is not None:
            pulumi.set(__self__, "can_delete", can_delete)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifier of the account or zone.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type of the membership.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> Optional[bool]:
        """
        Controls whether the membership can be deleted via the API or not.
        """
        return pulumi.get(self, "can_delete")


@pulumi.output_type
class ApiShieldAuthIdCharacteristic(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the characteristic.
        :param str type: The type of characteristic. Available values: `header`, `cookie`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the characteristic.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of characteristic. Available values: `header`, `cookie`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApiTokenCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestIp":
            suggest = "request_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_ip: Optional['outputs.ApiTokenConditionRequestIp'] = None):
        """
        :param 'ApiTokenConditionRequestIpArgs' request_ip: Request IP related conditions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional['outputs.ApiTokenConditionRequestIp']:
        """
        Request IP related conditions.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class ApiTokenConditionRequestIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notIns":
            suggest = "not_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenConditionRequestIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenConditionRequestIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenConditionRequestIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ins: Optional[Sequence[str]] = None,
                 not_ins: Optional[Sequence[str]] = None):
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class ApiTokenPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionGroups":
            suggest = "permission_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission_groups: Sequence[str],
                 resources: Mapping[str, str],
                 effect: Optional[str] = None):
        """
        :param Sequence[str] permission_groups: List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        :param Mapping[str, str] resources: Describes what operations against which resources are allowed or denied.
        :param str effect: Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence[str]:
        """
        List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, str]:
        """
        Describes what operations against which resources are allowed or denied.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
        return pulumi.get(self, "effect")


@pulumi.output_type
class CertificatePackValidationError(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class CertificatePackValidationRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cnameName":
            suggest = "cname_name"
        elif key == "cnameTarget":
            suggest = "cname_target"
        elif key == "httpBody":
            suggest = "http_body"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "txtName":
            suggest = "txt_name"
        elif key == "txtValue":
            suggest = "txt_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificatePackValidationRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificatePackValidationRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificatePackValidationRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cname_name: Optional[str] = None,
                 cname_target: Optional[str] = None,
                 emails: Optional[Sequence[str]] = None,
                 http_body: Optional[str] = None,
                 http_url: Optional[str] = None,
                 txt_name: Optional[str] = None,
                 txt_value: Optional[str] = None):
        if cname_name is not None:
            pulumi.set(__self__, "cname_name", cname_name)
        if cname_target is not None:
            pulumi.set(__self__, "cname_target", cname_target)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[str]:
        return pulumi.get(self, "cname_name")

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[str]:
        return pulumi.get(self, "cname_target")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[str]:
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[str]:
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[str]:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[str]:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class CustomHostnameSsl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bundleMethod":
            suggest = "bundle_method"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "customCertificate":
            suggest = "custom_certificate"
        elif key == "customKey":
            suggest = "custom_key"
        elif key == "validationErrors":
            suggest = "validation_errors"
        elif key == "validationRecords":
            suggest = "validation_records"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSsl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSsl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSsl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundle_method: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 custom_certificate: Optional[str] = None,
                 custom_key: Optional[str] = None,
                 method: Optional[str] = None,
                 settings: Optional[Sequence['outputs.CustomHostnameSslSetting']] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None,
                 validation_errors: Optional[Sequence['outputs.CustomHostnameSslValidationError']] = None,
                 validation_records: Optional[Sequence['outputs.CustomHostnameSslValidationRecord']] = None,
                 wildcard: Optional[bool] = None):
        """
        :param str bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        :param str custom_certificate: If a custom uploaded certificate is used.
        :param str custom_key: The key for a custom uploaded certificate.
        :param str method: Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        :param Sequence['CustomHostnameSslSettingArgs'] settings: SSL/TLS settings for the certificate.
        :param str status: Status of the certificate.
        :param str type: Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        :param bool wildcard: Indicates whether the certificate covers a wildcard.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)
        if validation_records is not None:
            pulumi.set(__self__, "validation_records", validation_records)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[str]:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[str]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[str]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Sequence['outputs.CustomHostnameSslSetting']]:
        """
        SSL/TLS settings for the certificate.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the certificate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[Sequence['outputs.CustomHostnameSslValidationError']]:
        return pulumi.get(self, "validation_errors")

    @property
    @pulumi.getter(name="validationRecords")
    def validation_records(self) -> Optional[Sequence['outputs.CustomHostnameSslValidationRecord']]:
        return pulumi.get(self, "validation_records")

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[bool]:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")


@pulumi.output_type
class CustomHostnameSslSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earlyHints":
            suggest = "early_hints"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSslSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSslSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSslSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ciphers: Optional[Sequence[str]] = None,
                 early_hints: Optional[str] = None,
                 http2: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 tls13: Optional[str] = None):
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[str]:
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter
    def http2(self) -> Optional[str]:
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[str]:
        return pulumi.get(self, "tls13")


@pulumi.output_type
class CustomHostnameSslValidationError(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class CustomHostnameSslValidationRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cnameName":
            suggest = "cname_name"
        elif key == "cnameTarget":
            suggest = "cname_target"
        elif key == "httpBody":
            suggest = "http_body"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "txtName":
            suggest = "txt_name"
        elif key == "txtValue":
            suggest = "txt_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSslValidationRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSslValidationRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSslValidationRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cname_name: Optional[str] = None,
                 cname_target: Optional[str] = None,
                 emails: Optional[Sequence[str]] = None,
                 http_body: Optional[str] = None,
                 http_url: Optional[str] = None,
                 txt_name: Optional[str] = None,
                 txt_value: Optional[str] = None):
        if cname_name is not None:
            pulumi.set(__self__, "cname_name", cname_name)
        if cname_target is not None:
            pulumi.set(__self__, "cname_target", cname_target)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[str]:
        return pulumi.get(self, "cname_name")

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[str]:
        return pulumi.get(self, "cname_target")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[str]:
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[str]:
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[str]:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[str]:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class CustomSslCustomSslOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bundleMethod":
            suggest = "bundle_method"
        elif key == "geoRestrictions":
            suggest = "geo_restrictions"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomSslCustomSslOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomSslCustomSslOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomSslCustomSslOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundle_method: Optional[str] = None,
                 certificate: Optional[str] = None,
                 geo_restrictions: Optional[str] = None,
                 private_key: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str bundle_method: Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        :param str certificate: Certificate certificate and the intermediate(s).
        :param str geo_restrictions: Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        :param str private_key: Certificate's private key.
        :param str type: Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if geo_restrictions is not None:
            pulumi.set(__self__, "geo_restrictions", geo_restrictions)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[str]:
        """
        Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Certificate certificate and the intermediate(s).
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="geoRestrictions")
    def geo_restrictions(self) -> Optional[str]:
        """
        Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        """
        return pulumi.get(self, "geo_restrictions")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        Certificate's private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CustomSslCustomSslPriority(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 priority: Optional[int] = None):
        """
        :param str id: The ID of this resource.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        return pulumi.get(self, "priority")


@pulumi.output_type
class DeviceDexTestData(dict):
    def __init__(__self__, *,
                 host: str,
                 kind: str,
                 method: Optional[str] = None):
        """
        :param str host: The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        :param str kind: The type of Device Dex Test. Available values: `http`, `traceroute`.
        :param str method: The http request method. Available values: `GET`.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type of Device Dex Test. Available values: `http`, `traceroute`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The http request method. Available values: `GET`.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class DeviceManagedNetworksConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSockaddr":
            suggest = "tls_sockaddr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceManagedNetworksConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceManagedNetworksConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceManagedNetworksConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sha256: str,
                 tls_sockaddr: str):
        """
        :param str sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        :param str tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)

    @property
    @pulumi.getter
    def sha256(self) -> str:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> str:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")


@pulumi.output_type
class DevicePostureIntegrationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customerId":
            suggest = "customer_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevicePostureIntegrationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevicePostureIntegrationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevicePostureIntegrationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_key: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 customer_id: Optional[str] = None):
        """
        :param str api_url: The third-party API's URL.
        :param str auth_url: The third-party authorization API URL.
        :param str client_id: The client identifier for authenticating API calls.
        :param str client_key: The client key for authenticating API calls.
        :param str client_secret: The client secret for authenticating API calls.
        :param str customer_id: The customer identifier for authenticating API calls.
        """
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        The third-party API's URL.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        """
        The third-party authorization API URL.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client identifier for authenticating API calls.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The client key for authenticating API calls.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret for authenticating API calls.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[str]:
        """
        The customer identifier for authenticating API calls.
        """
        return pulumi.get(self, "customer_id")


@pulumi.output_type
class DevicePostureRuleInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeThreats":
            suggest = "active_threats"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "checkDisks":
            suggest = "check_disks"
        elif key == "complianceStatus":
            suggest = "compliance_status"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "countOperator":
            suggest = "count_operator"
        elif key == "isActive":
            suggest = "is_active"
        elif key == "issueCount":
            suggest = "issue_count"
        elif key == "networkStatus":
            suggest = "network_status"
        elif key == "osDistroName":
            suggest = "os_distro_name"
        elif key == "osDistroRevision":
            suggest = "os_distro_revision"
        elif key == "requireAll":
            suggest = "require_all"
        elif key == "sensorConfig":
            suggest = "sensor_config"
        elif key == "versionOperator":
            suggest = "version_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevicePostureRuleInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevicePostureRuleInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevicePostureRuleInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_threats: Optional[int] = None,
                 certificate_id: Optional[str] = None,
                 check_disks: Optional[Sequence[str]] = None,
                 cn: Optional[str] = None,
                 compliance_status: Optional[str] = None,
                 connection_id: Optional[str] = None,
                 count_operator: Optional[str] = None,
                 domain: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 exists: Optional[bool] = None,
                 id: Optional[str] = None,
                 infected: Optional[bool] = None,
                 is_active: Optional[bool] = None,
                 issue_count: Optional[str] = None,
                 network_status: Optional[str] = None,
                 operator: Optional[str] = None,
                 os: Optional[str] = None,
                 os_distro_name: Optional[str] = None,
                 os_distro_revision: Optional[str] = None,
                 overall: Optional[str] = None,
                 path: Optional[str] = None,
                 require_all: Optional[bool] = None,
                 running: Optional[bool] = None,
                 sensor_config: Optional[str] = None,
                 sha256: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 version: Optional[str] = None,
                 version_operator: Optional[str] = None):
        """
        :param int active_threats: The number of active threats from SentinelOne.
        :param str certificate_id: The UUID of a Cloudflare managed certificate.
        :param Sequence[str] check_disks: Specific volume(s) to check for encryption.
        :param str cn: The common name for a certificate.
        :param str compliance_status: The workspace one device compliance status. Available values: `compliant`, `noncompliant`.
        :param str connection_id: The workspace one connection id.
        :param str count_operator: The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param str domain: The domain that the client must join.
        :param bool enabled: True if the firewall must be enabled.
        :param bool exists: Checks if the file should exist.
        :param str id: The Teams List id.
        :param bool infected: True if SentinelOne device is infected.
        :param bool is_active: True if SentinelOne device is active.
        :param str issue_count: The number of issues for kolide.
        :param str network_status: The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        :param str operator: The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param str os: OS signal score from Crowdstrike. Value must be between 1 and 100.
        :param str os_distro_name: The operating system excluding version information.
        :param str os_distro_revision: The operating system version excluding OS name information or release name.
        :param str overall: Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        :param str path: The path to the file.
        :param bool require_all: True if all drives must be encrypted.
        :param bool running: Checks if the application should be running.
        :param str sensor_config: Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        :param str sha256: The sha256 hash of the file.
        :param str thumbprint: The thumbprint of the file certificate.
        :param str version: The operating system semantic version.
        :param str version_operator: The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if running is not None:
            pulumi.set(__self__, "running", running)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[int]:
        """
        The number of active threats from SentinelOne.
        """
        return pulumi.get(self, "active_threats")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[str]:
        """
        The UUID of a Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[Sequence[str]]:
        """
        Specific volume(s) to check for encryption.
        """
        return pulumi.get(self, "check_disks")

    @property
    @pulumi.getter
    def cn(self) -> Optional[str]:
        """
        The common name for a certificate.
        """
        return pulumi.get(self, "cn")

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[str]:
        """
        The workspace one device compliance status. Available values: `compliant`, `noncompliant`.
        """
        return pulumi.get(self, "compliance_status")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[str]:
        """
        The workspace one connection id.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[str]:
        """
        The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "count_operator")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The domain that the client must join.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if the firewall must be enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exists(self) -> Optional[bool]:
        """
        Checks if the file should exist.
        """
        return pulumi.get(self, "exists")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Teams List id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def infected(self) -> Optional[bool]:
        """
        True if SentinelOne device is infected.
        """
        return pulumi.get(self, "infected")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[bool]:
        """
        True if SentinelOne device is active.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[str]:
        """
        The number of issues for kolide.
        """
        return pulumi.get(self, "issue_count")

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[str]:
        """
        The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        """
        return pulumi.get(self, "network_status")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def os(self) -> Optional[str]:
        """
        OS signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "os")

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[str]:
        """
        The operating system excluding version information.
        """
        return pulumi.get(self, "os_distro_name")

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[str]:
        """
        The operating system version excluding OS name information or release name.
        """
        return pulumi.get(self, "os_distro_revision")

    @property
    @pulumi.getter
    def overall(self) -> Optional[str]:
        """
        Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "overall")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[bool]:
        """
        True if all drives must be encrypted.
        """
        return pulumi.get(self, "require_all")

    @property
    @pulumi.getter
    def running(self) -> Optional[bool]:
        """
        Checks if the application should be running.
        """
        return pulumi.get(self, "running")

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[str]:
        """
        Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "sensor_config")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        The sha256 hash of the file.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the file certificate.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The operating system semantic version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[str]:
        """
        The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "version_operator")


@pulumi.output_type
class DevicePostureRuleMatch(dict):
    def __init__(__self__, *,
                 platform: Optional[str] = None):
        """
        :param str platform: The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        """
        The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class DlpProfileEntry(dict):
    def __init__(__self__, *,
                 name: str,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 pattern: Optional['outputs.DlpProfileEntryPattern'] = None):
        """
        :param str name: Name of the entry to deploy.
        :param bool enabled: Whether the entry is active. Defaults to `false`.
        :param str id: Unique entry identifier.
        """
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the entry to deploy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the entry is active. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique entry identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['outputs.DlpProfileEntryPattern']:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class DlpProfileEntryPattern(dict):
    def __init__(__self__, *,
                 regex: str,
                 validation: Optional[str] = None):
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> Optional[str]:
        return pulumi.get(self, "validation")


@pulumi.output_type
class EmailRoutingCatchAllAction(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Type of supported action. Available values: `drop`, `forward`, `worker`.
        :param Sequence[str] values: A list with items in the following form.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of supported action. Available values: `drop`, `forward`, `worker`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list with items in the following form.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class EmailRoutingCatchAllMatcher(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Type of matcher. Available values: `all`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of matcher. Available values: `all`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EmailRoutingRuleAction(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Type of supported action.
        :param Sequence[str] values: An array with items in the following form.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of supported action.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        An array with items in the following form.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class EmailRoutingRuleMatcher(dict):
    def __init__(__self__, *,
                 type: str,
                 field: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str type: Type of matcher.
        :param str field: Field for type matcher.
        :param str value: Value for matcher.
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of matcher.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        Field for type matcher.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value for matcher.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FallbackDomainDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FallbackDomainDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FallbackDomainDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FallbackDomainDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 dns_servers: Optional[Sequence[str]] = None,
                 suffix: Optional[str] = None):
        """
        :param str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[str] dns_servers: A list of IP addresses to handle domain resolution.
        :param str suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class HealthcheckHeader(dict):
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        """
        :param str header: The header name.
        :param Sequence[str] values: A list of string values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of string values for the header.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ListItem(dict):
    def __init__(__self__, *,
                 value: 'outputs.ListItemValue',
                 comment: Optional[str] = None):
        """
        :param str comment: An optional comment for the item.
        """
        pulumi.set(__self__, "value", value)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @property
    @pulumi.getter
    def value(self) -> 'outputs.ListItemValue':
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        An optional comment for the item.
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class ListItemHostname(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlHostname":
            suggest = "url_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemHostname. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemHostname.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemHostname.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_hostname: str):
        """
        :param str url_hostname: The FQDN to match on.
        """
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> str:
        """
        The FQDN to match on.
        """
        return pulumi.get(self, "url_hostname")


@pulumi.output_type
class ListItemRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceUrl":
            suggest = "source_url"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "preservePathSuffix":
            suggest = "preserve_path_suffix"
        elif key == "preserveQueryString":
            suggest = "preserve_query_string"
        elif key == "statusCode":
            suggest = "status_code"
        elif key == "subpathMatching":
            suggest = "subpath_matching"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_url: str,
                 target_url: str,
                 include_subdomains: Optional[str] = None,
                 preserve_path_suffix: Optional[str] = None,
                 preserve_query_string: Optional[str] = None,
                 status_code: Optional[int] = None,
                 subpath_matching: Optional[str] = None):
        """
        :param str source_url: The source url of the redirect.
        :param str target_url: The target url of the redirect.
        :param str include_subdomains: Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        :param str preserve_path_suffix: Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        :param str preserve_query_string: Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        :param int status_code: The status code to be used when redirecting a request.
        :param str subpath_matching: Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> str:
        """
        The source url of the redirect.
        """
        return pulumi.get(self, "source_url")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        """
        The target url of the redirect.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[str]:
        """
        Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[str]:
        """
        Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_path_suffix")

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[str]:
        """
        Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        The status code to be used when redirecting a request.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[str]:
        """
        Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "subpath_matching")


@pulumi.output_type
class ListItemValue(dict):
    def __init__(__self__, *,
                 asn: Optional[int] = None,
                 hostnames: Optional[Sequence['outputs.ListItemValueHostname']] = None,
                 ip: Optional[str] = None,
                 redirects: Optional[Sequence['outputs.ListItemValueRedirect']] = None):
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def asn(self) -> Optional[int]:
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence['outputs.ListItemValueHostname']]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.ListItemValueRedirect']]:
        return pulumi.get(self, "redirects")


@pulumi.output_type
class ListItemValueHostname(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlHostname":
            suggest = "url_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemValueHostname. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemValueHostname.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemValueHostname.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_hostname: str):
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> str:
        return pulumi.get(self, "url_hostname")


@pulumi.output_type
class ListItemValueRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceUrl":
            suggest = "source_url"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "preservePathSuffix":
            suggest = "preserve_path_suffix"
        elif key == "preserveQueryString":
            suggest = "preserve_query_string"
        elif key == "statusCode":
            suggest = "status_code"
        elif key == "subpathMatching":
            suggest = "subpath_matching"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemValueRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemValueRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemValueRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_url: str,
                 target_url: str,
                 include_subdomains: Optional[str] = None,
                 preserve_path_suffix: Optional[str] = None,
                 preserve_query_string: Optional[str] = None,
                 status_code: Optional[int] = None,
                 subpath_matching: Optional[str] = None):
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> str:
        return pulumi.get(self, "source_url")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[str]:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[str]:
        return pulumi.get(self, "preserve_path_suffix")

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[str]:
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[str]:
        return pulumi.get(self, "subpath_matching")


@pulumi.output_type
class LoadBalancerAdaptiveRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverAcrossPools":
            suggest = "failover_across_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerAdaptiveRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerAdaptiveRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerAdaptiveRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_across_pools: Optional[bool] = None):
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[bool]:
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class LoadBalancerCountryPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerCountryPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerCountryPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerCountryPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country: str,
                 pool_ids: Sequence[str]):
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "pool_ids", pool_ids)

    @property
    @pulumi.getter
    def country(self) -> str:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        return pulumi.get(self, "pool_ids")


@pulumi.output_type
class LoadBalancerLocationStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferEcs":
            suggest = "prefer_ecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerLocationStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerLocationStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerLocationStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 prefer_ecs: Optional[str] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[str]:
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class LoadBalancerMonitorHeader(dict):
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        """
        :param str header: The header name.
        :param Sequence[str] values: A list of values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values for the header.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LoadBalancerPoolLoadShedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPercent":
            suggest = "default_percent"
        elif key == "defaultPolicy":
            suggest = "default_policy"
        elif key == "sessionPercent":
            suggest = "session_percent"
        elif key == "sessionPolicy":
            suggest = "session_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPoolLoadShedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPoolLoadShedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPoolLoadShedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_percent: Optional[float] = None,
                 default_policy: Optional[str] = None,
                 session_percent: Optional[float] = None,
                 session_policy: Optional[str] = None):
        """
        :param float default_percent: Percent of traffic to shed 0 - 100. Defaults to `0`.
        :param str default_policy: Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        :param float session_percent: Percent of session traffic to shed 0 - 100. Defaults to `0`.
        :param str session_policy: Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[float]:
        """
        Percent of traffic to shed 0 - 100. Defaults to `0`.
        """
        return pulumi.get(self, "default_percent")

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[str]:
        """
        Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        """
        return pulumi.get(self, "default_policy")

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[float]:
        """
        Percent of session traffic to shed 0 - 100. Defaults to `0`.
        """
        return pulumi.get(self, "session_percent")

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[str]:
        """
        Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
        return pulumi.get(self, "session_policy")


@pulumi.output_type
class LoadBalancerPoolOrigin(dict):
    def __init__(__self__, *,
                 address: str,
                 name: str,
                 enabled: Optional[bool] = None,
                 headers: Optional[Sequence['outputs.LoadBalancerPoolOriginHeader']] = None,
                 weight: Optional[float] = None):
        """
        :param str address: The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        :param str name: A human-identifiable name for the origin.
        :param bool enabled: Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        :param Sequence['LoadBalancerPoolOriginHeaderArgs'] headers: HTTP request headers.
        :param float weight: The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. Defaults to `1`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.LoadBalancerPoolOriginHeader']]:
        """
        HTTP request headers.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. Defaults to `1`.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class LoadBalancerPoolOriginHeader(dict):
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class LoadBalancerPoolOriginSteering(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None):
        """
        :param str policy: Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Available values: `""`, `hash`, `random`, `least_outstanding_requests`. Defaults to `random`.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Available values: `""`, `hash`, `random`, `least_outstanding_requests`. Defaults to `random`.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class LoadBalancerPopPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPopPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPopPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPopPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[str],
                 pop: str):
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def pop(self) -> str:
        return pulumi.get(self, "pop")


@pulumi.output_type
class LoadBalancerRandomSteering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultWeight":
            suggest = "default_weight"
        elif key == "poolWeights":
            suggest = "pool_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRandomSteering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRandomSteering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRandomSteering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_weight: Optional[float] = None,
                 pool_weights: Optional[Mapping[str, float]] = None):
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[float]:
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[Mapping[str, float]]:
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class LoadBalancerRegionPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRegionPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRegionPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRegionPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[str],
                 region: str):
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class LoadBalancerRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedResponse":
            suggest = "fixed_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 condition: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 fixed_response: Optional['outputs.LoadBalancerRuleFixedResponse'] = None,
                 overrides: Optional[Sequence['outputs.LoadBalancerRuleOverride']] = None,
                 priority: Optional[int] = None,
                 terminates: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if terminates is not None:
            pulumi.set(__self__, "terminates", terminates)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional['outputs.LoadBalancerRuleFixedResponse']:
        return pulumi.get(self, "fixed_response")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverride']]:
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def terminates(self) -> Optional[bool]:
        return pulumi.get(self, "terminates")


@pulumi.output_type
class LoadBalancerRuleFixedResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleFixedResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleFixedResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleFixedResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[str] = None,
                 location: Optional[str] = None,
                 message_body: Optional[str] = None,
                 status_code: Optional[int] = None):
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[str]:
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class LoadBalancerRuleOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveRoutings":
            suggest = "adaptive_routings"
        elif key == "countryPools":
            suggest = "country_pools"
        elif key == "defaultPools":
            suggest = "default_pools"
        elif key == "fallbackPool":
            suggest = "fallback_pool"
        elif key == "locationStrategies":
            suggest = "location_strategies"
        elif key == "popPools":
            suggest = "pop_pools"
        elif key == "randomSteerings":
            suggest = "random_steerings"
        elif key == "regionPools":
            suggest = "region_pools"
        elif key == "sessionAffinity":
            suggest = "session_affinity"
        elif key == "sessionAffinityAttributes":
            suggest = "session_affinity_attributes"
        elif key == "sessionAffinityTtl":
            suggest = "session_affinity_ttl"
        elif key == "steeringPolicy":
            suggest = "steering_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_routings: Optional[Sequence['outputs.LoadBalancerRuleOverrideAdaptiveRouting']] = None,
                 country_pools: Optional[Sequence['outputs.LoadBalancerRuleOverrideCountryPool']] = None,
                 default_pools: Optional[Sequence[str]] = None,
                 fallback_pool: Optional[str] = None,
                 location_strategies: Optional[Sequence['outputs.LoadBalancerRuleOverrideLocationStrategy']] = None,
                 pop_pools: Optional[Sequence['outputs.LoadBalancerRuleOverridePopPool']] = None,
                 random_steerings: Optional[Sequence['outputs.LoadBalancerRuleOverrideRandomSteering']] = None,
                 region_pools: Optional[Sequence['outputs.LoadBalancerRuleOverrideRegionPool']] = None,
                 session_affinity: Optional[str] = None,
                 session_affinity_attributes: Optional[Sequence['outputs.LoadBalancerRuleOverrideSessionAffinityAttribute']] = None,
                 session_affinity_ttl: Optional[int] = None,
                 steering_policy: Optional[str] = None,
                 ttl: Optional[int] = None):
        if adaptive_routings is not None:
            pulumi.set(__self__, "adaptive_routings", adaptive_routings)
        if country_pools is not None:
            pulumi.set(__self__, "country_pools", country_pools)
        if default_pools is not None:
            pulumi.set(__self__, "default_pools", default_pools)
        if fallback_pool is not None:
            pulumi.set(__self__, "fallback_pool", fallback_pool)
        if location_strategies is not None:
            pulumi.set(__self__, "location_strategies", location_strategies)
        if pop_pools is not None:
            pulumi.set(__self__, "pop_pools", pop_pools)
        if random_steerings is not None:
            pulumi.set(__self__, "random_steerings", random_steerings)
        if region_pools is not None:
            pulumi.set(__self__, "region_pools", region_pools)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_affinity_attributes is not None:
            pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        if session_affinity_ttl is not None:
            pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        if steering_policy is not None:
            pulumi.set(__self__, "steering_policy", steering_policy)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRoutings")
    def adaptive_routings(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideAdaptiveRouting']]:
        return pulumi.get(self, "adaptive_routings")

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideCountryPool']]:
        return pulumi.get(self, "country_pools")

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "default_pools")

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> Optional[str]:
        return pulumi.get(self, "fallback_pool")

    @property
    @pulumi.getter(name="locationStrategies")
    def location_strategies(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideLocationStrategy']]:
        return pulumi.get(self, "location_strategies")

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverridePopPool']]:
        return pulumi.get(self, "pop_pools")

    @property
    @pulumi.getter(name="randomSteerings")
    def random_steerings(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideRandomSteering']]:
        return pulumi.get(self, "random_steerings")

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideRegionPool']]:
        return pulumi.get(self, "region_pools")

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[str]:
        return pulumi.get(self, "session_affinity")

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideSessionAffinityAttribute']]:
        return pulumi.get(self, "session_affinity_attributes")

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> Optional[int]:
        return pulumi.get(self, "session_affinity_ttl")

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> Optional[str]:
        return pulumi.get(self, "steering_policy")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        return pulumi.get(self, "ttl")


@pulumi.output_type
class LoadBalancerRuleOverrideAdaptiveRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverAcrossPools":
            suggest = "failover_across_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideAdaptiveRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideAdaptiveRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideAdaptiveRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_across_pools: Optional[bool] = None):
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[bool]:
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class LoadBalancerRuleOverrideCountryPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideCountryPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideCountryPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideCountryPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country: str,
                 pool_ids: Sequence[str]):
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "pool_ids", pool_ids)

    @property
    @pulumi.getter
    def country(self) -> str:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        return pulumi.get(self, "pool_ids")


@pulumi.output_type
class LoadBalancerRuleOverrideLocationStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferEcs":
            suggest = "prefer_ecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideLocationStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideLocationStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideLocationStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 prefer_ecs: Optional[str] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[str]:
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class LoadBalancerRuleOverridePopPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverridePopPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverridePopPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverridePopPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[str],
                 pop: str):
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def pop(self) -> str:
        return pulumi.get(self, "pop")


@pulumi.output_type
class LoadBalancerRuleOverrideRandomSteering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultWeight":
            suggest = "default_weight"
        elif key == "poolWeights":
            suggest = "pool_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideRandomSteering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideRandomSteering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideRandomSteering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_weight: Optional[float] = None,
                 pool_weights: Optional[Mapping[str, float]] = None):
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[float]:
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[Mapping[str, float]]:
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class LoadBalancerRuleOverrideRegionPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideRegionPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideRegionPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideRegionPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[str],
                 region: str):
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class LoadBalancerRuleOverrideSessionAffinityAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireAllHeaders":
            suggest = "require_all_headers"
        elif key == "zeroDowntimeFailover":
            suggest = "zero_downtime_failover"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideSessionAffinityAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideSessionAffinityAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideSessionAffinityAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 require_all_headers: Optional[bool] = None,
                 samesite: Optional[str] = None,
                 secure: Optional[str] = None,
                 zero_downtime_failover: Optional[str] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[bool]:
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> Optional[str]:
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> Optional[str]:
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[str]:
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class LoadBalancerSessionAffinityAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainDuration":
            suggest = "drain_duration"
        elif key == "requireAllHeaders":
            suggest = "require_all_headers"
        elif key == "zeroDowntimeFailover":
            suggest = "zero_downtime_failover"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerSessionAffinityAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerSessionAffinityAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerSessionAffinityAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_duration: Optional[int] = None,
                 headers: Optional[Sequence[str]] = None,
                 require_all_headers: Optional[bool] = None,
                 samesite: Optional[str] = None,
                 secure: Optional[str] = None,
                 zero_downtime_failover: Optional[str] = None):
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[int]:
        return pulumi.get(self, "drain_duration")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[bool]:
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> Optional[str]:
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> Optional[str]:
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[str]:
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class ManagedHeadersManagedRequestHeader(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 id: str):
        """
        :param bool enabled: Whether the headers rule is active.
        :param str id: Unique headers rule identifier.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique headers rule identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ManagedHeadersManagedResponseHeader(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 id: str):
        """
        :param bool enabled: Whether the headers rule is active.
        :param str id: Unique headers rule identifier.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique headers rule identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NotificationPolicyEmailIntegration(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str name: The name of the notification policy.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the notification policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NotificationPolicyFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertTriggerPreferences":
            suggest = "alert_trigger_preferences"
        elif key == "eventSources":
            suggest = "event_sources"
        elif key == "eventTypes":
            suggest = "event_types"
        elif key == "healthCheckIds":
            suggest = "health_check_ids"
        elif key == "inputIds":
            suggest = "input_ids"
        elif key == "megabitsPerSeconds":
            suggest = "megabits_per_seconds"
        elif key == "newHealths":
            suggest = "new_healths"
        elif key == "packetsPerSeconds":
            suggest = "packets_per_seconds"
        elif key == "poolIds":
            suggest = "pool_ids"
        elif key == "requestsPerSeconds":
            suggest = "requests_per_seconds"
        elif key == "targetHostnames":
            suggest = "target_hostnames"
        elif key == "targetZoneNames":
            suggest = "target_zone_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_trigger_preferences: Optional[Sequence[str]] = None,
                 enableds: Optional[Sequence[str]] = None,
                 event_sources: Optional[Sequence[str]] = None,
                 event_types: Optional[Sequence[str]] = None,
                 health_check_ids: Optional[Sequence[str]] = None,
                 input_ids: Optional[Sequence[str]] = None,
                 limits: Optional[Sequence[str]] = None,
                 megabits_per_seconds: Optional[Sequence[str]] = None,
                 new_healths: Optional[Sequence[str]] = None,
                 packets_per_seconds: Optional[Sequence[str]] = None,
                 pool_ids: Optional[Sequence[str]] = None,
                 products: Optional[Sequence[str]] = None,
                 protocols: Optional[Sequence[str]] = None,
                 requests_per_seconds: Optional[Sequence[str]] = None,
                 services: Optional[Sequence[str]] = None,
                 slos: Optional[Sequence[str]] = None,
                 statuses: Optional[Sequence[str]] = None,
                 target_hostnames: Optional[Sequence[str]] = None,
                 target_zone_names: Optional[Sequence[str]] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] alert_trigger_preferences: Alert trigger preferences. Example: `slo`.
        :param Sequence[str] enableds: State of the pool to alert on.
        :param Sequence[str] event_sources: Source configuration to alert on for pool or origin.
        :param Sequence[str] event_types: Stream event type to alert on.
        :param Sequence[str] health_check_ids: Identifier health check. Required when using `filters.0.status`.
        :param Sequence[str] input_ids: Stream input id to alert on.
        :param Sequence[str] limits: A numerical limit. Example: `100`.
        :param Sequence[str] megabits_per_seconds: Megabits per second threshold for dos alert.
        :param Sequence[str] new_healths: Health status to alert on for pool or origin.
        :param Sequence[str] packets_per_seconds: Packets per second threshold for dos alert.
        :param Sequence[str] pool_ids: Load balancer pool identifier.
        :param Sequence[str] products: Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        :param Sequence[str] protocols: Protocol to alert on for dos.
        :param Sequence[str] requests_per_seconds: Requests per second threshold for dos alert.
        :param Sequence[str] slos: A numerical limit. Example: `99.9`.
        :param Sequence[str] statuses: Status to alert on.
        :param Sequence[str] target_hostnames: Target host to alert on for dos.
        :param Sequence[str] target_zone_names: Target domain to alert on.
        :param Sequence[str] zones: A list of zone identifiers.
        """
        if alert_trigger_preferences is not None:
            pulumi.set(__self__, "alert_trigger_preferences", alert_trigger_preferences)
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)
        if event_sources is not None:
            pulumi.set(__self__, "event_sources", event_sources)
        if event_types is not None:
            pulumi.set(__self__, "event_types", event_types)
        if health_check_ids is not None:
            pulumi.set(__self__, "health_check_ids", health_check_ids)
        if input_ids is not None:
            pulumi.set(__self__, "input_ids", input_ids)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if megabits_per_seconds is not None:
            pulumi.set(__self__, "megabits_per_seconds", megabits_per_seconds)
        if new_healths is not None:
            pulumi.set(__self__, "new_healths", new_healths)
        if packets_per_seconds is not None:
            pulumi.set(__self__, "packets_per_seconds", packets_per_seconds)
        if pool_ids is not None:
            pulumi.set(__self__, "pool_ids", pool_ids)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if requests_per_seconds is not None:
            pulumi.set(__self__, "requests_per_seconds", requests_per_seconds)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if slos is not None:
            pulumi.set(__self__, "slos", slos)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if target_hostnames is not None:
            pulumi.set(__self__, "target_hostnames", target_hostnames)
        if target_zone_names is not None:
            pulumi.set(__self__, "target_zone_names", target_zone_names)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Optional[Sequence[str]]:
        """
        Alert trigger preferences. Example: `slo`.
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[str]]:
        """
        State of the pool to alert on.
        """
        return pulumi.get(self, "enableds")

    @property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Optional[Sequence[str]]:
        """
        Source configuration to alert on for pool or origin.
        """
        return pulumi.get(self, "event_sources")

    @property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Optional[Sequence[str]]:
        """
        Stream event type to alert on.
        """
        return pulumi.get(self, "event_types")

    @property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Optional[Sequence[str]]:
        """
        Identifier health check. Required when using `filters.0.status`.
        """
        return pulumi.get(self, "health_check_ids")

    @property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Optional[Sequence[str]]:
        """
        Stream input id to alert on.
        """
        return pulumi.get(self, "input_ids")

    @property
    @pulumi.getter
    def limits(self) -> Optional[Sequence[str]]:
        """
        A numerical limit. Example: `100`.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Optional[Sequence[str]]:
        """
        Megabits per second threshold for dos alert.
        """
        return pulumi.get(self, "megabits_per_seconds")

    @property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Optional[Sequence[str]]:
        """
        Health status to alert on for pool or origin.
        """
        return pulumi.get(self, "new_healths")

    @property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Optional[Sequence[str]]:
        """
        Packets per second threshold for dos alert.
        """
        return pulumi.get(self, "packets_per_seconds")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[Sequence[str]]:
        """
        Load balancer pool identifier.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[str]]:
        """
        Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[str]]:
        """
        Protocol to alert on for dos.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Optional[Sequence[str]]:
        """
        Requests per second threshold for dos alert.
        """
        return pulumi.get(self, "requests_per_seconds")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def slos(self) -> Optional[Sequence[str]]:
        """
        A numerical limit. Example: `99.9`.
        """
        return pulumi.get(self, "slos")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[str]]:
        """
        Status to alert on.
        """
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Optional[Sequence[str]]:
        """
        Target host to alert on for dos.
        """
        return pulumi.get(self, "target_hostnames")

    @property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Optional[Sequence[str]]:
        """
        Target domain to alert on.
        """
        return pulumi.get(self, "target_zone_names")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        A list of zone identifiers.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class NotificationPolicyPagerdutyIntegration(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str name: The name of the notification policy.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the notification policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NotificationPolicyWebhooksIntegration(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str name: The name of the notification policy.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the notification policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PageRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "bypassCacheOnCookie":
            suggest = "bypass_cache_on_cookie"
        elif key == "cacheByDeviceType":
            suggest = "cache_by_device_type"
        elif key == "cacheDeceptionArmor":
            suggest = "cache_deception_armor"
        elif key == "cacheKeyFields":
            suggest = "cache_key_fields"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "cacheOnCookie":
            suggest = "cache_on_cookie"
        elif key == "cacheTtlByStatuses":
            suggest = "cache_ttl_by_statuses"
        elif key == "disableApps":
            suggest = "disable_apps"
        elif key == "disablePerformance":
            suggest = "disable_performance"
        elif key == "disableRailgun":
            suggest = "disable_railgun"
        elif key == "disableSecurity":
            suggest = "disable_security"
        elif key == "disableZaraz":
            suggest = "disable_zaraz"
        elif key == "edgeCacheTtl":
            suggest = "edge_cache_ttl"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "explicitCacheControl":
            suggest = "explicit_cache_control"
        elif key == "forwardingUrl":
            suggest = "forwarding_url"
        elif key == "hostHeaderOverride":
            suggest = "host_header_override"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "resolveOverride":
            suggest = "resolve_override"
        elif key == "respectStrongEtag":
            suggest = "respect_strong_etag"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_use_https: Optional[bool] = None,
                 automatic_https_rewrites: Optional[str] = None,
                 browser_cache_ttl: Optional[str] = None,
                 browser_check: Optional[str] = None,
                 bypass_cache_on_cookie: Optional[str] = None,
                 cache_by_device_type: Optional[str] = None,
                 cache_deception_armor: Optional[str] = None,
                 cache_key_fields: Optional['outputs.PageRuleActionsCacheKeyFields'] = None,
                 cache_level: Optional[str] = None,
                 cache_on_cookie: Optional[str] = None,
                 cache_ttl_by_statuses: Optional[Sequence['outputs.PageRuleActionsCacheTtlByStatus']] = None,
                 disable_apps: Optional[bool] = None,
                 disable_performance: Optional[bool] = None,
                 disable_railgun: Optional[bool] = None,
                 disable_security: Optional[bool] = None,
                 disable_zaraz: Optional[bool] = None,
                 edge_cache_ttl: Optional[int] = None,
                 email_obfuscation: Optional[str] = None,
                 explicit_cache_control: Optional[str] = None,
                 forwarding_url: Optional['outputs.PageRuleActionsForwardingUrl'] = None,
                 host_header_override: Optional[str] = None,
                 ip_geolocation: Optional[str] = None,
                 minifies: Optional[Sequence['outputs.PageRuleActionsMinify']] = None,
                 mirage: Optional[str] = None,
                 opportunistic_encryption: Optional[str] = None,
                 origin_error_page_pass_thru: Optional[str] = None,
                 polish: Optional[str] = None,
                 resolve_override: Optional[str] = None,
                 respect_strong_etag: Optional[str] = None,
                 response_buffering: Optional[str] = None,
                 rocket_loader: Optional[str] = None,
                 security_level: Optional[str] = None,
                 server_side_exclude: Optional[str] = None,
                 sort_query_string_for_cache: Optional[str] = None,
                 ssl: Optional[str] = None,
                 true_client_ip_header: Optional[str] = None,
                 waf: Optional[str] = None):
        """
        :param bool always_use_https: Boolean of whether this action is enabled. Default: false.
        :param str automatic_https_rewrites: Whether this action is `"on"` or `"off"`.
        :param str browser_cache_ttl: The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        :param str browser_check: Whether this action is `"on"` or `"off"`.
        :param str bypass_cache_on_cookie: String value of cookie name to conditionally bypass cache the page.
        :param str cache_by_device_type: Whether this action is `"on"` or `"off"`.
        :param str cache_deception_armor: Whether this action is `"on"` or `"off"`.
        :param 'PageRuleActionsCacheKeyFieldsArgs' cache_key_fields: Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        :param str cache_level: Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        :param str cache_on_cookie: String value of cookie name to conditionally cache the page.
        :param Sequence['PageRuleActionsCacheTtlByStatusArgs'] cache_ttl_by_statuses: Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        :param bool disable_apps: Boolean of whether this action is enabled. Default: false.
        :param bool disable_performance: Boolean of whether this action is enabled. Default: false.
        :param bool disable_railgun: Boolean of whether this action is enabled. Default: false.
        :param bool disable_security: Boolean of whether this action is enabled. Default: false.
        :param bool disable_zaraz: Boolean of whether this action is enabled. Default: false.
        :param int edge_cache_ttl: The Time To Live for the edge cache.
        :param str email_obfuscation: Whether this action is `"on"` or `"off"`.
        :param str explicit_cache_control: Whether origin Cache-Control action is `"on"` or `"off"`.
        :param 'PageRuleActionsForwardingUrlArgs' forwarding_url: The URL to forward to, and with what status. See below.
        :param str host_header_override: Value of the Host header to send.
        :param str ip_geolocation: Whether this action is `"on"` or `"off"`.
        :param Sequence['PageRuleActionsMinifyArgs'] minifies: The configuration for HTML, CSS and JS minification. See below for full list of options.
        :param str mirage: Whether this action is `"on"` or `"off"`.
        :param str opportunistic_encryption: Whether this action is `"on"` or `"off"`.
        :param str origin_error_page_pass_thru: Whether this action is `"on"` or `"off"`.
        :param str polish: Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        :param str resolve_override: Overridden origin server name.
        :param str respect_strong_etag: Whether this action is `"on"` or `"off"`.
        :param str response_buffering: Whether this action is `"on"` or `"off"`.
        :param str rocket_loader: Whether to set the rocket loader to `"on"`, `"off"`.
        :param str security_level: Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        :param str server_side_exclude: Whether this action is `"on"` or `"off"`.
        :param str sort_query_string_for_cache: Whether this action is `"on"` or `"off"`.
        :param str ssl: Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        :param str true_client_ip_header: Whether this action is `"on"` or `"off"`.
        :param str waf: Whether this action is `"on"` or `"off"`.
        """
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if bypass_cache_on_cookie is not None:
            pulumi.set(__self__, "bypass_cache_on_cookie", bypass_cache_on_cookie)
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if cache_key_fields is not None:
            pulumi.set(__self__, "cache_key_fields", cache_key_fields)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if cache_on_cookie is not None:
            pulumi.set(__self__, "cache_on_cookie", cache_on_cookie)
        if cache_ttl_by_statuses is not None:
            pulumi.set(__self__, "cache_ttl_by_statuses", cache_ttl_by_statuses)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_performance is not None:
            pulumi.set(__self__, "disable_performance", disable_performance)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_security is not None:
            pulumi.set(__self__, "disable_security", disable_security)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_cache_ttl is not None:
            pulumi.set(__self__, "edge_cache_ttl", edge_cache_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if explicit_cache_control is not None:
            pulumi.set(__self__, "explicit_cache_control", explicit_cache_control)
        if forwarding_url is not None:
            pulumi.set(__self__, "forwarding_url", forwarding_url)
        if host_header_override is not None:
            pulumi.set(__self__, "host_header_override", host_header_override)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if minifies is not None:
            pulumi.set(__self__, "minifies", minifies)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if resolve_override is not None:
            pulumi.set(__self__, "resolve_override", resolve_override)
        if respect_strong_etag is not None:
            pulumi.set(__self__, "respect_strong_etag", respect_strong_etag)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[str]:
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="bypassCacheOnCookie")
    def bypass_cache_on_cookie(self) -> Optional[str]:
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        return pulumi.get(self, "bypass_cache_on_cookie")

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="cacheKeyFields")
    def cache_key_fields(self) -> Optional['outputs.PageRuleActionsCacheKeyFields']:
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        return pulumi.get(self, "cache_key_fields")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[str]:
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="cacheOnCookie")
    def cache_on_cookie(self) -> Optional[str]:
        """
        String value of cookie name to conditionally cache the page.
        """
        return pulumi.get(self, "cache_on_cookie")

    @property
    @pulumi.getter(name="cacheTtlByStatuses")
    def cache_ttl_by_statuses(self) -> Optional[Sequence['outputs.PageRuleActionsCacheTtlByStatus']]:
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        return pulumi.get(self, "cache_ttl_by_statuses")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disablePerformance")
    def disable_performance(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_performance")

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_railgun")

    @property
    @pulumi.getter(name="disableSecurity")
    def disable_security(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_security")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeCacheTtl")
    def edge_cache_ttl(self) -> Optional[int]:
        """
        The Time To Live for the edge cache.
        """
        return pulumi.get(self, "edge_cache_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="explicitCacheControl")
    def explicit_cache_control(self) -> Optional[str]:
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "explicit_cache_control")

    @property
    @pulumi.getter(name="forwardingUrl")
    def forwarding_url(self) -> Optional['outputs.PageRuleActionsForwardingUrl']:
        """
        The URL to forward to, and with what status. See below.
        """
        return pulumi.get(self, "forwarding_url")

    @property
    @pulumi.getter(name="hostHeaderOverride")
    def host_header_override(self) -> Optional[str]:
        """
        Value of the Host header to send.
        """
        return pulumi.get(self, "host_header_override")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def minifies(self) -> Optional[Sequence['outputs.PageRuleActionsMinify']]:
        """
        The configuration for HTML, CSS and JS minification. See below for full list of options.
        """
        return pulumi.get(self, "minifies")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="resolveOverride")
    def resolve_override(self) -> Optional[str]:
        """
        Overridden origin server name.
        """
        return pulumi.get(self, "resolve_override")

    @property
    @pulumi.getter(name="respectStrongEtag")
    def respect_strong_etag(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "respect_strong_etag")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[str]:
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter
    def waf(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "waf")


@pulumi.output_type
class PageRuleActionsCacheKeyFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: 'outputs.PageRuleActionsCacheKeyFieldsHost',
                 query_string: 'outputs.PageRuleActionsCacheKeyFieldsQueryString',
                 user: 'outputs.PageRuleActionsCacheKeyFieldsUser',
                 cookie: Optional['outputs.PageRuleActionsCacheKeyFieldsCookie'] = None,
                 header: Optional['outputs.PageRuleActionsCacheKeyFieldsHeader'] = None):
        """
        :param 'PageRuleActionsCacheKeyFieldsHostArgs' host: Controls which Host header goes into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsQueryStringArgs' query_string: Controls which URL query string parameters go into the Cache Key.
        :param 'PageRuleActionsCacheKeyFieldsUserArgs' user: Controls which end user-related features go into the Cache Key.
        :param 'PageRuleActionsCacheKeyFieldsCookieArgs' cookie: Controls what cookies go into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsHeaderArgs' header: Controls what HTTP headers go into Cache Key:
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "user", user)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def host(self) -> 'outputs.PageRuleActionsCacheKeyFieldsHost':
        """
        Controls which Host header goes into Cache Key:
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> 'outputs.PageRuleActionsCacheKeyFieldsQueryString':
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> 'outputs.PageRuleActionsCacheKeyFieldsUser':
        """
        Controls which end user-related features go into the Cache Key.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsCookie']:
        """
        Controls what cookies go into Cache Key:
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsHeader']:
        """
        Controls what HTTP headers go into Cache Key:
        """
        return pulumi.get(self, "header")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] check_presences: Check for presence of specified cookies, without including their actual values.
        :param Sequence[str] includes: Use values of specified cookies in Cache Key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        """
        Check for presence of specified cookies, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Use values of specified cookies in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] check_presences: Check for presence of specified cookies, without including their actual values.
        :param Sequence[str] excludes: Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        :param Sequence[str] includes: Use values of specified cookies in Cache Key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        """
        Check for presence of specified cookies, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Use values of specified cookies in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsHost(dict):
    def __init__(__self__, *,
                 resolved: Optional[bool] = None):
        """
        :param bool resolved: `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[bool]:
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        return pulumi.get(self, "resolved")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsQueryString(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 ignore: Optional[bool] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] excludes: Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        :param bool ignore: `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        :param Sequence[str] includes: Use values of specified cookies in Cache Key.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if ignore is not None:
            pulumi.set(__self__, "ignore", ignore)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def ignore(self) -> Optional[bool]:
        """
        `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        """
        return pulumi.get(self, "ignore")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Use values of specified cookies in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_type: Optional[bool] = None,
                 geo: Optional[bool] = None,
                 lang: Optional[bool] = None):
        """
        :param bool device_type: `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
        :param bool geo: `true` - includes the client’s country, derived from the IP address; defaults to `false`.
        :param bool lang: `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
               
               Example:
               
               ```python
               import pulumi
               import pulumi_cloudflare as cloudflare
               
               # Unrealistic example with all features used
               foobar = cloudflare.PageRule("foobar",
                   zone_id=var["cloudflare_zone_id"],
                   target=f"{var['cloudflare_zone']}/app/*",
                   priority=1,
                   actions=cloudflare.PageRuleActionsArgs(
                       cache_key_fields=cloudflare.PageRuleActionsCacheKeyFieldsArgs(
                           cookie=cloudflare.PageRuleActionsCacheKeyFieldsCookieArgs(
                               check_presences=["wordpress_test_cookie"],
                           ),
                           header=cloudflare.PageRuleActionsCacheKeyFieldsHeaderArgs(
                               check_presences=["header_present"],
                               excludes=["origin"],
                               includes=[
                                   "api-key",
                                   "dnt",
                               ],
                           ),
                           host=cloudflare.PageRuleActionsCacheKeyFieldsHostArgs(
                               resolved=True,
                           ),
                           query_string=cloudflare.PageRuleActionsCacheKeyFieldsQueryStringArgs(
                               ignore=True,
                           ),
                           user=cloudflare.PageRuleActionsCacheKeyFieldsUserArgs(
                               device_type=False,
                               geo=True,
                               lang=True,
                           ),
                       ),
                   ))
               ```
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[bool]:
        """
        `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[bool]:
        """
        `true` - includes the client’s country, derived from the IP address; defaults to `false`.
        """
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[bool]:
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.

        Example:

        ```python
        import pulumi
        import pulumi_cloudflare as cloudflare

        # Unrealistic example with all features used
        foobar = cloudflare.PageRule("foobar",
            zone_id=var["cloudflare_zone_id"],
            target=f"{var['cloudflare_zone']}/app/*",
            priority=1,
            actions=cloudflare.PageRuleActionsArgs(
                cache_key_fields=cloudflare.PageRuleActionsCacheKeyFieldsArgs(
                    cookie=cloudflare.PageRuleActionsCacheKeyFieldsCookieArgs(
                        check_presences=["wordpress_test_cookie"],
                    ),
                    header=cloudflare.PageRuleActionsCacheKeyFieldsHeaderArgs(
                        check_presences=["header_present"],
                        excludes=["origin"],
                        includes=[
                            "api-key",
                            "dnt",
                        ],
                    ),
                    host=cloudflare.PageRuleActionsCacheKeyFieldsHostArgs(
                        resolved=True,
                    ),
                    query_string=cloudflare.PageRuleActionsCacheKeyFieldsQueryStringArgs(
                        ignore=True,
                    ),
                    user=cloudflare.PageRuleActionsCacheKeyFieldsUserArgs(
                        device_type=False,
                        geo=True,
                        lang=True,
                    ),
                ),
            ))
        ```
        """
        return pulumi.get(self, "lang")


@pulumi.output_type
class PageRuleActionsCacheTtlByStatus(dict):
    def __init__(__self__, *,
                 codes: str,
                 ttl: int):
        """
        :param str codes: A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        :param int ttl: Duration a resource lives in the Cloudflare cache.
               - positive number - cache for specified duration in seconds
        """
        pulumi.set(__self__, "codes", codes)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def codes(self) -> str:
        """
        A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        """
        return pulumi.get(self, "codes")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        Duration a resource lives in the Cloudflare cache.
        - positive number - cache for specified duration in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class PageRuleActionsForwardingUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsForwardingUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsForwardingUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsForwardingUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: int,
                 url: str):
        """
        :param int status_code: The status code to use for the redirection.
        :param str url: The URL to which the page rule should forward.
        """
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The status code to use for the redirection.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to which the page rule should forward.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PageRuleActionsMinify(dict):
    def __init__(__self__, *,
                 css: str,
                 html: str,
                 js: str):
        """
        :param str css: Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        :param str html: Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        :param str js: Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> str:
        """
        Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> str:
        """
        Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> str:
        """
        Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class PagesProjectBuildConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "destinationDir":
            suggest = "destination_dir"
        elif key == "rootDir":
            suggest = "root_dir"
        elif key == "webAnalyticsTag":
            suggest = "web_analytics_tag"
        elif key == "webAnalyticsToken":
            suggest = "web_analytics_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectBuildConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectBuildConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectBuildConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_command: Optional[str] = None,
                 destination_dir: Optional[str] = None,
                 root_dir: Optional[str] = None,
                 web_analytics_tag: Optional[str] = None,
                 web_analytics_token: Optional[str] = None):
        """
        :param str build_command: Command used to build project.
        :param str destination_dir: Output directory of the build.
        :param str root_dir: Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        :param str web_analytics_tag: The classifying tag for analytics.
        :param str web_analytics_token: The auth token for analytics.
        """
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[str]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[str]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[str]:
        """
        Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[str]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[str]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class PagesProjectDeploymentConfigs(dict):
    def __init__(__self__, *,
                 preview: 'outputs.PagesProjectDeploymentConfigsPreview',
                 production: 'outputs.PagesProjectDeploymentConfigsProduction'):
        """
        :param 'PagesProjectDeploymentConfigsPreviewArgs' preview: Configuration for preview deploys.
        :param 'PagesProjectDeploymentConfigsProductionArgs' production: Configuration for production deploys.
        """
        pulumi.set(__self__, "preview", preview)
        pulumi.set(__self__, "production", production)

    @property
    @pulumi.getter
    def preview(self) -> 'outputs.PagesProjectDeploymentConfigsPreview':
        """
        Configuration for preview deploys.
        """
        return pulumi.get(self, "preview")

    @property
    @pulumi.getter
    def production(self) -> 'outputs.PagesProjectDeploymentConfigsProduction':
        """
        Configuration for production deploys.
        """
        return pulumi.get(self, "production")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreview(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysUseLatestCompatibilityDate":
            suggest = "always_use_latest_compatibility_date"
        elif key == "compatibilityDate":
            suggest = "compatibility_date"
        elif key == "compatibilityFlags":
            suggest = "compatibility_flags"
        elif key == "d1Databases":
            suggest = "d1_databases"
        elif key == "durableObjectNamespaces":
            suggest = "durable_object_namespaces"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "failOpen":
            suggest = "fail_open"
        elif key == "kvNamespaces":
            suggest = "kv_namespaces"
        elif key == "r2Buckets":
            suggest = "r2_buckets"
        elif key == "serviceBindings":
            suggest = "service_bindings"
        elif key == "usageModel":
            suggest = "usage_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsPreview. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsPreview.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsPreview.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_use_latest_compatibility_date: Optional[bool] = None,
                 compatibility_date: Optional[str] = None,
                 compatibility_flags: Optional[Sequence[str]] = None,
                 d1_databases: Optional[Mapping[str, Any]] = None,
                 durable_object_namespaces: Optional[Mapping[str, Any]] = None,
                 environment_variables: Optional[Mapping[str, Any]] = None,
                 fail_open: Optional[bool] = None,
                 kv_namespaces: Optional[Mapping[str, Any]] = None,
                 placement: Optional['outputs.PagesProjectDeploymentConfigsPreviewPlacement'] = None,
                 r2_buckets: Optional[Mapping[str, Any]] = None,
                 secrets: Optional[Mapping[str, Any]] = None,
                 service_bindings: Optional[Sequence['outputs.PagesProjectDeploymentConfigsPreviewServiceBinding']] = None,
                 usage_model: Optional[str] = None):
        if always_use_latest_compatibility_date is not None:
            pulumi.set(__self__, "always_use_latest_compatibility_date", always_use_latest_compatibility_date)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_bindings is not None:
            pulumi.set(__self__, "service_bindings", service_bindings)
        if usage_model is not None:
            pulumi.set(__self__, "usage_model", usage_model)

    @property
    @pulumi.getter(name="alwaysUseLatestCompatibilityDate")
    def always_use_latest_compatibility_date(self) -> Optional[bool]:
        return pulumi.get(self, "always_use_latest_compatibility_date")

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[str]:
        return pulumi.get(self, "compatibility_date")

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "compatibility_flags")

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "d1_databases")

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "durable_object_namespaces")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[bool]:
        return pulumi.get(self, "fail_open")

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "kv_namespaces")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.PagesProjectDeploymentConfigsPreviewPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "r2_buckets")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceBindings")
    def service_bindings(self) -> Optional[Sequence['outputs.PagesProjectDeploymentConfigsPreviewServiceBinding']]:
        return pulumi.get(self, "service_bindings")

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[str]:
        return pulumi.get(self, "usage_model")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewPlacement(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewServiceBinding(dict):
    def __init__(__self__, *,
                 name: str,
                 service: str,
                 environment: Optional[str] = None):
        """
        :param str name: Name of the project. **Modifying this attribute will force creation of a new resource.**
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the project. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        return pulumi.get(self, "environment")


@pulumi.output_type
class PagesProjectDeploymentConfigsProduction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysUseLatestCompatibilityDate":
            suggest = "always_use_latest_compatibility_date"
        elif key == "compatibilityDate":
            suggest = "compatibility_date"
        elif key == "compatibilityFlags":
            suggest = "compatibility_flags"
        elif key == "d1Databases":
            suggest = "d1_databases"
        elif key == "durableObjectNamespaces":
            suggest = "durable_object_namespaces"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "failOpen":
            suggest = "fail_open"
        elif key == "kvNamespaces":
            suggest = "kv_namespaces"
        elif key == "r2Buckets":
            suggest = "r2_buckets"
        elif key == "serviceBindings":
            suggest = "service_bindings"
        elif key == "usageModel":
            suggest = "usage_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsProduction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsProduction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsProduction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_use_latest_compatibility_date: Optional[bool] = None,
                 compatibility_date: Optional[str] = None,
                 compatibility_flags: Optional[Sequence[str]] = None,
                 d1_databases: Optional[Mapping[str, Any]] = None,
                 durable_object_namespaces: Optional[Mapping[str, Any]] = None,
                 environment_variables: Optional[Mapping[str, Any]] = None,
                 fail_open: Optional[bool] = None,
                 kv_namespaces: Optional[Mapping[str, Any]] = None,
                 placement: Optional['outputs.PagesProjectDeploymentConfigsProductionPlacement'] = None,
                 r2_buckets: Optional[Mapping[str, Any]] = None,
                 secrets: Optional[Mapping[str, Any]] = None,
                 service_bindings: Optional[Sequence['outputs.PagesProjectDeploymentConfigsProductionServiceBinding']] = None,
                 usage_model: Optional[str] = None):
        if always_use_latest_compatibility_date is not None:
            pulumi.set(__self__, "always_use_latest_compatibility_date", always_use_latest_compatibility_date)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_bindings is not None:
            pulumi.set(__self__, "service_bindings", service_bindings)
        if usage_model is not None:
            pulumi.set(__self__, "usage_model", usage_model)

    @property
    @pulumi.getter(name="alwaysUseLatestCompatibilityDate")
    def always_use_latest_compatibility_date(self) -> Optional[bool]:
        return pulumi.get(self, "always_use_latest_compatibility_date")

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[str]:
        return pulumi.get(self, "compatibility_date")

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "compatibility_flags")

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "d1_databases")

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "durable_object_namespaces")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[bool]:
        return pulumi.get(self, "fail_open")

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "kv_namespaces")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.PagesProjectDeploymentConfigsProductionPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "r2_buckets")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceBindings")
    def service_bindings(self) -> Optional[Sequence['outputs.PagesProjectDeploymentConfigsProductionServiceBinding']]:
        return pulumi.get(self, "service_bindings")

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[str]:
        return pulumi.get(self, "usage_model")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionPlacement(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionServiceBinding(dict):
    def __init__(__self__, *,
                 name: str,
                 service: str,
                 environment: Optional[str] = None):
        """
        :param str name: Name of the project. **Modifying this attribute will force creation of a new resource.**
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the project. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        return pulumi.get(self, "environment")


@pulumi.output_type
class PagesProjectSource(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.PagesProjectSourceConfig'] = None,
                 type: Optional[str] = None):
        """
        :param 'PagesProjectSourceConfigArgs' config: Configuration for the source of the Cloudflare Pages project.
        :param str type: Project host type.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.PagesProjectSourceConfig']:
        """
        Configuration for the source of the Cloudflare Pages project.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Project host type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productionBranch":
            suggest = "production_branch"
        elif key == "deploymentsEnabled":
            suggest = "deployments_enabled"
        elif key == "prCommentsEnabled":
            suggest = "pr_comments_enabled"
        elif key == "previewBranchExcludes":
            suggest = "preview_branch_excludes"
        elif key == "previewBranchIncludes":
            suggest = "preview_branch_includes"
        elif key == "previewDeploymentSetting":
            suggest = "preview_deployment_setting"
        elif key == "productionDeploymentEnabled":
            suggest = "production_deployment_enabled"
        elif key == "repoName":
            suggest = "repo_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 production_branch: str,
                 deployments_enabled: Optional[bool] = None,
                 owner: Optional[str] = None,
                 pr_comments_enabled: Optional[bool] = None,
                 preview_branch_excludes: Optional[Sequence[str]] = None,
                 preview_branch_includes: Optional[Sequence[str]] = None,
                 preview_deployment_setting: Optional[str] = None,
                 production_deployment_enabled: Optional[bool] = None,
                 repo_name: Optional[str] = None):
        """
        :param str production_branch: The name of the branch that is used for the production environment.
        """
        pulumi.set(__self__, "production_branch", production_branch)
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_deployment_enabled is not None:
            pulumi.set(__self__, "production_deployment_enabled", production_deployment_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> str:
        """
        The name of the branch that is used for the production environment.
        """
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[str]:
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionDeploymentEnabled")
    def production_deployment_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "production_deployment_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class RateLimitAction(dict):
    def __init__(__self__, *,
                 mode: str,
                 response: Optional['outputs.RateLimitActionResponse'] = None,
                 timeout: Optional[int] = None):
        """
        :param str mode: The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        :param 'RateLimitActionResponseArgs' response: Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        :param int timeout: The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
        pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RateLimitActionResponse']:
        """
        Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RateLimitActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: str,
                 content_type: str):
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> str:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        return pulumi.get(self, "content_type")


@pulumi.output_type
class RateLimitCorrelate(dict):
    def __init__(__self__, *,
                 by: Optional[str] = None):
        """
        :param str by: If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
        if by is not None:
            pulumi.set(__self__, "by", by)

    @property
    @pulumi.getter
    def by(self) -> Optional[str]:
        """
        If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
        return pulumi.get(self, "by")


@pulumi.output_type
class RateLimitMatch(dict):
    def __init__(__self__, *,
                 request: Optional['outputs.RateLimitMatchRequest'] = None,
                 response: Optional['outputs.RateLimitMatchResponse'] = None):
        """
        :param 'RateLimitMatchRequestArgs' request: Matches HTTP requests (from the client to Cloudflare).
        :param 'RateLimitMatchResponseArgs' response: Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.RateLimitMatchRequest']:
        """
        Matches HTTP requests (from the client to Cloudflare).
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RateLimitMatchResponse']:
        """
        Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class RateLimitMatchRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlPattern":
            suggest = "url_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitMatchRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitMatchRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitMatchRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 methods: Optional[Sequence[str]] = None,
                 schemes: Optional[Sequence[str]] = None,
                 url_pattern: Optional[str] = None):
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if schemes is not None:
            pulumi.set(__self__, "schemes", schemes)
        if url_pattern is not None:
            pulumi.set(__self__, "url_pattern", url_pattern)

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def schemes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "schemes")

    @property
    @pulumi.getter(name="urlPattern")
    def url_pattern(self) -> Optional[str]:
        return pulumi.get(self, "url_pattern")


@pulumi.output_type
class RateLimitMatchResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originTraffic":
            suggest = "origin_traffic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitMatchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitMatchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitMatchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[Mapping[str, str]]] = None,
                 origin_traffic: Optional[bool] = None,
                 statuses: Optional[Sequence[int]] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if origin_traffic is not None:
            pulumi.set(__self__, "origin_traffic", origin_traffic)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[Mapping[str, str]]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> Optional[bool]:
        return pulumi.get(self, "origin_traffic")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "statuses")


@pulumi.output_type
class RecordData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "digestType":
            suggest = "digest_type"
        elif key == "keyTag":
            suggest = "key_tag"
        elif key == "latDegrees":
            suggest = "lat_degrees"
        elif key == "latDirection":
            suggest = "lat_direction"
        elif key == "latMinutes":
            suggest = "lat_minutes"
        elif key == "latSeconds":
            suggest = "lat_seconds"
        elif key == "longDegrees":
            suggest = "long_degrees"
        elif key == "longDirection":
            suggest = "long_direction"
        elif key == "longMinutes":
            suggest = "long_minutes"
        elif key == "longSeconds":
            suggest = "long_seconds"
        elif key == "matchingType":
            suggest = "matching_type"
        elif key == "precisionHorz":
            suggest = "precision_horz"
        elif key == "precisionVert":
            suggest = "precision_vert"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[int] = None,
                 altitude: Optional[float] = None,
                 certificate: Optional[str] = None,
                 content: Optional[str] = None,
                 digest: Optional[str] = None,
                 digest_type: Optional[int] = None,
                 fingerprint: Optional[str] = None,
                 flags: Optional[str] = None,
                 key_tag: Optional[int] = None,
                 lat_degrees: Optional[int] = None,
                 lat_direction: Optional[str] = None,
                 lat_minutes: Optional[int] = None,
                 lat_seconds: Optional[float] = None,
                 long_degrees: Optional[int] = None,
                 long_direction: Optional[str] = None,
                 long_minutes: Optional[int] = None,
                 long_seconds: Optional[float] = None,
                 matching_type: Optional[int] = None,
                 name: Optional[str] = None,
                 order: Optional[int] = None,
                 port: Optional[int] = None,
                 precision_horz: Optional[float] = None,
                 precision_vert: Optional[float] = None,
                 preference: Optional[int] = None,
                 priority: Optional[int] = None,
                 proto: Optional[str] = None,
                 protocol: Optional[int] = None,
                 public_key: Optional[str] = None,
                 regex: Optional[str] = None,
                 replacement: Optional[str] = None,
                 selector: Optional[int] = None,
                 service: Optional[str] = None,
                 size: Optional[float] = None,
                 tag: Optional[str] = None,
                 target: Optional[str] = None,
                 type: Optional[int] = None,
                 usage: Optional[int] = None,
                 value: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str name: The name of the record. **Modifying this attribute will force creation of a new resource.**
        :param int priority: The priority of the record.
        :param int type: The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`, `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`. **Modifying this attribute will force creation of a new resource.**
        :param str value: The value of the record. Conflicts with `data`.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if proto is not None:
            pulumi.set(__self__, "proto", proto)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[int]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def altitude(self) -> Optional[float]:
        return pulumi.get(self, "altitude")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[int]:
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def flags(self) -> Optional[str]:
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[int]:
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[int]:
        return pulumi.get(self, "lat_degrees")

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[str]:
        return pulumi.get(self, "lat_direction")

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[int]:
        return pulumi.get(self, "lat_minutes")

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[float]:
        return pulumi.get(self, "lat_seconds")

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[int]:
        return pulumi.get(self, "long_degrees")

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[str]:
        return pulumi.get(self, "long_direction")

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[int]:
        return pulumi.get(self, "long_minutes")

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[float]:
        return pulumi.get(self, "long_seconds")

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[int]:
        return pulumi.get(self, "matching_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the record. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[float]:
        return pulumi.get(self, "precision_horz")

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[float]:
        return pulumi.get(self, "precision_vert")

    @property
    @pulumi.getter
    def preference(self) -> Optional[int]:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority of the record.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def proto(self) -> Optional[str]:
        return pulumi.get(self, "proto")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        return pulumi.get(self, "replacement")

    @property
    @pulumi.getter
    def selector(self) -> Optional[int]:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def size(self) -> Optional[float]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[int]:
        """
        The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`, `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> Optional[int]:
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the record. Conflicts with `data`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class RulesetRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionParameters":
            suggest = "action_parameters"
        elif key == "exposedCredentialCheck":
            suggest = "exposed_credential_check"
        elif key == "lastUpdated":
            suggest = "last_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 action: Optional[str] = None,
                 action_parameters: Optional['outputs.RulesetRuleActionParameters'] = None,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 exposed_credential_check: Optional['outputs.RulesetRuleExposedCredentialCheck'] = None,
                 id: Optional[str] = None,
                 last_updated: Optional[str] = None,
                 logging: Optional['outputs.RulesetRuleLogging'] = None,
                 ratelimit: Optional['outputs.RulesetRuleRatelimit'] = None,
                 ref: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str expression: Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param str action: Action to perform in the ruleset rule. Available values: `allow`, `block`, `challenge`, `ddos_dynamic`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `set_cache_settings`, `set_config`, `serve_error`, `skip`, `compress_response`.
        :param 'RulesetRuleActionParametersArgs' action_parameters: List of parameters that configure the behavior of the ruleset rule action.
        :param str description: Brief summary of the ruleset rule and its intended use.
        :param bool enabled: Whether the rule is active.
        :param 'RulesetRuleExposedCredentialCheckArgs' exposed_credential_check: List of parameters that configure exposed credential checks.
        :param str id: Unique rule identifier.
        :param str last_updated: The most recent update to this rule.
        :param 'RulesetRuleLoggingArgs' logging: List parameters to configure how the rule generates logs.
        :param 'RulesetRuleRatelimitArgs' ratelimit: List of parameters that configure HTTP rate limiting behaviour.
        :param str ref: Rule reference.
        :param str version: Version of the ruleset to deploy.
        """
        pulumi.set(__self__, "expression", expression)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to perform in the ruleset rule. Available values: `allow`, `block`, `challenge`, `ddos_dynamic`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `set_cache_settings`, `set_config`, `serve_error`, `skip`, `compress_response`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional['outputs.RulesetRuleActionParameters']:
        """
        List of parameters that configure the behavior of the ruleset rule action.
        """
        return pulumi.get(self, "action_parameters")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Brief summary of the ruleset rule and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional['outputs.RulesetRuleExposedCredentialCheck']:
        """
        List of parameters that configure exposed credential checks.
        """
        return pulumi.get(self, "exposed_credential_check")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        """
        The most recent update to this rule.
        """
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.RulesetRuleLogging']:
        """
        List parameters to configure how the rule generates logs.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional['outputs.RulesetRuleRatelimit']:
        """
        List of parameters that configure HTTP rate limiting behaviour.
        """
        return pulumi.get(self, "ratelimit")

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        Rule reference.
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the ruleset to deploy.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class RulesetRuleActionParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "browserTtl":
            suggest = "browser_ttl"
        elif key == "cacheKey":
            suggest = "cache_key"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "cookieFields":
            suggest = "cookie_fields"
        elif key == "disableApps":
            suggest = "disable_apps"
        elif key == "disableRailgun":
            suggest = "disable_railgun"
        elif key == "disableZaraz":
            suggest = "disable_zaraz"
        elif key == "edgeTtl":
            suggest = "edge_ttl"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "fromList":
            suggest = "from_list"
        elif key == "fromValue":
            suggest = "from_value"
        elif key == "hostHeader":
            suggest = "host_header"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "matchedData":
            suggest = "matched_data"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "originErrorPagePassthru":
            suggest = "origin_error_page_passthru"
        elif key == "requestFields":
            suggest = "request_fields"
        elif key == "respectStrongEtags":
            suggest = "respect_strong_etags"
        elif key == "responseFields":
            suggest = "response_fields"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serveStale":
            suggest = "serve_stale"
        elif key == "serverSideExcludes":
            suggest = "server_side_excludes"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithms: Optional[Sequence['outputs.RulesetRuleActionParametersAlgorithm']] = None,
                 automatic_https_rewrites: Optional[bool] = None,
                 autominifies: Optional[Sequence['outputs.RulesetRuleActionParametersAutominify']] = None,
                 bic: Optional[bool] = None,
                 browser_ttl: Optional['outputs.RulesetRuleActionParametersBrowserTtl'] = None,
                 cache: Optional[bool] = None,
                 cache_key: Optional['outputs.RulesetRuleActionParametersCacheKey'] = None,
                 content: Optional[str] = None,
                 content_type: Optional[str] = None,
                 cookie_fields: Optional[Sequence[str]] = None,
                 disable_apps: Optional[bool] = None,
                 disable_railgun: Optional[bool] = None,
                 disable_zaraz: Optional[bool] = None,
                 edge_ttl: Optional['outputs.RulesetRuleActionParametersEdgeTtl'] = None,
                 email_obfuscation: Optional[bool] = None,
                 from_list: Optional['outputs.RulesetRuleActionParametersFromList'] = None,
                 from_value: Optional['outputs.RulesetRuleActionParametersFromValue'] = None,
                 headers: Optional[Sequence['outputs.RulesetRuleActionParametersHeader']] = None,
                 host_header: Optional[str] = None,
                 hotlink_protection: Optional[bool] = None,
                 id: Optional[str] = None,
                 increment: Optional[int] = None,
                 matched_data: Optional['outputs.RulesetRuleActionParametersMatchedData'] = None,
                 mirage: Optional[bool] = None,
                 opportunistic_encryption: Optional[bool] = None,
                 origin: Optional['outputs.RulesetRuleActionParametersOrigin'] = None,
                 origin_error_page_passthru: Optional[bool] = None,
                 overrides: Optional['outputs.RulesetRuleActionParametersOverrides'] = None,
                 phases: Optional[Sequence[str]] = None,
                 polish: Optional[str] = None,
                 products: Optional[Sequence[str]] = None,
                 request_fields: Optional[Sequence[str]] = None,
                 respect_strong_etags: Optional[bool] = None,
                 response_fields: Optional[Sequence[str]] = None,
                 responses: Optional[Sequence['outputs.RulesetRuleActionParametersResponse']] = None,
                 rocket_loader: Optional[bool] = None,
                 rules: Optional[Mapping[str, str]] = None,
                 ruleset: Optional[str] = None,
                 rulesets: Optional[Sequence[str]] = None,
                 security_level: Optional[str] = None,
                 serve_stale: Optional['outputs.RulesetRuleActionParametersServeStale'] = None,
                 server_side_excludes: Optional[bool] = None,
                 sni: Optional['outputs.RulesetRuleActionParametersSni'] = None,
                 ssl: Optional[str] = None,
                 status_code: Optional[int] = None,
                 sxg: Optional[bool] = None,
                 uri: Optional['outputs.RulesetRuleActionParametersUri'] = None,
                 version: Optional[str] = None):
        """
        :param str id: The identifier of this resource.
        :param Mapping[str, str] rules: List of rules to apply to the ruleset.
        """
        if algorithms is not None:
            pulumi.set(__self__, "algorithms", algorithms)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if autominifies is not None:
            pulumi.set(__self__, "autominifies", autominifies)
        if bic is not None:
            pulumi.set(__self__, "bic", bic)
        if browser_ttl is not None:
            pulumi.set(__self__, "browser_ttl", browser_ttl)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if cache_key is not None:
            pulumi.set(__self__, "cache_key", cache_key)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if cookie_fields is not None:
            pulumi.set(__self__, "cookie_fields", cookie_fields)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            pulumi.set(__self__, "edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if from_list is not None:
            pulumi.set(__self__, "from_list", from_list)
        if from_value is not None:
            pulumi.set(__self__, "from_value", from_value)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_error_page_passthru is not None:
            pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if request_fields is not None:
            pulumi.set(__self__, "request_fields", request_fields)
        if respect_strong_etags is not None:
            pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        if response_fields is not None:
            pulumi.set(__self__, "response_fields", response_fields)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if serve_stale is not None:
            pulumi.set(__self__, "serve_stale", serve_stale)
        if server_side_excludes is not None:
            pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if sxg is not None:
            pulumi.set(__self__, "sxg", sxg)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def algorithms(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersAlgorithm']]:
        return pulumi.get(self, "algorithms")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[bool]:
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter
    def autominifies(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersAutominify']]:
        return pulumi.get(self, "autominifies")

    @property
    @pulumi.getter
    def bic(self) -> Optional[bool]:
        return pulumi.get(self, "bic")

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional['outputs.RulesetRuleActionParametersBrowserTtl']:
        return pulumi.get(self, "browser_ttl")

    @property
    @pulumi.getter
    def cache(self) -> Optional[bool]:
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional['outputs.RulesetRuleActionParametersCacheKey']:
        return pulumi.get(self, "cache_key")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cookie_fields")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[bool]:
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[bool]:
        return pulumi.get(self, "disable_railgun")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[bool]:
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional['outputs.RulesetRuleActionParametersEdgeTtl']:
        return pulumi.get(self, "edge_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[bool]:
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional['outputs.RulesetRuleActionParametersFromList']:
        return pulumi.get(self, "from_list")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional['outputs.RulesetRuleActionParametersFromValue']:
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersHeader']]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[bool]:
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The identifier of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def increment(self) -> Optional[int]:
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional['outputs.RulesetRuleActionParametersMatchedData']:
        return pulumi.get(self, "matched_data")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[bool]:
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter
    def origin(self) -> Optional['outputs.RulesetRuleActionParametersOrigin']:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[bool]:
        return pulumi.get(self, "origin_error_page_passthru")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.RulesetRuleActionParametersOverrides']:
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def phases(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "phases")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "request_fields")

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[bool]:
        return pulumi.get(self, "respect_strong_etags")

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "response_fields")

    @property
    @pulumi.getter
    def responses(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersResponse']]:
        return pulumi.get(self, "responses")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[bool]:
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Mapping[str, str]]:
        """
        List of rules to apply to the ruleset.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[str]:
        return pulumi.get(self, "ruleset")

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "rulesets")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional['outputs.RulesetRuleActionParametersServeStale']:
        return pulumi.get(self, "serve_stale")

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[bool]:
        return pulumi.get(self, "server_side_excludes")

    @property
    @pulumi.getter
    def sni(self) -> Optional['outputs.RulesetRuleActionParametersSni']:
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def sxg(self) -> Optional[bool]:
        return pulumi.get(self, "sxg")

    @property
    @pulumi.getter
    def uri(self) -> Optional['outputs.RulesetRuleActionParametersUri']:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class RulesetRuleActionParametersAlgorithm(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the ruleset.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the ruleset.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersAutominify(dict):
    def __init__(__self__, *,
                 css: Optional[bool] = None,
                 html: Optional[bool] = None,
                 js: Optional[bool] = None):
        if css is not None:
            pulumi.set(__self__, "css", css)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if js is not None:
            pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> Optional[bool]:
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> Optional[bool]:
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> Optional[bool]:
        return pulumi.get(self, "js")


@pulumi.output_type
class RulesetRuleActionParametersBrowserTtl(dict):
    def __init__(__self__, *,
                 mode: str,
                 default: Optional[int] = None):
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        return pulumi.get(self, "default")


@pulumi.output_type
class RulesetRuleActionParametersCacheKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheByDeviceType":
            suggest = "cache_by_device_type"
        elif key == "cacheDeceptionArmor":
            suggest = "cache_deception_armor"
        elif key == "customKey":
            suggest = "custom_key"
        elif key == "ignoreQueryStringsOrder":
            suggest = "ignore_query_strings_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_by_device_type: Optional[bool] = None,
                 cache_deception_armor: Optional[bool] = None,
                 custom_key: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKey'] = None,
                 ignore_query_strings_order: Optional[bool] = None):
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if ignore_query_strings_order is not None:
            pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[bool]:
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[bool]:
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKey']:
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_query_strings_order")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie'] = None,
                 header: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader'] = None,
                 host: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost'] = None,
                 query_string: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString'] = None,
                 user: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser'] = None):
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie']:
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader']:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def host(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost']:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString']:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser']:
        return pulumi.get(self, "user")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"
        elif key == "excludeOrigin":
            suggest = "exclude_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 exclude_origin: Optional[bool] = None,
                 includes: Optional[Sequence[str]] = None):
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if exclude_origin is not None:
            pulumi.set(__self__, "exclude_origin", exclude_origin)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[bool]:
        return pulumi.get(self, "exclude_origin")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyHost(dict):
    def __init__(__self__, *,
                 resolved: Optional[bool] = None):
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[bool]:
        return pulumi.get(self, "resolved")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryString(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_type: Optional[bool] = None,
                 geo: Optional[bool] = None,
                 lang: Optional[bool] = None):
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[bool]:
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[bool]:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[bool]:
        return pulumi.get(self, "lang")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeTtls":
            suggest = "status_code_ttls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: str,
                 default: Optional[int] = None,
                 status_code_ttls: Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl']] = None):
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if status_code_ttls is not None:
            pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl']]:
        return pulumi.get(self, "status_code_ttls")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"
        elif key == "statusCodeRanges":
            suggest = "status_code_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtlStatusCodeTtl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: Optional[int] = None,
                 status_code_ranges: Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange']] = None,
                 value: Optional[int] = None):
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if status_code_ranges is not None:
            pulumi.set(__self__, "status_code_ranges", status_code_ranges)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange']]:
        return pulumi.get(self, "status_code_ranges")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class RulesetRuleActionParametersFromList(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str name: Name of the ruleset.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ruleset.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preserveQueryString":
            suggest = "preserve_query_string"
        elif key == "statusCode":
            suggest = "status_code"
        elif key == "targetUrl":
            suggest = "target_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preserve_query_string: Optional[bool] = None,
                 status_code: Optional[int] = None,
                 target_url: Optional['outputs.RulesetRuleActionParametersFromValueTargetUrl'] = None):
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[bool]:
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional['outputs.RulesetRuleActionParametersFromValueTargetUrl']:
        return pulumi.get(self, "target_url")


@pulumi.output_type
class RulesetRuleActionParametersFromValueTargetUrl(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersHeader(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 name: Optional[str] = None,
                 operation: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: Name of the ruleset.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ruleset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operation(self) -> Optional[str]:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersMatchedData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersMatchedData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersMatchedData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersMatchedData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: Optional[str] = None):
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        return pulumi.get(self, "public_key")


@pulumi.output_type
class RulesetRuleActionParametersOrigin(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class RulesetRuleActionParametersOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 categories: Optional[Sequence['outputs.RulesetRuleActionParametersOverridesCategory']] = None,
                 enabled: Optional[bool] = None,
                 rules: Optional[Sequence['outputs.RulesetRuleActionParametersOverridesRule']] = None,
                 sensitivity_level: Optional[str] = None):
        """
        :param Sequence['RulesetRuleActionParametersOverridesRuleArgs'] rules: List of rules to apply to the ruleset.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersOverridesCategory']]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersOverridesRule']]:
        """
        List of rules to apply to the ruleset.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[str]:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RulesetRuleActionParametersOverridesCategory(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 category: Optional[str] = None,
                 enabled: Optional[bool] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RulesetRuleActionParametersOverridesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoreThreshold":
            suggest = "score_threshold"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersOverridesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersOverridesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersOverridesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 score_threshold: Optional[int] = None,
                 sensitivity_level: Optional[str] = None):
        """
        :param str action: Action to perform in the ruleset rule. Available values: `allow`, `block`, `challenge`, `ddos_dynamic`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `set_cache_settings`, `set_config`, `serve_error`, `skip`, `compress_response`.
        :param bool enabled: Whether the rule is active.
        :param str id: Unique rule identifier.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to perform in the ruleset rule. Available values: `allow`, `block`, `challenge`, `ddos_dynamic`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `set_cache_settings`, `set_config`, `serve_error`, `skip`, `compress_response`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[int]:
        return pulumi.get(self, "score_threshold")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[str]:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RulesetRuleActionParametersResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: Optional[str] = None,
                 content_type: Optional[str] = None,
                 status_code: Optional[int] = None):
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class RulesetRuleActionParametersServeStale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableStaleWhileUpdating":
            suggest = "disable_stale_while_updating"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersServeStale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersServeStale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersServeStale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_stale_while_updating: Optional[bool] = None):
        if disable_stale_while_updating is not None:
            pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> Optional[bool]:
        return pulumi.get(self, "disable_stale_while_updating")


@pulumi.output_type
class RulesetRuleActionParametersSni(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersUri(dict):
    def __init__(__self__, *,
                 origin: Optional[bool] = None,
                 path: Optional['outputs.RulesetRuleActionParametersUriPath'] = None,
                 query: Optional['outputs.RulesetRuleActionParametersUriQuery'] = None):
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def origin(self) -> Optional[bool]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.RulesetRuleActionParametersUriPath']:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> Optional['outputs.RulesetRuleActionParametersUriQuery']:
        return pulumi.get(self, "query")


@pulumi.output_type
class RulesetRuleActionParametersUriPath(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersUriQuery(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleExposedCredentialCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordExpression":
            suggest = "password_expression"
        elif key == "usernameExpression":
            suggest = "username_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleExposedCredentialCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleExposedCredentialCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleExposedCredentialCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_expression: Optional[str] = None,
                 username_expression: Optional[str] = None):
        if password_expression is not None:
            pulumi.set(__self__, "password_expression", password_expression)
        if username_expression is not None:
            pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> Optional[str]:
        return pulumi.get(self, "password_expression")

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> Optional[str]:
        return pulumi.get(self, "username_expression")


@pulumi.output_type
class RulesetRuleLogging(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RulesetRuleRatelimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countingExpression":
            suggest = "counting_expression"
        elif key == "mitigationTimeout":
            suggest = "mitigation_timeout"
        elif key == "requestsPerPeriod":
            suggest = "requests_per_period"
        elif key == "requestsToOrigin":
            suggest = "requests_to_origin"
        elif key == "scorePerPeriod":
            suggest = "score_per_period"
        elif key == "scoreResponseHeaderName":
            suggest = "score_response_header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleRatelimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleRatelimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleRatelimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 characteristics: Optional[Sequence[str]] = None,
                 counting_expression: Optional[str] = None,
                 mitigation_timeout: Optional[int] = None,
                 period: Optional[int] = None,
                 requests_per_period: Optional[int] = None,
                 requests_to_origin: Optional[bool] = None,
                 score_per_period: Optional[int] = None,
                 score_response_header_name: Optional[str] = None):
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if counting_expression is not None:
            pulumi.set(__self__, "counting_expression", counting_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)
        if requests_to_origin is not None:
            pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        if score_per_period is not None:
            pulumi.set(__self__, "score_per_period", score_per_period)
        if score_response_header_name is not None:
            pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter
    def characteristics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "characteristics")

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[str]:
        return pulumi.get(self, "counting_expression")

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[int]:
        return pulumi.get(self, "mitigation_timeout")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[int]:
        return pulumi.get(self, "requests_per_period")

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> Optional[bool]:
        return pulumi.get(self, "requests_to_origin")

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[int]:
        return pulumi.get(self, "score_per_period")

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[str]:
        return pulumi.get(self, "score_response_header_name")


@pulumi.output_type
class SpectrumApplicationDns(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: The name of the DNS record associated with the application.
        :param str type: The type of DNS record associated with the application.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the DNS record associated with the application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of DNS record associated with the application.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SpectrumApplicationEdgeIps(dict):
    def __init__(__self__, *,
                 type: str,
                 connectivity: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None):
        """
        :param str type: The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        :param str connectivity: The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        :param Sequence[str] ips: The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
        pulumi.set(__self__, "type", type)
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def connectivity(self) -> Optional[str]:
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        """
        return pulumi.get(self, "connectivity")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
        return pulumi.get(self, "ips")


@pulumi.output_type
class SpectrumApplicationOriginDns(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Fully qualified domain name of the origin.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Fully qualified domain name of the origin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SpectrumApplicationOriginPortRange(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        """
        :param int end: Upper bound of the origin port range.
        :param int start: Lower bound of the origin port range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        """
        Upper bound of the origin port range.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        """
        Lower bound of the origin port range.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class SplitTunnelTunnel(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 description: Optional[str] = None,
                 host: Optional[str] = None):
        """
        :param str address: The address for the tunnel.
        :param str description: A description for the tunnel.
        :param str host: The domain name for the tunnel.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address for the tunnel.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for the tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The domain name for the tunnel.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class TeamsAccountAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledDownloadPhase":
            suggest = "enabled_download_phase"
        elif key == "enabledUploadPhase":
            suggest = "enabled_upload_phase"
        elif key == "failClosed":
            suggest = "fail_closed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_download_phase: bool,
                 enabled_upload_phase: bool,
                 fail_closed: bool):
        """
        :param bool enabled_download_phase: Scan on file download.
        :param bool enabled_upload_phase: Scan on file upload.
        :param bool fail_closed: Block requests for files that cannot be scanned.
        """
        pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        pulumi.set(__self__, "fail_closed", fail_closed)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> bool:
        """
        Scan on file download.
        """
        return pulumi.get(self, "enabled_download_phase")

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> bool:
        """
        Scan on file upload.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> bool:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")


@pulumi.output_type
class TeamsAccountBlockPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"
        elif key == "mailtoAddress":
            suggest = "mailto_address"
        elif key == "mailtoSubject":
            suggest = "mailto_subject"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountBlockPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountBlockPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountBlockPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 footer_text: Optional[str] = None,
                 header_text: Optional[str] = None,
                 logo_path: Optional[str] = None,
                 mailto_address: Optional[str] = None,
                 mailto_subject: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str background_color: Hex code of block page background color.
        :param bool enabled: Indicator of enablement.
        :param str footer_text: Block page footer text.
        :param str header_text: Block page header text.
        :param str logo_path: URL of block page logo.
        :param str mailto_address: Admin email for users to contact.
        :param str mailto_subject: Subject line for emails created from block page.
        :param str name: Name of block page configuration.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        Hex code of block page background color.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicator of enablement.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[str]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[str]:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[str]:
        """
        URL of block page logo.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[str]:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[str]:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of block page configuration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TeamsAccountFips(dict):
    def __init__(__self__, *,
                 tls: Optional[bool] = None):
        """
        :param bool tls: Only allow FIPS-compliant TLS configuration.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[bool]:
        """
        Only allow FIPS-compliant TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class TeamsAccountLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redactPii":
            suggest = "redact_pii"
        elif key == "settingsByRuleType":
            suggest = "settings_by_rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redact_pii: bool,
                 settings_by_rule_type: 'outputs.TeamsAccountLoggingSettingsByRuleType'):
        """
        :param bool redact_pii: Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        :param 'TeamsAccountLoggingSettingsByRuleTypeArgs' settings_by_rule_type: Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        pulumi.set(__self__, "redact_pii", redact_pii)
        pulumi.set(__self__, "settings_by_rule_type", settings_by_rule_type)

    @property
    @pulumi.getter(name="redactPii")
    def redact_pii(self) -> bool:
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        """
        return pulumi.get(self, "redact_pii")

    @property
    @pulumi.getter(name="settingsByRuleType")
    def settings_by_rule_type(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleType':
        """
        Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        return pulumi.get(self, "settings_by_rule_type")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleType(dict):
    def __init__(__self__, *,
                 dns: 'outputs.TeamsAccountLoggingSettingsByRuleTypeDns',
                 http: 'outputs.TeamsAccountLoggingSettingsByRuleTypeHttp',
                 l4: 'outputs.TeamsAccountLoggingSettingsByRuleTypeL4'):
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "http", http)
        pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeDns':
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def http(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeHttp':
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def l4(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeL4':
        return pulumi.get(self, "l4")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: bool,
                 log_blocks: bool):
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> bool:
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: bool,
                 log_blocks: bool):
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> bool:
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeL4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeL4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeL4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeL4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: bool,
                 log_blocks: bool):
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> bool:
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountPayloadLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountPayloadLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountPayloadLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountPayloadLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: str):
        """
        :param str public_key: Public key used to encrypt matched payloads.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        Public key used to encrypt matched payloads.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class TeamsAccountProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rootCa":
            suggest = "root_ca"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 root_ca: bool,
                 tcp: bool,
                 udp: bool):
        """
        :param bool root_ca: Whether root ca is enabled account wide for ZT clients.
        :param bool tcp: Whether gateway proxy is enabled on gateway devices for TCP traffic.
        :param bool udp: Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        pulumi.set(__self__, "root_ca", root_ca)
        pulumi.set(__self__, "tcp", tcp)
        pulumi.set(__self__, "udp", udp)

    @property
    @pulumi.getter(name="rootCa")
    def root_ca(self) -> bool:
        """
        Whether root ca is enabled account wide for ZT clients.
        """
        return pulumi.get(self, "root_ca")

    @property
    @pulumi.getter
    def tcp(self) -> bool:
        """
        Whether gateway proxy is enabled on gateway devices for TCP traffic.
        """
        return pulumi.get(self, "tcp")

    @property
    @pulumi.getter
    def udp(self) -> bool:
        """
        Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        return pulumi.get(self, "udp")


@pulumi.output_type
class TeamsLocationNetwork(dict):
    def __init__(__self__, *,
                 network: str,
                 id: Optional[str] = None):
        """
        :param str network: CIDR notation representation of the network IP.
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "network", network)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class TeamsRuleRuleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addHeaders":
            suggest = "add_headers"
        elif key == "allowChildBypass":
            suggest = "allow_child_bypass"
        elif key == "auditSsh":
            suggest = "audit_ssh"
        elif key == "bisoAdminControls":
            suggest = "biso_admin_controls"
        elif key == "blockPageEnabled":
            suggest = "block_page_enabled"
        elif key == "blockPageReason":
            suggest = "block_page_reason"
        elif key == "bypassParentRule":
            suggest = "bypass_parent_rule"
        elif key == "checkSession":
            suggest = "check_session"
        elif key == "insecureDisableDnssecValidation":
            suggest = "insecure_disable_dnssec_validation"
        elif key == "ipCategories":
            suggest = "ip_categories"
        elif key == "overrideHost":
            suggest = "override_host"
        elif key == "overrideIps":
            suggest = "override_ips"
        elif key == "payloadLog":
            suggest = "payload_log"
        elif key == "untrustedCert":
            suggest = "untrusted_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_headers: Optional[Mapping[str, str]] = None,
                 allow_child_bypass: Optional[bool] = None,
                 audit_ssh: Optional['outputs.TeamsRuleRuleSettingsAuditSsh'] = None,
                 biso_admin_controls: Optional['outputs.TeamsRuleRuleSettingsBisoAdminControls'] = None,
                 block_page_enabled: Optional[bool] = None,
                 block_page_reason: Optional[str] = None,
                 bypass_parent_rule: Optional[bool] = None,
                 check_session: Optional['outputs.TeamsRuleRuleSettingsCheckSession'] = None,
                 egress: Optional['outputs.TeamsRuleRuleSettingsEgress'] = None,
                 insecure_disable_dnssec_validation: Optional[bool] = None,
                 ip_categories: Optional[bool] = None,
                 l4override: Optional['outputs.TeamsRuleRuleSettingsL4override'] = None,
                 override_host: Optional[str] = None,
                 override_ips: Optional[Sequence[str]] = None,
                 payload_log: Optional['outputs.TeamsRuleRuleSettingsPayloadLog'] = None,
                 untrusted_cert: Optional['outputs.TeamsRuleRuleSettingsUntrustedCert'] = None):
        """
        :param Mapping[str, str] add_headers: Add custom headers to allowed requests in the form of key-value pairs.
        :param bool allow_child_bypass: Allow parent MSP accounts to enable bypass their children's rules.
        :param 'TeamsRuleRuleSettingsAuditSshArgs' audit_ssh: Settings for auditing SSH usage.
        :param 'TeamsRuleRuleSettingsBisoAdminControlsArgs' biso_admin_controls: Configure how browser isolation behaves.
        :param bool block_page_enabled: Indicator of block page enablement.
        :param str block_page_reason: The displayed reason for a user being blocked.
        :param bool bypass_parent_rule: Allow child MSP accounts to bypass their parent's rule.
        :param 'TeamsRuleRuleSettingsCheckSessionArgs' check_session: Configure how session check behaves.
        :param 'TeamsRuleRuleSettingsEgressArgs' egress: Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        :param bool insecure_disable_dnssec_validation: Disable DNSSEC validation (must be Allow rule).
        :param bool ip_categories: Turns on IP category based filter on dns if the rule contains dns category checks.
        :param 'TeamsRuleRuleSettingsL4overrideArgs' l4override: Settings to forward layer 4 traffic.
        :param str override_host: The host to override matching DNS queries with.
        :param Sequence[str] override_ips: The IPs to override matching DNS queries with.
        :param 'TeamsRuleRuleSettingsPayloadLogArgs' payload_log: Configure DLP Payload Logging settings for this rule.
        :param 'TeamsRuleRuleSettingsUntrustedCertArgs' untrusted_cert: Configure untrusted certificate settings for this rule.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_page_reason is not None:
            pulumi.set(__self__, "block_page_reason", block_page_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[Mapping[str, str]]:
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        return pulumi.get(self, "add_headers")

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[bool]:
        """
        Allow parent MSP accounts to enable bypass their children's rules.
        """
        return pulumi.get(self, "allow_child_bypass")

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional['outputs.TeamsRuleRuleSettingsAuditSsh']:
        """
        Settings for auditing SSH usage.
        """
        return pulumi.get(self, "audit_ssh")

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional['outputs.TeamsRuleRuleSettingsBisoAdminControls']:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[bool]:
        """
        Indicator of block page enablement.
        """
        return pulumi.get(self, "block_page_enabled")

    @property
    @pulumi.getter(name="blockPageReason")
    def block_page_reason(self) -> Optional[str]:
        """
        The displayed reason for a user being blocked.
        """
        return pulumi.get(self, "block_page_reason")

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[bool]:
        """
        Allow child MSP accounts to bypass their parent's rule.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional['outputs.TeamsRuleRuleSettingsCheckSession']:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @property
    @pulumi.getter
    def egress(self) -> Optional['outputs.TeamsRuleRuleSettingsEgress']:
        """
        Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        """
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[bool]:
        """
        Disable DNSSEC validation (must be Allow rule).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[bool]:
        """
        Turns on IP category based filter on dns if the rule contains dns category checks.
        """
        return pulumi.get(self, "ip_categories")

    @property
    @pulumi.getter
    def l4override(self) -> Optional['outputs.TeamsRuleRuleSettingsL4override']:
        """
        Settings to forward layer 4 traffic.
        """
        return pulumi.get(self, "l4override")

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[str]:
        """
        The host to override matching DNS queries with.
        """
        return pulumi.get(self, "override_host")

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[Sequence[str]]:
        """
        The IPs to override matching DNS queries with.
        """
        return pulumi.get(self, "override_ips")

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional['outputs.TeamsRuleRuleSettingsPayloadLog']:
        """
        Configure DLP Payload Logging settings for this rule.
        """
        return pulumi.get(self, "payload_log")

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional['outputs.TeamsRuleRuleSettingsUntrustedCert']:
        """
        Configure untrusted certificate settings for this rule.
        """
        return pulumi.get(self, "untrusted_cert")


@pulumi.output_type
class TeamsRuleRuleSettingsAuditSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandLogging":
            suggest = "command_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsAuditSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsAuditSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsAuditSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_logging: bool):
        pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> bool:
        return pulumi.get(self, "command_logging")


@pulumi.output_type
class TeamsRuleRuleSettingsBisoAdminControls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableCopyPaste":
            suggest = "disable_copy_paste"
        elif key == "disableDownload":
            suggest = "disable_download"
        elif key == "disableKeyboard":
            suggest = "disable_keyboard"
        elif key == "disablePrinting":
            suggest = "disable_printing"
        elif key == "disableUpload":
            suggest = "disable_upload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsBisoAdminControls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsBisoAdminControls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsBisoAdminControls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_copy_paste: Optional[bool] = None,
                 disable_download: Optional[bool] = None,
                 disable_keyboard: Optional[bool] = None,
                 disable_printing: Optional[bool] = None,
                 disable_upload: Optional[bool] = None):
        if disable_copy_paste is not None:
            pulumi.set(__self__, "disable_copy_paste", disable_copy_paste)
        if disable_download is not None:
            pulumi.set(__self__, "disable_download", disable_download)
        if disable_keyboard is not None:
            pulumi.set(__self__, "disable_keyboard", disable_keyboard)
        if disable_printing is not None:
            pulumi.set(__self__, "disable_printing", disable_printing)
        if disable_upload is not None:
            pulumi.set(__self__, "disable_upload", disable_upload)

    @property
    @pulumi.getter(name="disableCopyPaste")
    def disable_copy_paste(self) -> Optional[bool]:
        return pulumi.get(self, "disable_copy_paste")

    @property
    @pulumi.getter(name="disableDownload")
    def disable_download(self) -> Optional[bool]:
        return pulumi.get(self, "disable_download")

    @property
    @pulumi.getter(name="disableKeyboard")
    def disable_keyboard(self) -> Optional[bool]:
        return pulumi.get(self, "disable_keyboard")

    @property
    @pulumi.getter(name="disablePrinting")
    def disable_printing(self) -> Optional[bool]:
        return pulumi.get(self, "disable_printing")

    @property
    @pulumi.getter(name="disableUpload")
    def disable_upload(self) -> Optional[bool]:
        return pulumi.get(self, "disable_upload")


@pulumi.output_type
class TeamsRuleRuleSettingsCheckSession(dict):
    def __init__(__self__, *,
                 duration: str,
                 enforce: bool):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> str:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enforce(self) -> bool:
        return pulumi.get(self, "enforce")


@pulumi.output_type
class TeamsRuleRuleSettingsEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Fallback":
            suggest = "ipv4_fallback"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4: str,
                 ipv6: str,
                 ipv4_fallback: Optional[str] = None):
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)

    @property
    @pulumi.getter
    def ipv4(self) -> str:
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> str:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[str]:
        return pulumi.get(self, "ipv4_fallback")


@pulumi.output_type
class TeamsRuleRuleSettingsL4override(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int):
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class TeamsRuleRuleSettingsPayloadLog(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Indicator of rule enablement.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicator of rule enablement.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class TeamsRuleRuleSettingsUntrustedCert(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None):
        """
        :param str action: The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class TunnelConfigConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingressRules":
            suggest = "ingress_rules"
        elif key == "originRequest":
            suggest = "origin_request"
        elif key == "warpRouting":
            suggest = "warp_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingress_rules: Sequence['outputs.TunnelConfigConfigIngressRule'],
                 origin_request: Optional['outputs.TunnelConfigConfigOriginRequest'] = None,
                 warp_routing: Optional['outputs.TunnelConfigConfigWarpRouting'] = None):
        """
        :param Sequence['TunnelConfigConfigIngressRuleArgs'] ingress_rules: Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        :param 'TunnelConfigConfigWarpRoutingArgs' warp_routing: If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        pulumi.set(__self__, "ingress_rules", ingress_rules)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @property
    @pulumi.getter(name="ingressRules")
    def ingress_rules(self) -> Sequence['outputs.TunnelConfigConfigIngressRule']:
        """
        Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        """
        return pulumi.get(self, "ingress_rules")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional['outputs.TunnelConfigConfigOriginRequest']:
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional['outputs.TunnelConfigConfigWarpRouting']:
        """
        If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        return pulumi.get(self, "warp_routing")


@pulumi.output_type
class TunnelConfigConfigIngressRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originRequest":
            suggest = "origin_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigIngressRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigIngressRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigIngressRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: str,
                 hostname: Optional[str] = None,
                 origin_request: Optional['outputs.TunnelConfigConfigIngressRuleOriginRequest'] = None,
                 path: Optional[str] = None):
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional['outputs.TunnelConfigConfigIngressRuleOriginRequest']:
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class TunnelConfigConfigIngressRuleOriginRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bastionMode":
            suggest = "bastion_mode"
        elif key == "caPool":
            suggest = "ca_pool"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "disableChunkedEncoding":
            suggest = "disable_chunked_encoding"
        elif key == "http2Origin":
            suggest = "http2_origin"
        elif key == "httpHostHeader":
            suggest = "http_host_header"
        elif key == "ipRules":
            suggest = "ip_rules"
        elif key == "keepAliveConnections":
            suggest = "keep_alive_connections"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "noHappyEyeballs":
            suggest = "no_happy_eyeballs"
        elif key == "noTlsVerify":
            suggest = "no_tls_verify"
        elif key == "originServerName":
            suggest = "origin_server_name"
        elif key == "proxyAddress":
            suggest = "proxy_address"
        elif key == "proxyPort":
            suggest = "proxy_port"
        elif key == "proxyType":
            suggest = "proxy_type"
        elif key == "tcpKeepAlive":
            suggest = "tcp_keep_alive"
        elif key == "tlsTimeout":
            suggest = "tls_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigIngressRuleOriginRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigIngressRuleOriginRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigIngressRuleOriginRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: Optional['outputs.TunnelConfigConfigIngressRuleOriginRequestAccess'] = None,
                 bastion_mode: Optional[bool] = None,
                 ca_pool: Optional[str] = None,
                 connect_timeout: Optional[str] = None,
                 disable_chunked_encoding: Optional[bool] = None,
                 http2_origin: Optional[bool] = None,
                 http_host_header: Optional[str] = None,
                 ip_rules: Optional[Sequence['outputs.TunnelConfigConfigIngressRuleOriginRequestIpRule']] = None,
                 keep_alive_connections: Optional[int] = None,
                 keep_alive_timeout: Optional[str] = None,
                 no_happy_eyeballs: Optional[bool] = None,
                 no_tls_verify: Optional[bool] = None,
                 origin_server_name: Optional[str] = None,
                 proxy_address: Optional[str] = None,
                 proxy_port: Optional[int] = None,
                 proxy_type: Optional[str] = None,
                 tcp_keep_alive: Optional[str] = None,
                 tls_timeout: Optional[str] = None):
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.TunnelConfigConfigIngressRuleOriginRequestAccess']:
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[bool]:
        return pulumi.get(self, "bastion_mode")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[str]:
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[bool]:
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[bool]:
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[str]:
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.TunnelConfigConfigIngressRuleOriginRequestIpRule']]:
        return pulumi.get(self, "ip_rules")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[int]:
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[str]:
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[bool]:
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[bool]:
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[str]:
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[str]:
        return pulumi.get(self, "proxy_address")

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[int]:
        return pulumi.get(self, "proxy_port")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[str]:
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[str]:
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[str]:
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class TunnelConfigConfigIngressRuleOriginRequestAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audTags":
            suggest = "aud_tags"
        elif key == "teamName":
            suggest = "team_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigIngressRuleOriginRequestAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigIngressRuleOriginRequestAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigIngressRuleOriginRequestAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aud_tags: Optional[Sequence[str]] = None,
                 required: Optional[bool] = None,
                 team_name: Optional[str] = None):
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[str]:
        return pulumi.get(self, "team_name")


@pulumi.output_type
class TunnelConfigConfigIngressRuleOriginRequestIpRule(dict):
    def __init__(__self__, *,
                 allow: Optional[bool] = None,
                 ports: Optional[Sequence[int]] = None,
                 prefix: Optional[str] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[bool]:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class TunnelConfigConfigOriginRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bastionMode":
            suggest = "bastion_mode"
        elif key == "caPool":
            suggest = "ca_pool"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "disableChunkedEncoding":
            suggest = "disable_chunked_encoding"
        elif key == "http2Origin":
            suggest = "http2_origin"
        elif key == "httpHostHeader":
            suggest = "http_host_header"
        elif key == "ipRules":
            suggest = "ip_rules"
        elif key == "keepAliveConnections":
            suggest = "keep_alive_connections"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "noHappyEyeballs":
            suggest = "no_happy_eyeballs"
        elif key == "noTlsVerify":
            suggest = "no_tls_verify"
        elif key == "originServerName":
            suggest = "origin_server_name"
        elif key == "proxyAddress":
            suggest = "proxy_address"
        elif key == "proxyPort":
            suggest = "proxy_port"
        elif key == "proxyType":
            suggest = "proxy_type"
        elif key == "tcpKeepAlive":
            suggest = "tcp_keep_alive"
        elif key == "tlsTimeout":
            suggest = "tls_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigOriginRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigOriginRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigOriginRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: Optional['outputs.TunnelConfigConfigOriginRequestAccess'] = None,
                 bastion_mode: Optional[bool] = None,
                 ca_pool: Optional[str] = None,
                 connect_timeout: Optional[str] = None,
                 disable_chunked_encoding: Optional[bool] = None,
                 http2_origin: Optional[bool] = None,
                 http_host_header: Optional[str] = None,
                 ip_rules: Optional[Sequence['outputs.TunnelConfigConfigOriginRequestIpRule']] = None,
                 keep_alive_connections: Optional[int] = None,
                 keep_alive_timeout: Optional[str] = None,
                 no_happy_eyeballs: Optional[bool] = None,
                 no_tls_verify: Optional[bool] = None,
                 origin_server_name: Optional[str] = None,
                 proxy_address: Optional[str] = None,
                 proxy_port: Optional[int] = None,
                 proxy_type: Optional[str] = None,
                 tcp_keep_alive: Optional[str] = None,
                 tls_timeout: Optional[str] = None):
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.TunnelConfigConfigOriginRequestAccess']:
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[bool]:
        return pulumi.get(self, "bastion_mode")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[str]:
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[bool]:
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[bool]:
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[str]:
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.TunnelConfigConfigOriginRequestIpRule']]:
        return pulumi.get(self, "ip_rules")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[int]:
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[str]:
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[bool]:
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[bool]:
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[str]:
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[str]:
        return pulumi.get(self, "proxy_address")

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[int]:
        return pulumi.get(self, "proxy_port")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[str]:
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[str]:
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[str]:
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class TunnelConfigConfigOriginRequestAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audTags":
            suggest = "aud_tags"
        elif key == "teamName":
            suggest = "team_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigOriginRequestAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigOriginRequestAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigOriginRequestAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aud_tags: Optional[Sequence[str]] = None,
                 required: Optional[bool] = None,
                 team_name: Optional[str] = None):
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[str]:
        return pulumi.get(self, "team_name")


@pulumi.output_type
class TunnelConfigConfigOriginRequestIpRule(dict):
    def __init__(__self__, *,
                 allow: Optional[bool] = None,
                 ports: Optional[Sequence[int]] = None,
                 prefix: Optional[str] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[bool]:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class TunnelConfigConfigWarpRouting(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class UserAgentBlockingRuleConfiguration(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        :param str value: The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WaitingRoomAdditionalRoute(dict):
    def __init__(__self__, *,
                 host: str,
                 path: Optional[str] = None):
        """
        :param str host: The additional host name for which the waiting room to be applied on (no wildcards).
        :param str path: The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
        pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The additional host name for which the waiting room to be applied on (no wildcards).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class WaitingRoomRulesRule(dict):
    def __init__(__self__, *,
                 action: str,
                 expression: str,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 status: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str action: Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        :param str expression: Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        :param str description: Brief summary of the waiting room rule and its intended use.
        :param str id: Unique rule identifier.
        :param str status: Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        :param str version: Version of the waiting room rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Brief summary of the waiting room rule and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the waiting room rule.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WorkerScriptAnalyticsEngineBinding(dict):
    def __init__(__self__, *,
                 dataset: str,
                 name: str):
        """
        :param str dataset: The name of the Analytics Engine dataset to write to.
        :param str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def dataset(self) -> str:
        """
        The name of the Analytics Engine dataset to write to.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkerScriptKvNamespaceBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkerScriptKvNamespaceBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkerScriptKvNamespaceBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkerScriptKvNamespaceBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 namespace_id: str):
        """
        :param str name: The global variable for the binding in your Worker code.
        :param str namespace_id: ID of the KV namespace you want to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        ID of the KV namespace you want to use.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class WorkerScriptPlainTextBinding(dict):
    def __init__(__self__, *,
                 name: str,
                 text: str):
        """
        :param str name: The global variable for the binding in your Worker code.
        :param str text: The plain text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The plain text you want to store.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkerScriptQueueBinding(dict):
    def __init__(__self__, *,
                 binding: str,
                 queue: str):
        """
        :param str binding: The name of the global variable for the binding in your Worker code.
        :param str queue: Name of the queue you want to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "queue", queue)

    @property
    @pulumi.getter
    def binding(self) -> str:
        """
        The name of the global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @property
    @pulumi.getter
    def queue(self) -> str:
        """
        Name of the queue you want to use.
        """
        return pulumi.get(self, "queue")


@pulumi.output_type
class WorkerScriptR2BucketBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkerScriptR2BucketBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkerScriptR2BucketBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkerScriptR2BucketBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 name: str):
        """
        :param str bucket_name: The name of the Bucket to bind to.
        :param str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        The name of the Bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkerScriptSecretTextBinding(dict):
    def __init__(__self__, *,
                 name: str,
                 text: str):
        """
        :param str name: The global variable for the binding in your Worker code.
        :param str text: The secret text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The secret text you want to store.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkerScriptServiceBinding(dict):
    def __init__(__self__, *,
                 name: str,
                 service: str,
                 environment: Optional[str] = None):
        """
        :param str name: The global variable for the binding in your Worker code.
        :param str service: The name of the Worker to bind to.
        :param str environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")


@pulumi.output_type
class WorkerScriptWebassemblyBinding(dict):
    def __init__(__self__, *,
                 module: str,
                 name: str):
        """
        :param str module: The base64 encoded wasm module you want to store.
        :param str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "module", module)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def module(self) -> str:
        """
        The base64 encoded wasm module you want to store.
        """
        return pulumi.get(self, "module")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZoneLockdownConfiguration(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The request property to target. Available values: `ip`, `ip_range`.
        :param str value: The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The request property to target. Available values: `ip`, `ip_range`.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ZoneSettingsOverrideInitialSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOnline":
            suggest = "always_online"
        elif key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "binaryAst":
            suggest = "binary_ast"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "challengeTtl":
            suggest = "challenge_ttl"
        elif key == "cnameFlattening":
            suggest = "cname_flattening"
        elif key == "developmentMode":
            suggest = "development_mode"
        elif key == "earlyHints":
            suggest = "early_hints"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "filterLogsToCloudflare":
            suggest = "filter_logs_to_cloudflare"
        elif key == "h2Prioritization":
            suggest = "h2_prioritization"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "imageResizing":
            suggest = "image_resizing"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "logToCloudflare":
            suggest = "log_to_cloudflare"
        elif key == "maxUpload":
            suggest = "max_upload"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "mobileRedirect":
            suggest = "mobile_redirect"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "opportunisticOnion":
            suggest = "opportunistic_onion"
        elif key == "orangeToOrange":
            suggest = "orange_to_orange"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "originMaxHttpVersion":
            suggest = "origin_max_http_version"
        elif key == "prefetchPreload":
            suggest = "prefetch_preload"
        elif key == "privacyPass":
            suggest = "privacy_pass"
        elif key == "proxyReadTimeout":
            suggest = "proxy_read_timeout"
        elif key == "pseudoIpv4":
            suggest = "pseudo_ipv4"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityHeader":
            suggest = "security_header"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "tls12Only":
            suggest = "tls12_only"
        elif key == "tlsClientAuth":
            suggest = "tls_client_auth"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"
        elif key == "universalSsl":
            suggest = "universal_ssl"
        elif key == "visitorIp":
            suggest = "visitor_ip"
        elif key == "zeroRtt":
            suggest = "zero_rtt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_online: Optional[str] = None,
                 always_use_https: Optional[str] = None,
                 automatic_https_rewrites: Optional[str] = None,
                 binary_ast: Optional[str] = None,
                 brotli: Optional[str] = None,
                 browser_cache_ttl: Optional[int] = None,
                 browser_check: Optional[str] = None,
                 cache_level: Optional[str] = None,
                 challenge_ttl: Optional[int] = None,
                 ciphers: Optional[Sequence[str]] = None,
                 cname_flattening: Optional[str] = None,
                 development_mode: Optional[str] = None,
                 early_hints: Optional[str] = None,
                 email_obfuscation: Optional[str] = None,
                 filter_logs_to_cloudflare: Optional[str] = None,
                 h2_prioritization: Optional[str] = None,
                 hotlink_protection: Optional[str] = None,
                 http2: Optional[str] = None,
                 http3: Optional[str] = None,
                 image_resizing: Optional[str] = None,
                 ip_geolocation: Optional[str] = None,
                 ipv6: Optional[str] = None,
                 log_to_cloudflare: Optional[str] = None,
                 max_upload: Optional[int] = None,
                 min_tls_version: Optional[str] = None,
                 minify: Optional['outputs.ZoneSettingsOverrideInitialSettingMinify'] = None,
                 mirage: Optional[str] = None,
                 mobile_redirect: Optional['outputs.ZoneSettingsOverrideInitialSettingMobileRedirect'] = None,
                 opportunistic_encryption: Optional[str] = None,
                 opportunistic_onion: Optional[str] = None,
                 orange_to_orange: Optional[str] = None,
                 origin_error_page_pass_thru: Optional[str] = None,
                 origin_max_http_version: Optional[str] = None,
                 polish: Optional[str] = None,
                 prefetch_preload: Optional[str] = None,
                 privacy_pass: Optional[str] = None,
                 proxy_read_timeout: Optional[str] = None,
                 pseudo_ipv4: Optional[str] = None,
                 response_buffering: Optional[str] = None,
                 rocket_loader: Optional[str] = None,
                 security_header: Optional['outputs.ZoneSettingsOverrideInitialSettingSecurityHeader'] = None,
                 security_level: Optional[str] = None,
                 server_side_exclude: Optional[str] = None,
                 sort_query_string_for_cache: Optional[str] = None,
                 ssl: Optional[str] = None,
                 tls12_only: Optional[str] = None,
                 tls13: Optional[str] = None,
                 tls_client_auth: Optional[str] = None,
                 true_client_ip_header: Optional[str] = None,
                 universal_ssl: Optional[str] = None,
                 visitor_ip: Optional[str] = None,
                 waf: Optional[str] = None,
                 webp: Optional[str] = None,
                 websockets: Optional[str] = None,
                 zero_rtt: Optional[str] = None):
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            pulumi.set(__self__, "binary_ast", binary_ast)
        if brotli is not None:
            pulumi.set(__self__, "brotli", brotli)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if challenge_ttl is not None:
            pulumi.set(__self__, "challenge_ttl", challenge_ttl)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if cname_flattening is not None:
            pulumi.set(__self__, "cname_flattening", cname_flattening)
        if development_mode is not None:
            pulumi.set(__self__, "development_mode", development_mode)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            pulumi.set(__self__, "filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if h2_prioritization is not None:
            pulumi.set(__self__, "h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if http3 is not None:
            pulumi.set(__self__, "http3", http3)
        if image_resizing is not None:
            pulumi.set(__self__, "image_resizing", image_resizing)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if log_to_cloudflare is not None:
            pulumi.set(__self__, "log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            pulumi.set(__self__, "max_upload", max_upload)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minify is not None:
            pulumi.set(__self__, "minify", minify)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if mobile_redirect is not None:
            pulumi.set(__self__, "mobile_redirect", mobile_redirect)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            pulumi.set(__self__, "opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            pulumi.set(__self__, "orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if origin_max_http_version is not None:
            pulumi.set(__self__, "origin_max_http_version", origin_max_http_version)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if prefetch_preload is not None:
            pulumi.set(__self__, "prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            pulumi.set(__self__, "privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            pulumi.set(__self__, "proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            pulumi.set(__self__, "pseudo_ipv4", pseudo_ipv4)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_header is not None:
            pulumi.set(__self__, "security_header", security_header)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if tls12_only is not None:
            pulumi.set(__self__, "tls12_only", tls12_only)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)
        if tls_client_auth is not None:
            pulumi.set(__self__, "tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            pulumi.set(__self__, "universal_ssl", universal_ssl)
        if visitor_ip is not None:
            pulumi.set(__self__, "visitor_ip", visitor_ip)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)
        if zero_rtt is not None:
            pulumi.set(__self__, "zero_rtt", zero_rtt)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[str]:
        return pulumi.get(self, "always_online")

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[str]:
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[str]:
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[str]:
        return pulumi.get(self, "binary_ast")

    @property
    @pulumi.getter
    def brotli(self) -> Optional[str]:
        return pulumi.get(self, "brotli")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[int]:
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[str]:
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[str]:
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[int]:
        return pulumi.get(self, "challenge_ttl")

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[str]:
        return pulumi.get(self, "cname_flattening")

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[str]:
        return pulumi.get(self, "development_mode")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[str]:
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[str]:
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[str]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[str]:
        return pulumi.get(self, "h2_prioritization")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[str]:
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def http2(self) -> Optional[str]:
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def http3(self) -> Optional[str]:
        return pulumi.get(self, "http3")

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[str]:
        return pulumi.get(self, "image_resizing")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[str]:
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[str]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[str]:
        return pulumi.get(self, "log_to_cloudflare")

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[int]:
        return pulumi.get(self, "max_upload")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def minify(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingMinify']:
        return pulumi.get(self, "minify")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[str]:
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="mobileRedirect")
    def mobile_redirect(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingMobileRedirect']:
        return pulumi.get(self, "mobile_redirect")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[str]:
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[str]:
        return pulumi.get(self, "opportunistic_onion")

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[str]:
        return pulumi.get(self, "orange_to_orange")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[str]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter(name="originMaxHttpVersion")
    def origin_max_http_version(self) -> Optional[str]:
        return pulumi.get(self, "origin_max_http_version")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[str]:
        return pulumi.get(self, "prefetch_preload")

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[str]:
        return pulumi.get(self, "privacy_pass")

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[str]:
        return pulumi.get(self, "proxy_read_timeout")

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[str]:
        return pulumi.get(self, "pseudo_ipv4")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[str]:
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[str]:
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingSecurityHeader']:
        return pulumi.get(self, "security_header")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[str]:
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[str]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="tls12Only")
    def tls12_only(self) -> Optional[str]:
        warnings.warn("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""", DeprecationWarning)
        pulumi.log.warn("""tls12_only is deprecated: tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")

        return pulumi.get(self, "tls12_only")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[str]:
        return pulumi.get(self, "tls13")

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[str]:
        return pulumi.get(self, "tls_client_auth")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[str]:
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[str]:
        return pulumi.get(self, "universal_ssl")

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[str]:
        return pulumi.get(self, "visitor_ip")

    @property
    @pulumi.getter
    def waf(self) -> Optional[str]:
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter
    def webp(self) -> Optional[str]:
        return pulumi.get(self, "webp")

    @property
    @pulumi.getter
    def websockets(self) -> Optional[str]:
        return pulumi.get(self, "websockets")

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[str]:
        return pulumi.get(self, "zero_rtt")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingMinify(dict):
    def __init__(__self__, *,
                 css: str,
                 html: str,
                 js: str):
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> str:
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> str:
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> str:
        return pulumi.get(self, "js")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingMobileRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mobileSubdomain":
            suggest = "mobile_subdomain"
        elif key == "stripUri":
            suggest = "strip_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSettingMobileRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSettingMobileRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSettingMobileRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mobile_subdomain: str,
                 status: str,
                 strip_uri: bool):
        pulumi.set(__self__, "mobile_subdomain", mobile_subdomain)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> str:
        return pulumi.get(self, "mobile_subdomain")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> bool:
        return pulumi.get(self, "strip_uri")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingSecurityHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSettingSecurityHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSettingSecurityHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSettingSecurityHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 include_subdomains: Optional[bool] = None,
                 max_age: Optional[int] = None,
                 nosniff: Optional[bool] = None,
                 preload: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if nosniff is not None:
            pulumi.set(__self__, "nosniff", nosniff)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[bool]:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[bool]:
        return pulumi.get(self, "nosniff")

    @property
    @pulumi.getter
    def preload(self) -> Optional[bool]:
        return pulumi.get(self, "preload")


@pulumi.output_type
class ZoneSettingsOverrideSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOnline":
            suggest = "always_online"
        elif key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "binaryAst":
            suggest = "binary_ast"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "challengeTtl":
            suggest = "challenge_ttl"
        elif key == "cnameFlattening":
            suggest = "cname_flattening"
        elif key == "developmentMode":
            suggest = "development_mode"
        elif key == "earlyHints":
            suggest = "early_hints"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "filterLogsToCloudflare":
            suggest = "filter_logs_to_cloudflare"
        elif key == "h2Prioritization":
            suggest = "h2_prioritization"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "imageResizing":
            suggest = "image_resizing"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "logToCloudflare":
            suggest = "log_to_cloudflare"
        elif key == "maxUpload":
            suggest = "max_upload"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "mobileRedirect":
            suggest = "mobile_redirect"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "opportunisticOnion":
            suggest = "opportunistic_onion"
        elif key == "orangeToOrange":
            suggest = "orange_to_orange"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "originMaxHttpVersion":
            suggest = "origin_max_http_version"
        elif key == "prefetchPreload":
            suggest = "prefetch_preload"
        elif key == "privacyPass":
            suggest = "privacy_pass"
        elif key == "proxyReadTimeout":
            suggest = "proxy_read_timeout"
        elif key == "pseudoIpv4":
            suggest = "pseudo_ipv4"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityHeader":
            suggest = "security_header"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "tls12Only":
            suggest = "tls12_only"
        elif key == "tlsClientAuth":
            suggest = "tls_client_auth"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"
        elif key == "universalSsl":
            suggest = "universal_ssl"
        elif key == "visitorIp":
            suggest = "visitor_ip"
        elif key == "zeroRtt":
            suggest = "zero_rtt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_online: Optional[str] = None,
                 always_use_https: Optional[str] = None,
                 automatic_https_rewrites: Optional[str] = None,
                 binary_ast: Optional[str] = None,
                 brotli: Optional[str] = None,
                 browser_cache_ttl: Optional[int] = None,
                 browser_check: Optional[str] = None,
                 cache_level: Optional[str] = None,
                 challenge_ttl: Optional[int] = None,
                 ciphers: Optional[Sequence[str]] = None,
                 cname_flattening: Optional[str] = None,
                 development_mode: Optional[str] = None,
                 early_hints: Optional[str] = None,
                 email_obfuscation: Optional[str] = None,
                 filter_logs_to_cloudflare: Optional[str] = None,
                 h2_prioritization: Optional[str] = None,
                 hotlink_protection: Optional[str] = None,
                 http2: Optional[str] = None,
                 http3: Optional[str] = None,
                 image_resizing: Optional[str] = None,
                 ip_geolocation: Optional[str] = None,
                 ipv6: Optional[str] = None,
                 log_to_cloudflare: Optional[str] = None,
                 max_upload: Optional[int] = None,
                 min_tls_version: Optional[str] = None,
                 minify: Optional['outputs.ZoneSettingsOverrideSettingsMinify'] = None,
                 mirage: Optional[str] = None,
                 mobile_redirect: Optional['outputs.ZoneSettingsOverrideSettingsMobileRedirect'] = None,
                 opportunistic_encryption: Optional[str] = None,
                 opportunistic_onion: Optional[str] = None,
                 orange_to_orange: Optional[str] = None,
                 origin_error_page_pass_thru: Optional[str] = None,
                 origin_max_http_version: Optional[str] = None,
                 polish: Optional[str] = None,
                 prefetch_preload: Optional[str] = None,
                 privacy_pass: Optional[str] = None,
                 proxy_read_timeout: Optional[str] = None,
                 pseudo_ipv4: Optional[str] = None,
                 response_buffering: Optional[str] = None,
                 rocket_loader: Optional[str] = None,
                 security_header: Optional['outputs.ZoneSettingsOverrideSettingsSecurityHeader'] = None,
                 security_level: Optional[str] = None,
                 server_side_exclude: Optional[str] = None,
                 sort_query_string_for_cache: Optional[str] = None,
                 ssl: Optional[str] = None,
                 tls12_only: Optional[str] = None,
                 tls13: Optional[str] = None,
                 tls_client_auth: Optional[str] = None,
                 true_client_ip_header: Optional[str] = None,
                 universal_ssl: Optional[str] = None,
                 visitor_ip: Optional[str] = None,
                 waf: Optional[str] = None,
                 webp: Optional[str] = None,
                 websockets: Optional[str] = None,
                 zero_rtt: Optional[str] = None):
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            pulumi.set(__self__, "binary_ast", binary_ast)
        if brotli is not None:
            pulumi.set(__self__, "brotli", brotli)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if challenge_ttl is not None:
            pulumi.set(__self__, "challenge_ttl", challenge_ttl)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if cname_flattening is not None:
            pulumi.set(__self__, "cname_flattening", cname_flattening)
        if development_mode is not None:
            pulumi.set(__self__, "development_mode", development_mode)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            pulumi.set(__self__, "filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if h2_prioritization is not None:
            pulumi.set(__self__, "h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if http3 is not None:
            pulumi.set(__self__, "http3", http3)
        if image_resizing is not None:
            pulumi.set(__self__, "image_resizing", image_resizing)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if log_to_cloudflare is not None:
            pulumi.set(__self__, "log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            pulumi.set(__self__, "max_upload", max_upload)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minify is not None:
            pulumi.set(__self__, "minify", minify)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if mobile_redirect is not None:
            pulumi.set(__self__, "mobile_redirect", mobile_redirect)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            pulumi.set(__self__, "opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            pulumi.set(__self__, "orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if origin_max_http_version is not None:
            pulumi.set(__self__, "origin_max_http_version", origin_max_http_version)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if prefetch_preload is not None:
            pulumi.set(__self__, "prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            pulumi.set(__self__, "privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            pulumi.set(__self__, "proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            pulumi.set(__self__, "pseudo_ipv4", pseudo_ipv4)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_header is not None:
            pulumi.set(__self__, "security_header", security_header)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if tls12_only is not None:
            pulumi.set(__self__, "tls12_only", tls12_only)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)
        if tls_client_auth is not None:
            pulumi.set(__self__, "tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            pulumi.set(__self__, "universal_ssl", universal_ssl)
        if visitor_ip is not None:
            pulumi.set(__self__, "visitor_ip", visitor_ip)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)
        if zero_rtt is not None:
            pulumi.set(__self__, "zero_rtt", zero_rtt)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[str]:
        return pulumi.get(self, "always_online")

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[str]:
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[str]:
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[str]:
        return pulumi.get(self, "binary_ast")

    @property
    @pulumi.getter
    def brotli(self) -> Optional[str]:
        return pulumi.get(self, "brotli")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[int]:
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[str]:
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[str]:
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[int]:
        return pulumi.get(self, "challenge_ttl")

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[str]:
        return pulumi.get(self, "cname_flattening")

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[str]:
        return pulumi.get(self, "development_mode")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[str]:
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[str]:
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[str]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[str]:
        return pulumi.get(self, "h2_prioritization")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[str]:
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def http2(self) -> Optional[str]:
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def http3(self) -> Optional[str]:
        return pulumi.get(self, "http3")

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[str]:
        return pulumi.get(self, "image_resizing")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[str]:
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[str]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[str]:
        return pulumi.get(self, "log_to_cloudflare")

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[int]:
        return pulumi.get(self, "max_upload")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def minify(self) -> Optional['outputs.ZoneSettingsOverrideSettingsMinify']:
        return pulumi.get(self, "minify")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[str]:
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="mobileRedirect")
    def mobile_redirect(self) -> Optional['outputs.ZoneSettingsOverrideSettingsMobileRedirect']:
        return pulumi.get(self, "mobile_redirect")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[str]:
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[str]:
        return pulumi.get(self, "opportunistic_onion")

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[str]:
        return pulumi.get(self, "orange_to_orange")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[str]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter(name="originMaxHttpVersion")
    def origin_max_http_version(self) -> Optional[str]:
        return pulumi.get(self, "origin_max_http_version")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[str]:
        return pulumi.get(self, "prefetch_preload")

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[str]:
        return pulumi.get(self, "privacy_pass")

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[str]:
        return pulumi.get(self, "proxy_read_timeout")

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[str]:
        return pulumi.get(self, "pseudo_ipv4")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[str]:
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[str]:
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional['outputs.ZoneSettingsOverrideSettingsSecurityHeader']:
        return pulumi.get(self, "security_header")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[str]:
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[str]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="tls12Only")
    def tls12_only(self) -> Optional[str]:
        warnings.warn("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""", DeprecationWarning)
        pulumi.log.warn("""tls12_only is deprecated: tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")

        return pulumi.get(self, "tls12_only")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[str]:
        return pulumi.get(self, "tls13")

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[str]:
        return pulumi.get(self, "tls_client_auth")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[str]:
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[str]:
        return pulumi.get(self, "universal_ssl")

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[str]:
        return pulumi.get(self, "visitor_ip")

    @property
    @pulumi.getter
    def waf(self) -> Optional[str]:
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter
    def webp(self) -> Optional[str]:
        return pulumi.get(self, "webp")

    @property
    @pulumi.getter
    def websockets(self) -> Optional[str]:
        return pulumi.get(self, "websockets")

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[str]:
        return pulumi.get(self, "zero_rtt")


@pulumi.output_type
class ZoneSettingsOverrideSettingsMinify(dict):
    def __init__(__self__, *,
                 css: str,
                 html: str,
                 js: str):
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> str:
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> str:
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> str:
        return pulumi.get(self, "js")


@pulumi.output_type
class ZoneSettingsOverrideSettingsMobileRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mobileSubdomain":
            suggest = "mobile_subdomain"
        elif key == "stripUri":
            suggest = "strip_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettingsMobileRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettingsMobileRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettingsMobileRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mobile_subdomain: str,
                 status: str,
                 strip_uri: bool):
        pulumi.set(__self__, "mobile_subdomain", mobile_subdomain)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> str:
        return pulumi.get(self, "mobile_subdomain")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> bool:
        return pulumi.get(self, "strip_uri")


@pulumi.output_type
class ZoneSettingsOverrideSettingsSecurityHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettingsSecurityHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettingsSecurityHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettingsSecurityHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 include_subdomains: Optional[bool] = None,
                 max_age: Optional[int] = None,
                 nosniff: Optional[bool] = None,
                 preload: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if nosniff is not None:
            pulumi.set(__self__, "nosniff", nosniff)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[bool]:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[bool]:
        return pulumi.get(self, "nosniff")

    @property
    @pulumi.getter
    def preload(self) -> Optional[bool]:
        return pulumi.get(self, "preload")


@pulumi.output_type
class GetAccountRolesRoleResult(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAccountsAccountResult(dict):
    def __init__(__self__, *,
                 enforce_twofactor: Optional[bool] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str name: The account name to target for the resource.
        """
        if enforce_twofactor is not None:
            pulumi.set(__self__, "enforce_twofactor", enforce_twofactor)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="enforceTwofactor")
    def enforce_twofactor(self) -> Optional[bool]:
        return pulumi.get(self, "enforce_twofactor")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The account name to target for the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDevicesDeviceResult(dict):
    def __init__(__self__, *,
                 created: Optional[str] = None,
                 deleted: Optional[bool] = None,
                 device_type: Optional[str] = None,
                 id: Optional[str] = None,
                 ip: Optional[str] = None,
                 key: Optional[str] = None,
                 last_seen: Optional[str] = None,
                 mac_address: Optional[str] = None,
                 manufacturer: Optional[str] = None,
                 model: Optional[str] = None,
                 name: Optional[str] = None,
                 os_distro_name: Optional[str] = None,
                 os_distro_revision: Optional[str] = None,
                 os_version: Optional[str] = None,
                 revoked_at: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 updated: Optional[str] = None,
                 user_email: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if deleted is not None:
            pulumi.set(__self__, "deleted", deleted)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version is not None:
            pulumi.set(__self__, "os_version", os_version)
        if revoked_at is not None:
            pulumi.set(__self__, "revoked_at", revoked_at)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if updated is not None:
            pulumi.set(__self__, "updated", updated)
        if user_email is not None:
            pulumi.set(__self__, "user_email", user_email)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def created(self) -> Optional[str]:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def deleted(self) -> Optional[bool]:
        return pulumi.get(self, "deleted")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[str]:
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[str]:
        return pulumi.get(self, "last_seen")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter
    def model(self) -> Optional[str]:
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[str]:
        return pulumi.get(self, "os_distro_name")

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[str]:
        return pulumi.get(self, "os_distro_revision")

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> Optional[str]:
        return pulumi.get(self, "os_version")

    @property
    @pulumi.getter(name="revokedAt")
    def revoked_at(self) -> Optional[str]:
        return pulumi.get(self, "revoked_at")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def updated(self) -> Optional[str]:
        return pulumi.get(self, "updated")

    @property
    @pulumi.getter(name="userEmail")
    def user_email(self) -> Optional[str]:
        return pulumi.get(self, "user_email")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetListsListResult(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 numitems: Optional[int] = None):
        """
        :param str id: The ID of this resource.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if numitems is not None:
            pulumi.set(__self__, "numitems", numitems)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def numitems(self) -> Optional[int]:
        return pulumi.get(self, "numitems")


@pulumi.output_type
class GetLoadBalancerPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: A regular expression matching the name of the Load Balancer pool to lookup.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A regular expression matching the name of the Load Balancer pool to lookup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLoadBalancerPoolsPoolResult(dict):
    def __init__(__self__, *,
                 check_regions: Sequence[str],
                 created_on: str,
                 description: str,
                 enabled: bool,
                 id: str,
                 latitude: float,
                 load_sheddings: Sequence['outputs.GetLoadBalancerPoolsPoolLoadSheddingResult'],
                 longitude: float,
                 minimum_origins: int,
                 modified_on: str,
                 monitor: str,
                 name: str,
                 notification_email: str,
                 origins: Sequence['outputs.GetLoadBalancerPoolsPoolOriginResult']):
        """
        :param Sequence[str] check_regions: List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        :param str created_on: The RFC3339 timestamp of when the load balancer was created.
        :param str description: Brief description of the Load Balancer Pool intention.
        :param bool enabled: Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        :param str id: ID for this load balancer pool.
        :param float latitude: Latitude this pool is physically located at; used for proximity steering.
        :param Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs'] load_sheddings: Setting for controlling load shedding for this pool.
        :param float longitude: Longitude this pool is physically located at; used for proximity steering.
        :param int minimum_origins: Minimum number of origins that must be healthy for this pool to serve traffic.
        :param str modified_on: The RFC3339 timestamp of when the load balancer was last modified.
        :param str monitor: ID of the Monitor to use for health checking origins within this pool.
        :param str name: Short name (tag) for the pool.
        :param str notification_email: Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        :param Sequence['GetLoadBalancerPoolsPoolOriginArgs'] origins: The list of origins within this pool.
        """
        pulumi.set(__self__, "check_regions", check_regions)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "load_sheddings", load_sheddings)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "minimum_origins", minimum_origins)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "monitor", monitor)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_email", notification_email)
        pulumi.set(__self__, "origins", origins)

    @property
    @pulumi.getter(name="checkRegions")
    def check_regions(self) -> Sequence[str]:
        """
        List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        """
        return pulumi.get(self, "check_regions")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The RFC3339 timestamp of when the load balancer was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Brief description of the Load Balancer Pool intention.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID for this load balancer pool.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def latitude(self) -> float:
        """
        Latitude this pool is physically located at; used for proximity steering.
        """
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter(name="loadSheddings")
    def load_sheddings(self) -> Sequence['outputs.GetLoadBalancerPoolsPoolLoadSheddingResult']:
        """
        Setting for controlling load shedding for this pool.
        """
        return pulumi.get(self, "load_sheddings")

    @property
    @pulumi.getter
    def longitude(self) -> float:
        """
        Longitude this pool is physically located at; used for proximity steering.
        """
        return pulumi.get(self, "longitude")

    @property
    @pulumi.getter(name="minimumOrigins")
    def minimum_origins(self) -> int:
        """
        Minimum number of origins that must be healthy for this pool to serve traffic.
        """
        return pulumi.get(self, "minimum_origins")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The RFC3339 timestamp of when the load balancer was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def monitor(self) -> str:
        """
        ID of the Monitor to use for health checking origins within this pool.
        """
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Short name (tag) for the pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notificationEmail")
    def notification_email(self) -> str:
        """
        Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        """
        return pulumi.get(self, "notification_email")

    @property
    @pulumi.getter
    def origins(self) -> Sequence['outputs.GetLoadBalancerPoolsPoolOriginResult']:
        """
        The list of origins within this pool.
        """
        return pulumi.get(self, "origins")


@pulumi.output_type
class GetLoadBalancerPoolsPoolLoadSheddingResult(dict):
    def __init__(__self__, *,
                 default_percent: Optional[float] = None,
                 default_policy: Optional[str] = None,
                 session_percent: Optional[float] = None,
                 session_policy: Optional[str] = None):
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[float]:
        return pulumi.get(self, "default_percent")

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[str]:
        return pulumi.get(self, "default_policy")

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[float]:
        return pulumi.get(self, "session_percent")

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[str]:
        return pulumi.get(self, "session_policy")


@pulumi.output_type
class GetLoadBalancerPoolsPoolOriginResult(dict):
    def __init__(__self__, *,
                 address: str,
                 name: str,
                 enabled: Optional[bool] = None,
                 headers: Optional[Sequence['outputs.GetLoadBalancerPoolsPoolOriginHeaderResult']] = None,
                 weight: Optional[float] = None):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.GetLoadBalancerPoolsPoolOriginHeaderResult']]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetLoadBalancerPoolsPoolOriginHeaderResult(dict):
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRulesetsFilterResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 phase: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: The ID of the Ruleset to target.
        :param str kind: Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `schema`, `zone`.
        :param str name: Name of the ruleset.
        :param str phase: Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_custom_errors`, `http_log_custom_fields`, `http_request_cache_settings`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_late_transform_managed`, `http_request_main`, `http_request_origin`, `http_request_dynamic_redirect`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_firewall_managed`, `http_response_headers_transform`, `http_response_headers_transform_managed`, `http_response_compression`, `magic_transit`, `http_ratelimit`, `http_request_sbfm`, `http_config_settings`.
        :param str version: Version of the ruleset to filter on.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Ruleset to target.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `schema`, `zone`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ruleset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_custom_errors`, `http_log_custom_fields`, `http_request_cache_settings`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_late_transform_managed`, `http_request_main`, `http_request_origin`, `http_request_dynamic_redirect`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_firewall_managed`, `http_response_headers_transform`, `http_response_headers_transform_managed`, `http_response_compression`, `magic_transit`, `http_ratelimit`, `http_request_sbfm`, `http_config_settings`.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the ruleset to filter on.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetRulesetsRulesetResult(dict):
    def __init__(__self__, *,
                 id: str,
                 kind: str,
                 name: str,
                 phase: str,
                 version: str,
                 description: Optional[str] = None,
                 rules: Optional[Sequence['outputs.GetRulesetsRulesetRuleResult']] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def phase(self) -> str:
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleResult']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetRulesetsRulesetRuleResult(dict):
    def __init__(__self__, *,
                 expression: str,
                 id: str,
                 ref: str,
                 version: str,
                 action: Optional[str] = None,
                 action_parameters: Optional['outputs.GetRulesetsRulesetRuleActionParametersResult'] = None,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 exposed_credential_check: Optional['outputs.GetRulesetsRulesetRuleExposedCredentialCheckResult'] = None,
                 last_updated: Optional[str] = None,
                 logging: Optional['outputs.GetRulesetsRulesetRuleLoggingResult'] = None,
                 ratelimit: Optional['outputs.GetRulesetsRulesetRuleRatelimitResult'] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "version", version)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ref(self) -> str:
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersResult']:
        return pulumi.get(self, "action_parameters")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional['outputs.GetRulesetsRulesetRuleExposedCredentialCheckResult']:
        return pulumi.get(self, "exposed_credential_check")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.GetRulesetsRulesetRuleLoggingResult']:
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional['outputs.GetRulesetsRulesetRuleRatelimitResult']:
        return pulumi.get(self, "ratelimit")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersResult(dict):
    def __init__(__self__, *,
                 version: str,
                 automatic_https_rewrites: Optional[bool] = None,
                 autominifies: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersAutominifyResult']] = None,
                 bic: Optional[bool] = None,
                 browser_ttl: Optional['outputs.GetRulesetsRulesetRuleActionParametersBrowserTtlResult'] = None,
                 cache: Optional[bool] = None,
                 cache_key: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyResult'] = None,
                 content: Optional[str] = None,
                 content_type: Optional[str] = None,
                 cookie_fields: Optional[Sequence[str]] = None,
                 disable_apps: Optional[bool] = None,
                 disable_railgun: Optional[bool] = None,
                 disable_zaraz: Optional[bool] = None,
                 edge_ttl: Optional['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlResult'] = None,
                 email_obfuscation: Optional[bool] = None,
                 from_list: Optional['outputs.GetRulesetsRulesetRuleActionParametersFromListResult'] = None,
                 from_value: Optional['outputs.GetRulesetsRulesetRuleActionParametersFromValueResult'] = None,
                 headers: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersHeaderResult']] = None,
                 host_header: Optional[str] = None,
                 hotlink_protection: Optional[bool] = None,
                 id: Optional[str] = None,
                 increment: Optional[int] = None,
                 matched_data: Optional['outputs.GetRulesetsRulesetRuleActionParametersMatchedDataResult'] = None,
                 mirage: Optional[bool] = None,
                 opportunistic_encryption: Optional[bool] = None,
                 origin: Optional['outputs.GetRulesetsRulesetRuleActionParametersOriginResult'] = None,
                 origin_error_page_passthru: Optional[bool] = None,
                 overrides: Optional['outputs.GetRulesetsRulesetRuleActionParametersOverridesResult'] = None,
                 phases: Optional[Sequence[str]] = None,
                 polish: Optional[str] = None,
                 products: Optional[Sequence[str]] = None,
                 request_fields: Optional[Sequence[str]] = None,
                 respect_strong_etags: Optional[bool] = None,
                 response_fields: Optional[Sequence[str]] = None,
                 responses: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersResponseResult']] = None,
                 rocket_loader: Optional[bool] = None,
                 rules: Optional[Mapping[str, str]] = None,
                 ruleset: Optional[str] = None,
                 rulesets: Optional[Sequence[str]] = None,
                 security_level: Optional[str] = None,
                 serve_stale: Optional['outputs.GetRulesetsRulesetRuleActionParametersServeStaleResult'] = None,
                 server_side_excludes: Optional[bool] = None,
                 sni: Optional['outputs.GetRulesetsRulesetRuleActionParametersSniResult'] = None,
                 ssl: Optional[str] = None,
                 status_code: Optional[int] = None,
                 sxg: Optional[bool] = None,
                 uri: Optional['outputs.GetRulesetsRulesetRuleActionParametersUriResult'] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "version", version)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if autominifies is not None:
            pulumi.set(__self__, "autominifies", autominifies)
        if bic is not None:
            pulumi.set(__self__, "bic", bic)
        if browser_ttl is not None:
            pulumi.set(__self__, "browser_ttl", browser_ttl)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if cache_key is not None:
            pulumi.set(__self__, "cache_key", cache_key)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if cookie_fields is not None:
            pulumi.set(__self__, "cookie_fields", cookie_fields)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            pulumi.set(__self__, "edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if from_list is not None:
            pulumi.set(__self__, "from_list", from_list)
        if from_value is not None:
            pulumi.set(__self__, "from_value", from_value)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_error_page_passthru is not None:
            pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if request_fields is not None:
            pulumi.set(__self__, "request_fields", request_fields)
        if respect_strong_etags is not None:
            pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        if response_fields is not None:
            pulumi.set(__self__, "response_fields", response_fields)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if serve_stale is not None:
            pulumi.set(__self__, "serve_stale", serve_stale)
        if server_side_excludes is not None:
            pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if sxg is not None:
            pulumi.set(__self__, "sxg", sxg)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[bool]:
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter
    def autominifies(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersAutominifyResult']]:
        return pulumi.get(self, "autominifies")

    @property
    @pulumi.getter
    def bic(self) -> Optional[bool]:
        return pulumi.get(self, "bic")

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersBrowserTtlResult']:
        return pulumi.get(self, "browser_ttl")

    @property
    @pulumi.getter
    def cache(self) -> Optional[bool]:
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyResult']:
        return pulumi.get(self, "cache_key")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cookie_fields")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[bool]:
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[bool]:
        return pulumi.get(self, "disable_railgun")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[bool]:
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlResult']:
        return pulumi.get(self, "edge_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[bool]:
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersFromListResult']:
        return pulumi.get(self, "from_list")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersFromValueResult']:
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersHeaderResult']]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[bool]:
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def increment(self) -> Optional[int]:
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersMatchedDataResult']:
        return pulumi.get(self, "matched_data")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[bool]:
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter
    def origin(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersOriginResult']:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[bool]:
        return pulumi.get(self, "origin_error_page_passthru")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersOverridesResult']:
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def phases(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "phases")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "request_fields")

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[bool]:
        return pulumi.get(self, "respect_strong_etags")

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "response_fields")

    @property
    @pulumi.getter
    def responses(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersResponseResult']]:
        return pulumi.get(self, "responses")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[bool]:
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[str]:
        return pulumi.get(self, "ruleset")

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "rulesets")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersServeStaleResult']:
        return pulumi.get(self, "serve_stale")

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[bool]:
        return pulumi.get(self, "server_side_excludes")

    @property
    @pulumi.getter
    def sni(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersSniResult']:
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def sxg(self) -> Optional[bool]:
        return pulumi.get(self, "sxg")

    @property
    @pulumi.getter
    def uri(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersUriResult']:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersAutominifyResult(dict):
    def __init__(__self__, *,
                 css: Optional[bool] = None,
                 html: Optional[bool] = None,
                 js: Optional[bool] = None):
        if css is not None:
            pulumi.set(__self__, "css", css)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if js is not None:
            pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> Optional[bool]:
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> Optional[bool]:
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> Optional[bool]:
        return pulumi.get(self, "js")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersBrowserTtlResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 default: Optional[int] = None):
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        return pulumi.get(self, "default")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyResult(dict):
    def __init__(__self__, *,
                 cache_by_device_type: Optional[bool] = None,
                 cache_deception_armor: Optional[bool] = None,
                 custom_key: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyResult'] = None,
                 ignore_query_strings_order: Optional[bool] = None):
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if ignore_query_strings_order is not None:
            pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[bool]:
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[bool]:
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyResult']:
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_query_strings_order")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyResult(dict):
    def __init__(__self__, *,
                 cookie: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieResult'] = None,
                 header: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult'] = None,
                 host: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostResult'] = None,
                 query_string: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult'] = None,
                 user: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserResult'] = None):
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieResult']:
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult']:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def host(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostResult']:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult']:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserResult']:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieResult(dict):
    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult(dict):
    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 exclude_origin: Optional[bool] = None,
                 includes: Optional[Sequence[str]] = None):
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if exclude_origin is not None:
            pulumi.set(__self__, "exclude_origin", exclude_origin)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[bool]:
        return pulumi.get(self, "exclude_origin")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostResult(dict):
    def __init__(__self__, *,
                 resolved: Optional[bool] = None):
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[bool]:
        return pulumi.get(self, "resolved")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserResult(dict):
    def __init__(__self__, *,
                 device_type: Optional[bool] = None,
                 geo: Optional[bool] = None,
                 lang: Optional[bool] = None):
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[bool]:
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[bool]:
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[bool]:
        return pulumi.get(self, "lang")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersEdgeTtlResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 default: Optional[int] = None,
                 status_code_ttls: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult']] = None):
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if status_code_ttls is not None:
            pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult']]:
        return pulumi.get(self, "status_code_ttls")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult(dict):
    def __init__(__self__, *,
                 value: int,
                 status_code: Optional[int] = None,
                 status_code_ranges: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult']] = None):
        pulumi.set(__self__, "value", value)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if status_code_ranges is not None:
            pulumi.set(__self__, "status_code_ranges", status_code_ranges)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult']]:
        return pulumi.get(self, "status_code_ranges")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult(dict):
    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersFromListResult(dict):
    def __init__(__self__, *,
                 key: str,
                 name: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersFromValueResult(dict):
    def __init__(__self__, *,
                 preserve_query_string: Optional[bool] = None,
                 status_code: Optional[int] = None,
                 target_url: Optional['outputs.GetRulesetsRulesetRuleActionParametersFromValueTargetUrlResult'] = None):
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[bool]:
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersFromValueTargetUrlResult']:
        return pulumi.get(self, "target_url")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersFromValueTargetUrlResult(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersHeaderResult(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 name: Optional[str] = None,
                 operation: Optional[str] = None,
                 value: Optional[str] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operation(self) -> Optional[str]:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersMatchedDataResult(dict):
    def __init__(__self__, *,
                 public_key: Optional[str] = None):
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersOriginResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersOverridesResult(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 categories: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersOverridesCategoryResult']] = None,
                 enabled: Optional[bool] = None,
                 rules: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersOverridesRuleResult']] = None,
                 sensitivity_level: Optional[str] = None,
                 status: Optional[str] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersOverridesCategoryResult']]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        warnings.warn("""Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""", DeprecationWarning)
        pulumi.log.warn("""enabled is deprecated: Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""")

        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersOverridesRuleResult']]:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[str]:
        return pulumi.get(self, "sensitivity_level")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersOverridesCategoryResult(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 category: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 status: Optional[str] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        warnings.warn("""Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""", DeprecationWarning)
        pulumi.log.warn("""enabled is deprecated: Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""")

        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersOverridesRuleResult(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 score_threshold: Optional[int] = None,
                 sensitivity_level: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        warnings.warn("""Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""", DeprecationWarning)
        pulumi.log.warn("""enabled is deprecated: Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""")

        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[int]:
        return pulumi.get(self, "score_threshold")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[str]:
        return pulumi.get(self, "sensitivity_level")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersResponseResult(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 content_type: Optional[str] = None,
                 status_code: Optional[int] = None):
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersServeStaleResult(dict):
    def __init__(__self__, *,
                 disable_stale_while_updating: Optional[bool] = None):
        if disable_stale_while_updating is not None:
            pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> Optional[bool]:
        return pulumi.get(self, "disable_stale_while_updating")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersSniResult(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersUriResult(dict):
    def __init__(__self__, *,
                 origin: Optional[bool] = None,
                 path: Optional['outputs.GetRulesetsRulesetRuleActionParametersUriPathResult'] = None,
                 query: Optional['outputs.GetRulesetsRulesetRuleActionParametersUriQueryResult'] = None):
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def origin(self) -> Optional[bool]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersUriPathResult']:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersUriQueryResult']:
        return pulumi.get(self, "query")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersUriPathResult(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersUriQueryResult(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleExposedCredentialCheckResult(dict):
    def __init__(__self__, *,
                 password_expression: Optional[str] = None,
                 username_expression: Optional[str] = None):
        if password_expression is not None:
            pulumi.set(__self__, "password_expression", password_expression)
        if username_expression is not None:
            pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> Optional[str]:
        return pulumi.get(self, "password_expression")

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> Optional[str]:
        return pulumi.get(self, "username_expression")


@pulumi.output_type
class GetRulesetsRulesetRuleLoggingResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 status: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        warnings.warn("""Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""", DeprecationWarning)
        pulumi.log.warn("""enabled is deprecated: Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""")

        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesetsRulesetRuleRatelimitResult(dict):
    def __init__(__self__, *,
                 characteristics: Optional[Sequence[str]] = None,
                 counting_expression: Optional[str] = None,
                 mitigation_timeout: Optional[int] = None,
                 period: Optional[int] = None,
                 requests_per_period: Optional[int] = None,
                 requests_to_origin: Optional[bool] = None,
                 score_per_period: Optional[int] = None,
                 score_response_header_name: Optional[str] = None):
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if counting_expression is not None:
            pulumi.set(__self__, "counting_expression", counting_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)
        if requests_to_origin is not None:
            pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        if score_per_period is not None:
            pulumi.set(__self__, "score_per_period", score_per_period)
        if score_response_header_name is not None:
            pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter
    def characteristics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "characteristics")

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[str]:
        return pulumi.get(self, "counting_expression")

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[int]:
        return pulumi.get(self, "mitigation_timeout")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[int]:
        return pulumi.get(self, "requests_per_period")

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> Optional[bool]:
        return pulumi.get(self, "requests_to_origin")

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[int]:
        return pulumi.get(self, "score_per_period")

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[str]:
        return pulumi.get(self, "score_response_header_name")


@pulumi.output_type
class GetZonesFilterResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 lookup_type: Optional[str] = None,
                 match: Optional[str] = None,
                 name: Optional[str] = None,
                 paused: Optional[bool] = None,
                 status: Optional[str] = None):
        """
        :param str account_id: The account identifier to target for the resource.
        :param str lookup_type: The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        :param str match: A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        :param str name: A string value to search for.
        :param bool paused: Paused status of the zone to lookup. Defaults to `false`.
        :param str status: Status of the zone to lookup.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if lookup_type is not None:
            pulumi.set(__self__, "lookup_type", lookup_type)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The account identifier to target for the resource.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="lookupType")
    def lookup_type(self) -> Optional[str]:
        """
        The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        """
        return pulumi.get(self, "lookup_type")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A string value to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        Paused status of the zone to lookup. Defaults to `false`.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the zone to lookup.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


