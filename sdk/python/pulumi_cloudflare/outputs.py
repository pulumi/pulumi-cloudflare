# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AccessApplicationCorsHeader',
    'AccessGroupExclude',
    'AccessGroupExcludeAzure',
    'AccessGroupExcludeGithub',
    'AccessGroupExcludeGsuite',
    'AccessGroupExcludeOkta',
    'AccessGroupExcludeSaml',
    'AccessGroupInclude',
    'AccessGroupIncludeAzure',
    'AccessGroupIncludeGithub',
    'AccessGroupIncludeGsuite',
    'AccessGroupIncludeOkta',
    'AccessGroupIncludeSaml',
    'AccessGroupRequire',
    'AccessGroupRequireAzure',
    'AccessGroupRequireGithub',
    'AccessGroupRequireGsuite',
    'AccessGroupRequireOkta',
    'AccessGroupRequireSaml',
    'AccessIdentityProviderConfig',
    'AccessPolicyApprovalGroup',
    'AccessPolicyExclude',
    'AccessPolicyExcludeAzure',
    'AccessPolicyExcludeGithub',
    'AccessPolicyExcludeGsuite',
    'AccessPolicyExcludeOkta',
    'AccessPolicyExcludeSaml',
    'AccessPolicyInclude',
    'AccessPolicyIncludeAzure',
    'AccessPolicyIncludeGithub',
    'AccessPolicyIncludeGsuite',
    'AccessPolicyIncludeOkta',
    'AccessPolicyIncludeSaml',
    'AccessPolicyRequire',
    'AccessPolicyRequireAzure',
    'AccessPolicyRequireGithub',
    'AccessPolicyRequireGsuite',
    'AccessPolicyRequireOkta',
    'AccessPolicyRequireSaml',
    'AccessRuleConfiguration',
    'ApiTokenCondition',
    'ApiTokenConditionRequestIp',
    'ApiTokenPolicy',
    'CertificatePackValidationError',
    'CertificatePackValidationRecord',
    'CustomHostnameSsl',
    'CustomHostnameSslSetting',
    'CustomHostnameSslValidationError',
    'CustomHostnameSslValidationRecord',
    'CustomSslCustomSslOptions',
    'CustomSslCustomSslPriority',
    'DevicePostureIntegrationConfig',
    'DevicePostureRuleInput',
    'DevicePostureRuleMatch',
    'FallbackDomainDomain',
    'HealthcheckHeader',
    'IpListItem',
    'LoadBalancerMonitorHeader',
    'LoadBalancerPoolLoadShedding',
    'LoadBalancerPoolOrigin',
    'LoadBalancerPoolOriginHeader',
    'LoadBalancerPoolOriginSteering',
    'LoadBalancerPopPool',
    'LoadBalancerRegionPool',
    'LoadBalancerRule',
    'LoadBalancerRuleFixedResponse',
    'LoadBalancerRuleOverride',
    'LoadBalancerRuleOverridePopPool',
    'LoadBalancerRuleOverrideRegionPool',
    'NotificationPolicyEmailIntegration',
    'NotificationPolicyPagerdutyIntegration',
    'NotificationPolicyWebhooksIntegration',
    'PageRuleActions',
    'PageRuleActionsCacheKeyFields',
    'PageRuleActionsCacheKeyFieldsCookie',
    'PageRuleActionsCacheKeyFieldsHeader',
    'PageRuleActionsCacheKeyFieldsHost',
    'PageRuleActionsCacheKeyFieldsQueryString',
    'PageRuleActionsCacheKeyFieldsUser',
    'PageRuleActionsCacheTtlByStatus',
    'PageRuleActionsForwardingUrl',
    'PageRuleActionsMinify',
    'RateLimitAction',
    'RateLimitActionResponse',
    'RateLimitCorrelate',
    'RateLimitMatch',
    'RateLimitMatchRequest',
    'RateLimitMatchResponse',
    'RecordData',
    'RulesetRule',
    'RulesetRuleActionParameters',
    'RulesetRuleActionParametersHeader',
    'RulesetRuleActionParametersMatchedData',
    'RulesetRuleActionParametersOverrides',
    'RulesetRuleActionParametersOverridesCategory',
    'RulesetRuleActionParametersOverridesRule',
    'RulesetRuleActionParametersUri',
    'RulesetRuleActionParametersUriPath',
    'RulesetRuleActionParametersUriQuery',
    'RulesetRuleExposedCredentialCheck',
    'RulesetRuleRatelimit',
    'SpectrumApplicationDns',
    'SpectrumApplicationOriginDns',
    'SpectrumApplicationOriginPortRange',
    'SplitTunnelTunnel',
    'TeamsAccountAntivirus',
    'TeamsAccountBlockPage',
    'TeamsAccountFips',
    'TeamsAccountLogging',
    'TeamsAccountLoggingSettingsByRuleType',
    'TeamsAccountLoggingSettingsByRuleTypeDns',
    'TeamsAccountLoggingSettingsByRuleTypeHttp',
    'TeamsAccountLoggingSettingsByRuleTypeL4',
    'TeamsAccountProxy',
    'TeamsLocationNetwork',
    'TeamsRuleRuleSettings',
    'TeamsRuleRuleSettingsBisoAdminControls',
    'TeamsRuleRuleSettingsCheckSession',
    'TeamsRuleRuleSettingsL4override',
    'WorkerScriptKvNamespaceBinding',
    'WorkerScriptPlainTextBinding',
    'WorkerScriptSecretTextBinding',
    'WorkerScriptWebassemblyBinding',
    'ZoneLockdownConfiguration',
    'ZoneSettingsOverrideInitialSetting',
    'ZoneSettingsOverrideInitialSettingMinify',
    'ZoneSettingsOverrideInitialSettingMobileRedirect',
    'ZoneSettingsOverrideInitialSettingSecurityHeader',
    'ZoneSettingsOverrideSettings',
    'ZoneSettingsOverrideSettingsMinify',
    'ZoneSettingsOverrideSettingsMobileRedirect',
    'ZoneSettingsOverrideSettingsSecurityHeader',
    'GetAccountRolesRoleResult',
    'GetDevicesDeviceResult',
    'GetWafGroupsFilterResult',
    'GetWafGroupsGroupResult',
    'GetWafPackagesFilterResult',
    'GetWafPackagesPackageResult',
    'GetWafRulesFilterResult',
    'GetWafRulesRuleResult',
    'GetZonesFilterResult',
    'GetZonesZoneResult',
]

@pulumi.output_type
class AccessApplicationCorsHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllHeaders":
            suggest = "allow_all_headers"
        elif key == "allowAllMethods":
            suggest = "allow_all_methods"
        elif key == "allowAllOrigins":
            suggest = "allow_all_origins"
        elif key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationCorsHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationCorsHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationCorsHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_headers: Optional[bool] = None,
                 allow_all_methods: Optional[bool] = None,
                 allow_all_origins: Optional[bool] = None,
                 allow_credentials: Optional[bool] = None,
                 allowed_headers: Optional[Sequence[str]] = None,
                 allowed_methods: Optional[Sequence[str]] = None,
                 allowed_origins: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool allow_all_headers: Boolean value to determine whether all
               HTTP headers are exposed.
        :param bool allow_all_methods: Boolean value to determine whether all
               methods are exposed.
        :param bool allow_all_origins: Boolean value to determine whether all
               origins are permitted to make CORS requests.
        :param bool allow_credentials: Boolean value to determine if credentials
               (cookies, authorization headers, or TLS client certificates) are included with
               requests.
        :param Sequence[str] allowed_headers: List of HTTP headers to expose via CORS.
        :param Sequence[str] allowed_methods: List of methods to expose via CORS.
        :param Sequence[str] allowed_origins: List of origins permitted to make CORS requests.
        :param int max_age: Integer representing the maximum time a preflight
               request will be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[bool]:
        """
        Boolean value to determine whether all
        HTTP headers are exposed.
        """
        return pulumi.get(self, "allow_all_headers")

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[bool]:
        """
        Boolean value to determine whether all
        methods are exposed.
        """
        return pulumi.get(self, "allow_all_methods")

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[bool]:
        """
        Boolean value to determine whether all
        origins are permitted to make CORS requests.
        """
        return pulumi.get(self, "allow_all_origins")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        Boolean value to determine if credentials
        (cookies, authorization headers, or TLS client certificates) are included with
        requests.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[str]]:
        """
        List of HTTP headers to expose via CORS.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[str]]:
        """
        List of methods to expose via CORS.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        List of origins permitted to make CORS requests.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Integer representing the maximum time a preflight
        request will be cached.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class AccessGroupExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupExcludeAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupExcludeGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupExcludeGsuite']] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupExcludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupExcludeSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupExcludeAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupExcludeGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupExcludeGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupExcludeOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupExcludeSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupExcludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupExcludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupIncludeAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupIncludeGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupIncludeGsuite']] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupIncludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupIncludeSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupIncludeAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupIncludeGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupIncludeGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupIncludeOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupIncludeSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupIncludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupIncludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupRequireAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupRequireGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupRequireGsuite']] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupRequireOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupRequireSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupRequireAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupRequireGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupRequireGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupRequireOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupRequireSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupRequireAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupRequireGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessIdentityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "appsDomain":
            suggest = "apps_domain"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "centrifyAccount":
            suggest = "centrify_account"
        elif key == "centrifyAppId":
            suggest = "centrify_app_id"
        elif key == "certsUrl":
            suggest = "certs_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "directoryId":
            suggest = "directory_id"
        elif key == "emailAttributeName":
            suggest = "email_attribute_name"
        elif key == "idpPublicCert":
            suggest = "idp_public_cert"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "oktaAccount":
            suggest = "okta_account"
        elif key == "oneloginAccount":
            suggest = "onelogin_account"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "signRequest":
            suggest = "sign_request"
        elif key == "ssoTargetUrl":
            suggest = "sso_target_url"
        elif key == "supportGroups":
            suggest = "support_groups"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessIdentityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessIdentityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessIdentityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional[str] = None,
                 apps_domain: Optional[str] = None,
                 attributes: Optional[Sequence[str]] = None,
                 auth_url: Optional[str] = None,
                 centrify_account: Optional[str] = None,
                 centrify_app_id: Optional[str] = None,
                 certs_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 directory_id: Optional[str] = None,
                 email_attribute_name: Optional[str] = None,
                 idp_public_cert: Optional[str] = None,
                 issuer_url: Optional[str] = None,
                 okta_account: Optional[str] = None,
                 onelogin_account: Optional[str] = None,
                 redirect_url: Optional[str] = None,
                 sign_request: Optional[bool] = None,
                 sso_target_url: Optional[str] = None,
                 support_groups: Optional[bool] = None,
                 token_url: Optional[str] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if idp_public_cert is not None:
            pulumi.set(__self__, "idp_public_cert", idp_public_cert)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[str]:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[str]:
        return pulumi.get(self, "apps_domain")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[str]:
        return pulumi.get(self, "centrify_account")

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[str]:
        return pulumi.get(self, "centrify_app_id")

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[str]:
        return pulumi.get(self, "certs_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[str]:
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "email_attribute_name")

    @property
    @pulumi.getter(name="idpPublicCert")
    def idp_public_cert(self) -> Optional[str]:
        return pulumi.get(self, "idp_public_cert")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[str]:
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[str]:
        return pulumi.get(self, "okta_account")

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[str]:
        return pulumi.get(self, "onelogin_account")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[bool]:
        return pulumi.get(self, "sign_request")

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[str]:
        return pulumi.get(self, "sso_target_url")

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[bool]:
        return pulumi.get(self, "support_groups")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class AccessPolicyApprovalGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalsNeeded":
            suggest = "approvals_needed"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailListUuid":
            suggest = "email_list_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyApprovalGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyApprovalGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyApprovalGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approvals_needed: int,
                 email_addresses: Optional[Sequence[str]] = None,
                 email_list_uuid: Optional[str] = None):
        """
        :param int approvals_needed: Number of approvals needed.
        :param Sequence[str] email_addresses: List of emails to request approval from.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> int:
        """
        Number of approvals needed.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[str]]:
        """
        List of emails to request approval from.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[str]:
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class AccessPolicyExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyExcludeAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyExcludeGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyExcludeGsuite']] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyExcludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyExcludeSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyExcludeAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyExcludeGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyExcludeGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyExcludeOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyExcludeSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyExcludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyExcludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Application.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Application.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Application.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyIncludeAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyIncludeGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyIncludeGsuite']] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyIncludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyIncludeSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyIncludeAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyIncludeGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyIncludeGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyIncludeOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyIncludeSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyIncludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyIncludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Application.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Application.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Application.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[bool] = None,
                 auth_method: Optional[str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyRequireAzure']] = None,
                 certificate: Optional[bool] = None,
                 common_name: Optional[str] = None,
                 device_postures: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 everyone: Optional[bool] = None,
                 geos: Optional[Sequence[str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyRequireGithub']] = None,
                 groups: Optional[Sequence[str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyRequireGsuite']] = None,
                 ips: Optional[Sequence[str]] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyRequireOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyRequireSaml']] = None,
                 service_tokens: Optional[Sequence[str]] = None):
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[bool]:
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[str]:
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyRequireAzure']]:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[bool]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[bool]:
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyRequireGithub']]:
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyRequireGsuite']]:
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyRequireOkta']]:
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyRequireSaml']]:
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyRequireAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 ids: Optional[Sequence[str]] = None):
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyRequireGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 name: Optional[str] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str name: Friendly name of the Access Application.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Friendly name of the Access Application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[str]] = None,
                 identity_provider_id: Optional[str] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] names: Friendly name of the Access Application.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Friendly name of the Access Application.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_value: Optional[str] = None,
                 identity_provider_id: Optional[str] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[str]:
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessRuleConfiguration(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The request property to target. Allowed values: "ip", "ip6", "ip_range", "asn", "country"
        :param str value: The value to target. Depends on target's type.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The request property to target. Allowed values: "ip", "ip6", "ip_range", "asn", "country"
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to target. Depends on target's type.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ApiTokenCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestIp":
            suggest = "request_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_ip: Optional['outputs.ApiTokenConditionRequestIp'] = None):
        """
        :param 'ApiTokenConditionRequestIpArgs' request_ip: Request IP related conditions. See the definition below.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional['outputs.ApiTokenConditionRequestIp']:
        """
        Request IP related conditions. See the definition below.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class ApiTokenConditionRequestIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notIns":
            suggest = "not_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenConditionRequestIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenConditionRequestIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenConditionRequestIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ins: Optional[Sequence[str]] = None,
                 not_ins: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ins: List of IPv4/IPv6 CIDR addresses where
               the Token can be used from.
        :param Sequence[str] not_ins: List of IPv4/IPv6 CIDR addresses where
               the Token cannot be used from.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[Sequence[str]]:
        """
        List of IPv4/IPv6 CIDR addresses where
        the Token can be used from.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[Sequence[str]]:
        """
        List of IPv4/IPv6 CIDR addresses where
        the Token cannot be used from.
        """
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class ApiTokenPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionGroups":
            suggest = "permission_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission_groups: Sequence[str],
                 resources: Mapping[str, str],
                 effect: Optional[str] = None):
        """
        :param Sequence[str] permission_groups: List of permissions groups
               ids ([see official docs](https://developers.cloudflare.com/api/tokens/create/permissions)).
        :param Mapping[str, str] resources: Map describes what operations against which resources
               are allowed or denied.
        :param str effect: Policy effect. Valid values are `allow` or `deny`. `allow`
               is set as default.
        """
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence[str]:
        """
        List of permissions groups
        ids ([see official docs](https://developers.cloudflare.com/api/tokens/create/permissions)).
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, str]:
        """
        Map describes what operations against which resources
        are allowed or denied.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Policy effect. Valid values are `allow` or `deny`. `allow`
        is set as default.
        """
        return pulumi.get(self, "effect")


@pulumi.output_type
class CertificatePackValidationError(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class CertificatePackValidationRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cnameName":
            suggest = "cname_name"
        elif key == "cnameTarget":
            suggest = "cname_target"
        elif key == "httpBody":
            suggest = "http_body"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "txtName":
            suggest = "txt_name"
        elif key == "txtValue":
            suggest = "txt_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificatePackValidationRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificatePackValidationRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificatePackValidationRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cname_name: Optional[str] = None,
                 cname_target: Optional[str] = None,
                 emails: Optional[Sequence[str]] = None,
                 http_body: Optional[str] = None,
                 http_url: Optional[str] = None,
                 txt_name: Optional[str] = None,
                 txt_value: Optional[str] = None):
        if cname_name is not None:
            pulumi.set(__self__, "cname_name", cname_name)
        if cname_target is not None:
            pulumi.set(__self__, "cname_target", cname_target)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[str]:
        return pulumi.get(self, "cname_name")

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[str]:
        return pulumi.get(self, "cname_target")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[str]:
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[str]:
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[str]:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[str]:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class CustomHostnameSsl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "customCertificate":
            suggest = "custom_certificate"
        elif key == "customKey":
            suggest = "custom_key"
        elif key == "validationErrors":
            suggest = "validation_errors"
        elif key == "validationRecords":
            suggest = "validation_records"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSsl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSsl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSsl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority: Optional[str] = None,
                 custom_certificate: Optional[str] = None,
                 custom_key: Optional[str] = None,
                 method: Optional[str] = None,
                 settings: Optional[Sequence['outputs.CustomHostnameSslSetting']] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None,
                 validation_errors: Optional[Sequence['outputs.CustomHostnameSslValidationError']] = None,
                 validation_records: Optional[Sequence['outputs.CustomHostnameSslValidationRecord']] = None,
                 wildcard: Optional[bool] = None):
        """
        :param str custom_certificate: If a custom uploaded certificate is used.
        :param str custom_key: The key for a custom uploaded certificate.
        :param str method: Domain control validation (DCV) method used for this
               hostname. Valid values are `"txt"`, `"http"` and `"email"`.
        :param Sequence['CustomHostnameSslSettingArgs'] settings: SSL/TLS settings for the certificate. See further notes below.
        :param str type: Level of validation to be used for this hostname. Domain validation ("dv") must be used.
        :param bool wildcard: Indicates whether the certificate covers a wildcard.
        """
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)
        if validation_records is not None:
            pulumi.set(__self__, "validation_records", validation_records)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[str]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[str]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Domain control validation (DCV) method used for this
        hostname. Valid values are `"txt"`, `"http"` and `"email"`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Sequence['outputs.CustomHostnameSslSetting']]:
        """
        SSL/TLS settings for the certificate. See further notes below.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Level of validation to be used for this hostname. Domain validation ("dv") must be used.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[Sequence['outputs.CustomHostnameSslValidationError']]:
        return pulumi.get(self, "validation_errors")

    @property
    @pulumi.getter(name="validationRecords")
    def validation_records(self) -> Optional[Sequence['outputs.CustomHostnameSslValidationRecord']]:
        return pulumi.get(self, "validation_records")

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[bool]:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")


@pulumi.output_type
class CustomHostnameSslSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earlyHints":
            suggest = "early_hints"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSslSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSslSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSslSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ciphers: Optional[Sequence[str]] = None,
                 early_hints: Optional[str] = None,
                 http2: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 tls13: Optional[str] = None):
        """
        :param Sequence[str] ciphers: List of SSL/TLS ciphers to associate with this certificate.
        :param str early_hints: Whether or not early hints should be supported. Valid values are `"on"` or `"off"`.
        :param str http2: Whether or not HTTP2 should be supported. Valid values are `"on"` or `"off"`.
        :param str min_tls_version: Lowest version of TLS this certificate should
               support. Valid values are `"1.0"`, `"1.1"`, `"1.2"` and `"1.3"`.
        :param str tls13: Whether or not TLSv1.3 should be supported. Valid values are `"on"` or `"off"`.
        """
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[str]]:
        """
        List of SSL/TLS ciphers to associate with this certificate.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[str]:
        """
        Whether or not early hints should be supported. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter
    def http2(self) -> Optional[str]:
        """
        Whether or not HTTP2 should be supported. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        Lowest version of TLS this certificate should
        support. Valid values are `"1.0"`, `"1.1"`, `"1.2"` and `"1.3"`.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[str]:
        """
        Whether or not TLSv1.3 should be supported. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "tls13")


@pulumi.output_type
class CustomHostnameSslValidationError(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class CustomHostnameSslValidationRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cnameName":
            suggest = "cname_name"
        elif key == "cnameTarget":
            suggest = "cname_target"
        elif key == "httpBody":
            suggest = "http_body"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "txtName":
            suggest = "txt_name"
        elif key == "txtValue":
            suggest = "txt_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSslValidationRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSslValidationRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSslValidationRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cname_name: Optional[str] = None,
                 cname_target: Optional[str] = None,
                 emails: Optional[Sequence[str]] = None,
                 http_body: Optional[str] = None,
                 http_url: Optional[str] = None,
                 txt_name: Optional[str] = None,
                 txt_value: Optional[str] = None):
        if cname_name is not None:
            pulumi.set(__self__, "cname_name", cname_name)
        if cname_target is not None:
            pulumi.set(__self__, "cname_target", cname_target)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[str]:
        return pulumi.get(self, "cname_name")

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[str]:
        return pulumi.get(self, "cname_target")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[str]:
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[str]:
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[str]:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[str]:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class CustomSslCustomSslOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bundleMethod":
            suggest = "bundle_method"
        elif key == "geoRestrictions":
            suggest = "geo_restrictions"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomSslCustomSslOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomSslCustomSslOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomSslCustomSslOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundle_method: Optional[str] = None,
                 certificate: Optional[str] = None,
                 geo_restrictions: Optional[str] = None,
                 private_key: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str bundle_method: Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
        :param str certificate: Certificate certificate and the intermediate(s)
        :param str geo_restrictions: Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
        :param str private_key: Certificate's private key
        :param str type: Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if geo_restrictions is not None:
            pulumi.set(__self__, "geo_restrictions", geo_restrictions)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[str]:
        """
        Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Certificate certificate and the intermediate(s)
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="geoRestrictions")
    def geo_restrictions(self) -> Optional[str]:
        """
        Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
        """
        return pulumi.get(self, "geo_restrictions")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        Certificate's private key
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CustomSslCustomSslPriority(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 priority: Optional[int] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        return pulumi.get(self, "priority")


@pulumi.output_type
class DevicePostureIntegrationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevicePostureIntegrationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevicePostureIntegrationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevicePostureIntegrationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str api_url: The third-party API's URL.
        :param str auth_url: The third-party authorization API URL.
        :param str client_id: The client identifier for authenticating API calls.
        :param str client_secret: The client secret for authenticating API calls.
        """
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        The third-party API's URL.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        """
        The third-party authorization API URL.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client identifier for authenticating API calls.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret for authenticating API calls.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class DevicePostureRuleInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "complianceStatus":
            suggest = "compliance_status"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "requireAll":
            suggest = "require_all"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevicePostureRuleInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevicePostureRuleInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevicePostureRuleInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compliance_status: Optional[str] = None,
                 connection_id: Optional[str] = None,
                 domain: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 exists: Optional[bool] = None,
                 id: Optional[str] = None,
                 operator: Optional[str] = None,
                 path: Optional[str] = None,
                 require_all: Optional[bool] = None,
                 running: Optional[bool] = None,
                 sha256: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str domain: = (Required) The domain that the client must join.
        :param bool enabled: = (Required) True if the firewall must be enabled.
        :param bool exists: Checks if the file should exist.
        :param str id: The Teams List id.
        :param str operator: = (Required) The version comparison operator in (>,>=,<,<=,==)
        :param str path: The path to the application.
        :param bool require_all: = (Required) True if all drives must be encrypted.
        :param bool running: Checks if the application should be running.
        :param str sha256: The sha256 hash of the file.
        :param str thumbprint: The thumbprint of the application certificate.
        :param str version: = (Required) The operating system semantic version.
        """
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if running is not None:
            pulumi.set(__self__, "running", running)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[str]:
        return pulumi.get(self, "compliance_status")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[str]:
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        = (Required) The domain that the client must join.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        = (Required) True if the firewall must be enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exists(self) -> Optional[bool]:
        """
        Checks if the file should exist.
        """
        return pulumi.get(self, "exists")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Teams List id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        = (Required) The version comparison operator in (>,>=,<,<=,==)
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the application.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[bool]:
        """
        = (Required) True if all drives must be encrypted.
        """
        return pulumi.get(self, "require_all")

    @property
    @pulumi.getter
    def running(self) -> Optional[bool]:
        """
        Checks if the application should be running.
        """
        return pulumi.get(self, "running")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        The sha256 hash of the file.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the application certificate.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        = (Required) The operating system semantic version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DevicePostureRuleMatch(dict):
    def __init__(__self__, *,
                 platform: Optional[str] = None):
        """
        :param str platform: The platform of the device. Valid values are `windows`, `mac`, `linux`, `android`, and `ios`.
        """
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        """
        The platform of the device. Valid values are `windows`, `mac`, `linux`, `android`, and `ios`.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class FallbackDomainDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FallbackDomainDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FallbackDomainDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FallbackDomainDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 dns_servers: Optional[Sequence[str]] = None,
                 suffix: Optional[str] = None):
        """
        :param str description: The description of the domain.
        :param Sequence[str] dns_servers: The DNS servers to receive the redirected request.
        :param str suffix: The domain to ignore DNS requests.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the domain.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        The DNS servers to receive the redirected request.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        The domain to ignore DNS requests.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class HealthcheckHeader(dict):
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        """
        :param str header: The header name.
        :param Sequence[str] values: A list of string values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of string values for the header.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class IpListItem(dict):
    def __init__(__self__, *,
                 value: str,
                 comment: Optional[str] = None):
        """
        :param str value: The IPv4 address, IPv4 CIDR or IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64.
        :param str comment: A note that can be used to annotate the item.
        """
        pulumi.set(__self__, "value", value)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The IPv4 address, IPv4 CIDR or IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        A note that can be used to annotate the item.
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class LoadBalancerMonitorHeader(dict):
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        """
        :param str header: The header name.
        :param Sequence[str] values: A list of string values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of string values for the header.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LoadBalancerPoolLoadShedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPercent":
            suggest = "default_percent"
        elif key == "defaultPolicy":
            suggest = "default_policy"
        elif key == "sessionPercent":
            suggest = "session_percent"
        elif key == "sessionPolicy":
            suggest = "session_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPoolLoadShedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPoolLoadShedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPoolLoadShedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_percent: Optional[float] = None,
                 default_policy: Optional[str] = None,
                 session_percent: Optional[float] = None,
                 session_policy: Optional[str] = None):
        """
        :param float default_percent: Percent of traffic to shed 0 - 100.
        :param str default_policy: Method of shedding traffic "", "hash" or "random".
        :param float session_percent: Percent of session traffic to shed 0 - 100.
        :param str session_policy: Method of shedding session traffic "" or "hash".
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[float]:
        """
        Percent of traffic to shed 0 - 100.
        """
        return pulumi.get(self, "default_percent")

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[str]:
        """
        Method of shedding traffic "", "hash" or "random".
        """
        return pulumi.get(self, "default_policy")

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[float]:
        """
        Percent of session traffic to shed 0 - 100.
        """
        return pulumi.get(self, "session_percent")

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[str]:
        """
        Method of shedding session traffic "" or "hash".
        """
        return pulumi.get(self, "session_policy")


@pulumi.output_type
class LoadBalancerPoolOrigin(dict):
    def __init__(__self__, *,
                 address: str,
                 name: str,
                 enabled: Optional[bool] = None,
                 headers: Optional[Sequence['outputs.LoadBalancerPoolOriginHeader']] = None,
                 weight: Optional[float] = None):
        """
        :param str address: The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare.
        :param str name: A human-identifiable name for the origin.
        :param bool enabled: Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        :param Sequence['LoadBalancerPoolOriginHeaderArgs'] headers: The header name.
        :param float weight: The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. Default: 1.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.LoadBalancerPoolOriginHeader']]:
        """
        The header name.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. Default: 1.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class LoadBalancerPoolOriginHeader(dict):
    def __init__(__self__, *,
                 header: str,
                 values: Sequence[str]):
        """
        :param str header: The header name.
        :param Sequence[str] values: A list of string values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of string values for the header.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LoadBalancerPoolOriginSteering(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None):
        """
        :param str policy: Either "random" (default) or "hash".
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Either "random" (default) or "hash".
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class LoadBalancerPopPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPopPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPopPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPopPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[str],
                 pop: str):
        """
        :param Sequence[str] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param str pop: A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def pop(self) -> str:
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        return pulumi.get(self, "pop")


@pulumi.output_type
class LoadBalancerRegionPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRegionPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRegionPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRegionPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[str],
                 region: str):
        """
        :param Sequence[str] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param str region: A region code which must be in the list defined [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions). Multiple entries should not be specified with the same region.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        A region code which must be in the list defined [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions). Multiple entries should not be specified with the same region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class LoadBalancerRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedResponse":
            suggest = "fixed_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 condition: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 fixed_response: Optional['outputs.LoadBalancerRuleFixedResponse'] = None,
                 overrides: Optional[Sequence['outputs.LoadBalancerRuleOverride']] = None,
                 priority: Optional[int] = None,
                 terminates: Optional[bool] = None):
        """
        :param str name: Human readable name for this rule.
        :param str condition: The statement to evaluate to determine if this rules effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        :param bool disabled: A disabled rule will be be executed.
        :param 'LoadBalancerRuleFixedResponseArgs' fixed_response: Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: overrides or fixed_response must be set. See the field documentation below.
        :param Sequence['LoadBalancerRuleOverrideArgs'] overrides: The Load Balancer settings to alter if this rules condition is true. Note: overrides or fixed_response must be set. See the field documentation below.
        :param int priority: Priority used when determining the order of rule execution. Lower values are executed first. If not provided list order will be used.
        :param bool terminates: Terminates indicates that if this rule is true no further rules should be executed. Note: setting a fixed_response forces this field to true.
        """
        pulumi.set(__self__, "name", name)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if terminates is not None:
            pulumi.set(__self__, "terminates", terminates)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Human readable name for this rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The statement to evaluate to determine if this rules effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        A disabled rule will be be executed.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional['outputs.LoadBalancerRuleFixedResponse']:
        """
        Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: overrides or fixed_response must be set. See the field documentation below.
        """
        return pulumi.get(self, "fixed_response")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverride']]:
        """
        The Load Balancer settings to alter if this rules condition is true. Note: overrides or fixed_response must be set. See the field documentation below.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority used when determining the order of rule execution. Lower values are executed first. If not provided list order will be used.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def terminates(self) -> Optional[bool]:
        """
        Terminates indicates that if this rule is true no further rules should be executed. Note: setting a fixed_response forces this field to true.
        """
        return pulumi.get(self, "terminates")


@pulumi.output_type
class LoadBalancerRuleFixedResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleFixedResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleFixedResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleFixedResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[str] = None,
                 location: Optional[str] = None,
                 message_body: Optional[str] = None,
                 status_code: Optional[int] = None):
        """
        :param str content_type: The value of the HTTP context-type header for this fixed response.
        :param str location: The value of the HTTP location header for this fixed response.
        :param str message_body: The text used as the html body for this fixed response.
        :param int status_code: The HTTP status code used for this fixed response.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        The value of the HTTP context-type header for this fixed response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The value of the HTTP location header for this fixed response.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[str]:
        """
        The text used as the html body for this fixed response.
        """
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        The HTTP status code used for this fixed response.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class LoadBalancerRuleOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPools":
            suggest = "default_pools"
        elif key == "fallbackPool":
            suggest = "fallback_pool"
        elif key == "popPools":
            suggest = "pop_pools"
        elif key == "regionPools":
            suggest = "region_pools"
        elif key == "sessionAffinity":
            suggest = "session_affinity"
        elif key == "sessionAffinityAttributes":
            suggest = "session_affinity_attributes"
        elif key == "sessionAffinityTtl":
            suggest = "session_affinity_ttl"
        elif key == "steeringPolicy":
            suggest = "steering_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_pools: Optional[Sequence[str]] = None,
                 fallback_pool: Optional[str] = None,
                 pop_pools: Optional[Sequence['outputs.LoadBalancerRuleOverridePopPool']] = None,
                 region_pools: Optional[Sequence['outputs.LoadBalancerRuleOverrideRegionPool']] = None,
                 session_affinity: Optional[str] = None,
                 session_affinity_attributes: Optional[Mapping[str, str]] = None,
                 session_affinity_ttl: Optional[int] = None,
                 steering_policy: Optional[str] = None,
                 ttl: Optional[int] = None):
        """
        :param Sequence[str] default_pools: See default_pool_ids above.
        :param str fallback_pool: See fallback_pool_id above.
        :param Sequence['LoadBalancerRuleOverridePopPoolArgs'] pop_pools: See pop_pools above.
        :param Sequence['LoadBalancerRuleOverrideRegionPoolArgs'] region_pools: See region_pools above.
        :param str session_affinity: See field above.
        :param Mapping[str, str] session_affinity_attributes: See field above.
        :param int session_affinity_ttl: See field above.
        :param str steering_policy: See field above.
        :param int ttl: See field above.
        """
        if default_pools is not None:
            pulumi.set(__self__, "default_pools", default_pools)
        if fallback_pool is not None:
            pulumi.set(__self__, "fallback_pool", fallback_pool)
        if pop_pools is not None:
            pulumi.set(__self__, "pop_pools", pop_pools)
        if region_pools is not None:
            pulumi.set(__self__, "region_pools", region_pools)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_affinity_attributes is not None:
            pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        if session_affinity_ttl is not None:
            pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        if steering_policy is not None:
            pulumi.set(__self__, "steering_policy", steering_policy)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Optional[Sequence[str]]:
        """
        See default_pool_ids above.
        """
        return pulumi.get(self, "default_pools")

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> Optional[str]:
        """
        See fallback_pool_id above.
        """
        return pulumi.get(self, "fallback_pool")

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverridePopPool']]:
        """
        See pop_pools above.
        """
        return pulumi.get(self, "pop_pools")

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideRegionPool']]:
        """
        See region_pools above.
        """
        return pulumi.get(self, "region_pools")

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[str]:
        """
        See field above.
        """
        return pulumi.get(self, "session_affinity")

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> Optional[Mapping[str, str]]:
        """
        See field above.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> Optional[int]:
        """
        See field above.
        """
        return pulumi.get(self, "session_affinity_ttl")

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> Optional[str]:
        """
        See field above.
        """
        return pulumi.get(self, "steering_policy")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        See field above.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class LoadBalancerRuleOverridePopPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverridePopPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverridePopPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverridePopPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[str],
                 pop: str):
        """
        :param Sequence[str] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param str pop: A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def pop(self) -> str:
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        return pulumi.get(self, "pop")


@pulumi.output_type
class LoadBalancerRuleOverrideRegionPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideRegionPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideRegionPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideRegionPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[str],
                 region: str):
        """
        :param Sequence[str] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param str region: A region code which must be in the list defined [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions). Multiple entries should not be specified with the same region.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[str]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        A region code which must be in the list defined [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions). Multiple entries should not be specified with the same region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class NotificationPolicyEmailIntegration(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str name: The name of the notification policy.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the notification policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NotificationPolicyPagerdutyIntegration(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str name: The name of the notification policy.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the notification policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NotificationPolicyWebhooksIntegration(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str name: The name of the notification policy.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the notification policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PageRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOnline":
            suggest = "always_online"
        elif key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "bypassCacheOnCookie":
            suggest = "bypass_cache_on_cookie"
        elif key == "cacheByDeviceType":
            suggest = "cache_by_device_type"
        elif key == "cacheDeceptionArmor":
            suggest = "cache_deception_armor"
        elif key == "cacheKeyFields":
            suggest = "cache_key_fields"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "cacheOnCookie":
            suggest = "cache_on_cookie"
        elif key == "cacheTtlByStatuses":
            suggest = "cache_ttl_by_statuses"
        elif key == "disableApps":
            suggest = "disable_apps"
        elif key == "disablePerformance":
            suggest = "disable_performance"
        elif key == "disableRailgun":
            suggest = "disable_railgun"
        elif key == "disableSecurity":
            suggest = "disable_security"
        elif key == "edgeCacheTtl":
            suggest = "edge_cache_ttl"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "explicitCacheControl":
            suggest = "explicit_cache_control"
        elif key == "forwardingUrl":
            suggest = "forwarding_url"
        elif key == "hostHeaderOverride":
            suggest = "host_header_override"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "resolveOverride":
            suggest = "resolve_override"
        elif key == "respectStrongEtag":
            suggest = "respect_strong_etag"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_online: Optional[str] = None,
                 always_use_https: Optional[bool] = None,
                 automatic_https_rewrites: Optional[str] = None,
                 browser_cache_ttl: Optional[str] = None,
                 browser_check: Optional[str] = None,
                 bypass_cache_on_cookie: Optional[str] = None,
                 cache_by_device_type: Optional[str] = None,
                 cache_deception_armor: Optional[str] = None,
                 cache_key_fields: Optional['outputs.PageRuleActionsCacheKeyFields'] = None,
                 cache_level: Optional[str] = None,
                 cache_on_cookie: Optional[str] = None,
                 cache_ttl_by_statuses: Optional[Sequence['outputs.PageRuleActionsCacheTtlByStatus']] = None,
                 disable_apps: Optional[bool] = None,
                 disable_performance: Optional[bool] = None,
                 disable_railgun: Optional[bool] = None,
                 disable_security: Optional[bool] = None,
                 edge_cache_ttl: Optional[int] = None,
                 email_obfuscation: Optional[str] = None,
                 explicit_cache_control: Optional[str] = None,
                 forwarding_url: Optional['outputs.PageRuleActionsForwardingUrl'] = None,
                 host_header_override: Optional[str] = None,
                 ip_geolocation: Optional[str] = None,
                 minifies: Optional[Sequence['outputs.PageRuleActionsMinify']] = None,
                 mirage: Optional[str] = None,
                 opportunistic_encryption: Optional[str] = None,
                 origin_error_page_pass_thru: Optional[str] = None,
                 polish: Optional[str] = None,
                 resolve_override: Optional[str] = None,
                 respect_strong_etag: Optional[str] = None,
                 response_buffering: Optional[str] = None,
                 rocket_loader: Optional[str] = None,
                 security_level: Optional[str] = None,
                 server_side_exclude: Optional[str] = None,
                 sort_query_string_for_cache: Optional[str] = None,
                 ssl: Optional[str] = None,
                 true_client_ip_header: Optional[str] = None,
                 waf: Optional[str] = None):
        """
        :param str always_online: Whether this action is `"on"` or `"off"`.
        :param bool always_use_https: Boolean of whether this action is enabled. Default: false.
        :param str automatic_https_rewrites: Whether this action is `"on"` or `"off"`.
        :param str browser_cache_ttl: The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        :param str browser_check: Whether this action is `"on"` or `"off"`.
        :param str bypass_cache_on_cookie: String value of cookie name to conditionally bypass cache the page.
        :param str cache_by_device_type: Whether this action is `"on"` or `"off"`.
        :param str cache_deception_armor: Whether this action is `"on"` or `"off"`.
        :param 'PageRuleActionsCacheKeyFieldsArgs' cache_key_fields: Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        :param str cache_level: Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        :param str cache_on_cookie: String value of cookie name to conditionally cache the page.
        :param Sequence['PageRuleActionsCacheTtlByStatusArgs'] cache_ttl_by_statuses: Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        :param bool disable_apps: Boolean of whether this action is enabled. Default: false.
        :param bool disable_performance: Boolean of whether this action is enabled. Default: false.
        :param bool disable_railgun: Boolean of whether this action is enabled. Default: false.
        :param bool disable_security: Boolean of whether this action is enabled. Default: false.
        :param int edge_cache_ttl: The Time To Live for the edge cache.
        :param str email_obfuscation: Whether this action is `"on"` or `"off"`.
        :param str explicit_cache_control: Whether origin Cache-Control action is `"on"` or `"off"`.
        :param 'PageRuleActionsForwardingUrlArgs' forwarding_url: The URL to forward to, and with what status. See below.
        :param str host_header_override: Value of the Host header to send.
        :param str ip_geolocation: Whether this action is `"on"` or `"off"`.
        :param Sequence['PageRuleActionsMinifyArgs'] minifies: The configuration for HTML, CSS and JS minification. See below for full list of options.
        :param str mirage: Whether this action is `"on"` or `"off"`.
        :param str opportunistic_encryption: Whether this action is `"on"` or `"off"`.
        :param str origin_error_page_pass_thru: Whether this action is `"on"` or `"off"`.
        :param str polish: Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        :param str resolve_override: Overridden origin server name.
        :param str respect_strong_etag: Whether this action is `"on"` or `"off"`.
        :param str response_buffering: Whether this action is `"on"` or `"off"`.
        :param str rocket_loader: Whether to set the rocket loader to `"on"`, `"off"`.
        :param str security_level: Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        :param str server_side_exclude: Whether this action is `"on"` or `"off"`.
        :param str sort_query_string_for_cache: Whether this action is `"on"` or `"off"`.
        :param str ssl: Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        :param str true_client_ip_header: Whether this action is `"on"` or `"off"`.
        :param str waf: Whether this action is `"on"` or `"off"`.
        """
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if bypass_cache_on_cookie is not None:
            pulumi.set(__self__, "bypass_cache_on_cookie", bypass_cache_on_cookie)
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if cache_key_fields is not None:
            pulumi.set(__self__, "cache_key_fields", cache_key_fields)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if cache_on_cookie is not None:
            pulumi.set(__self__, "cache_on_cookie", cache_on_cookie)
        if cache_ttl_by_statuses is not None:
            pulumi.set(__self__, "cache_ttl_by_statuses", cache_ttl_by_statuses)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_performance is not None:
            pulumi.set(__self__, "disable_performance", disable_performance)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_security is not None:
            pulumi.set(__self__, "disable_security", disable_security)
        if edge_cache_ttl is not None:
            pulumi.set(__self__, "edge_cache_ttl", edge_cache_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if explicit_cache_control is not None:
            pulumi.set(__self__, "explicit_cache_control", explicit_cache_control)
        if forwarding_url is not None:
            pulumi.set(__self__, "forwarding_url", forwarding_url)
        if host_header_override is not None:
            pulumi.set(__self__, "host_header_override", host_header_override)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if minifies is not None:
            pulumi.set(__self__, "minifies", minifies)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if resolve_override is not None:
            pulumi.set(__self__, "resolve_override", resolve_override)
        if respect_strong_etag is not None:
            pulumi.set(__self__, "respect_strong_etag", respect_strong_etag)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "always_online")

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[str]:
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="bypassCacheOnCookie")
    def bypass_cache_on_cookie(self) -> Optional[str]:
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        return pulumi.get(self, "bypass_cache_on_cookie")

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="cacheKeyFields")
    def cache_key_fields(self) -> Optional['outputs.PageRuleActionsCacheKeyFields']:
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        return pulumi.get(self, "cache_key_fields")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[str]:
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="cacheOnCookie")
    def cache_on_cookie(self) -> Optional[str]:
        """
        String value of cookie name to conditionally cache the page.
        """
        return pulumi.get(self, "cache_on_cookie")

    @property
    @pulumi.getter(name="cacheTtlByStatuses")
    def cache_ttl_by_statuses(self) -> Optional[Sequence['outputs.PageRuleActionsCacheTtlByStatus']]:
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        return pulumi.get(self, "cache_ttl_by_statuses")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disablePerformance")
    def disable_performance(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_performance")

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_railgun")

    @property
    @pulumi.getter(name="disableSecurity")
    def disable_security(self) -> Optional[bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_security")

    @property
    @pulumi.getter(name="edgeCacheTtl")
    def edge_cache_ttl(self) -> Optional[int]:
        """
        The Time To Live for the edge cache.
        """
        return pulumi.get(self, "edge_cache_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="explicitCacheControl")
    def explicit_cache_control(self) -> Optional[str]:
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "explicit_cache_control")

    @property
    @pulumi.getter(name="forwardingUrl")
    def forwarding_url(self) -> Optional['outputs.PageRuleActionsForwardingUrl']:
        """
        The URL to forward to, and with what status. See below.
        """
        return pulumi.get(self, "forwarding_url")

    @property
    @pulumi.getter(name="hostHeaderOverride")
    def host_header_override(self) -> Optional[str]:
        """
        Value of the Host header to send.
        """
        return pulumi.get(self, "host_header_override")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def minifies(self) -> Optional[Sequence['outputs.PageRuleActionsMinify']]:
        """
        The configuration for HTML, CSS and JS minification. See below for full list of options.
        """
        return pulumi.get(self, "minifies")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="resolveOverride")
    def resolve_override(self) -> Optional[str]:
        """
        Overridden origin server name.
        """
        return pulumi.get(self, "resolve_override")

    @property
    @pulumi.getter(name="respectStrongEtag")
    def respect_strong_etag(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "respect_strong_etag")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[str]:
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter
    def waf(self) -> Optional[str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "waf")


@pulumi.output_type
class PageRuleActionsCacheKeyFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: 'outputs.PageRuleActionsCacheKeyFieldsCookie',
                 header: 'outputs.PageRuleActionsCacheKeyFieldsHeader',
                 host: 'outputs.PageRuleActionsCacheKeyFieldsHost',
                 query_string: 'outputs.PageRuleActionsCacheKeyFieldsQueryString',
                 user: 'outputs.PageRuleActionsCacheKeyFieldsUser'):
        """
        :param 'PageRuleActionsCacheKeyFieldsCookieArgs' cookie: Controls what cookies go into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsHeaderArgs' header: Controls what HTTP headers go into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsHostArgs' host: Controls which Host header goes into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsQueryStringArgs' query_string: Controls which URL query string parameters go into the Cache Key.
        :param 'PageRuleActionsCacheKeyFieldsUserArgs' user: Controls which end user-related features go into the Cache Key.
        """
        pulumi.set(__self__, "cookie", cookie)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> 'outputs.PageRuleActionsCacheKeyFieldsCookie':
        """
        Controls what cookies go into Cache Key:
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> 'outputs.PageRuleActionsCacheKeyFieldsHeader':
        """
        Controls what HTTP headers go into Cache Key:
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def host(self) -> 'outputs.PageRuleActionsCacheKeyFieldsHost':
        """
        Controls which Host header goes into Cache Key:
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> 'outputs.PageRuleActionsCacheKeyFieldsQueryString':
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> 'outputs.PageRuleActionsCacheKeyFieldsUser':
        """
        Controls which end user-related features go into the Cache Key.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] check_presences: Check for presence of specified HTTP headers, without including their actual values.
        :param Sequence[str] includes: Only use values of specified query string parameters in Cache Key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[str]] = None,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] check_presences: Check for presence of specified HTTP headers, without including their actual values.
        :param Sequence[str] excludes: Exclude these query string parameters from Cache Key.
        :param Sequence[str] includes: Only use values of specified query string parameters in Cache Key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[str]]:
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        Exclude these query string parameters from Cache Key.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsHost(dict):
    def __init__(__self__, *,
                 resolved: Optional[bool] = None):
        """
        :param bool resolved: `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[bool]:
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        return pulumi.get(self, "resolved")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsQueryString(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 ignore: Optional[bool] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] excludes: Exclude these query string parameters from Cache Key.
        :param bool ignore: `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value is ignored if any of `exclude` or `include` is non-empty.
        :param Sequence[str] includes: Only use values of specified query string parameters in Cache Key.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if ignore is not None:
            pulumi.set(__self__, "ignore", ignore)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        Exclude these query string parameters from Cache Key.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def ignore(self) -> Optional[bool]:
        """
        `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value is ignored if any of `exclude` or `include` is non-empty.
        """
        return pulumi.get(self, "ignore")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_type: Optional[bool] = None,
                 geo: Optional[bool] = None,
                 lang: Optional[bool] = None):
        """
        :param bool device_type: `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
        :param bool geo: `true` - includes the client’s country, derived from the IP address; defaults to `false`.
        :param bool lang: `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[bool]:
        """
        `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[bool]:
        """
        `true` - includes the client’s country, derived from the IP address; defaults to `false`.
        """
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[bool]:
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
        """
        return pulumi.get(self, "lang")


@pulumi.output_type
class PageRuleActionsCacheTtlByStatus(dict):
    def __init__(__self__, *,
                 codes: str,
                 ttl: int):
        """
        :param str codes: A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        :param int ttl: Duration a resource lives in the Cloudflare cache.
               * positive number - cache for specified duration in seconds
        """
        pulumi.set(__self__, "codes", codes)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def codes(self) -> str:
        """
        A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        """
        return pulumi.get(self, "codes")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        Duration a resource lives in the Cloudflare cache.
        * positive number - cache for specified duration in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class PageRuleActionsForwardingUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsForwardingUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsForwardingUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsForwardingUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: int,
                 url: str):
        """
        :param int status_code: The status code to use for the redirection.
        :param str url: The URL to which the page rule should forward.
        """
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The status code to use for the redirection.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to which the page rule should forward.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PageRuleActionsMinify(dict):
    def __init__(__self__, *,
                 css: str,
                 html: str,
                 js: str):
        """
        :param str css: Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        :param str html: Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        :param str js: Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> str:
        """
        Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> str:
        """
        Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> str:
        """
        Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class RateLimitAction(dict):
    def __init__(__self__, *,
                 mode: str,
                 response: Optional['outputs.RateLimitActionResponse'] = None,
                 timeout: Optional[int] = None):
        """
        :param str mode: The type of action to perform. Allowable values are 'simulate', 'ban', 'challenge', 'js_challenge' and 'managed_challenge'.
        :param 'RateLimitActionResponseArgs' response: Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.
        :param int timeout: The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period (min: 1, max: 86400).
        """
        pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The type of action to perform. Allowable values are 'simulate', 'ban', 'challenge', 'js_challenge' and 'managed_challenge'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RateLimitActionResponse']:
        """
        Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period (min: 1, max: 86400).
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RateLimitActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: str,
                 content_type: str):
        """
        :param str body: The body to return, the content here should conform to the content_type.
        :param str content_type: The content-type of the body, must be one of: 'text/plain', 'text/xml', 'application/json'.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The body to return, the content here should conform to the content_type.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The content-type of the body, must be one of: 'text/plain', 'text/xml', 'application/json'.
        """
        return pulumi.get(self, "content_type")


@pulumi.output_type
class RateLimitCorrelate(dict):
    def __init__(__self__, *,
                 by: Optional[str] = None):
        """
        :param str by: If set to 'nat', NAT support will be enabled for rate limiting.
        """
        if by is not None:
            pulumi.set(__self__, "by", by)

    @property
    @pulumi.getter
    def by(self) -> Optional[str]:
        """
        If set to 'nat', NAT support will be enabled for rate limiting.
        """
        return pulumi.get(self, "by")


@pulumi.output_type
class RateLimitMatch(dict):
    def __init__(__self__, *,
                 request: Optional['outputs.RateLimitMatchRequest'] = None,
                 response: Optional['outputs.RateLimitMatchResponse'] = None):
        """
        :param 'RateLimitMatchRequestArgs' request: Matches HTTP requests (from the client to Cloudflare). See definition below.
        :param 'RateLimitMatchResponseArgs' response: Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.RateLimitMatchRequest']:
        """
        Matches HTTP requests (from the client to Cloudflare). See definition below.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RateLimitMatchResponse']:
        """
        Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class RateLimitMatchRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlPattern":
            suggest = "url_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitMatchRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitMatchRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitMatchRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 methods: Optional[Sequence[str]] = None,
                 schemes: Optional[Sequence[str]] = None,
                 url_pattern: Optional[str] = None):
        """
        :param Sequence[str] methods: HTTP Methods, can be a subset ['POST','PUT'] or all ['\_ALL\_']. Default: ['\_ALL\_'].
        :param Sequence[str] schemes: HTTP Schemes, can be one ['HTTPS'], both ['HTTP','HTTPS'] or all ['\_ALL\_'].  Default: ['\_ALL\_'].
        :param str url_pattern: The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use * for all traffic to your zone. Default: '*'.
        """
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if schemes is not None:
            pulumi.set(__self__, "schemes", schemes)
        if url_pattern is not None:
            pulumi.set(__self__, "url_pattern", url_pattern)

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[str]]:
        """
        HTTP Methods, can be a subset ['POST','PUT'] or all ['\_ALL\_']. Default: ['\_ALL\_'].
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def schemes(self) -> Optional[Sequence[str]]:
        """
        HTTP Schemes, can be one ['HTTPS'], both ['HTTP','HTTPS'] or all ['\_ALL\_'].  Default: ['\_ALL\_'].
        """
        return pulumi.get(self, "schemes")

    @property
    @pulumi.getter(name="urlPattern")
    def url_pattern(self) -> Optional[str]:
        """
        The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use * for all traffic to your zone. Default: '*'.
        """
        return pulumi.get(self, "url_pattern")


@pulumi.output_type
class RateLimitMatchResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originTraffic":
            suggest = "origin_traffic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitMatchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitMatchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitMatchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[Mapping[str, str]]] = None,
                 origin_traffic: Optional[bool] = None,
                 statuses: Optional[Sequence[int]] = None):
        """
        :param Sequence[Mapping[str, str]] headers: block is a list of maps with the following attributes:
        :param bool origin_traffic: Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting. Default: `true`.
        :param Sequence[int] statuses: HTTP Status codes, can be one [403], many [401,403] or indicate all by not providing this value.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if origin_traffic is not None:
            pulumi.set(__self__, "origin_traffic", origin_traffic)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[Mapping[str, str]]]:
        """
        block is a list of maps with the following attributes:
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> Optional[bool]:
        """
        Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting. Default: `true`.
        """
        return pulumi.get(self, "origin_traffic")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[int]]:
        """
        HTTP Status codes, can be one [403], many [401,403] or indicate all by not providing this value.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class RecordData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "digestType":
            suggest = "digest_type"
        elif key == "keyTag":
            suggest = "key_tag"
        elif key == "latDegrees":
            suggest = "lat_degrees"
        elif key == "latDirection":
            suggest = "lat_direction"
        elif key == "latMinutes":
            suggest = "lat_minutes"
        elif key == "latSeconds":
            suggest = "lat_seconds"
        elif key == "longDegrees":
            suggest = "long_degrees"
        elif key == "longDirection":
            suggest = "long_direction"
        elif key == "longMinutes":
            suggest = "long_minutes"
        elif key == "longSeconds":
            suggest = "long_seconds"
        elif key == "matchingType":
            suggest = "matching_type"
        elif key == "precisionHorz":
            suggest = "precision_horz"
        elif key == "precisionVert":
            suggest = "precision_vert"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[int] = None,
                 altitude: Optional[float] = None,
                 certificate: Optional[str] = None,
                 content: Optional[str] = None,
                 digest: Optional[str] = None,
                 digest_type: Optional[int] = None,
                 fingerprint: Optional[str] = None,
                 flags: Optional[str] = None,
                 key_tag: Optional[int] = None,
                 lat_degrees: Optional[int] = None,
                 lat_direction: Optional[str] = None,
                 lat_minutes: Optional[int] = None,
                 lat_seconds: Optional[float] = None,
                 long_degrees: Optional[int] = None,
                 long_direction: Optional[str] = None,
                 long_minutes: Optional[int] = None,
                 long_seconds: Optional[float] = None,
                 matching_type: Optional[int] = None,
                 name: Optional[str] = None,
                 order: Optional[int] = None,
                 port: Optional[int] = None,
                 precision_horz: Optional[float] = None,
                 precision_vert: Optional[float] = None,
                 preference: Optional[int] = None,
                 priority: Optional[int] = None,
                 proto: Optional[str] = None,
                 protocol: Optional[int] = None,
                 public_key: Optional[str] = None,
                 regex: Optional[str] = None,
                 replacement: Optional[str] = None,
                 selector: Optional[int] = None,
                 service: Optional[str] = None,
                 size: Optional[float] = None,
                 tag: Optional[str] = None,
                 target: Optional[str] = None,
                 type: Optional[int] = None,
                 usage: Optional[int] = None,
                 value: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str name: The name of the record
        :param int priority: The priority of the record
        :param int type: The type of the record
        :param str value: The (string) value of the record. Either this or `data` must be specified
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if proto is not None:
            pulumi.set(__self__, "proto", proto)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[int]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def altitude(self) -> Optional[float]:
        return pulumi.get(self, "altitude")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[int]:
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def flags(self) -> Optional[str]:
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[int]:
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[int]:
        return pulumi.get(self, "lat_degrees")

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[str]:
        return pulumi.get(self, "lat_direction")

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[int]:
        return pulumi.get(self, "lat_minutes")

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[float]:
        return pulumi.get(self, "lat_seconds")

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[int]:
        return pulumi.get(self, "long_degrees")

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[str]:
        return pulumi.get(self, "long_direction")

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[int]:
        return pulumi.get(self, "long_minutes")

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[float]:
        return pulumi.get(self, "long_seconds")

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[int]:
        return pulumi.get(self, "matching_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the record
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[float]:
        return pulumi.get(self, "precision_horz")

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[float]:
        return pulumi.get(self, "precision_vert")

    @property
    @pulumi.getter
    def preference(self) -> Optional[int]:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority of the record
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def proto(self) -> Optional[str]:
        return pulumi.get(self, "proto")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        return pulumi.get(self, "replacement")

    @property
    @pulumi.getter
    def selector(self) -> Optional[int]:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def size(self) -> Optional[float]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[int]:
        """
        The type of the record
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> Optional[int]:
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The (string) value of the record. Either this or `data` must be specified
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class RulesetRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionParameters":
            suggest = "action_parameters"
        elif key == "exposedCredentialCheck":
            suggest = "exposed_credential_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 action: Optional[str] = None,
                 action_parameters: Optional['outputs.RulesetRuleActionParameters'] = None,
                 enabled: Optional[bool] = None,
                 exposed_credential_check: Optional['outputs.RulesetRuleExposedCredentialCheck'] = None,
                 id: Optional[str] = None,
                 ratelimit: Optional['outputs.RulesetRuleRatelimit'] = None,
                 ref: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str description: Brief summary of the ruleset rule and its intended use.
        :param str expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.
        :param str action: Action to perform in the rule-level override. Valid values are `"block"`, `"challenge"`, `"ddos_dynamic"`, `"execute"`, `"force_connection_close"`, `"js_challenge"`, `"managed_challenge"`, `"log"`, `"rewrite"`, `"score"`, or  `"skip"`.
        :param 'RulesetRuleActionParametersArgs' action_parameters: List of parameters that configure the behavior of the ruleset rule action (refer to the nested schema).
        :param bool enabled: Defines if the current rule-level override enables or disables the rule.
        :param 'RulesetRuleExposedCredentialCheckArgs' exposed_credential_check: List of parameters that configure exposed credential checks (refer to the nested schema).
        :param str id: Rule ID to apply the override to.
        :param 'RulesetRuleRatelimitArgs' ratelimit: List of parameters that configure HTTP rate limiting behaviour (refer to the nested schema).
        :param str ref: Rule reference.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Brief summary of the ruleset rule and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to perform in the rule-level override. Valid values are `"block"`, `"challenge"`, `"ddos_dynamic"`, `"execute"`, `"force_connection_close"`, `"js_challenge"`, `"managed_challenge"`, `"log"`, `"rewrite"`, `"score"`, or  `"skip"`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional['outputs.RulesetRuleActionParameters']:
        """
        List of parameters that configure the behavior of the ruleset rule action (refer to the nested schema).
        """
        return pulumi.get(self, "action_parameters")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defines if the current rule-level override enables or disables the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional['outputs.RulesetRuleExposedCredentialCheck']:
        """
        List of parameters that configure exposed credential checks (refer to the nested schema).
        """
        return pulumi.get(self, "exposed_credential_check")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Rule ID to apply the override to.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional['outputs.RulesetRuleRatelimit']:
        """
        List of parameters that configure HTTP rate limiting behaviour (refer to the nested schema).
        """
        return pulumi.get(self, "ratelimit")

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        Rule reference.
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class RulesetRuleActionParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchedData":
            suggest = "matched_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.RulesetRuleActionParametersHeader']] = None,
                 id: Optional[str] = None,
                 increment: Optional[int] = None,
                 matched_data: Optional['outputs.RulesetRuleActionParametersMatchedData'] = None,
                 overrides: Optional['outputs.RulesetRuleActionParametersOverrides'] = None,
                 phases: Optional[Sequence[str]] = None,
                 products: Optional[Sequence[str]] = None,
                 rules: Optional[Mapping[str, str]] = None,
                 ruleset: Optional[str] = None,
                 rulesets: Optional[Sequence[str]] = None,
                 uri: Optional['outputs.RulesetRuleActionParametersUri'] = None,
                 version: Optional[str] = None):
        """
        :param Sequence['RulesetRuleActionParametersHeaderArgs'] headers: List of HTTP header modifications to perform in the ruleset rule (refer to the nested schema).
        :param str id: Rule ID to apply the override to.
        :param 'RulesetRuleActionParametersMatchedDataArgs' matched_data: List of properties to configure WAF payload logging (refer to the nested schema).
        :param 'RulesetRuleActionParametersOverridesArgs' overrides: List of override configurations to apply to the ruleset (refer to the nested schema).
        :param Sequence[str] products: Products to target with the actions. Valid values are `"bic"`, `"hot"`, `"ratelimit"`, `"securityLevel"`, `"uablock"`, `"waf"` or `"zonelockdown"`.
        :param Mapping[str, str] rules: List of rule-based overrides (refer to the nested schema).
        :param str ruleset: Which ruleset ID to target.
        :param Sequence[str] rulesets: List of managed WAF rule IDs to target. Only valid when the "action" is set to skip.
        :param 'RulesetRuleActionParametersUriArgs' uri: List of URI properties to configure for the ruleset rule when performing URL rewrite transformations (refer to the nested schema).
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersHeader']]:
        """
        List of HTTP header modifications to perform in the ruleset rule (refer to the nested schema).
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Rule ID to apply the override to.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def increment(self) -> Optional[int]:
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional['outputs.RulesetRuleActionParametersMatchedData']:
        """
        List of properties to configure WAF payload logging (refer to the nested schema).
        """
        return pulumi.get(self, "matched_data")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.RulesetRuleActionParametersOverrides']:
        """
        List of override configurations to apply to the ruleset (refer to the nested schema).
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def phases(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "phases")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[str]]:
        """
        Products to target with the actions. Valid values are `"bic"`, `"hot"`, `"ratelimit"`, `"securityLevel"`, `"uablock"`, `"waf"` or `"zonelockdown"`.
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Mapping[str, str]]:
        """
        List of rule-based overrides (refer to the nested schema).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[str]:
        """
        Which ruleset ID to target.
        """
        return pulumi.get(self, "ruleset")

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[Sequence[str]]:
        """
        List of managed WAF rule IDs to target. Only valid when the "action" is set to skip.
        """
        return pulumi.get(self, "rulesets")

    @property
    @pulumi.getter
    def uri(self) -> Optional['outputs.RulesetRuleActionParametersUri']:
        """
        List of URI properties to configure for the ruleset rule when performing URL rewrite transformations (refer to the nested schema).
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class RulesetRuleActionParametersHeader(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 name: Optional[str] = None,
                 operation: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.
        :param str name: Name of the HTTP request header to target.
        :param str operation: Action to perform on the HTTP request header. Valid values are `"set"` or `"remove"`.
        :param str value: Static string value of the updated URI path or query string component. Conflicts with `expression`.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the HTTP request header to target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operation(self) -> Optional[str]:
        """
        Action to perform on the HTTP request header. Valid values are `"set"` or `"remove"`.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Static string value of the updated URI path or query string component. Conflicts with `expression`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersMatchedData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersMatchedData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersMatchedData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersMatchedData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: Optional[str] = None):
        """
        :param str public_key: Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class RulesetRuleActionParametersOverrides(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 categories: Optional[Sequence['outputs.RulesetRuleActionParametersOverridesCategory']] = None,
                 enabled: Optional[bool] = None,
                 rules: Optional[Sequence['outputs.RulesetRuleActionParametersOverridesRule']] = None):
        """
        :param str action: Action to perform in the rule-level override. Valid values are `"block"`, `"challenge"`, `"ddos_dynamic"`, `"execute"`, `"force_connection_close"`, `"js_challenge"`, `"managed_challenge"`, `"log"`, `"rewrite"`, `"score"`, or  `"skip"`.
        :param Sequence['RulesetRuleActionParametersOverridesCategoryArgs'] categories: List of tag-based overrides (refer to the nested schema).
        :param bool enabled: Defines if the current rule-level override enables or disables the rule.
        :param Sequence['RulesetRuleActionParametersOverridesRuleArgs'] rules: List of rule-based overrides (refer to the nested schema).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to perform in the rule-level override. Valid values are `"block"`, `"challenge"`, `"ddos_dynamic"`, `"execute"`, `"force_connection_close"`, `"js_challenge"`, `"managed_challenge"`, `"log"`, `"rewrite"`, `"score"`, or  `"skip"`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersOverridesCategory']]:
        """
        List of tag-based overrides (refer to the nested schema).
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defines if the current rule-level override enables or disables the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersOverridesRule']]:
        """
        List of rule-based overrides (refer to the nested schema).
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class RulesetRuleActionParametersOverridesCategory(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 category: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str action: Action to perform in the rule-level override. Valid values are `"block"`, `"challenge"`, `"ddos_dynamic"`, `"execute"`, `"force_connection_close"`, `"js_challenge"`, `"managed_challenge"`, `"log"`, `"rewrite"`, `"score"`, or  `"skip"`.
        :param str category: Tag name to apply the ruleset rule override to.
        :param bool enabled: Defines if the current rule-level override enables or disables the rule.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to perform in the rule-level override. Valid values are `"block"`, `"challenge"`, `"ddos_dynamic"`, `"execute"`, `"force_connection_close"`, `"js_challenge"`, `"managed_challenge"`, `"log"`, `"rewrite"`, `"score"`, or  `"skip"`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag name to apply the ruleset rule override to.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defines if the current rule-level override enables or disables the rule.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RulesetRuleActionParametersOverridesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoreThreshold":
            suggest = "score_threshold"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersOverridesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersOverridesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersOverridesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 score_threshold: Optional[int] = None,
                 sensitivity_level: Optional[str] = None):
        """
        :param str action: Action to perform in the rule-level override. Valid values are `"block"`, `"challenge"`, `"ddos_dynamic"`, `"execute"`, `"force_connection_close"`, `"js_challenge"`, `"managed_challenge"`, `"log"`, `"rewrite"`, `"score"`, or  `"skip"`.
        :param bool enabled: Defines if the current rule-level override enables or disables the rule.
        :param str id: Rule ID to apply the override to.
        :param int score_threshold: Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        :param str sensitivity_level: Sensitivity level for a ruleset rule override.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to perform in the rule-level override. Valid values are `"block"`, `"challenge"`, `"ddos_dynamic"`, `"execute"`, `"force_connection_close"`, `"js_challenge"`, `"managed_challenge"`, `"log"`, `"rewrite"`, `"score"`, or  `"skip"`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defines if the current rule-level override enables or disables the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Rule ID to apply the override to.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[int]:
        """
        Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        """
        return pulumi.get(self, "score_threshold")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[str]:
        """
        Sensitivity level for a ruleset rule override.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RulesetRuleActionParametersUri(dict):
    def __init__(__self__, *,
                 origin: Optional[bool] = None,
                 path: Optional['outputs.RulesetRuleActionParametersUriPath'] = None,
                 query: Optional['outputs.RulesetRuleActionParametersUriQuery'] = None):
        """
        :param 'RulesetRuleActionParametersUriPathArgs' path: URI path configuration when performing a URL rewrite (refer to the nested schema).
        :param 'RulesetRuleActionParametersUriQueryArgs' query: Query string configuration when performing a URL rewrite (refer to the nested schema).
        """
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def origin(self) -> Optional[bool]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.RulesetRuleActionParametersUriPath']:
        """
        URI path configuration when performing a URL rewrite (refer to the nested schema).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> Optional['outputs.RulesetRuleActionParametersUriQuery']:
        """
        Query string configuration when performing a URL rewrite (refer to the nested schema).
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class RulesetRuleActionParametersUriPath(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.
        :param str value: Static string value of the updated URI path or query string component. Conflicts with `expression`.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Static string value of the updated URI path or query string component. Conflicts with `expression`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersUriQuery(dict):
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.
        :param str value: Static string value of the updated URI path or query string component. Conflicts with `expression`.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Static string value of the updated URI path or query string component. Conflicts with `expression`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleExposedCredentialCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordExpression":
            suggest = "password_expression"
        elif key == "usernameExpression":
            suggest = "username_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleExposedCredentialCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleExposedCredentialCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleExposedCredentialCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_expression: Optional[str] = None,
                 username_expression: Optional[str] = None):
        """
        :param str password_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        :param str username_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        if password_expression is not None:
            pulumi.set(__self__, "password_expression", password_expression)
        if username_expression is not None:
            pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> Optional[str]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "password_expression")

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> Optional[str]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "username_expression")


@pulumi.output_type
class RulesetRuleRatelimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mitigationExpression":
            suggest = "mitigation_expression"
        elif key == "mitigationTimeout":
            suggest = "mitigation_timeout"
        elif key == "requestsPerPeriod":
            suggest = "requests_per_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleRatelimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleRatelimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleRatelimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 characteristics: Optional[Sequence[str]] = None,
                 mitigation_expression: Optional[str] = None,
                 mitigation_timeout: Optional[int] = None,
                 period: Optional[int] = None,
                 requests_per_period: Optional[int] = None):
        """
        :param Sequence[str] characteristics: List of parameters that define how Cloudflare tracks the request rate for this rule.
        :param str mitigation_expression: Scope of the mitigation action. Allows you to specify an action scope different from the rule scope. Refer to the [rate limiting parameters documentation](https://developers.cloudflare.com/firewall/cf-rulesets/custom-rules/rate-limiting/parameters) for full details.
        :param int mitigation_timeout: Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        :param int period: The period of time to consider (in seconds) when evaluating the request rate.
        :param int requests_per_period: The number of requests over the period of time that will trigger the Rate Limiting rule.
        """
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if mitigation_expression is not None:
            pulumi.set(__self__, "mitigation_expression", mitigation_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)

    @property
    @pulumi.getter
    def characteristics(self) -> Optional[Sequence[str]]:
        """
        List of parameters that define how Cloudflare tracks the request rate for this rule.
        """
        return pulumi.get(self, "characteristics")

    @property
    @pulumi.getter(name="mitigationExpression")
    def mitigation_expression(self) -> Optional[str]:
        """
        Scope of the mitigation action. Allows you to specify an action scope different from the rule scope. Refer to the [rate limiting parameters documentation](https://developers.cloudflare.com/firewall/cf-rulesets/custom-rules/rate-limiting/parameters) for full details.
        """
        return pulumi.get(self, "mitigation_expression")

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[int]:
        """
        Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        """
        return pulumi.get(self, "mitigation_timeout")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The period of time to consider (in seconds) when evaluating the request rate.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[int]:
        """
        The number of requests over the period of time that will trigger the Rate Limiting rule.
        """
        return pulumi.get(self, "requests_per_period")


@pulumi.output_type
class SpectrumApplicationDns(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Fully qualified domain name of the origin e.g. origin-ssh.example.com.
        :param str type: The type of DNS record associated with the application. Valid values: `CNAME`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Fully qualified domain name of the origin e.g. origin-ssh.example.com.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of DNS record associated with the application. Valid values: `CNAME`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SpectrumApplicationOriginDns(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Fully qualified domain name of the origin e.g. origin-ssh.example.com.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Fully qualified domain name of the origin e.g. origin-ssh.example.com.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SpectrumApplicationOriginPortRange(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        """
        :param int end: Upper bound of the origin port range, e.g. `2000`
        :param int start: Lower bound of the origin port range, e.g. `1000`
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        """
        Upper bound of the origin port range, e.g. `2000`
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        """
        Lower bound of the origin port range, e.g. `1000`
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class SplitTunnelTunnel(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 description: Optional[str] = None,
                 host: Optional[str] = None):
        """
        :param str address: The address in CIDR format to include in the tunnel configuration. Conflicts with `"host"`.
        :param str description: The description of the tunnel.
        :param str host: The domain name to include in the tunnel configuration. Conflicts with `"address"`.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address in CIDR format to include in the tunnel configuration. Conflicts with `"host"`.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The domain name to include in the tunnel configuration. Conflicts with `"address"`.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class TeamsAccountAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledDownloadPhase":
            suggest = "enabled_download_phase"
        elif key == "enabledUploadPhase":
            suggest = "enabled_upload_phase"
        elif key == "failClosed":
            suggest = "fail_closed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_download_phase: bool,
                 enabled_upload_phase: bool,
                 fail_closed: bool):
        """
        :param bool enabled_download_phase: Scan on file download.
        :param bool enabled_upload_phase: Scan on file upload.
        :param bool fail_closed: Block requests for files that cannot be scanned.
        """
        pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        pulumi.set(__self__, "fail_closed", fail_closed)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> bool:
        """
        Scan on file download.
        """
        return pulumi.get(self, "enabled_download_phase")

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> bool:
        """
        Scan on file upload.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> bool:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")


@pulumi.output_type
class TeamsAccountBlockPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountBlockPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountBlockPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountBlockPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 footer_text: Optional[str] = None,
                 header_text: Optional[str] = None,
                 logo_path: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str background_color: Hex code of block page background color.
        :param bool enabled: Indicator of enablement.
        :param str footer_text: Block page header text.
        :param str header_text: Block page footer text.
        :param str logo_path: URL of block page logo.
        :param str name: Name of block page configuration.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        Hex code of block page background color.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicator of enablement.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[str]:
        """
        Block page header text.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[str]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[str]:
        """
        URL of block page logo.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of block page configuration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TeamsAccountFips(dict):
    def __init__(__self__, *,
                 tls: Optional[bool] = None):
        """
        :param bool tls: Only allow FIPS-compliant TLS configuration.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[bool]:
        """
        Only allow FIPS-compliant TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class TeamsAccountLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redactPii":
            suggest = "redact_pii"
        elif key == "settingsByRuleType":
            suggest = "settings_by_rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redact_pii: bool,
                 settings_by_rule_type: 'outputs.TeamsAccountLoggingSettingsByRuleType'):
        """
        :param bool redact_pii: Redact personally identifiable information from activity logging (PII fields are: source IP,
               user email, user ID, device ID, URL, referrer, user agent).
        :param 'TeamsAccountLoggingSettingsByRuleTypeArgs' settings_by_rule_type: Represents whether all requests are logged or only the blocked requests are
               logged in DNS, HTTP and L4 filters.
        """
        pulumi.set(__self__, "redact_pii", redact_pii)
        pulumi.set(__self__, "settings_by_rule_type", settings_by_rule_type)

    @property
    @pulumi.getter(name="redactPii")
    def redact_pii(self) -> bool:
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP,
        user email, user ID, device ID, URL, referrer, user agent).
        """
        return pulumi.get(self, "redact_pii")

    @property
    @pulumi.getter(name="settingsByRuleType")
    def settings_by_rule_type(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleType':
        """
        Represents whether all requests are logged or only the blocked requests are
        logged in DNS, HTTP and L4 filters.
        """
        return pulumi.get(self, "settings_by_rule_type")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleType(dict):
    def __init__(__self__, *,
                 dns: 'outputs.TeamsAccountLoggingSettingsByRuleTypeDns',
                 http: 'outputs.TeamsAccountLoggingSettingsByRuleTypeHttp',
                 l4: 'outputs.TeamsAccountLoggingSettingsByRuleTypeL4'):
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "http", http)
        pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeDns':
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def http(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeHttp':
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def l4(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeL4':
        return pulumi.get(self, "l4")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: bool,
                 log_blocks: bool):
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> bool:
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: bool,
                 log_blocks: bool):
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> bool:
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeL4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeL4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeL4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeL4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: bool,
                 log_blocks: bool):
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> bool:
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountProxy(dict):
    def __init__(__self__, *,
                 tcp: bool,
                 udp: bool):
        """
        :param bool tcp: Whether gateway proxy is enabled on gateway devices for tcp traffic.
        :param bool udp: Whether gateway proxy is enabled on gateway devices for udp traffic.
        """
        pulumi.set(__self__, "tcp", tcp)
        pulumi.set(__self__, "udp", udp)

    @property
    @pulumi.getter
    def tcp(self) -> bool:
        """
        Whether gateway proxy is enabled on gateway devices for tcp traffic.
        """
        return pulumi.get(self, "tcp")

    @property
    @pulumi.getter
    def udp(self) -> bool:
        """
        Whether gateway proxy is enabled on gateway devices for udp traffic.
        """
        return pulumi.get(self, "udp")


@pulumi.output_type
class TeamsLocationNetwork(dict):
    def __init__(__self__, *,
                 network: str,
                 id: Optional[str] = None):
        """
        :param str id: ID of the teams location.
        """
        pulumi.set(__self__, "network", network)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def network(self) -> str:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the teams location.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class TeamsRuleRuleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addHeaders":
            suggest = "add_headers"
        elif key == "bisoAdminControls":
            suggest = "biso_admin_controls"
        elif key == "blockPageEnabled":
            suggest = "block_page_enabled"
        elif key == "blockPageReason":
            suggest = "block_page_reason"
        elif key == "checkSession":
            suggest = "check_session"
        elif key == "overrideHost":
            suggest = "override_host"
        elif key == "overrideIps":
            suggest = "override_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_headers: Optional[Mapping[str, str]] = None,
                 biso_admin_controls: Optional['outputs.TeamsRuleRuleSettingsBisoAdminControls'] = None,
                 block_page_enabled: Optional[bool] = None,
                 block_page_reason: Optional[str] = None,
                 check_session: Optional['outputs.TeamsRuleRuleSettingsCheckSession'] = None,
                 l4override: Optional['outputs.TeamsRuleRuleSettingsL4override'] = None,
                 override_host: Optional[str] = None,
                 override_ips: Optional[Sequence[str]] = None):
        """
        :param Mapping[str, str] add_headers: Add custom headers to allowed requests in the form of key-value pairs.
        :param 'TeamsRuleRuleSettingsBisoAdminControlsArgs' biso_admin_controls: Configure how browser isolation behaves (refer to the nested schema).
        :param bool block_page_enabled: Indicator of block page enablement.
        :param str block_page_reason: The displayed reason for a user being blocked.
        :param 'TeamsRuleRuleSettingsCheckSessionArgs' check_session: Configure how session check behaves (refer to the nested schema).
        :param 'TeamsRuleRuleSettingsL4overrideArgs' l4override: Settings to forward layer 4 traffic (refer to the nested schema).
        :param str override_host: The host to override matching DNS queries with.
        :param Sequence[str] override_ips: The IPs to override matching DNS queries with.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_page_reason is not None:
            pulumi.set(__self__, "block_page_reason", block_page_reason)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[Mapping[str, str]]:
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        return pulumi.get(self, "add_headers")

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional['outputs.TeamsRuleRuleSettingsBisoAdminControls']:
        """
        Configure how browser isolation behaves (refer to the nested schema).
        """
        return pulumi.get(self, "biso_admin_controls")

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[bool]:
        """
        Indicator of block page enablement.
        """
        return pulumi.get(self, "block_page_enabled")

    @property
    @pulumi.getter(name="blockPageReason")
    def block_page_reason(self) -> Optional[str]:
        """
        The displayed reason for a user being blocked.
        """
        return pulumi.get(self, "block_page_reason")

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional['outputs.TeamsRuleRuleSettingsCheckSession']:
        """
        Configure how session check behaves (refer to the nested schema).
        """
        return pulumi.get(self, "check_session")

    @property
    @pulumi.getter
    def l4override(self) -> Optional['outputs.TeamsRuleRuleSettingsL4override']:
        """
        Settings to forward layer 4 traffic (refer to the nested schema).
        """
        return pulumi.get(self, "l4override")

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[str]:
        """
        The host to override matching DNS queries with.
        """
        return pulumi.get(self, "override_host")

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[Sequence[str]]:
        """
        The IPs to override matching DNS queries with.
        """
        return pulumi.get(self, "override_ips")


@pulumi.output_type
class TeamsRuleRuleSettingsBisoAdminControls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableCopyPaste":
            suggest = "disable_copy_paste"
        elif key == "disableDownload":
            suggest = "disable_download"
        elif key == "disableKeyboard":
            suggest = "disable_keyboard"
        elif key == "disablePrinting":
            suggest = "disable_printing"
        elif key == "disableUpload":
            suggest = "disable_upload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsBisoAdminControls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsBisoAdminControls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsBisoAdminControls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_copy_paste: Optional[bool] = None,
                 disable_download: Optional[bool] = None,
                 disable_keyboard: Optional[bool] = None,
                 disable_printing: Optional[bool] = None,
                 disable_upload: Optional[bool] = None):
        """
        :param bool disable_copy_paste: Disable copy-paste.
        :param bool disable_download: Disable download.
        :param bool disable_keyboard: Disable keyboard usage.
        :param bool disable_printing: Disable printing.
        :param bool disable_upload: Disable upload.
        """
        if disable_copy_paste is not None:
            pulumi.set(__self__, "disable_copy_paste", disable_copy_paste)
        if disable_download is not None:
            pulumi.set(__self__, "disable_download", disable_download)
        if disable_keyboard is not None:
            pulumi.set(__self__, "disable_keyboard", disable_keyboard)
        if disable_printing is not None:
            pulumi.set(__self__, "disable_printing", disable_printing)
        if disable_upload is not None:
            pulumi.set(__self__, "disable_upload", disable_upload)

    @property
    @pulumi.getter(name="disableCopyPaste")
    def disable_copy_paste(self) -> Optional[bool]:
        """
        Disable copy-paste.
        """
        return pulumi.get(self, "disable_copy_paste")

    @property
    @pulumi.getter(name="disableDownload")
    def disable_download(self) -> Optional[bool]:
        """
        Disable download.
        """
        return pulumi.get(self, "disable_download")

    @property
    @pulumi.getter(name="disableKeyboard")
    def disable_keyboard(self) -> Optional[bool]:
        """
        Disable keyboard usage.
        """
        return pulumi.get(self, "disable_keyboard")

    @property
    @pulumi.getter(name="disablePrinting")
    def disable_printing(self) -> Optional[bool]:
        """
        Disable printing.
        """
        return pulumi.get(self, "disable_printing")

    @property
    @pulumi.getter(name="disableUpload")
    def disable_upload(self) -> Optional[bool]:
        """
        Disable upload.
        """
        return pulumi.get(self, "disable_upload")


@pulumi.output_type
class TeamsRuleRuleSettingsCheckSession(dict):
    def __init__(__self__, *,
                 duration: str,
                 enforce: bool):
        """
        :param str duration: Configure how fresh the session needs to be to be considered valid.
        :param bool enforce: Enable session enforcement for this rule.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enforce(self) -> bool:
        """
        Enable session enforcement for this rule.
        """
        return pulumi.get(self, "enforce")


@pulumi.output_type
class TeamsRuleRuleSettingsL4override(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int):
        """
        :param str ip: Override IP to forward traffic to.
        :param int port: Override Port to forward traffic to.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        Override IP to forward traffic to.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Override Port to forward traffic to.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkerScriptKvNamespaceBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkerScriptKvNamespaceBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkerScriptKvNamespaceBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkerScriptKvNamespaceBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 namespace_id: str):
        """
        :param str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class WorkerScriptPlainTextBinding(dict):
    def __init__(__self__, *,
                 name: str,
                 text: str):
        """
        :param str name: The global variable for the binding in your Worker code.
        :param str text: The secret text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The secret text you want to store.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkerScriptSecretTextBinding(dict):
    def __init__(__self__, *,
                 name: str,
                 text: str):
        """
        :param str name: The global variable for the binding in your Worker code.
        :param str text: The secret text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The secret text you want to store.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkerScriptWebassemblyBinding(dict):
    def __init__(__self__, *,
                 module: str,
                 name: str):
        """
        :param str module: The base64 encoded wasm module you want to store.
        :param str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "module", module)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def module(self) -> str:
        """
        The base64 encoded wasm module you want to store.
        """
        return pulumi.get(self, "module")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZoneLockdownConfiguration(dict):
    def __init__(__self__, *,
                 target: str,
                 value: str):
        """
        :param str target: The request property to target. Allowed values: "ip", "ip_range"
        :param str value: The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `198.51.100.4` or `2001:db8::/32` and IP ranges in CIDR format i.e. `198.51.0.0/16`.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The request property to target. Allowed values: "ip", "ip_range"
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `198.51.100.4` or `2001:db8::/32` and IP ranges in CIDR format i.e. `198.51.0.0/16`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ZoneSettingsOverrideInitialSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOnline":
            suggest = "always_online"
        elif key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "binaryAst":
            suggest = "binary_ast"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "challengeTtl":
            suggest = "challenge_ttl"
        elif key == "cnameFlattening":
            suggest = "cname_flattening"
        elif key == "developmentMode":
            suggest = "development_mode"
        elif key == "earlyHints":
            suggest = "early_hints"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "filterLogsToCloudflare":
            suggest = "filter_logs_to_cloudflare"
        elif key == "h2Prioritization":
            suggest = "h2_prioritization"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "imageResizing":
            suggest = "image_resizing"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "logToCloudflare":
            suggest = "log_to_cloudflare"
        elif key == "maxUpload":
            suggest = "max_upload"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "mobileRedirect":
            suggest = "mobile_redirect"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "opportunisticOnion":
            suggest = "opportunistic_onion"
        elif key == "orangeToOrange":
            suggest = "orange_to_orange"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "prefetchPreload":
            suggest = "prefetch_preload"
        elif key == "privacyPass":
            suggest = "privacy_pass"
        elif key == "proxyReadTimeout":
            suggest = "proxy_read_timeout"
        elif key == "pseudoIpv4":
            suggest = "pseudo_ipv4"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityHeader":
            suggest = "security_header"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "tls12Only":
            suggest = "tls12_only"
        elif key == "tlsClientAuth":
            suggest = "tls_client_auth"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"
        elif key == "universalSsl":
            suggest = "universal_ssl"
        elif key == "visitorIp":
            suggest = "visitor_ip"
        elif key == "zeroRtt":
            suggest = "zero_rtt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_online: Optional[str] = None,
                 always_use_https: Optional[str] = None,
                 automatic_https_rewrites: Optional[str] = None,
                 binary_ast: Optional[str] = None,
                 brotli: Optional[str] = None,
                 browser_cache_ttl: Optional[int] = None,
                 browser_check: Optional[str] = None,
                 cache_level: Optional[str] = None,
                 challenge_ttl: Optional[int] = None,
                 ciphers: Optional[Sequence[str]] = None,
                 cname_flattening: Optional[str] = None,
                 development_mode: Optional[str] = None,
                 early_hints: Optional[str] = None,
                 email_obfuscation: Optional[str] = None,
                 filter_logs_to_cloudflare: Optional[str] = None,
                 h2_prioritization: Optional[str] = None,
                 hotlink_protection: Optional[str] = None,
                 http2: Optional[str] = None,
                 http3: Optional[str] = None,
                 image_resizing: Optional[str] = None,
                 ip_geolocation: Optional[str] = None,
                 ipv6: Optional[str] = None,
                 log_to_cloudflare: Optional[str] = None,
                 max_upload: Optional[int] = None,
                 min_tls_version: Optional[str] = None,
                 minify: Optional['outputs.ZoneSettingsOverrideInitialSettingMinify'] = None,
                 mirage: Optional[str] = None,
                 mobile_redirect: Optional['outputs.ZoneSettingsOverrideInitialSettingMobileRedirect'] = None,
                 opportunistic_encryption: Optional[str] = None,
                 opportunistic_onion: Optional[str] = None,
                 orange_to_orange: Optional[str] = None,
                 origin_error_page_pass_thru: Optional[str] = None,
                 polish: Optional[str] = None,
                 prefetch_preload: Optional[str] = None,
                 privacy_pass: Optional[str] = None,
                 proxy_read_timeout: Optional[str] = None,
                 pseudo_ipv4: Optional[str] = None,
                 response_buffering: Optional[str] = None,
                 rocket_loader: Optional[str] = None,
                 security_header: Optional['outputs.ZoneSettingsOverrideInitialSettingSecurityHeader'] = None,
                 security_level: Optional[str] = None,
                 server_side_exclude: Optional[str] = None,
                 sort_query_string_for_cache: Optional[str] = None,
                 ssl: Optional[str] = None,
                 tls12_only: Optional[str] = None,
                 tls13: Optional[str] = None,
                 tls_client_auth: Optional[str] = None,
                 true_client_ip_header: Optional[str] = None,
                 universal_ssl: Optional[str] = None,
                 visitor_ip: Optional[str] = None,
                 waf: Optional[str] = None,
                 webp: Optional[str] = None,
                 websockets: Optional[str] = None,
                 zero_rtt: Optional[str] = None):
        """
        :param str cache_level: Allowed values: "aggressive" (default) - delivers a different resource each time the query string changes, "basic" - delivers resources from cache when there is no query string, "simplified" - delivers the same resource to everyone independent of the query string.
        :param Sequence[str] ciphers: An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        :param str cname_flattening: Allowed values: "flatten_at_root" (default), "flatten_all", "flatten_none".
        :param str h2_prioritization: Allowed values: "on", "off" (default), "custom".
        :param str image_resizing: Allowed values: "on", "off" (default), "open".
        :param str min_tls_version: Allowed values: "1.0" (default), "1.1", "1.2", "1.3".
        :param str polish: Allowed values: "off" (default), "lossless", "lossy".
        :param str pseudo_ipv4: Allowed values: "off" (default), "add_header", "overwrite_header".
        :param str security_level: Allowed values: "off" (Enterprise only), "essentially_off", "low", "medium" (default), "high", "under_attack".
        :param str ssl: Allowed values: "off" (default), "flexible", "full", "strict", "origin_pull".
        :param str tls13: Allowed values: "off" (default), "on", "zrt".
        :param str webp: . Note that the value specified will be ignored unless `polish` is turned on (i.e. is "lossless" or "lossy")
        """
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            pulumi.set(__self__, "binary_ast", binary_ast)
        if brotli is not None:
            pulumi.set(__self__, "brotli", brotli)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if challenge_ttl is not None:
            pulumi.set(__self__, "challenge_ttl", challenge_ttl)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if cname_flattening is not None:
            pulumi.set(__self__, "cname_flattening", cname_flattening)
        if development_mode is not None:
            pulumi.set(__self__, "development_mode", development_mode)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            pulumi.set(__self__, "filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if h2_prioritization is not None:
            pulumi.set(__self__, "h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if http3 is not None:
            pulumi.set(__self__, "http3", http3)
        if image_resizing is not None:
            pulumi.set(__self__, "image_resizing", image_resizing)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if log_to_cloudflare is not None:
            pulumi.set(__self__, "log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            pulumi.set(__self__, "max_upload", max_upload)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minify is not None:
            pulumi.set(__self__, "minify", minify)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if mobile_redirect is not None:
            pulumi.set(__self__, "mobile_redirect", mobile_redirect)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            pulumi.set(__self__, "opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            pulumi.set(__self__, "orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if prefetch_preload is not None:
            pulumi.set(__self__, "prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            pulumi.set(__self__, "privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            pulumi.set(__self__, "proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            pulumi.set(__self__, "pseudo_ipv4", pseudo_ipv4)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_header is not None:
            pulumi.set(__self__, "security_header", security_header)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if tls12_only is not None:
            pulumi.set(__self__, "tls12_only", tls12_only)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)
        if tls_client_auth is not None:
            pulumi.set(__self__, "tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            pulumi.set(__self__, "universal_ssl", universal_ssl)
        if visitor_ip is not None:
            pulumi.set(__self__, "visitor_ip", visitor_ip)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)
        if zero_rtt is not None:
            pulumi.set(__self__, "zero_rtt", zero_rtt)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[str]:
        return pulumi.get(self, "always_online")

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[str]:
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[str]:
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[str]:
        return pulumi.get(self, "binary_ast")

    @property
    @pulumi.getter
    def brotli(self) -> Optional[str]:
        return pulumi.get(self, "brotli")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[int]:
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[str]:
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[str]:
        """
        Allowed values: "aggressive" (default) - delivers a different resource each time the query string changes, "basic" - delivers resources from cache when there is no query string, "simplified" - delivers the same resource to everyone independent of the query string.
        """
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[int]:
        return pulumi.get(self, "challenge_ttl")

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[str]]:
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[str]:
        """
        Allowed values: "flatten_at_root" (default), "flatten_all", "flatten_none".
        """
        return pulumi.get(self, "cname_flattening")

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[str]:
        return pulumi.get(self, "development_mode")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[str]:
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[str]:
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[str]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[str]:
        """
        Allowed values: "on", "off" (default), "custom".
        """
        return pulumi.get(self, "h2_prioritization")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[str]:
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def http2(self) -> Optional[str]:
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def http3(self) -> Optional[str]:
        return pulumi.get(self, "http3")

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[str]:
        """
        Allowed values: "on", "off" (default), "open".
        """
        return pulumi.get(self, "image_resizing")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[str]:
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[str]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[str]:
        return pulumi.get(self, "log_to_cloudflare")

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[int]:
        return pulumi.get(self, "max_upload")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        Allowed values: "1.0" (default), "1.1", "1.2", "1.3".
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def minify(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingMinify']:
        return pulumi.get(self, "minify")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[str]:
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="mobileRedirect")
    def mobile_redirect(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingMobileRedirect']:
        return pulumi.get(self, "mobile_redirect")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[str]:
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[str]:
        return pulumi.get(self, "opportunistic_onion")

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[str]:
        return pulumi.get(self, "orange_to_orange")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[str]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        """
        Allowed values: "off" (default), "lossless", "lossy".
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[str]:
        return pulumi.get(self, "prefetch_preload")

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[str]:
        return pulumi.get(self, "privacy_pass")

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[str]:
        return pulumi.get(self, "proxy_read_timeout")

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[str]:
        """
        Allowed values: "off" (default), "add_header", "overwrite_header".
        """
        return pulumi.get(self, "pseudo_ipv4")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[str]:
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[str]:
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingSecurityHeader']:
        return pulumi.get(self, "security_header")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        Allowed values: "off" (Enterprise only), "essentially_off", "low", "medium" (default), "high", "under_attack".
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[str]:
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[str]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Allowed values: "off" (default), "flexible", "full", "strict", "origin_pull".
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="tls12Only")
    def tls12_only(self) -> Optional[str]:
        return pulumi.get(self, "tls12_only")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[str]:
        """
        Allowed values: "off" (default), "on", "zrt".
        """
        return pulumi.get(self, "tls13")

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[str]:
        return pulumi.get(self, "tls_client_auth")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[str]:
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[str]:
        return pulumi.get(self, "universal_ssl")

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[str]:
        return pulumi.get(self, "visitor_ip")

    @property
    @pulumi.getter
    def waf(self) -> Optional[str]:
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter
    def webp(self) -> Optional[str]:
        """
        . Note that the value specified will be ignored unless `polish` is turned on (i.e. is "lossless" or "lossy")
        """
        return pulumi.get(self, "webp")

    @property
    @pulumi.getter
    def websockets(self) -> Optional[str]:
        return pulumi.get(self, "websockets")

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[str]:
        return pulumi.get(self, "zero_rtt")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingMinify(dict):
    def __init__(__self__, *,
                 css: str,
                 html: str,
                 js: str):
        """
        :param str css: "on"/"off"
        :param str html: "on"/"off"
        :param str js: "on"/"off"
        """
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> str:
        """
        "on"/"off"
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> str:
        """
        "on"/"off"
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> str:
        """
        "on"/"off"
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingMobileRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mobileSubdomain":
            suggest = "mobile_subdomain"
        elif key == "stripUri":
            suggest = "strip_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSettingMobileRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSettingMobileRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSettingMobileRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mobile_subdomain: str,
                 status: str,
                 strip_uri: bool):
        """
        :param str mobile_subdomain: String value
        :param str status: "on"/"off"
        :param bool strip_uri: true/false
        """
        pulumi.set(__self__, "mobile_subdomain", mobile_subdomain)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> str:
        """
        String value
        """
        return pulumi.get(self, "mobile_subdomain")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        "on"/"off"
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> bool:
        """
        true/false
        """
        return pulumi.get(self, "strip_uri")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingSecurityHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSettingSecurityHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSettingSecurityHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSettingSecurityHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 include_subdomains: Optional[bool] = None,
                 max_age: Optional[int] = None,
                 nosniff: Optional[bool] = None,
                 preload: Optional[bool] = None):
        """
        :param bool enabled: true/false
        :param bool include_subdomains: true/false
        :param int max_age: Integer
        :param bool nosniff: true/false
        :param bool preload: true/false
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if nosniff is not None:
            pulumi.set(__self__, "nosniff", nosniff)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        true/false
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[bool]:
        """
        true/false
        """
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Integer
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[bool]:
        """
        true/false
        """
        return pulumi.get(self, "nosniff")

    @property
    @pulumi.getter
    def preload(self) -> Optional[bool]:
        """
        true/false
        """
        return pulumi.get(self, "preload")


@pulumi.output_type
class ZoneSettingsOverrideSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOnline":
            suggest = "always_online"
        elif key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "binaryAst":
            suggest = "binary_ast"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "challengeTtl":
            suggest = "challenge_ttl"
        elif key == "cnameFlattening":
            suggest = "cname_flattening"
        elif key == "developmentMode":
            suggest = "development_mode"
        elif key == "earlyHints":
            suggest = "early_hints"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "filterLogsToCloudflare":
            suggest = "filter_logs_to_cloudflare"
        elif key == "h2Prioritization":
            suggest = "h2_prioritization"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "imageResizing":
            suggest = "image_resizing"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "logToCloudflare":
            suggest = "log_to_cloudflare"
        elif key == "maxUpload":
            suggest = "max_upload"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "mobileRedirect":
            suggest = "mobile_redirect"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "opportunisticOnion":
            suggest = "opportunistic_onion"
        elif key == "orangeToOrange":
            suggest = "orange_to_orange"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "prefetchPreload":
            suggest = "prefetch_preload"
        elif key == "privacyPass":
            suggest = "privacy_pass"
        elif key == "proxyReadTimeout":
            suggest = "proxy_read_timeout"
        elif key == "pseudoIpv4":
            suggest = "pseudo_ipv4"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityHeader":
            suggest = "security_header"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "tls12Only":
            suggest = "tls12_only"
        elif key == "tlsClientAuth":
            suggest = "tls_client_auth"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"
        elif key == "universalSsl":
            suggest = "universal_ssl"
        elif key == "visitorIp":
            suggest = "visitor_ip"
        elif key == "zeroRtt":
            suggest = "zero_rtt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_online: Optional[str] = None,
                 always_use_https: Optional[str] = None,
                 automatic_https_rewrites: Optional[str] = None,
                 binary_ast: Optional[str] = None,
                 brotli: Optional[str] = None,
                 browser_cache_ttl: Optional[int] = None,
                 browser_check: Optional[str] = None,
                 cache_level: Optional[str] = None,
                 challenge_ttl: Optional[int] = None,
                 ciphers: Optional[Sequence[str]] = None,
                 cname_flattening: Optional[str] = None,
                 development_mode: Optional[str] = None,
                 early_hints: Optional[str] = None,
                 email_obfuscation: Optional[str] = None,
                 filter_logs_to_cloudflare: Optional[str] = None,
                 h2_prioritization: Optional[str] = None,
                 hotlink_protection: Optional[str] = None,
                 http2: Optional[str] = None,
                 http3: Optional[str] = None,
                 image_resizing: Optional[str] = None,
                 ip_geolocation: Optional[str] = None,
                 ipv6: Optional[str] = None,
                 log_to_cloudflare: Optional[str] = None,
                 max_upload: Optional[int] = None,
                 min_tls_version: Optional[str] = None,
                 minify: Optional['outputs.ZoneSettingsOverrideSettingsMinify'] = None,
                 mirage: Optional[str] = None,
                 mobile_redirect: Optional['outputs.ZoneSettingsOverrideSettingsMobileRedirect'] = None,
                 opportunistic_encryption: Optional[str] = None,
                 opportunistic_onion: Optional[str] = None,
                 orange_to_orange: Optional[str] = None,
                 origin_error_page_pass_thru: Optional[str] = None,
                 polish: Optional[str] = None,
                 prefetch_preload: Optional[str] = None,
                 privacy_pass: Optional[str] = None,
                 proxy_read_timeout: Optional[str] = None,
                 pseudo_ipv4: Optional[str] = None,
                 response_buffering: Optional[str] = None,
                 rocket_loader: Optional[str] = None,
                 security_header: Optional['outputs.ZoneSettingsOverrideSettingsSecurityHeader'] = None,
                 security_level: Optional[str] = None,
                 server_side_exclude: Optional[str] = None,
                 sort_query_string_for_cache: Optional[str] = None,
                 ssl: Optional[str] = None,
                 tls12_only: Optional[str] = None,
                 tls13: Optional[str] = None,
                 tls_client_auth: Optional[str] = None,
                 true_client_ip_header: Optional[str] = None,
                 universal_ssl: Optional[str] = None,
                 visitor_ip: Optional[str] = None,
                 waf: Optional[str] = None,
                 webp: Optional[str] = None,
                 websockets: Optional[str] = None,
                 zero_rtt: Optional[str] = None):
        """
        :param str cache_level: Allowed values: "aggressive" (default) - delivers a different resource each time the query string changes, "basic" - delivers resources from cache when there is no query string, "simplified" - delivers the same resource to everyone independent of the query string.
        :param Sequence[str] ciphers: An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        :param str cname_flattening: Allowed values: "flatten_at_root" (default), "flatten_all", "flatten_none".
        :param str h2_prioritization: Allowed values: "on", "off" (default), "custom".
        :param str image_resizing: Allowed values: "on", "off" (default), "open".
        :param str min_tls_version: Allowed values: "1.0" (default), "1.1", "1.2", "1.3".
        :param str polish: Allowed values: "off" (default), "lossless", "lossy".
        :param str pseudo_ipv4: Allowed values: "off" (default), "add_header", "overwrite_header".
        :param str security_level: Allowed values: "off" (Enterprise only), "essentially_off", "low", "medium" (default), "high", "under_attack".
        :param str ssl: Allowed values: "off" (default), "flexible", "full", "strict", "origin_pull".
        :param str tls13: Allowed values: "off" (default), "on", "zrt".
        :param str webp: . Note that the value specified will be ignored unless `polish` is turned on (i.e. is "lossless" or "lossy")
        """
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            pulumi.set(__self__, "binary_ast", binary_ast)
        if brotli is not None:
            pulumi.set(__self__, "brotli", brotli)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if challenge_ttl is not None:
            pulumi.set(__self__, "challenge_ttl", challenge_ttl)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if cname_flattening is not None:
            pulumi.set(__self__, "cname_flattening", cname_flattening)
        if development_mode is not None:
            pulumi.set(__self__, "development_mode", development_mode)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            pulumi.set(__self__, "filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if h2_prioritization is not None:
            pulumi.set(__self__, "h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if http3 is not None:
            pulumi.set(__self__, "http3", http3)
        if image_resizing is not None:
            pulumi.set(__self__, "image_resizing", image_resizing)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if log_to_cloudflare is not None:
            pulumi.set(__self__, "log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            pulumi.set(__self__, "max_upload", max_upload)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minify is not None:
            pulumi.set(__self__, "minify", minify)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if mobile_redirect is not None:
            pulumi.set(__self__, "mobile_redirect", mobile_redirect)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            pulumi.set(__self__, "opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            pulumi.set(__self__, "orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if prefetch_preload is not None:
            pulumi.set(__self__, "prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            pulumi.set(__self__, "privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            pulumi.set(__self__, "proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            pulumi.set(__self__, "pseudo_ipv4", pseudo_ipv4)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_header is not None:
            pulumi.set(__self__, "security_header", security_header)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if tls12_only is not None:
            pulumi.set(__self__, "tls12_only", tls12_only)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)
        if tls_client_auth is not None:
            pulumi.set(__self__, "tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            pulumi.set(__self__, "universal_ssl", universal_ssl)
        if visitor_ip is not None:
            pulumi.set(__self__, "visitor_ip", visitor_ip)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)
        if zero_rtt is not None:
            pulumi.set(__self__, "zero_rtt", zero_rtt)

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[str]:
        return pulumi.get(self, "always_online")

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[str]:
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[str]:
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[str]:
        return pulumi.get(self, "binary_ast")

    @property
    @pulumi.getter
    def brotli(self) -> Optional[str]:
        return pulumi.get(self, "brotli")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[int]:
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[str]:
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[str]:
        """
        Allowed values: "aggressive" (default) - delivers a different resource each time the query string changes, "basic" - delivers resources from cache when there is no query string, "simplified" - delivers the same resource to everyone independent of the query string.
        """
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[int]:
        return pulumi.get(self, "challenge_ttl")

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[str]]:
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[str]:
        """
        Allowed values: "flatten_at_root" (default), "flatten_all", "flatten_none".
        """
        return pulumi.get(self, "cname_flattening")

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[str]:
        return pulumi.get(self, "development_mode")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[str]:
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[str]:
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[str]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[str]:
        """
        Allowed values: "on", "off" (default), "custom".
        """
        return pulumi.get(self, "h2_prioritization")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[str]:
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def http2(self) -> Optional[str]:
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def http3(self) -> Optional[str]:
        return pulumi.get(self, "http3")

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[str]:
        """
        Allowed values: "on", "off" (default), "open".
        """
        return pulumi.get(self, "image_resizing")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[str]:
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[str]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[str]:
        return pulumi.get(self, "log_to_cloudflare")

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[int]:
        return pulumi.get(self, "max_upload")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        Allowed values: "1.0" (default), "1.1", "1.2", "1.3".
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def minify(self) -> Optional['outputs.ZoneSettingsOverrideSettingsMinify']:
        return pulumi.get(self, "minify")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[str]:
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="mobileRedirect")
    def mobile_redirect(self) -> Optional['outputs.ZoneSettingsOverrideSettingsMobileRedirect']:
        return pulumi.get(self, "mobile_redirect")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[str]:
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[str]:
        return pulumi.get(self, "opportunistic_onion")

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[str]:
        return pulumi.get(self, "orange_to_orange")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[str]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter
    def polish(self) -> Optional[str]:
        """
        Allowed values: "off" (default), "lossless", "lossy".
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[str]:
        return pulumi.get(self, "prefetch_preload")

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[str]:
        return pulumi.get(self, "privacy_pass")

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[str]:
        return pulumi.get(self, "proxy_read_timeout")

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[str]:
        """
        Allowed values: "off" (default), "add_header", "overwrite_header".
        """
        return pulumi.get(self, "pseudo_ipv4")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[str]:
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[str]:
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional['outputs.ZoneSettingsOverrideSettingsSecurityHeader']:
        return pulumi.get(self, "security_header")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        Allowed values: "off" (Enterprise only), "essentially_off", "low", "medium" (default), "high", "under_attack".
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[str]:
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[str]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Allowed values: "off" (default), "flexible", "full", "strict", "origin_pull".
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="tls12Only")
    def tls12_only(self) -> Optional[str]:
        return pulumi.get(self, "tls12_only")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[str]:
        """
        Allowed values: "off" (default), "on", "zrt".
        """
        return pulumi.get(self, "tls13")

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[str]:
        return pulumi.get(self, "tls_client_auth")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[str]:
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[str]:
        return pulumi.get(self, "universal_ssl")

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[str]:
        return pulumi.get(self, "visitor_ip")

    @property
    @pulumi.getter
    def waf(self) -> Optional[str]:
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter
    def webp(self) -> Optional[str]:
        """
        . Note that the value specified will be ignored unless `polish` is turned on (i.e. is "lossless" or "lossy")
        """
        return pulumi.get(self, "webp")

    @property
    @pulumi.getter
    def websockets(self) -> Optional[str]:
        return pulumi.get(self, "websockets")

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[str]:
        return pulumi.get(self, "zero_rtt")


@pulumi.output_type
class ZoneSettingsOverrideSettingsMinify(dict):
    def __init__(__self__, *,
                 css: str,
                 html: str,
                 js: str):
        """
        :param str css: "on"/"off"
        :param str html: "on"/"off"
        :param str js: "on"/"off"
        """
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> str:
        """
        "on"/"off"
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> str:
        """
        "on"/"off"
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> str:
        """
        "on"/"off"
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class ZoneSettingsOverrideSettingsMobileRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mobileSubdomain":
            suggest = "mobile_subdomain"
        elif key == "stripUri":
            suggest = "strip_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettingsMobileRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettingsMobileRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettingsMobileRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mobile_subdomain: str,
                 status: str,
                 strip_uri: bool):
        """
        :param str mobile_subdomain: String value
        :param str status: "on"/"off"
        :param bool strip_uri: true/false
        """
        pulumi.set(__self__, "mobile_subdomain", mobile_subdomain)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> str:
        """
        String value
        """
        return pulumi.get(self, "mobile_subdomain")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        "on"/"off"
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> bool:
        """
        true/false
        """
        return pulumi.get(self, "strip_uri")


@pulumi.output_type
class ZoneSettingsOverrideSettingsSecurityHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettingsSecurityHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettingsSecurityHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettingsSecurityHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 include_subdomains: Optional[bool] = None,
                 max_age: Optional[int] = None,
                 nosniff: Optional[bool] = None,
                 preload: Optional[bool] = None):
        """
        :param bool enabled: true/false
        :param bool include_subdomains: true/false
        :param int max_age: Integer
        :param bool nosniff: true/false
        :param bool preload: true/false
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if nosniff is not None:
            pulumi.set(__self__, "nosniff", nosniff)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        true/false
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[bool]:
        """
        true/false
        """
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Integer
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[bool]:
        """
        true/false
        """
        return pulumi.get(self, "nosniff")

    @property
    @pulumi.getter
    def preload(self) -> Optional[bool]:
        """
        true/false
        """
        return pulumi.get(self, "preload")


@pulumi.output_type
class GetAccountRolesRoleResult(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str description: Description of role's permissions
        :param str id: Role identifier tag
        :param str name: Role Name
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of role's permissions
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Role identifier tag
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Role Name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDevicesDeviceResult(dict):
    def __init__(__self__, *,
                 created: Optional[str] = None,
                 device_type: Optional[str] = None,
                 id: Optional[str] = None,
                 ip: Optional[str] = None,
                 key: Optional[str] = None,
                 last_seen: Optional[str] = None,
                 model: Optional[str] = None,
                 name: Optional[str] = None,
                 os_version: Optional[str] = None,
                 updated: Optional[str] = None,
                 user_email: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str created: When the device was created.
        :param str device_type: The type of the device.
        :param str id: Device ID.
        :param str ip: IPv4 or IPv6 address.
        :param str key: The device's public key.
        :param str last_seen: When the device was last seen.
        :param str model: The device model name.
        :param str name: The device name.
        :param str os_version: The operating system version.
        :param str updated: When the device was updated.
        :param str user_email: User's email.
        :param str user_id: User's ID.
        :param str user_name: User's Name.
        :param str version: The WARP client version.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_version is not None:
            pulumi.set(__self__, "os_version", os_version)
        if updated is not None:
            pulumi.set(__self__, "updated", updated)
        if user_email is not None:
            pulumi.set(__self__, "user_email", user_email)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def created(self) -> Optional[str]:
        """
        When the device was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[str]:
        """
        The type of the device.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Device ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The device's public key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[str]:
        """
        When the device was last seen.
        """
        return pulumi.get(self, "last_seen")

    @property
    @pulumi.getter
    def model(self) -> Optional[str]:
        """
        The device model name.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The device name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> Optional[str]:
        """
        The operating system version.
        """
        return pulumi.get(self, "os_version")

    @property
    @pulumi.getter
    def updated(self) -> Optional[str]:
        """
        When the device was updated.
        """
        return pulumi.get(self, "updated")

    @property
    @pulumi.getter(name="userEmail")
    def user_email(self) -> Optional[str]:
        """
        User's email.
        """
        return pulumi.get(self, "user_email")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        User's ID.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User's Name.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The WARP client version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetWafGroupsFilterResult(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str mode: Mode of the WAF Rule Groups to lookup. Valid values: on and off.
        :param str name: A regular expression matching the name of the WAF Rule Groups to lookup.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode of the WAF Rule Groups to lookup. Valid values: on and off.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A regular expression matching the name of the WAF Rule Groups to lookup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetWafGroupsGroupResult(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 mode: Optional[str] = None,
                 modified_rules_count: Optional[int] = None,
                 name: Optional[str] = None,
                 package_id: Optional[str] = None,
                 rules_count: Optional[int] = None):
        """
        :param str description: The WAF Rule Group description
        :param str id: The WAF Rule Group ID
        :param str mode: Mode of the WAF Rule Groups to lookup. Valid values: on and off.
        :param int modified_rules_count: The number of modified rules in the WAF Rule Group
        :param str name: A regular expression matching the name of the WAF Rule Groups to lookup.
        :param str package_id: The ID of the WAF Rule Package in which to search for the WAF Rule Groups.
        :param int rules_count: The number of rules in the WAF Rule Group
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if modified_rules_count is not None:
            pulumi.set(__self__, "modified_rules_count", modified_rules_count)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if package_id is not None:
            pulumi.set(__self__, "package_id", package_id)
        if rules_count is not None:
            pulumi.set(__self__, "rules_count", rules_count)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The WAF Rule Group description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The WAF Rule Group ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode of the WAF Rule Groups to lookup. Valid values: on and off.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="modifiedRulesCount")
    def modified_rules_count(self) -> Optional[int]:
        """
        The number of modified rules in the WAF Rule Group
        """
        return pulumi.get(self, "modified_rules_count")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A regular expression matching the name of the WAF Rule Groups to lookup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="packageId")
    def package_id(self) -> Optional[str]:
        """
        The ID of the WAF Rule Package in which to search for the WAF Rule Groups.
        """
        return pulumi.get(self, "package_id")

    @property
    @pulumi.getter(name="rulesCount")
    def rules_count(self) -> Optional[int]:
        """
        The number of rules in the WAF Rule Group
        """
        return pulumi.get(self, "rules_count")


@pulumi.output_type
class GetWafPackagesFilterResult(dict):
    def __init__(__self__, *,
                 action_mode: Optional[str] = None,
                 detection_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 sensitivity: Optional[str] = None):
        """
        :param str action_mode: Action mode of the WAF Rule Packages to lookup. Valid values: simulate, block and challenge.
        :param str detection_mode: Detection mode of the WAF Rule Packages to lookup.
        :param str name: A regular expression matching the name of the WAF Rule Packages to lookup.
        :param str sensitivity: Sensitivity of the WAF Rule Packages to lookup. Valid values: high, medium, low and off.
        """
        if action_mode is not None:
            pulumi.set(__self__, "action_mode", action_mode)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sensitivity is not None:
            pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="actionMode")
    def action_mode(self) -> Optional[str]:
        """
        Action mode of the WAF Rule Packages to lookup. Valid values: simulate, block and challenge.
        """
        return pulumi.get(self, "action_mode")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode of the WAF Rule Packages to lookup.
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A regular expression matching the name of the WAF Rule Packages to lookup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def sensitivity(self) -> Optional[str]:
        """
        Sensitivity of the WAF Rule Packages to lookup. Valid values: high, medium, low and off.
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class GetWafPackagesPackageResult(dict):
    def __init__(__self__, *,
                 action_mode: Optional[str] = None,
                 description: Optional[str] = None,
                 detection_mode: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 sensitivity: Optional[str] = None):
        """
        :param str action_mode: Action mode of the WAF Rule Packages to lookup. Valid values: simulate, block and challenge.
        :param str description: The WAF Rule Package description
        :param str detection_mode: Detection mode of the WAF Rule Packages to lookup.
        :param str id: The WAF Rule Package ID
        :param str name: A regular expression matching the name of the WAF Rule Packages to lookup.
        :param str sensitivity: Sensitivity of the WAF Rule Packages to lookup. Valid values: high, medium, low and off.
        """
        if action_mode is not None:
            pulumi.set(__self__, "action_mode", action_mode)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sensitivity is not None:
            pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="actionMode")
    def action_mode(self) -> Optional[str]:
        """
        Action mode of the WAF Rule Packages to lookup. Valid values: simulate, block and challenge.
        """
        return pulumi.get(self, "action_mode")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The WAF Rule Package description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode of the WAF Rule Packages to lookup.
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The WAF Rule Package ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A regular expression matching the name of the WAF Rule Packages to lookup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def sensitivity(self) -> Optional[str]:
        """
        Sensitivity of the WAF Rule Packages to lookup. Valid values: high, medium, low and off.
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class GetWafRulesFilterResult(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 group_id: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str description: A regular expression matching the description of the WAF Rules to lookup.
        :param str group_id: The ID of the WAF Rule Group in which the WAF Rules to lookup have to be.
        :param str mode: Mode of the WAF Rules to lookup. Valid values: one of ["block", "challenge", "default", "disable", "simulate"] or ["on", "off"] depending on the WAF Rule type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A regular expression matching the description of the WAF Rules to lookup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The ID of the WAF Rule Group in which the WAF Rules to lookup have to be.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode of the WAF Rules to lookup. Valid values: one of ["block", "challenge", "default", "disable", "simulate"] or ["on", "off"] depending on the WAF Rule type.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetWafRulesRuleResult(dict):
    def __init__(__self__, *,
                 allowed_modes: Optional[Sequence[str]] = None,
                 default_mode: Optional[str] = None,
                 description: Optional[str] = None,
                 group_id: Optional[str] = None,
                 group_name: Optional[str] = None,
                 id: Optional[str] = None,
                 mode: Optional[str] = None,
                 package_id: Optional[str] = None,
                 priority: Optional[str] = None):
        """
        :param Sequence[str] allowed_modes: The list of allowed `mode` values for the WAF Rule
        :param str default_mode: The default `mode` value for the WAF Rule
        :param str description: A regular expression matching the description of the WAF Rules to lookup.
        :param str group_id: The ID of the WAF Rule Group in which the WAF Rules to lookup have to be.
        :param str group_name: The Name of the WAF Rule Group that contains the WAF Rule
        :param str id: The WAF Rule ID
        :param str mode: Mode of the WAF Rules to lookup. Valid values: one of ["block", "challenge", "default", "disable", "simulate"] or ["on", "off"] depending on the WAF Rule type.
        :param str package_id: The ID of the WAF Rule Package in which to search for the WAF Rules.
        :param str priority: The WAF Rule priority
        """
        if allowed_modes is not None:
            pulumi.set(__self__, "allowed_modes", allowed_modes)
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if package_id is not None:
            pulumi.set(__self__, "package_id", package_id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="allowedModes")
    def allowed_modes(self) -> Optional[Sequence[str]]:
        """
        The list of allowed `mode` values for the WAF Rule
        """
        return pulumi.get(self, "allowed_modes")

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        The default `mode` value for the WAF Rule
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A regular expression matching the description of the WAF Rules to lookup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The ID of the WAF Rule Group in which the WAF Rules to lookup have to be.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        The Name of the WAF Rule Group that contains the WAF Rule
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The WAF Rule ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode of the WAF Rules to lookup. Valid values: one of ["block", "challenge", "default", "disable", "simulate"] or ["on", "off"] depending on the WAF Rule type.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="packageId")
    def package_id(self) -> Optional[str]:
        """
        The ID of the WAF Rule Package in which to search for the WAF Rules.
        """
        return pulumi.get(self, "package_id")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        The WAF Rule priority
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetZonesFilterResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 lookup_type: Optional[str] = None,
                 match: Optional[str] = None,
                 name: Optional[str] = None,
                 paused: Optional[bool] = None,
                 status: Optional[str] = None):
        """
        :param str account_id: Only search for zones in this account.
        :param str lookup_type: The type of search to perform for the `name` value
               when querying the zone API. Valid values: `"exact"` and `"contains"`. Defaults
               to `"exact"`.
        :param str match: A RE2 compatible regular expression to filter the
               results. This is performed client side whereas the `name` and `lookup_type`
               are performed on the Cloudflare server side.
        :param str name: A string value to search for.
        :param bool paused: Paused status of the zone to lookup. Valid values are
               `true` or `false`.
        :param str status: Status of the zone to lookup. Valid values: `"active"`,
               `"pending"`, `"initializing"`, `"moved"`, `"deleted"`, `"deactivated"` and
               `"read only"`.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if lookup_type is not None:
            pulumi.set(__self__, "lookup_type", lookup_type)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        Only search for zones in this account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="lookupType")
    def lookup_type(self) -> Optional[str]:
        """
        The type of search to perform for the `name` value
        when querying the zone API. Valid values: `"exact"` and `"contains"`. Defaults
        to `"exact"`.
        """
        return pulumi.get(self, "lookup_type")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        A RE2 compatible regular expression to filter the
        results. This is performed client side whereas the `name` and `lookup_type`
        are performed on the Cloudflare server side.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A string value to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        Paused status of the zone to lookup. Valid values are
        `true` or `false`.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the zone to lookup. Valid values: `"active"`,
        `"pending"`, `"initializing"`, `"moved"`, `"deleted"`, `"deactivated"` and
        `"read only"`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The zone ID
        :param str name: A string value to search for.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The zone ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A string value to search for.
        """
        return pulumi.get(self, "name")


