# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AccessApplicationCorsHeader',
    'AccessApplicationDestination',
    'AccessApplicationFooterLink',
    'AccessApplicationLandingPageDesign',
    'AccessApplicationSaasApp',
    'AccessApplicationSaasAppCustomAttribute',
    'AccessApplicationSaasAppCustomAttributeSource',
    'AccessApplicationSaasAppCustomClaim',
    'AccessApplicationSaasAppCustomClaimSource',
    'AccessApplicationSaasAppHybridAndImplicitOptions',
    'AccessApplicationSaasAppRefreshTokenOption',
    'AccessApplicationScimConfig',
    'AccessApplicationScimConfigAuthentication',
    'AccessApplicationScimConfigMapping',
    'AccessApplicationScimConfigMappingOperations',
    'AccessApplicationTargetCriteria',
    'AccessApplicationTargetCriteriaTargetAttribute',
    'AccessGroupExclude',
    'AccessGroupExcludeAuthContext',
    'AccessGroupExcludeAzure',
    'AccessGroupExcludeExternalEvaluation',
    'AccessGroupExcludeGithub',
    'AccessGroupExcludeGsuite',
    'AccessGroupExcludeOkta',
    'AccessGroupExcludeSaml',
    'AccessGroupInclude',
    'AccessGroupIncludeAuthContext',
    'AccessGroupIncludeAzure',
    'AccessGroupIncludeExternalEvaluation',
    'AccessGroupIncludeGithub',
    'AccessGroupIncludeGsuite',
    'AccessGroupIncludeOkta',
    'AccessGroupIncludeSaml',
    'AccessGroupRequire',
    'AccessGroupRequireAuthContext',
    'AccessGroupRequireAzure',
    'AccessGroupRequireExternalEvaluation',
    'AccessGroupRequireGithub',
    'AccessGroupRequireGsuite',
    'AccessGroupRequireOkta',
    'AccessGroupRequireSaml',
    'AccessIdentityProviderConfig',
    'AccessIdentityProviderScimConfig',
    'AccessMutualTlsHostnameSettingsSetting',
    'AccessOrganizationCustomPage',
    'AccessOrganizationLoginDesign',
    'AccessPolicyApprovalGroup',
    'AccessPolicyConnectionRules',
    'AccessPolicyConnectionRulesSsh',
    'AccessPolicyExclude',
    'AccessPolicyExcludeAuthContext',
    'AccessPolicyExcludeAzure',
    'AccessPolicyExcludeExternalEvaluation',
    'AccessPolicyExcludeGithub',
    'AccessPolicyExcludeGsuite',
    'AccessPolicyExcludeOkta',
    'AccessPolicyExcludeSaml',
    'AccessPolicyInclude',
    'AccessPolicyIncludeAuthContext',
    'AccessPolicyIncludeAzure',
    'AccessPolicyIncludeExternalEvaluation',
    'AccessPolicyIncludeGithub',
    'AccessPolicyIncludeGsuite',
    'AccessPolicyIncludeOkta',
    'AccessPolicyIncludeSaml',
    'AccessPolicyRequire',
    'AccessPolicyRequireAuthContext',
    'AccessPolicyRequireAzure',
    'AccessPolicyRequireExternalEvaluation',
    'AccessPolicyRequireGithub',
    'AccessPolicyRequireGsuite',
    'AccessPolicyRequireOkta',
    'AccessPolicyRequireSaml',
    'AccessRuleConfiguration',
    'AddressMapIp',
    'AddressMapMembership',
    'ApiShieldAuthIdCharacteristic',
    'ApiTokenCondition',
    'ApiTokenConditionRequestIp',
    'ApiTokenPolicy',
    'CertificatePackValidationError',
    'CertificatePackValidationRecord',
    'CloudConnectorRulesRule',
    'CloudConnectorRulesRuleParameters',
    'CustomHostnameSsl',
    'CustomHostnameSslSetting',
    'CustomHostnameSslValidationError',
    'CustomHostnameSslValidationRecord',
    'CustomSslCustomSslOptions',
    'CustomSslCustomSslPriority',
    'DeviceDexTestData',
    'DeviceManagedNetworksConfig',
    'DevicePostureIntegrationConfig',
    'DevicePostureRuleInput',
    'DevicePostureRuleInputLocation',
    'DevicePostureRuleMatch',
    'DlpProfileContextAwareness',
    'DlpProfileContextAwarenessSkip',
    'DlpProfileEntry',
    'DlpProfileEntryPattern',
    'EmailRoutingCatchAllAction',
    'EmailRoutingCatchAllMatcher',
    'EmailRoutingRuleAction',
    'EmailRoutingRuleMatcher',
    'FallbackDomainDomain',
    'HealthcheckHeader',
    'HyperdriveConfigCaching',
    'HyperdriveConfigOrigin',
    'InfrastructureAccessTargetIp',
    'InfrastructureAccessTargetIpIpv4',
    'InfrastructureAccessTargetIpIpv6',
    'ListItem',
    'ListItemHostname',
    'ListItemRedirect',
    'ListItemValue',
    'ListItemValueHostname',
    'ListItemValueRedirect',
    'LoadBalancerAdaptiveRouting',
    'LoadBalancerCountryPool',
    'LoadBalancerLocationStrategy',
    'LoadBalancerMonitorHeader',
    'LoadBalancerPoolLoadShedding',
    'LoadBalancerPoolOrigin',
    'LoadBalancerPoolOriginHeader',
    'LoadBalancerPoolOriginSteering',
    'LoadBalancerPopPool',
    'LoadBalancerRandomSteering',
    'LoadBalancerRegionPool',
    'LoadBalancerRule',
    'LoadBalancerRuleFixedResponse',
    'LoadBalancerRuleOverride',
    'LoadBalancerRuleOverrideAdaptiveRouting',
    'LoadBalancerRuleOverrideCountryPool',
    'LoadBalancerRuleOverrideLocationStrategy',
    'LoadBalancerRuleOverridePopPool',
    'LoadBalancerRuleOverrideRandomSteering',
    'LoadBalancerRuleOverrideRegionPool',
    'LoadBalancerRuleOverrideSessionAffinityAttribute',
    'LoadBalancerSessionAffinityAttribute',
    'LogpushJobOutputOptions',
    'ManagedHeadersManagedRequestHeader',
    'ManagedHeadersManagedResponseHeader',
    'NotificationPolicyEmailIntegration',
    'NotificationPolicyFilters',
    'NotificationPolicyPagerdutyIntegration',
    'NotificationPolicyWebhooksIntegration',
    'PageRuleActions',
    'PageRuleActionsCacheKeyFields',
    'PageRuleActionsCacheKeyFieldsCookie',
    'PageRuleActionsCacheKeyFieldsHeader',
    'PageRuleActionsCacheKeyFieldsHost',
    'PageRuleActionsCacheKeyFieldsQueryString',
    'PageRuleActionsCacheKeyFieldsUser',
    'PageRuleActionsCacheTtlByStatus',
    'PageRuleActionsForwardingUrl',
    'PageRuleActionsMinify',
    'PagesProjectBuildConfig',
    'PagesProjectDeploymentConfigs',
    'PagesProjectDeploymentConfigsPreview',
    'PagesProjectDeploymentConfigsPreviewPlacement',
    'PagesProjectDeploymentConfigsPreviewServiceBinding',
    'PagesProjectDeploymentConfigsProduction',
    'PagesProjectDeploymentConfigsProductionPlacement',
    'PagesProjectDeploymentConfigsProductionServiceBinding',
    'PagesProjectSource',
    'PagesProjectSourceConfig',
    'RateLimitAction',
    'RateLimitActionResponse',
    'RateLimitCorrelate',
    'RateLimitMatch',
    'RateLimitMatchRequest',
    'RateLimitMatchResponse',
    'RecordData',
    'RiskBehaviorBehavior',
    'RulesetRule',
    'RulesetRuleActionParameters',
    'RulesetRuleActionParametersAlgorithm',
    'RulesetRuleActionParametersAutominify',
    'RulesetRuleActionParametersBrowserTtl',
    'RulesetRuleActionParametersCacheKey',
    'RulesetRuleActionParametersCacheKeyCustomKey',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookie',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeader',
    'RulesetRuleActionParametersCacheKeyCustomKeyHost',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryString',
    'RulesetRuleActionParametersCacheKeyCustomKeyUser',
    'RulesetRuleActionParametersCacheReserve',
    'RulesetRuleActionParametersEdgeTtl',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtl',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange',
    'RulesetRuleActionParametersFromList',
    'RulesetRuleActionParametersFromValue',
    'RulesetRuleActionParametersFromValueTargetUrl',
    'RulesetRuleActionParametersHeader',
    'RulesetRuleActionParametersMatchedData',
    'RulesetRuleActionParametersOrigin',
    'RulesetRuleActionParametersOverrides',
    'RulesetRuleActionParametersOverridesCategory',
    'RulesetRuleActionParametersOverridesRule',
    'RulesetRuleActionParametersResponse',
    'RulesetRuleActionParametersServeStale',
    'RulesetRuleActionParametersSni',
    'RulesetRuleActionParametersUri',
    'RulesetRuleActionParametersUriPath',
    'RulesetRuleActionParametersUriQuery',
    'RulesetRuleExposedCredentialCheck',
    'RulesetRuleLogging',
    'RulesetRuleRatelimit',
    'SnippetFile',
    'SnippetRulesRule',
    'SpectrumApplicationDns',
    'SpectrumApplicationEdgeIps',
    'SpectrumApplicationOriginDns',
    'SpectrumApplicationOriginPortRange',
    'SplitTunnelTunnel',
    'TeamsAccountAntivirus',
    'TeamsAccountAntivirusNotificationSettings',
    'TeamsAccountBlockPage',
    'TeamsAccountBodyScanning',
    'TeamsAccountCertificate',
    'TeamsAccountCustomCertificate',
    'TeamsAccountExtendedEmailMatching',
    'TeamsAccountFips',
    'TeamsAccountLogging',
    'TeamsAccountLoggingSettingsByRuleType',
    'TeamsAccountLoggingSettingsByRuleTypeDns',
    'TeamsAccountLoggingSettingsByRuleTypeHttp',
    'TeamsAccountLoggingSettingsByRuleTypeL4',
    'TeamsAccountPayloadLog',
    'TeamsAccountProxy',
    'TeamsAccountSshSessionLog',
    'TeamsListItemsWithDescription',
    'TeamsLocationEndpoints',
    'TeamsLocationEndpointsDoh',
    'TeamsLocationEndpointsDohNetwork',
    'TeamsLocationEndpointsDot',
    'TeamsLocationEndpointsDotNetwork',
    'TeamsLocationEndpointsIpv4',
    'TeamsLocationEndpointsIpv6',
    'TeamsLocationEndpointsIpv6Network',
    'TeamsLocationNetwork',
    'TeamsRuleRuleSettings',
    'TeamsRuleRuleSettingsAuditSsh',
    'TeamsRuleRuleSettingsBisoAdminControls',
    'TeamsRuleRuleSettingsCheckSession',
    'TeamsRuleRuleSettingsDnsResolvers',
    'TeamsRuleRuleSettingsDnsResolversIpv4',
    'TeamsRuleRuleSettingsDnsResolversIpv6',
    'TeamsRuleRuleSettingsEgress',
    'TeamsRuleRuleSettingsL4override',
    'TeamsRuleRuleSettingsNotificationSettings',
    'TeamsRuleRuleSettingsPayloadLog',
    'TeamsRuleRuleSettingsResolveDnsInternally',
    'TeamsRuleRuleSettingsUntrustedCert',
    'TunnelConfigConfig',
    'TunnelConfigConfigIngressRule',
    'TunnelConfigConfigIngressRuleOriginRequest',
    'TunnelConfigConfigIngressRuleOriginRequestAccess',
    'TunnelConfigConfigIngressRuleOriginRequestIpRule',
    'TunnelConfigConfigOriginRequest',
    'TunnelConfigConfigOriginRequestAccess',
    'TunnelConfigConfigOriginRequestIpRule',
    'TunnelConfigConfigWarpRouting',
    'UserAgentBlockingRuleConfiguration',
    'WaitingRoomAdditionalRoute',
    'WaitingRoomRulesRule',
    'WorkerScriptAnalyticsEngineBinding',
    'WorkerScriptD1DatabaseBinding',
    'WorkerScriptHyperdriveConfigBinding',
    'WorkerScriptKvNamespaceBinding',
    'WorkerScriptPlacement',
    'WorkerScriptPlainTextBinding',
    'WorkerScriptQueueBinding',
    'WorkerScriptR2BucketBinding',
    'WorkerScriptSecretTextBinding',
    'WorkerScriptServiceBinding',
    'WorkerScriptWebassemblyBinding',
    'WorkersScriptAnalyticsEngineBinding',
    'WorkersScriptD1DatabaseBinding',
    'WorkersScriptHyperdriveConfigBinding',
    'WorkersScriptKvNamespaceBinding',
    'WorkersScriptPlacement',
    'WorkersScriptPlainTextBinding',
    'WorkersScriptQueueBinding',
    'WorkersScriptR2BucketBinding',
    'WorkersScriptSecretTextBinding',
    'WorkersScriptServiceBinding',
    'WorkersScriptWebassemblyBinding',
    'ZeroTrustAccessApplicationCorsHeader',
    'ZeroTrustAccessApplicationDestination',
    'ZeroTrustAccessApplicationFooterLink',
    'ZeroTrustAccessApplicationLandingPageDesign',
    'ZeroTrustAccessApplicationSaasApp',
    'ZeroTrustAccessApplicationSaasAppCustomAttribute',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSource',
    'ZeroTrustAccessApplicationSaasAppCustomClaim',
    'ZeroTrustAccessApplicationSaasAppCustomClaimSource',
    'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions',
    'ZeroTrustAccessApplicationSaasAppRefreshTokenOption',
    'ZeroTrustAccessApplicationScimConfig',
    'ZeroTrustAccessApplicationScimConfigAuthentication',
    'ZeroTrustAccessApplicationScimConfigMapping',
    'ZeroTrustAccessApplicationScimConfigMappingOperations',
    'ZeroTrustAccessApplicationTargetCriteria',
    'ZeroTrustAccessApplicationTargetCriteriaTargetAttribute',
    'ZeroTrustAccessGroupExclude',
    'ZeroTrustAccessGroupExcludeAuthContext',
    'ZeroTrustAccessGroupExcludeAzure',
    'ZeroTrustAccessGroupExcludeExternalEvaluation',
    'ZeroTrustAccessGroupExcludeGithub',
    'ZeroTrustAccessGroupExcludeGsuite',
    'ZeroTrustAccessGroupExcludeOkta',
    'ZeroTrustAccessGroupExcludeSaml',
    'ZeroTrustAccessGroupInclude',
    'ZeroTrustAccessGroupIncludeAuthContext',
    'ZeroTrustAccessGroupIncludeAzure',
    'ZeroTrustAccessGroupIncludeExternalEvaluation',
    'ZeroTrustAccessGroupIncludeGithub',
    'ZeroTrustAccessGroupIncludeGsuite',
    'ZeroTrustAccessGroupIncludeOkta',
    'ZeroTrustAccessGroupIncludeSaml',
    'ZeroTrustAccessGroupRequire',
    'ZeroTrustAccessGroupRequireAuthContext',
    'ZeroTrustAccessGroupRequireAzure',
    'ZeroTrustAccessGroupRequireExternalEvaluation',
    'ZeroTrustAccessGroupRequireGithub',
    'ZeroTrustAccessGroupRequireGsuite',
    'ZeroTrustAccessGroupRequireOkta',
    'ZeroTrustAccessGroupRequireSaml',
    'ZeroTrustAccessIdentityProviderConfig',
    'ZeroTrustAccessIdentityProviderScimConfig',
    'ZeroTrustAccessMtlsHostnameSettingsSetting',
    'ZeroTrustAccessOrganizationCustomPage',
    'ZeroTrustAccessOrganizationLoginDesign',
    'ZeroTrustAccessPolicyApprovalGroup',
    'ZeroTrustAccessPolicyConnectionRules',
    'ZeroTrustAccessPolicyConnectionRulesSsh',
    'ZeroTrustAccessPolicyExclude',
    'ZeroTrustAccessPolicyExcludeAuthContext',
    'ZeroTrustAccessPolicyExcludeAzure',
    'ZeroTrustAccessPolicyExcludeExternalEvaluation',
    'ZeroTrustAccessPolicyExcludeGithub',
    'ZeroTrustAccessPolicyExcludeGsuite',
    'ZeroTrustAccessPolicyExcludeOkta',
    'ZeroTrustAccessPolicyExcludeSaml',
    'ZeroTrustAccessPolicyInclude',
    'ZeroTrustAccessPolicyIncludeAuthContext',
    'ZeroTrustAccessPolicyIncludeAzure',
    'ZeroTrustAccessPolicyIncludeExternalEvaluation',
    'ZeroTrustAccessPolicyIncludeGithub',
    'ZeroTrustAccessPolicyIncludeGsuite',
    'ZeroTrustAccessPolicyIncludeOkta',
    'ZeroTrustAccessPolicyIncludeSaml',
    'ZeroTrustAccessPolicyRequire',
    'ZeroTrustAccessPolicyRequireAuthContext',
    'ZeroTrustAccessPolicyRequireAzure',
    'ZeroTrustAccessPolicyRequireExternalEvaluation',
    'ZeroTrustAccessPolicyRequireGithub',
    'ZeroTrustAccessPolicyRequireGsuite',
    'ZeroTrustAccessPolicyRequireOkta',
    'ZeroTrustAccessPolicyRequireSaml',
    'ZeroTrustDeviceManagedNetworksConfig',
    'ZeroTrustDevicePostureIntegrationConfig',
    'ZeroTrustDevicePostureRuleInput',
    'ZeroTrustDevicePostureRuleInputLocation',
    'ZeroTrustDevicePostureRuleMatch',
    'ZeroTrustDexTestData',
    'ZeroTrustDlpProfileContextAwareness',
    'ZeroTrustDlpProfileContextAwarenessSkip',
    'ZeroTrustDlpProfileEntry',
    'ZeroTrustDlpProfileEntryPattern',
    'ZeroTrustDnsLocationEndpoints',
    'ZeroTrustDnsLocationEndpointsDoh',
    'ZeroTrustDnsLocationEndpointsDohNetwork',
    'ZeroTrustDnsLocationEndpointsDot',
    'ZeroTrustDnsLocationEndpointsDotNetwork',
    'ZeroTrustDnsLocationEndpointsIpv4',
    'ZeroTrustDnsLocationEndpointsIpv6',
    'ZeroTrustDnsLocationEndpointsIpv6Network',
    'ZeroTrustDnsLocationNetwork',
    'ZeroTrustGatewayPolicyRuleSettings',
    'ZeroTrustGatewayPolicyRuleSettingsAuditSsh',
    'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls',
    'ZeroTrustGatewayPolicyRuleSettingsCheckSession',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolvers',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6',
    'ZeroTrustGatewayPolicyRuleSettingsEgress',
    'ZeroTrustGatewayPolicyRuleSettingsL4override',
    'ZeroTrustGatewayPolicyRuleSettingsNotificationSettings',
    'ZeroTrustGatewayPolicyRuleSettingsPayloadLog',
    'ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally',
    'ZeroTrustGatewayPolicyRuleSettingsUntrustedCert',
    'ZeroTrustGatewaySettingsAntivirus',
    'ZeroTrustGatewaySettingsAntivirusNotificationSettings',
    'ZeroTrustGatewaySettingsBlockPage',
    'ZeroTrustGatewaySettingsBodyScanning',
    'ZeroTrustGatewaySettingsCertificate',
    'ZeroTrustGatewaySettingsCustomCertificate',
    'ZeroTrustGatewaySettingsExtendedEmailMatching',
    'ZeroTrustGatewaySettingsFips',
    'ZeroTrustGatewaySettingsLogging',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleType',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp',
    'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4',
    'ZeroTrustGatewaySettingsPayloadLog',
    'ZeroTrustGatewaySettingsProxy',
    'ZeroTrustGatewaySettingsSshSessionLog',
    'ZeroTrustInfrastructureAccessTargetIp',
    'ZeroTrustInfrastructureAccessTargetIpIpv4',
    'ZeroTrustInfrastructureAccessTargetIpIpv6',
    'ZeroTrustListItemsWithDescription',
    'ZeroTrustLocalFallbackDomainDomain',
    'ZeroTrustRiskBehaviorBehavior',
    'ZeroTrustSplitTunnelTunnel',
    'ZeroTrustTunnelCloudflaredConfigConfig',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRule',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequest',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule',
    'ZeroTrustTunnelCloudflaredConfigConfigWarpRouting',
    'ZoneLockdownConfiguration',
    'ZoneSettingsOverrideInitialSetting',
    'ZoneSettingsOverrideInitialSettingAegis',
    'ZoneSettingsOverrideInitialSettingMinify',
    'ZoneSettingsOverrideInitialSettingMobileRedirect',
    'ZoneSettingsOverrideInitialSettingNel',
    'ZoneSettingsOverrideInitialSettingSecurityHeader',
    'ZoneSettingsOverrideSettings',
    'ZoneSettingsOverrideSettingsAegis',
    'ZoneSettingsOverrideSettingsMinify',
    'ZoneSettingsOverrideSettingsMobileRedirect',
    'ZoneSettingsOverrideSettingsNel',
    'ZoneSettingsOverrideSettingsSecurityHeader',
    'GetAccountRolesRoleResult',
    'GetAccountsAccountResult',
    'GetDevicePostureRulesRuleResult',
    'GetDevicesDeviceResult',
    'GetDlpDatasetsDatasetResult',
    'GetGatewayAppTypesAppTypeResult',
    'GetGatewayCategoriesCategoryResult',
    'GetGatewayCategoriesCategorySubcategoryResult',
    'GetInfrastructureAccessTargetsTargetResult',
    'GetInfrastructureAccessTargetsTargetIpResult',
    'GetInfrastructureAccessTargetsTargetIpIpv4Result',
    'GetInfrastructureAccessTargetsTargetIpIpv6Result',
    'GetListsListResult',
    'GetLoadBalancerPoolsFilterResult',
    'GetLoadBalancerPoolsPoolResult',
    'GetLoadBalancerPoolsPoolLoadSheddingResult',
    'GetLoadBalancerPoolsPoolOriginResult',
    'GetLoadBalancerPoolsPoolOriginHeaderResult',
    'GetRulesetsFilterResult',
    'GetRulesetsRulesetResult',
    'GetRulesetsRulesetRuleResult',
    'GetRulesetsRulesetRuleActionParametersResult',
    'GetRulesetsRulesetRuleActionParametersAutominifyResult',
    'GetRulesetsRulesetRuleActionParametersBrowserTtlResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult',
    'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserResult',
    'GetRulesetsRulesetRuleActionParametersCacheReserveResult',
    'GetRulesetsRulesetRuleActionParametersEdgeTtlResult',
    'GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult',
    'GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult',
    'GetRulesetsRulesetRuleActionParametersFromListResult',
    'GetRulesetsRulesetRuleActionParametersFromValueResult',
    'GetRulesetsRulesetRuleActionParametersFromValueTargetUrlResult',
    'GetRulesetsRulesetRuleActionParametersHeaderResult',
    'GetRulesetsRulesetRuleActionParametersMatchedDataResult',
    'GetRulesetsRulesetRuleActionParametersOriginResult',
    'GetRulesetsRulesetRuleActionParametersOverridesResult',
    'GetRulesetsRulesetRuleActionParametersOverridesCategoryResult',
    'GetRulesetsRulesetRuleActionParametersOverridesRuleResult',
    'GetRulesetsRulesetRuleActionParametersResponseResult',
    'GetRulesetsRulesetRuleActionParametersServeStaleResult',
    'GetRulesetsRulesetRuleActionParametersSniResult',
    'GetRulesetsRulesetRuleActionParametersUriResult',
    'GetRulesetsRulesetRuleActionParametersUriPathResult',
    'GetRulesetsRulesetRuleActionParametersUriQueryResult',
    'GetRulesetsRulesetRuleExposedCredentialCheckResult',
    'GetRulesetsRulesetRuleLoggingResult',
    'GetRulesetsRulesetRuleRatelimitResult',
    'GetZeroTrustInfrastructureAccessTargetsTargetResult',
    'GetZeroTrustInfrastructureAccessTargetsTargetIpResult',
    'GetZeroTrustInfrastructureAccessTargetsTargetIpIpv4Result',
    'GetZeroTrustInfrastructureAccessTargetsTargetIpIpv6Result',
    'GetZonesFilterResult',
    'GetZonesZoneResult',
]

@pulumi.output_type
class AccessApplicationCorsHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllHeaders":
            suggest = "allow_all_headers"
        elif key == "allowAllMethods":
            suggest = "allow_all_methods"
        elif key == "allowAllOrigins":
            suggest = "allow_all_origins"
        elif key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationCorsHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationCorsHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationCorsHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_headers: Optional[builtins.bool] = None,
                 allow_all_methods: Optional[builtins.bool] = None,
                 allow_all_origins: Optional[builtins.bool] = None,
                 allow_credentials: Optional[builtins.bool] = None,
                 allowed_headers: Optional[Sequence[builtins.str]] = None,
                 allowed_methods: Optional[Sequence[builtins.str]] = None,
                 allowed_origins: Optional[Sequence[builtins.str]] = None,
                 max_age: Optional[builtins.int] = None):
        """
        :param builtins.bool allow_all_headers: Value to determine whether all HTTP headers are exposed.
        :param builtins.bool allow_all_methods: Value to determine whether all methods are exposed.
        :param builtins.bool allow_all_origins: Value to determine whether all origins are permitted to make CORS requests.
        :param builtins.bool allow_credentials: Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        :param Sequence[builtins.str] allowed_headers: List of HTTP headers to expose via CORS.
        :param Sequence[builtins.str] allowed_methods: List of methods to expose via CORS.
        :param Sequence[builtins.str] allowed_origins: List of origins permitted to make CORS requests.
        :param builtins.int max_age: The maximum time a preflight request will be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[builtins.bool]:
        """
        Value to determine whether all HTTP headers are exposed.
        """
        return pulumi.get(self, "allow_all_headers")

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[builtins.bool]:
        """
        Value to determine whether all methods are exposed.
        """
        return pulumi.get(self, "allow_all_methods")

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[builtins.bool]:
        """
        Value to determine whether all origins are permitted to make CORS requests.
        """
        return pulumi.get(self, "allow_all_origins")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[builtins.bool]:
        """
        Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[builtins.str]]:
        """
        List of HTTP headers to expose via CORS.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        List of methods to expose via CORS.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[builtins.str]]:
        """
        List of origins permitted to make CORS requests.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[builtins.int]:
        """
        The maximum time a preflight request will be cached.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class AccessApplicationDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "l4Protocol":
            suggest = "l4_protocol"
        elif key == "portRange":
            suggest = "port_range"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[builtins.str] = None,
                 hostname: Optional[builtins.str] = None,
                 l4_protocol: Optional[builtins.str] = None,
                 port_range: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None,
                 vnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: The private CIDR of the destination. Only valid when type=private. IPs are computed as /32 cidr. Private destinations are an early access feature and gated behind a feature flag.
        :param builtins.str hostname: The private hostname of the destination. Only valid when type=private. Private hostnames currently match only Server Name Indications (SNI). Private destinations are an early access feature and gated behind a feature flag.
        :param builtins.str l4_protocol: The l4 protocol that matches this destination. Only valid when type=private. Private destinations are an early access feature and gated behind a feature flag.
        :param builtins.str port_range: The port range of the destination. Only valid when type=private. Single ports are supported. Private destinations are an early access feature and gated behind a feature flag.
        :param builtins.str type: The destination type. Available values: `public`, `private`. Defaults to `public`.
        :param builtins.str uri: The public URI of the destination. Can include a domain and path with wildcards. Only valid when type=public.
        :param builtins.str vnet_id: The VNet ID of the destination. Only valid when type=private. Private destinations are an early access feature and gated behind a feature flag.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if l4_protocol is not None:
            pulumi.set(__self__, "l4_protocol", l4_protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[builtins.str]:
        """
        The private CIDR of the destination. Only valid when type=private. IPs are computed as /32 cidr. Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[builtins.str]:
        """
        The private hostname of the destination. Only valid when type=private. Private hostnames currently match only Server Name Indications (SNI). Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="l4Protocol")
    def l4_protocol(self) -> Optional[builtins.str]:
        """
        The l4 protocol that matches this destination. Only valid when type=private. Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "l4_protocol")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[builtins.str]:
        """
        The port range of the destination. Only valid when type=private. Single ports are supported. Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The destination type. Available values: `public`, `private`. Defaults to `public`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        The public URI of the destination. Can include a domain and path with wildcards. Only valid when type=public.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[builtins.str]:
        """
        The VNet ID of the destination. Only valid when type=private. Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class AccessApplicationFooterLink(dict):
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 url: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the footer link.
        :param builtins.str url: The URL of the footer link.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the footer link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        The URL of the footer link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AccessApplicationLandingPageDesign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buttonColor":
            suggest = "button_color"
        elif key == "buttonTextColor":
            suggest = "button_text_color"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationLandingPageDesign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationLandingPageDesign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationLandingPageDesign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 button_color: Optional[builtins.str] = None,
                 button_text_color: Optional[builtins.str] = None,
                 image_url: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 title: Optional[builtins.str] = None):
        """
        :param builtins.str button_color: The button color of the landing page.
        :param builtins.str button_text_color: The button text color of the landing page.
        :param builtins.str image_url: The URL of the image to be displayed in the landing page.
        :param builtins.str message: The message of the landing page.
        :param builtins.str title: The title of the landing page.
        """
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[builtins.str]:
        """
        The button color of the landing page.
        """
        return pulumi.get(self, "button_color")

    @property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[builtins.str]:
        """
        The button text color of the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[builtins.str]:
        """
        The URL of the image to be displayed in the landing page.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        The message of the landing page.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        The title of the landing page.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class AccessApplicationSaasApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenLifetime":
            suggest = "access_token_lifetime"
        elif key == "allowPkceWithoutClientSecret":
            suggest = "allow_pkce_without_client_secret"
        elif key == "appLauncherUrl":
            suggest = "app_launcher_url"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "consumerServiceUrl":
            suggest = "consumer_service_url"
        elif key == "customAttributes":
            suggest = "custom_attributes"
        elif key == "customClaims":
            suggest = "custom_claims"
        elif key == "defaultRelayState":
            suggest = "default_relay_state"
        elif key == "grantTypes":
            suggest = "grant_types"
        elif key == "groupFilterRegex":
            suggest = "group_filter_regex"
        elif key == "hybridAndImplicitOptions":
            suggest = "hybrid_and_implicit_options"
        elif key == "idpEntityId":
            suggest = "idp_entity_id"
        elif key == "nameIdFormat":
            suggest = "name_id_format"
        elif key == "nameIdTransformJsonata":
            suggest = "name_id_transform_jsonata"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "redirectUris":
            suggest = "redirect_uris"
        elif key == "refreshTokenOptions":
            suggest = "refresh_token_options"
        elif key == "samlAttributeTransformJsonata":
            suggest = "saml_attribute_transform_jsonata"
        elif key == "spEntityId":
            suggest = "sp_entity_id"
        elif key == "ssoEndpoint":
            suggest = "sso_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationSaasApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationSaasApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationSaasApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_lifetime: Optional[builtins.str] = None,
                 allow_pkce_without_client_secret: Optional[builtins.bool] = None,
                 app_launcher_url: Optional[builtins.str] = None,
                 auth_type: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 consumer_service_url: Optional[builtins.str] = None,
                 custom_attributes: Optional[Sequence['outputs.AccessApplicationSaasAppCustomAttribute']] = None,
                 custom_claims: Optional[Sequence['outputs.AccessApplicationSaasAppCustomClaim']] = None,
                 default_relay_state: Optional[builtins.str] = None,
                 grant_types: Optional[Sequence[builtins.str]] = None,
                 group_filter_regex: Optional[builtins.str] = None,
                 hybrid_and_implicit_options: Optional['outputs.AccessApplicationSaasAppHybridAndImplicitOptions'] = None,
                 idp_entity_id: Optional[builtins.str] = None,
                 name_id_format: Optional[builtins.str] = None,
                 name_id_transform_jsonata: Optional[builtins.str] = None,
                 public_key: Optional[builtins.str] = None,
                 redirect_uris: Optional[Sequence[builtins.str]] = None,
                 refresh_token_options: Optional[Sequence['outputs.AccessApplicationSaasAppRefreshTokenOption']] = None,
                 saml_attribute_transform_jsonata: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None,
                 sp_entity_id: Optional[builtins.str] = None,
                 sso_endpoint: Optional[builtins.str] = None):
        """
        :param builtins.str access_token_lifetime: The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        :param builtins.bool allow_pkce_without_client_secret: Allow PKCE flow without a client secret.
        :param builtins.str app_launcher_url: The URL where this applications tile redirects users.
        :param builtins.str auth_type: **Modifying this attribute will force creation of a new resource.**
        :param builtins.str client_id: The application client id.
        :param builtins.str client_secret: The application client secret, only returned on initial apply.
        :param builtins.str consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param Sequence['AccessApplicationSaasAppCustomAttributeArgs'] custom_attributes: Custom attribute mapped from IDPs.
        :param Sequence['AccessApplicationSaasAppCustomClaimArgs'] custom_claims: Custom claim mapped from IDPs.
        :param builtins.str default_relay_state: The relay state used if not provided by the identity provider.
        :param Sequence[builtins.str] grant_types: The OIDC flows supported by this application.
        :param builtins.str group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        :param 'AccessApplicationSaasAppHybridAndImplicitOptionsArgs' hybrid_and_implicit_options: Hybrid and Implicit Flow options.
        :param builtins.str idp_entity_id: The unique identifier for the SaaS application.
        :param builtins.str name_id_format: The format of the name identifier sent to the SaaS application.
        :param builtins.str name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param builtins.str public_key: The public certificate that will be used to verify identities.
        :param Sequence[builtins.str] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        :param Sequence['AccessApplicationSaasAppRefreshTokenOptionArgs'] refresh_token_options: Refresh token grant options.
        :param builtins.str saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param Sequence[builtins.str] scopes: Define the user information shared with access.
        :param builtins.str sp_entity_id: A globally unique name for an identity or service provider.
        :param builtins.str sso_endpoint: The endpoint where the SaaS application will send login requests.
        """
        if access_token_lifetime is not None:
            pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        if allow_pkce_without_client_secret is not None:
            pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        if app_launcher_url is not None:
            pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if consumer_service_url is not None:
            pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if custom_claims is not None:
            pulumi.set(__self__, "custom_claims", custom_claims)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if group_filter_regex is not None:
            pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        if hybrid_and_implicit_options is not None:
            pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if name_id_transform_jsonata is not None:
            pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if refresh_token_options is not None:
            pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        if saml_attribute_transform_jsonata is not None:
            pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sso_endpoint is not None:
            pulumi.set(__self__, "sso_endpoint", sso_endpoint)

    @property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> Optional[builtins.str]:
        """
        The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> Optional[builtins.bool]:
        """
        Allow PKCE flow without a client secret.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> Optional[builtins.str]:
        """
        The URL where this applications tile redirects users.
        """
        return pulumi.get(self, "app_launcher_url")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[builtins.str]:
        """
        **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The application client id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The application client secret, only returned on initial apply.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> Optional[builtins.str]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[Sequence['outputs.AccessApplicationSaasAppCustomAttribute']]:
        """
        Custom attribute mapped from IDPs.
        """
        return pulumi.get(self, "custom_attributes")

    @property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Optional[Sequence['outputs.AccessApplicationSaasAppCustomClaim']]:
        """
        Custom claim mapped from IDPs.
        """
        return pulumi.get(self, "custom_claims")

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[builtins.str]:
        """
        The relay state used if not provided by the identity provider.
        """
        return pulumi.get(self, "default_relay_state")

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The OIDC flows supported by this application.
        """
        return pulumi.get(self, "grant_types")

    @property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> Optional[builtins.str]:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        """
        return pulumi.get(self, "group_filter_regex")

    @property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> Optional['outputs.AccessApplicationSaasAppHybridAndImplicitOptions']:
        """
        Hybrid and Implicit Flow options.
        """
        return pulumi.get(self, "hybrid_and_implicit_options")

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[builtins.str]:
        """
        The unique identifier for the SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[builtins.str]:
        """
        The format of the name identifier sent to the SaaS application.
        """
        return pulumi.get(self, "name_id_format")

    @property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> Optional[builtins.str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[builtins.str]:
        """
        The public certificate that will be used to verify identities.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> Optional[Sequence['outputs.AccessApplicationSaasAppRefreshTokenOption']]:
        """
        Refresh token grant options.
        """
        return pulumi.get(self, "refresh_token_options")

    @property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> Optional[builtins.str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        Define the user information shared with access.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[builtins.str]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> Optional[builtins.str]:
        """
        The endpoint where the SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")


@pulumi.output_type
class AccessApplicationSaasAppCustomAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "friendlyName":
            suggest = "friendly_name"
        elif key == "nameFormat":
            suggest = "name_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationSaasAppCustomAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationSaasAppCustomAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationSaasAppCustomAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: 'outputs.AccessApplicationSaasAppCustomAttributeSource',
                 friendly_name: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 name_format: Optional[builtins.str] = None,
                 required: Optional[builtins.bool] = None):
        """
        :param builtins.str friendly_name: A friendly name for the attribute as provided to the SaaS app.
        :param builtins.str name: The name of the attribute as provided to the SaaS app.
        :param builtins.str name_format: A globally unique name for an identity or service provider.
        :param builtins.bool required: True if the attribute must be always present.
        """
        pulumi.set(__self__, "source", source)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_format is not None:
            pulumi.set(__self__, "name_format", name_format)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def source(self) -> 'outputs.AccessApplicationSaasAppCustomAttributeSource':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[builtins.str]:
        """
        A friendly name for the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[builtins.str]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class AccessApplicationSaasAppCustomAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameByIdp":
            suggest = "name_by_idp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationSaasAppCustomAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationSaasAppCustomAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationSaasAppCustomAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 name_by_idp: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name of the attribute as provided by the IDP.
        :param Mapping[str, builtins.str] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the attribute as provided by the IDP.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")


@pulumi.output_type
class AccessApplicationSaasAppCustomClaim(dict):
    def __init__(__self__, *,
                 source: 'outputs.AccessApplicationSaasAppCustomClaimSource',
                 name: Optional[builtins.str] = None,
                 required: Optional[builtins.bool] = None,
                 scope: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the attribute as provided to the SaaS app.
        :param builtins.bool required: True if the attribute must be always present.
        :param builtins.str scope: The scope of the claim.
        """
        pulumi.set(__self__, "source", source)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def source(self) -> 'outputs.AccessApplicationSaasAppCustomClaimSource':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def scope(self) -> Optional[builtins.str]:
        """
        The scope of the claim.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class AccessApplicationSaasAppCustomClaimSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameByIdp":
            suggest = "name_by_idp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationSaasAppCustomClaimSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationSaasAppCustomClaimSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationSaasAppCustomClaimSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 name_by_idp: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name of the attribute as provided by the IDP.
        :param Mapping[str, builtins.str] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the attribute as provided by the IDP.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")


@pulumi.output_type
class AccessApplicationSaasAppHybridAndImplicitOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "returnAccessTokenFromAuthorizationEndpoint":
            suggest = "return_access_token_from_authorization_endpoint"
        elif key == "returnIdTokenFromAuthorizationEndpoint":
            suggest = "return_id_token_from_authorization_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationSaasAppHybridAndImplicitOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationSaasAppHybridAndImplicitOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationSaasAppHybridAndImplicitOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: Optional[builtins.bool] = None,
                 return_id_token_from_authorization_endpoint: Optional[builtins.bool] = None):
        """
        :param builtins.bool return_access_token_from_authorization_endpoint: If true, the authorization endpoint will return an access token.
        :param builtins.bool return_id_token_from_authorization_endpoint: If true, the authorization endpoint will return an id token.
        """
        if return_access_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        if return_id_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> Optional[builtins.bool]:
        """
        If true, the authorization endpoint will return an access token.
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> Optional[builtins.bool]:
        """
        If true, the authorization endpoint will return an id token.
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")


@pulumi.output_type
class AccessApplicationSaasAppRefreshTokenOption(dict):
    def __init__(__self__, *,
                 lifetime: Optional[builtins.str] = None):
        """
        :param builtins.str lifetime: How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
        if lifetime is not None:
            pulumi.set(__self__, "lifetime", lifetime)

    @property
    @pulumi.getter
    def lifetime(self) -> Optional[builtins.str]:
        """
        How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")


@pulumi.output_type
class AccessApplicationScimConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idpUid":
            suggest = "idp_uid"
        elif key == "remoteUri":
            suggest = "remote_uri"
        elif key == "deactivateOnDelete":
            suggest = "deactivate_on_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationScimConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationScimConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationScimConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idp_uid: builtins.str,
                 remote_uri: builtins.str,
                 authentication: Optional['outputs.AccessApplicationScimConfigAuthentication'] = None,
                 deactivate_on_delete: Optional[builtins.bool] = None,
                 enabled: Optional[builtins.bool] = None,
                 mappings: Optional[Sequence['outputs.AccessApplicationScimConfigMapping']] = None):
        """
        :param builtins.str idp_uid: The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        :param builtins.str remote_uri: The base URI for the application's SCIM-compatible API.
        :param 'AccessApplicationScimConfigAuthenticationArgs' authentication: Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        :param builtins.bool deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param builtins.bool enabled: Whether SCIM provisioning is turned on for this application.
        :param Sequence['AccessApplicationScimConfigMappingArgs'] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "remote_uri", remote_uri)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if deactivate_on_delete is not None:
            pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> builtins.str:
        """
        The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> builtins.str:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.AccessApplicationScimConfigAuthentication']:
        """
        Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> Optional[builtins.bool]:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.AccessApplicationScimConfigMapping']]:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class AccessApplicationScimConfigAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationUrl":
            suggest = "authorization_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationScimConfigAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationScimConfigAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationScimConfigAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scheme: builtins.str,
                 authorization_url: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None,
                 token: Optional[builtins.str] = None,
                 token_url: Optional[builtins.str] = None,
                 user: Optional[builtins.str] = None):
        """
        :param builtins.str scheme: The authentication scheme to use when making SCIM requests to this application.
        :param builtins.str authorization_url: URL used to generate the auth code used during token generation.
        :param builtins.str client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        :param builtins.str client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        :param Sequence[builtins.str] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        :param builtins.str token: Token used to authenticate with the remote SCIM service.
        :param builtins.str token_url: URL used to generate the token used to authenticate with the remote SCIM service.
        :param builtins.str user: User name used to authenticate with the remote SCIM service.
        """
        pulumi.set(__self__, "scheme", scheme)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def scheme(self) -> builtins.str:
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[builtins.str]:
        """
        URL used to generate the auth code used during token generation.
        """
        return pulumi.get(self, "authorization_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def token(self) -> Optional[builtins.str]:
        """
        Token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[builtins.str]:
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter
    def user(self) -> Optional[builtins.str]:
        """
        User name used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class AccessApplicationScimConfigMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformJsonata":
            suggest = "transform_jsonata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationScimConfigMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationScimConfigMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationScimConfigMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: builtins.str,
                 enabled: Optional[builtins.bool] = None,
                 filter: Optional[builtins.str] = None,
                 operations: Optional['outputs.AccessApplicationScimConfigMappingOperations'] = None,
                 strictness: Optional[builtins.str] = None,
                 transform_jsonata: Optional[builtins.str] = None):
        """
        :param builtins.str schema: Which SCIM resource type this mapping applies to.
        :param builtins.bool enabled: Whether or not this mapping is enabled.
        :param builtins.str filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param 'AccessApplicationScimConfigMappingOperationsArgs' operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param builtins.str strictness: How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        :param builtins.str transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "schema", schema)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if strictness is not None:
            pulumi.set(__self__, "strictness", strictness)
        if transform_jsonata is not None:
            pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @property
    @pulumi.getter
    def schema(self) -> builtins.str:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filter(self) -> Optional[builtins.str]:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def operations(self) -> Optional['outputs.AccessApplicationScimConfigMappingOperations']:
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def strictness(self) -> Optional[builtins.str]:
        """
        How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        """
        return pulumi.get(self, "strictness")

    @property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> Optional[builtins.str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")


@pulumi.output_type
class AccessApplicationScimConfigMappingOperations(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.bool] = None,
                 delete: Optional[builtins.bool] = None,
                 update: Optional[builtins.bool] = None):
        """
        :param builtins.bool create: Whether or not this mapping applies to create (POST) operations.
        :param builtins.bool delete: Whether or not this mapping applies to DELETE operations.
        :param builtins.bool update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.bool]:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.bool]:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.bool]:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AccessApplicationTargetCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetAttributes":
            suggest = "target_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessApplicationTargetCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessApplicationTargetCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessApplicationTargetCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: builtins.int,
                 protocol: builtins.str,
                 target_attributes: Sequence['outputs.AccessApplicationTargetCriteriaTargetAttribute']):
        """
        :param builtins.int port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param builtins.str protocol: The communication protocol your application secures.
        :param Sequence['AccessApplicationTargetCriteriaTargetAttributeArgs'] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> builtins.str:
        """
        The communication protocol your application secures.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> Sequence['outputs.AccessApplicationTargetCriteriaTargetAttribute']:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")


@pulumi.output_type
class AccessApplicationTargetCriteriaTargetAttribute(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str name: The key of the attribute.
        :param Sequence[builtins.str] values: The values of the attribute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The key of the attribute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        The values of the attribute.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AccessGroupExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.AccessGroupExcludeAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupExcludeAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluation: Optional['outputs.AccessGroupExcludeExternalEvaluation'] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupExcludeGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupExcludeGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupExcludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupExcludeSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['AccessGroupExcludeAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param 'AccessGroupExcludeExternalEvaluationArgs' external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['AccessGroupExcludeGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['AccessGroupExcludeGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['AccessGroupExcludeOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['AccessGroupExcludeSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.AccessGroupExcludeAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupExcludeAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessGroupExcludeExternalEvaluation']:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupExcludeGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupExcludeGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupExcludeOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupExcludeSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupExcludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupExcludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessGroupExcludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.AccessGroupIncludeAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupIncludeAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluation: Optional['outputs.AccessGroupIncludeExternalEvaluation'] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupIncludeGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupIncludeGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupIncludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupIncludeSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['AccessGroupIncludeAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param 'AccessGroupIncludeExternalEvaluationArgs' external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['AccessGroupIncludeGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['AccessGroupIncludeGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['AccessGroupIncludeOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['AccessGroupIncludeSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.AccessGroupIncludeAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupIncludeAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessGroupIncludeExternalEvaluation']:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupIncludeGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupIncludeGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupIncludeOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupIncludeSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupIncludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupIncludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessGroupIncludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.AccessGroupRequireAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.AccessGroupRequireAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluation: Optional['outputs.AccessGroupRequireExternalEvaluation'] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.AccessGroupRequireGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessGroupRequireGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.AccessGroupRequireOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessGroupRequireSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['AccessGroupRequireAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param 'AccessGroupRequireExternalEvaluationArgs' external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['AccessGroupRequireGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['AccessGroupRequireGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['AccessGroupRequireOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['AccessGroupRequireSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.AccessGroupRequireAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessGroupRequireAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessGroupRequireExternalEvaluation']:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessGroupRequireGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessGroupRequireGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessGroupRequireOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessGroupRequireSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessGroupRequireAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupRequireAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessGroupRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessGroupRequireGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessGroupRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessGroupRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessGroupRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessGroupRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessGroupRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessGroupRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessIdentityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "appsDomain":
            suggest = "apps_domain"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "authorizationServerId":
            suggest = "authorization_server_id"
        elif key == "centrifyAccount":
            suggest = "centrify_account"
        elif key == "centrifyAppId":
            suggest = "centrify_app_id"
        elif key == "certsUrl":
            suggest = "certs_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "conditionalAccessEnabled":
            suggest = "conditional_access_enabled"
        elif key == "directoryId":
            suggest = "directory_id"
        elif key == "emailAttributeName":
            suggest = "email_attribute_name"
        elif key == "emailClaimName":
            suggest = "email_claim_name"
        elif key == "idpPublicCert":
            suggest = "idp_public_cert"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "oktaAccount":
            suggest = "okta_account"
        elif key == "oneloginAccount":
            suggest = "onelogin_account"
        elif key == "pingEnvId":
            suggest = "ping_env_id"
        elif key == "pkceEnabled":
            suggest = "pkce_enabled"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "signRequest":
            suggest = "sign_request"
        elif key == "ssoTargetUrl":
            suggest = "sso_target_url"
        elif key == "supportGroups":
            suggest = "support_groups"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessIdentityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessIdentityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessIdentityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional[builtins.str] = None,
                 apps_domain: Optional[builtins.str] = None,
                 attributes: Optional[Sequence[builtins.str]] = None,
                 auth_url: Optional[builtins.str] = None,
                 authorization_server_id: Optional[builtins.str] = None,
                 centrify_account: Optional[builtins.str] = None,
                 centrify_app_id: Optional[builtins.str] = None,
                 certs_url: Optional[builtins.str] = None,
                 claims: Optional[Sequence[builtins.str]] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 conditional_access_enabled: Optional[builtins.bool] = None,
                 directory_id: Optional[builtins.str] = None,
                 email_attribute_name: Optional[builtins.str] = None,
                 email_claim_name: Optional[builtins.str] = None,
                 idp_public_cert: Optional[builtins.str] = None,
                 issuer_url: Optional[builtins.str] = None,
                 okta_account: Optional[builtins.str] = None,
                 onelogin_account: Optional[builtins.str] = None,
                 ping_env_id: Optional[builtins.str] = None,
                 pkce_enabled: Optional[builtins.bool] = None,
                 redirect_url: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None,
                 sign_request: Optional[builtins.bool] = None,
                 sso_target_url: Optional[builtins.str] = None,
                 support_groups: Optional[builtins.bool] = None,
                 token_url: Optional[builtins.str] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if conditional_access_enabled is not None:
            pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            pulumi.set(__self__, "email_claim_name", email_claim_name)
        if idp_public_cert is not None:
            pulumi.set(__self__, "idp_public_cert", idp_public_cert)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if ping_env_id is not None:
            pulumi.set(__self__, "ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[builtins.str]:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[builtins.str]:
        return pulumi.get(self, "apps_domain")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "authorization_server_id")

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[builtins.str]:
        return pulumi.get(self, "centrify_account")

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "centrify_app_id")

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "certs_url")

    @property
    @pulumi.getter
    def claims(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "claims")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "conditional_access_enabled")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email_attribute_name")

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email_claim_name")

    @property
    @pulumi.getter(name="idpPublicCert")
    def idp_public_cert(self) -> Optional[builtins.str]:
        return pulumi.get(self, "idp_public_cert")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[builtins.str]:
        return pulumi.get(self, "okta_account")

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[builtins.str]:
        return pulumi.get(self, "onelogin_account")

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ping_env_id")

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "pkce_enabled")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "sign_request")

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "sso_target_url")

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "support_groups")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class AccessIdentityProviderScimConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupMemberDeprovision":
            suggest = "group_member_deprovision"
        elif key == "identityUpdateBehavior":
            suggest = "identity_update_behavior"
        elif key == "seatDeprovision":
            suggest = "seat_deprovision"
        elif key == "userDeprovision":
            suggest = "user_deprovision"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessIdentityProviderScimConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessIdentityProviderScimConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessIdentityProviderScimConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 group_member_deprovision: Optional[builtins.bool] = None,
                 identity_update_behavior: Optional[builtins.str] = None,
                 seat_deprovision: Optional[builtins.bool] = None,
                 secret: Optional[builtins.str] = None,
                 user_deprovision: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: A flag to enable or disable SCIM for the identity provider.
        :param builtins.bool group_member_deprovision: Deprecated. Use `identity_update_behavior`.
        :param builtins.str identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        :param builtins.bool seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param builtins.str secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        :param builtins.bool user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group_member_deprovision is not None:
            pulumi.set(__self__, "group_member_deprovision", group_member_deprovision)
        if identity_update_behavior is not None:
            pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="groupMemberDeprovision")
    def group_member_deprovision(self) -> Optional[builtins.bool]:
        """
        Deprecated. Use `identity_update_behavior`.
        """
        return pulumi.get(self, "group_member_deprovision")

    @property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> Optional[builtins.str]:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        return pulumi.get(self, "identity_update_behavior")

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[builtins.bool]:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @property
    @pulumi.getter
    def secret(self) -> Optional[builtins.str]:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[builtins.bool]:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")


@pulumi.output_type
class AccessMutualTlsHostnameSettingsSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chinaNetwork":
            suggest = "china_network"
        elif key == "clientCertificateForwarding":
            suggest = "client_certificate_forwarding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessMutualTlsHostnameSettingsSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessMutualTlsHostnameSettingsSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessMutualTlsHostnameSettingsSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: builtins.str,
                 china_network: Optional[builtins.bool] = None,
                 client_certificate_forwarding: Optional[builtins.bool] = None):
        """
        :param builtins.str hostname: The hostname that these settings apply to.
        :param builtins.bool china_network: Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        :param builtins.bool client_certificate_forwarding: Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        pulumi.set(__self__, "hostname", hostname)
        if china_network is not None:
            pulumi.set(__self__, "china_network", china_network)
        if client_certificate_forwarding is not None:
            pulumi.set(__self__, "client_certificate_forwarding", client_certificate_forwarding)

    @property
    @pulumi.getter
    def hostname(self) -> builtins.str:
        """
        The hostname that these settings apply to.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="chinaNetwork")
    def china_network(self) -> Optional[builtins.bool]:
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        return pulumi.get(self, "china_network")

    @property
    @pulumi.getter(name="clientCertificateForwarding")
    def client_certificate_forwarding(self) -> Optional[builtins.bool]:
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        return pulumi.get(self, "client_certificate_forwarding")


@pulumi.output_type
class AccessOrganizationCustomPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityDenied":
            suggest = "identity_denied"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessOrganizationCustomPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessOrganizationCustomPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessOrganizationCustomPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forbidden: Optional[builtins.str] = None,
                 identity_denied: Optional[builtins.str] = None):
        """
        :param builtins.str forbidden: The id of the forbidden page.
        :param builtins.str identity_denied: The id of the identity denied page.
        """
        if forbidden is not None:
            pulumi.set(__self__, "forbidden", forbidden)
        if identity_denied is not None:
            pulumi.set(__self__, "identity_denied", identity_denied)

    @property
    @pulumi.getter
    def forbidden(self) -> Optional[builtins.str]:
        """
        The id of the forbidden page.
        """
        return pulumi.get(self, "forbidden")

    @property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[builtins.str]:
        """
        The id of the identity denied page.
        """
        return pulumi.get(self, "identity_denied")


@pulumi.output_type
class AccessOrganizationLoginDesign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessOrganizationLoginDesign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessOrganizationLoginDesign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessOrganizationLoginDesign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[builtins.str] = None,
                 footer_text: Optional[builtins.str] = None,
                 header_text: Optional[builtins.str] = None,
                 logo_path: Optional[builtins.str] = None,
                 text_color: Optional[builtins.str] = None):
        """
        :param builtins.str background_color: The background color on the login page.
        :param builtins.str footer_text: The text at the bottom of the login page.
        :param builtins.str header_text: The text at the top of the login page.
        :param builtins.str logo_path: The URL of the logo on the login page.
        :param builtins.str text_color: The text color on the login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[builtins.str]:
        """
        The background color on the login page.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[builtins.str]:
        """
        The text at the bottom of the login page.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[builtins.str]:
        """
        The text at the top of the login page.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[builtins.str]:
        """
        The URL of the logo on the login page.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[builtins.str]:
        """
        The text color on the login page.
        """
        return pulumi.get(self, "text_color")


@pulumi.output_type
class AccessPolicyApprovalGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalsNeeded":
            suggest = "approvals_needed"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailListUuid":
            suggest = "email_list_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyApprovalGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyApprovalGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyApprovalGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approvals_needed: builtins.int,
                 email_addresses: Optional[Sequence[builtins.str]] = None,
                 email_list_uuid: Optional[builtins.str] = None):
        """
        :param builtins.int approvals_needed: Number of approvals needed.
        :param Sequence[builtins.str] email_addresses: List of emails to request approval from.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> builtins.int:
        """
        Number of approvals needed.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[builtins.str]]:
        """
        List of emails to request approval from.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class AccessPolicyConnectionRules(dict):
    def __init__(__self__, *,
                 ssh: 'outputs.AccessPolicyConnectionRulesSsh'):
        """
        :param 'AccessPolicyConnectionRulesSshArgs' ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def ssh(self) -> 'outputs.AccessPolicyConnectionRulesSsh':
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class AccessPolicyConnectionRulesSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowEmailAlias":
            suggest = "allow_email_alias"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyConnectionRulesSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyConnectionRulesSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyConnectionRulesSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usernames: Sequence[builtins.str],
                 allow_email_alias: Optional[builtins.bool] = None):
        """
        :param Sequence[builtins.str] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        :param builtins.bool allow_email_alias: Allows connecting to Unix username that matches the authenticating email prefix.
        """
        pulumi.set(__self__, "usernames", usernames)
        if allow_email_alias is not None:
            pulumi.set(__self__, "allow_email_alias", allow_email_alias)

    @property
    @pulumi.getter
    def usernames(self) -> Sequence[builtins.str]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")

    @property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> Optional[builtins.bool]:
        """
        Allows connecting to Unix username that matches the authenticating email prefix.
        """
        return pulumi.get(self, "allow_email_alias")


@pulumi.output_type
class AccessPolicyExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.AccessPolicyExcludeAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyExcludeAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluation: Optional['outputs.AccessPolicyExcludeExternalEvaluation'] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyExcludeGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyExcludeGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyExcludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyExcludeSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['AccessPolicyExcludeAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param 'AccessPolicyExcludeExternalEvaluationArgs' external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['AccessPolicyExcludeGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['AccessPolicyExcludeGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['AccessPolicyExcludeOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['AccessPolicyExcludeSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.AccessPolicyExcludeAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyExcludeAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessPolicyExcludeExternalEvaluation']:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyExcludeGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyExcludeGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyExcludeOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyExcludeSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyExcludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyExcludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessPolicyExcludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.AccessPolicyIncludeAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyIncludeAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluation: Optional['outputs.AccessPolicyIncludeExternalEvaluation'] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyIncludeGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyIncludeGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyIncludeOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyIncludeSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['AccessPolicyIncludeAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param 'AccessPolicyIncludeExternalEvaluationArgs' external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['AccessPolicyIncludeGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['AccessPolicyIncludeGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['AccessPolicyIncludeOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['AccessPolicyIncludeSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.AccessPolicyIncludeAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyIncludeAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessPolicyIncludeExternalEvaluation']:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyIncludeGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyIncludeGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyIncludeOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyIncludeSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyIncludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyIncludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessPolicyIncludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluation":
            suggest = "external_evaluation"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.AccessPolicyRequireAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.AccessPolicyRequireAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluation: Optional['outputs.AccessPolicyRequireExternalEvaluation'] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.AccessPolicyRequireGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.AccessPolicyRequireGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.AccessPolicyRequireOkta']] = None,
                 samls: Optional[Sequence['outputs.AccessPolicyRequireSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['AccessPolicyRequireAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param 'AccessPolicyRequireExternalEvaluationArgs' external_evaluation: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['AccessPolicyRequireGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['AccessPolicyRequireGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['AccessPolicyRequireOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['AccessPolicyRequireSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.AccessPolicyRequireAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.AccessPolicyRequireAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional['outputs.AccessPolicyRequireExternalEvaluation']:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluation")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.AccessPolicyRequireGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.AccessPolicyRequireGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.AccessPolicyRequireOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.AccessPolicyRequireSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class AccessPolicyRequireAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyRequireAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class AccessPolicyRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class AccessPolicyRequireGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class AccessPolicyRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessPolicyRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class AccessPolicyRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessPolicyRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessPolicyRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessPolicyRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class AccessRuleConfiguration(dict):
    def __init__(__self__, *,
                 target: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str target: The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        :param builtins.str value: The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AddressMapIp(dict):
    def __init__(__self__, *,
                 ip: builtins.str):
        """
        :param builtins.str ip: An IPv4 or IPv6 address.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        An IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class AddressMapMembership(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canDelete":
            suggest = "can_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddressMapMembership. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddressMapMembership.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddressMapMembership.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifier: builtins.str,
                 kind: builtins.str,
                 can_delete: Optional[builtins.bool] = None):
        """
        :param builtins.str identifier: Identifier of the account or zone.
        :param builtins.str kind: The type of the membership.
        :param builtins.bool can_delete: Controls whether the membership can be deleted via the API or not.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "kind", kind)
        if can_delete is not None:
            pulumi.set(__self__, "can_delete", can_delete)

    @property
    @pulumi.getter
    def identifier(self) -> builtins.str:
        """
        Identifier of the account or zone.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        The type of the membership.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> Optional[builtins.bool]:
        """
        Controls whether the membership can be deleted via the API or not.
        """
        return pulumi.get(self, "can_delete")


@pulumi.output_type
class ApiShieldAuthIdCharacteristic(dict):
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the characteristic.
        :param builtins.str type: The type of characteristic. Available values: `header`, `cookie`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the characteristic.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The type of characteristic. Available values: `header`, `cookie`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApiTokenCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestIp":
            suggest = "request_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_ip: Optional['outputs.ApiTokenConditionRequestIp'] = None):
        """
        :param 'ApiTokenConditionRequestIpArgs' request_ip: Request IP related conditions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional['outputs.ApiTokenConditionRequestIp']:
        """
        Request IP related conditions.
        """
        return pulumi.get(self, "request_ip")


@pulumi.output_type
class ApiTokenConditionRequestIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notIns":
            suggest = "not_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenConditionRequestIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenConditionRequestIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenConditionRequestIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ins: Optional[Sequence[builtins.str]] = None,
                 not_ins: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] ins: List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
        :param Sequence[builtins.str] not_ins: List of IP addresses or CIDR notation where the token should not be used from.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP addresses or CIDR notation where the token should not be used from.
        """
        return pulumi.get(self, "not_ins")


@pulumi.output_type
class ApiTokenPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionGroups":
            suggest = "permission_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiTokenPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiTokenPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiTokenPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission_groups: Sequence[builtins.str],
                 resources: Mapping[str, builtins.str],
                 effect: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] permission_groups: List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        :param Mapping[str, builtins.str] resources: Describes what operations against which resources are allowed or denied.
        :param builtins.str effect: Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> Sequence[builtins.str]:
        """
        List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
        """
        return pulumi.get(self, "permission_groups")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, builtins.str]:
        """
        Describes what operations against which resources are allowed or denied.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def effect(self) -> Optional[builtins.str]:
        """
        Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
        """
        return pulumi.get(self, "effect")


@pulumi.output_type
class CertificatePackValidationError(dict):
    def __init__(__self__, *,
                 message: Optional[builtins.str] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class CertificatePackValidationRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cnameName":
            suggest = "cname_name"
        elif key == "cnameTarget":
            suggest = "cname_target"
        elif key == "httpBody":
            suggest = "http_body"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "txtName":
            suggest = "txt_name"
        elif key == "txtValue":
            suggest = "txt_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificatePackValidationRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificatePackValidationRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificatePackValidationRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cname_name: Optional[builtins.str] = None,
                 cname_target: Optional[builtins.str] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 http_body: Optional[builtins.str] = None,
                 http_url: Optional[builtins.str] = None,
                 txt_name: Optional[builtins.str] = None,
                 txt_value: Optional[builtins.str] = None):
        if cname_name is not None:
            pulumi.set(__self__, "cname_name", cname_name)
        if cname_target is not None:
            pulumi.set(__self__, "cname_target", cname_target)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cname_name")

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cname_target")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[builtins.str]:
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[builtins.str]:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class CloudConnectorRulesRule(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 provider: builtins.str,
                 description: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 parameters: Optional['outputs.CloudConnectorRulesRuleParameters'] = None):
        """
        :param builtins.str expression: Criteria for an HTTP request to trigger the cloud connector rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        :param builtins.str provider: Type of provider. Available values: `aws_s3`, `cloudflare_r2`, `azure_storage`, `gcp_storage`
        :param builtins.str description: Brief summary of the cloud connector rule and its intended use.
        :param builtins.bool enabled: Whether the headers rule is active.
        :param 'CloudConnectorRulesRuleParametersArgs' parameters: Cloud Connector Rule Parameters
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "provider", provider)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        Criteria for an HTTP request to trigger the cloud connector rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def provider(self) -> builtins.str:
        """
        Type of provider. Available values: `aws_s3`, `cloudflare_r2`, `azure_storage`, `gcp_storage`
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Brief summary of the cloud connector rule and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def parameters(self) -> Optional['outputs.CloudConnectorRulesRuleParameters']:
        """
        Cloud Connector Rule Parameters
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class CloudConnectorRulesRuleParameters(dict):
    def __init__(__self__, *,
                 host: builtins.str):
        """
        :param builtins.str host: Host parameter for cloud connector rule
        """
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        Host parameter for cloud connector rule
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class CustomHostnameSsl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bundleMethod":
            suggest = "bundle_method"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "customCertificate":
            suggest = "custom_certificate"
        elif key == "customKey":
            suggest = "custom_key"
        elif key == "validationErrors":
            suggest = "validation_errors"
        elif key == "validationRecords":
            suggest = "validation_records"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSsl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSsl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSsl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundle_method: Optional[builtins.str] = None,
                 certificate_authority: Optional[builtins.str] = None,
                 custom_certificate: Optional[builtins.str] = None,
                 custom_key: Optional[builtins.str] = None,
                 method: Optional[builtins.str] = None,
                 settings: Optional[Sequence['outputs.CustomHostnameSslSetting']] = None,
                 status: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 validation_errors: Optional[Sequence['outputs.CustomHostnameSslValidationError']] = None,
                 validation_records: Optional[Sequence['outputs.CustomHostnameSslValidationRecord']] = None,
                 wildcard: Optional[builtins.bool] = None):
        """
        :param builtins.str bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        :param builtins.str custom_certificate: If a custom uploaded certificate is used.
        :param builtins.str custom_key: The key for a custom uploaded certificate.
        :param builtins.str method: Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        :param Sequence['CustomHostnameSslSettingArgs'] settings: SSL/TLS settings for the certificate.
        :param builtins.str type: Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        :param builtins.bool wildcard: Indicates whether the certificate covers a wildcard.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)
        if validation_records is not None:
            pulumi.set(__self__, "validation_records", validation_records)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[builtins.str]:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[builtins.str]:
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[builtins.str]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[builtins.str]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter
    def method(self) -> Optional[builtins.str]:
        """
        Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Sequence['outputs.CustomHostnameSslSetting']]:
        """
        SSL/TLS settings for the certificate.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[Sequence['outputs.CustomHostnameSslValidationError']]:
        return pulumi.get(self, "validation_errors")

    @property
    @pulumi.getter(name="validationRecords")
    def validation_records(self) -> Optional[Sequence['outputs.CustomHostnameSslValidationRecord']]:
        return pulumi.get(self, "validation_records")

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[builtins.bool]:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")


@pulumi.output_type
class CustomHostnameSslSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earlyHints":
            suggest = "early_hints"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSslSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSslSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSslSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ciphers: Optional[Sequence[builtins.str]] = None,
                 early_hints: Optional[builtins.str] = None,
                 http2: Optional[builtins.str] = None,
                 min_tls_version: Optional[builtins.str] = None,
                 tls13: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] ciphers: List of SSL/TLS ciphers to associate with this certificate.
        :param builtins.str early_hints: Whether early hints should be supported. Available values: `on`, `off`.
        :param builtins.str http2: Whether HTTP2 should be supported. Available values: `on`, `off`.
        :param builtins.str min_tls_version: Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
        :param builtins.str tls13: Whether TLSv1.3 should be supported. Available values: `on`, `off`.
        """
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[builtins.str]]:
        """
        List of SSL/TLS ciphers to associate with this certificate.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[builtins.str]:
        """
        Whether early hints should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter
    def http2(self) -> Optional[builtins.str]:
        """
        Whether HTTP2 should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[builtins.str]:
        """
        Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[builtins.str]:
        """
        Whether TLSv1.3 should be supported. Available values: `on`, `off`.
        """
        return pulumi.get(self, "tls13")


@pulumi.output_type
class CustomHostnameSslValidationError(dict):
    def __init__(__self__, *,
                 message: Optional[builtins.str] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class CustomHostnameSslValidationRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cnameName":
            suggest = "cname_name"
        elif key == "cnameTarget":
            suggest = "cname_target"
        elif key == "httpBody":
            suggest = "http_body"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "txtName":
            suggest = "txt_name"
        elif key == "txtValue":
            suggest = "txt_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHostnameSslValidationRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHostnameSslValidationRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHostnameSslValidationRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cname_name: Optional[builtins.str] = None,
                 cname_target: Optional[builtins.str] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 http_body: Optional[builtins.str] = None,
                 http_url: Optional[builtins.str] = None,
                 txt_name: Optional[builtins.str] = None,
                 txt_value: Optional[builtins.str] = None):
        if cname_name is not None:
            pulumi.set(__self__, "cname_name", cname_name)
        if cname_target is not None:
            pulumi.set(__self__, "cname_target", cname_target)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="cnameName")
    def cname_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cname_name")

    @property
    @pulumi.getter(name="cnameTarget")
    def cname_target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cname_target")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[builtins.str]:
        return pulumi.get(self, "http_body")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "txt_name")

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[builtins.str]:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class CustomSslCustomSslOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bundleMethod":
            suggest = "bundle_method"
        elif key == "geoRestrictions":
            suggest = "geo_restrictions"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomSslCustomSslOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomSslCustomSslOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomSslCustomSslOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundle_method: Optional[builtins.str] = None,
                 certificate: Optional[builtins.str] = None,
                 geo_restrictions: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str bundle_method: Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        :param builtins.str certificate: Certificate certificate and the intermediate(s).
        :param builtins.str geo_restrictions: Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        :param builtins.str private_key: Certificate's private key.
        :param builtins.str type: Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if geo_restrictions is not None:
            pulumi.set(__self__, "geo_restrictions", geo_restrictions)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[builtins.str]:
        """
        Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        """
        return pulumi.get(self, "bundle_method")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.str]:
        """
        Certificate certificate and the intermediate(s).
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="geoRestrictions")
    def geo_restrictions(self) -> Optional[builtins.str]:
        """
        Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
        """
        return pulumi.get(self, "geo_restrictions")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        """
        Certificate's private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CustomSslCustomSslPriority(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 priority: Optional[builtins.int] = None):
        """
        :param builtins.str id: The ID of this resource.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def priority(self) -> Optional[builtins.int]:
        return pulumi.get(self, "priority")


@pulumi.output_type
class DeviceDexTestData(dict):
    def __init__(__self__, *,
                 host: builtins.str,
                 kind: builtins.str,
                 method: Optional[builtins.str] = None):
        """
        :param builtins.str host: The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        :param builtins.str kind: The type of Device Dex Test. Available values: `http`, `traceroute`.
        :param builtins.str method: The http request method. Available values: `GET`.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        The type of Device Dex Test. Available values: `http`, `traceroute`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def method(self) -> Optional[builtins.str]:
        """
        The http request method. Available values: `GET`.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class DeviceManagedNetworksConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSockaddr":
            suggest = "tls_sockaddr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceManagedNetworksConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceManagedNetworksConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceManagedNetworksConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sha256: builtins.str,
                 tls_sockaddr: builtins.str):
        """
        :param builtins.str sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        :param builtins.str tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)

    @property
    @pulumi.getter
    def sha256(self) -> builtins.str:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> builtins.str:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")


@pulumi.output_type
class DevicePostureIntegrationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessClientId":
            suggest = "access_client_id"
        elif key == "accessClientSecret":
            suggest = "access_client_secret"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customerId":
            suggest = "customer_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevicePostureIntegrationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevicePostureIntegrationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevicePostureIntegrationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_client_id: Optional[builtins.str] = None,
                 access_client_secret: Optional[builtins.str] = None,
                 api_url: Optional[builtins.str] = None,
                 auth_url: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_key: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 customer_id: Optional[builtins.str] = None):
        """
        :param builtins.str access_client_id: The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        :param builtins.str access_client_secret: The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        :param builtins.str api_url: The third-party API's URL.
        :param builtins.str auth_url: The third-party authorization API URL.
        :param builtins.str client_id: The client identifier for authenticating API calls.
        :param builtins.str client_key: The client key for authenticating API calls.
        :param builtins.str client_secret: The client secret for authenticating API calls.
        :param builtins.str customer_id: The customer identifier for authenticating API calls.
        """
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[builtins.str]:
        """
        The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        """
        return pulumi.get(self, "access_client_id")

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[builtins.str]:
        """
        The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        """
        return pulumi.get(self, "access_client_secret")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[builtins.str]:
        """
        The third-party API's URL.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[builtins.str]:
        """
        The third-party authorization API URL.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The client identifier for authenticating API calls.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[builtins.str]:
        """
        The client key for authenticating API calls.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The client secret for authenticating API calls.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[builtins.str]:
        """
        The customer identifier for authenticating API calls.
        """
        return pulumi.get(self, "customer_id")


@pulumi.output_type
class DevicePostureRuleInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeThreats":
            suggest = "active_threats"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "checkDisks":
            suggest = "check_disks"
        elif key == "checkPrivateKey":
            suggest = "check_private_key"
        elif key == "complianceStatus":
            suggest = "compliance_status"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "countOperator":
            suggest = "count_operator"
        elif key == "eidLastSeen":
            suggest = "eid_last_seen"
        elif key == "extendedKeyUsages":
            suggest = "extended_key_usages"
        elif key == "isActive":
            suggest = "is_active"
        elif key == "issueCount":
            suggest = "issue_count"
        elif key == "lastSeen":
            suggest = "last_seen"
        elif key == "networkStatus":
            suggest = "network_status"
        elif key == "operationalState":
            suggest = "operational_state"
        elif key == "osDistroName":
            suggest = "os_distro_name"
        elif key == "osDistroRevision":
            suggest = "os_distro_revision"
        elif key == "osVersionExtra":
            suggest = "os_version_extra"
        elif key == "requireAll":
            suggest = "require_all"
        elif key == "riskLevel":
            suggest = "risk_level"
        elif key == "sensorConfig":
            suggest = "sensor_config"
        elif key == "totalScore":
            suggest = "total_score"
        elif key == "versionOperator":
            suggest = "version_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevicePostureRuleInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevicePostureRuleInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevicePostureRuleInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_threats: Optional[builtins.int] = None,
                 certificate_id: Optional[builtins.str] = None,
                 check_disks: Optional[Sequence[builtins.str]] = None,
                 check_private_key: Optional[builtins.bool] = None,
                 cn: Optional[builtins.str] = None,
                 compliance_status: Optional[builtins.str] = None,
                 connection_id: Optional[builtins.str] = None,
                 count_operator: Optional[builtins.str] = None,
                 domain: Optional[builtins.str] = None,
                 eid_last_seen: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 exists: Optional[builtins.bool] = None,
                 extended_key_usages: Optional[Sequence[builtins.str]] = None,
                 id: Optional[builtins.str] = None,
                 infected: Optional[builtins.bool] = None,
                 is_active: Optional[builtins.bool] = None,
                 issue_count: Optional[builtins.str] = None,
                 last_seen: Optional[builtins.str] = None,
                 locations: Optional[Sequence['outputs.DevicePostureRuleInputLocation']] = None,
                 network_status: Optional[builtins.str] = None,
                 operational_state: Optional[builtins.str] = None,
                 operator: Optional[builtins.str] = None,
                 os: Optional[builtins.str] = None,
                 os_distro_name: Optional[builtins.str] = None,
                 os_distro_revision: Optional[builtins.str] = None,
                 os_version_extra: Optional[builtins.str] = None,
                 overall: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None,
                 require_all: Optional[builtins.bool] = None,
                 risk_level: Optional[builtins.str] = None,
                 running: Optional[builtins.bool] = None,
                 score: Optional[builtins.int] = None,
                 sensor_config: Optional[builtins.str] = None,
                 sha256: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None,
                 total_score: Optional[builtins.int] = None,
                 version: Optional[builtins.str] = None,
                 version_operator: Optional[builtins.str] = None):
        """
        :param builtins.int active_threats: The number of active threats from SentinelOne.
        :param builtins.str certificate_id: The UUID of a Cloudflare managed certificate.
        :param Sequence[builtins.str] check_disks: Specific volume(s) to check for encryption.
        :param builtins.bool check_private_key: Confirm the certificate was not imported from another device.
        :param builtins.str cn: The common name for a certificate.
        :param builtins.str compliance_status: The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        :param builtins.str connection_id: The workspace one or intune connection id.
        :param builtins.str count_operator: The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param builtins.str domain: The domain that the client must join.
        :param builtins.str eid_last_seen: The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        :param builtins.bool enabled: True if the firewall must be enabled.
        :param builtins.bool exists: Checks if the file should exist.
        :param Sequence[builtins.str] extended_key_usages: List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        :param builtins.str id: The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        :param builtins.bool infected: True if SentinelOne device is infected.
        :param builtins.bool is_active: True if SentinelOne device is active.
        :param builtins.str issue_count: The number of issues for kolide.
        :param builtins.str last_seen: The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        :param Sequence['DevicePostureRuleInputLocationArgs'] locations: List of operating system locations to check for a client certificate..
        :param builtins.str network_status: The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        :param builtins.str operational_state: The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        :param builtins.str operator: The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param builtins.str os: OS signal score from Crowdstrike. Value must be between 1 and 100.
        :param builtins.str os_distro_name: The operating system excluding version information.
        :param builtins.str os_distro_revision: The operating system version excluding OS name information or release name.
        :param builtins.str os_version_extra: Extra version value following the operating system semantic version.
        :param builtins.str overall: Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        :param builtins.str path: The path to the file.
        :param builtins.bool require_all: True if all drives must be encrypted.
        :param builtins.str risk_level: The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        :param builtins.bool running: Checks if the application should be running.
        :param builtins.int score: A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        :param builtins.str sensor_config: Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        :param builtins.str sha256: The sha256 hash of the file.
        :param builtins.str state: The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        :param builtins.str thumbprint: The thumbprint of the file certificate.
        :param builtins.int total_score: The total score from Tanium.
        :param builtins.str version: The operating system semantic version.
        :param builtins.str version_operator: The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if check_private_key is not None:
            pulumi.set(__self__, "check_private_key", check_private_key)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if eid_last_seen is not None:
            pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)
        if running is not None:
            pulumi.set(__self__, "running", running)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if total_score is not None:
            pulumi.set(__self__, "total_score", total_score)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[builtins.int]:
        """
        The number of active threats from SentinelOne.
        """
        return pulumi.get(self, "active_threats")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[builtins.str]:
        """
        The UUID of a Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[Sequence[builtins.str]]:
        """
        Specific volume(s) to check for encryption.
        """
        return pulumi.get(self, "check_disks")

    @property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> Optional[builtins.bool]:
        """
        Confirm the certificate was not imported from another device.
        """
        return pulumi.get(self, "check_private_key")

    @property
    @pulumi.getter
    def cn(self) -> Optional[builtins.str]:
        """
        The common name for a certificate.
        """
        return pulumi.get(self, "cn")

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[builtins.str]:
        """
        The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        """
        return pulumi.get(self, "compliance_status")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[builtins.str]:
        """
        The workspace one or intune connection id.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[builtins.str]:
        """
        The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "count_operator")

    @property
    @pulumi.getter
    def domain(self) -> Optional[builtins.str]:
        """
        The domain that the client must join.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[builtins.str]:
        """
        The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        return pulumi.get(self, "eid_last_seen")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        True if the firewall must be enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exists(self) -> Optional[builtins.bool]:
        """
        Checks if the file should exist.
        """
        return pulumi.get(self, "exists")

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[Sequence[builtins.str]]:
        """
        List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        """
        return pulumi.get(self, "extended_key_usages")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def infected(self) -> Optional[builtins.bool]:
        """
        True if SentinelOne device is infected.
        """
        return pulumi.get(self, "infected")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[builtins.bool]:
        """
        True if SentinelOne device is active.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[builtins.str]:
        """
        The number of issues for kolide.
        """
        return pulumi.get(self, "issue_count")

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[builtins.str]:
        """
        The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        return pulumi.get(self, "last_seen")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.DevicePostureRuleInputLocation']]:
        """
        List of operating system locations to check for a client certificate..
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[builtins.str]:
        """
        The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        """
        return pulumi.get(self, "network_status")

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[builtins.str]:
        """
        The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        """
        return pulumi.get(self, "operational_state")

    @property
    @pulumi.getter
    def operator(self) -> Optional[builtins.str]:
        """
        The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def os(self) -> Optional[builtins.str]:
        """
        OS signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "os")

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[builtins.str]:
        """
        The operating system excluding version information.
        """
        return pulumi.get(self, "os_distro_name")

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[builtins.str]:
        """
        The operating system version excluding OS name information or release name.
        """
        return pulumi.get(self, "os_distro_revision")

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[builtins.str]:
        """
        Extra version value following the operating system semantic version.
        """
        return pulumi.get(self, "os_version_extra")

    @property
    @pulumi.getter
    def overall(self) -> Optional[builtins.str]:
        """
        Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "overall")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The path to the file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[builtins.bool]:
        """
        True if all drives must be encrypted.
        """
        return pulumi.get(self, "require_all")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[builtins.str]:
        """
        The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "risk_level")

    @property
    @pulumi.getter
    def running(self) -> Optional[builtins.bool]:
        """
        Checks if the application should be running.
        """
        return pulumi.get(self, "running")

    @property
    @pulumi.getter
    def score(self) -> Optional[builtins.int]:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[builtins.str]:
        """
        Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "sensor_config")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[builtins.str]:
        """
        The sha256 hash of the file.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of the file certificate.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[builtins.int]:
        """
        The total score from Tanium.
        """
        return pulumi.get(self, "total_score")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        The operating system semantic version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[builtins.str]:
        """
        The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "version_operator")


@pulumi.output_type
class DevicePostureRuleInputLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustStores":
            suggest = "trust_stores"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevicePostureRuleInputLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevicePostureRuleInputLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevicePostureRuleInputLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paths: Optional[Sequence[builtins.str]] = None,
                 trust_stores: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] paths: List of paths to check for client certificate rule.
        :param Sequence[builtins.str] trust_stores: List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if trust_stores is not None:
            pulumi.set(__self__, "trust_stores", trust_stores)

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[builtins.str]]:
        """
        List of paths to check for client certificate rule.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Optional[Sequence[builtins.str]]:
        """
        List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
        return pulumi.get(self, "trust_stores")


@pulumi.output_type
class DevicePostureRuleMatch(dict):
    def __init__(__self__, *,
                 platform: Optional[builtins.str] = None):
        """
        :param builtins.str platform: The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[builtins.str]:
        """
        The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class DlpProfileContextAwareness(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool,
                 skip: 'outputs.DlpProfileContextAwarenessSkip'):
        """
        :param builtins.bool enabled: Scan the context of predefined entries to only return matches surrounded by keywords.
        :param 'DlpProfileContextAwarenessSkipArgs' skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def skip(self) -> 'outputs.DlpProfileContextAwarenessSkip':
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")


@pulumi.output_type
class DlpProfileContextAwarenessSkip(dict):
    def __init__(__self__, *,
                 files: builtins.bool):
        """
        :param builtins.bool files: Return all matches, regardless of context analysis result, if the data is a file.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> builtins.bool:
        """
        Return all matches, regardless of context analysis result, if the data is a file.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class DlpProfileEntry(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 enabled: Optional[builtins.bool] = None,
                 id: Optional[builtins.str] = None,
                 pattern: Optional['outputs.DlpProfileEntryPattern'] = None):
        """
        :param builtins.str name: Name of the entry to deploy.
        :param builtins.bool enabled: Whether the entry is active. Defaults to `false`.
        :param builtins.str id: Unique entry identifier.
        """
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the entry to deploy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether the entry is active. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Unique entry identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['outputs.DlpProfileEntryPattern']:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class DlpProfileEntryPattern(dict):
    def __init__(__self__, *,
                 regex: builtins.str,
                 validation: Optional[builtins.str] = None):
        """
        :param builtins.str regex: The regex that defines the pattern.
        :param builtins.str validation: The validation algorithm to apply with this pattern.
        """
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> builtins.str:
        """
        The regex that defines the pattern.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> Optional[builtins.str]:
        """
        The validation algorithm to apply with this pattern.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class EmailRoutingCatchAllAction(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str type: Type of supported action. Available values: `drop`, `forward`, `worker`.
        :param Sequence[builtins.str] values: A list with items in the following form.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of supported action. Available values: `drop`, `forward`, `worker`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        A list with items in the following form.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class EmailRoutingCatchAllMatcher(dict):
    def __init__(__self__, *,
                 type: builtins.str):
        """
        :param builtins.str type: Type of matcher. Available values: `all`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of matcher. Available values: `all`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EmailRoutingRuleAction(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str type: Type of action. Available values: `forward`, `worker`, `drop`
        :param Sequence[builtins.str] values: Value to match on. Required for `type` of `literal`.
        """
        pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of action. Available values: `forward`, `worker`, `drop`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        Value to match on. Required for `type` of `literal`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class EmailRoutingRuleMatcher(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 field: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str type: Type of matcher. Available values: `literal`, `all`
        :param builtins.str field: Field to match on. Required for `type` of `literal`.
        :param builtins.str value: Value to match on. Required for `type` of `literal`.
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of matcher. Available values: `literal`, `all`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        """
        Field to match on. Required for `type` of `literal`.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value to match on. Required for `type` of `literal`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FallbackDomainDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FallbackDomainDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FallbackDomainDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FallbackDomainDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[builtins.str] = None,
                 dns_servers: Optional[Sequence[builtins.str]] = None,
                 suffix: Optional[builtins.str] = None):
        """
        :param builtins.str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[builtins.str] dns_servers: A list of IP addresses to handle domain resolution.
        :param builtins.str suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[builtins.str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class HealthcheckHeader(dict):
    def __init__(__self__, *,
                 header: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str header: The header name.
        :param Sequence[builtins.str] values: A list of string values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> builtins.str:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        A list of string values for the header.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class HyperdriveConfigCaching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"
        elif key == "staleWhileRevalidate":
            suggest = "stale_while_revalidate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HyperdriveConfigCaching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HyperdriveConfigCaching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HyperdriveConfigCaching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[builtins.bool] = None,
                 max_age: Optional[builtins.int] = None,
                 stale_while_revalidate: Optional[builtins.int] = None):
        """
        :param builtins.bool disabled: Disable caching for this Hyperdrive configuration.
        :param builtins.int max_age: Configure the `max_age` value of this Hyperdrive configuration.
        :param builtins.int stale_while_revalidate: Disable caching for this Hyperdrive configuration.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if stale_while_revalidate is not None:
            pulumi.set(__self__, "stale_while_revalidate", stale_while_revalidate)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[builtins.bool]:
        """
        Disable caching for this Hyperdrive configuration.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[builtins.int]:
        """
        Configure the `max_age` value of this Hyperdrive configuration.
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="staleWhileRevalidate")
    def stale_while_revalidate(self) -> Optional[builtins.int]:
        """
        Disable caching for this Hyperdrive configuration.
        """
        return pulumi.get(self, "stale_while_revalidate")


@pulumi.output_type
class HyperdriveConfigOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessClientId":
            suggest = "access_client_id"
        elif key == "accessClientSecret":
            suggest = "access_client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HyperdriveConfigOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HyperdriveConfigOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HyperdriveConfigOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: builtins.str,
                 host: builtins.str,
                 password: builtins.str,
                 scheme: builtins.str,
                 user: builtins.str,
                 access_client_id: Optional[builtins.str] = None,
                 access_client_secret: Optional[builtins.str] = None,
                 port: Optional[builtins.int] = None):
        """
        :param builtins.str database: The name of your origin database.
        :param builtins.str host: The host (hostname or IP) of your origin database.
        :param builtins.str password: The password of the Hyperdrive configuration.
        :param builtins.str scheme: Specifies the URL scheme used to connect to your origin database.
        :param builtins.str user: The user of your origin database.
        :param builtins.str access_client_id: Client ID associated with the Cloudflare Access Service Token used to connect via Access.
        :param builtins.str access_client_secret: Client Secret associated with the Cloudflare Access Service Token used to connect via Access.
        :param builtins.int port: The port (default: 5432 for Postgres) of your origin database.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "user", user)
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> builtins.str:
        """
        The name of your origin database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        The host (hostname or IP) of your origin database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        """
        The password of the Hyperdrive configuration.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def scheme(self) -> builtins.str:
        """
        Specifies the URL scheme used to connect to your origin database.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def user(self) -> builtins.str:
        """
        The user of your origin database.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[builtins.str]:
        """
        Client ID associated with the Cloudflare Access Service Token used to connect via Access.
        """
        return pulumi.get(self, "access_client_id")

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[builtins.str]:
        """
        Client Secret associated with the Cloudflare Access Service Token used to connect via Access.
        """
        return pulumi.get(self, "access_client_secret")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        The port (default: 5432 for Postgres) of your origin database.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class InfrastructureAccessTargetIp(dict):
    def __init__(__self__, *,
                 ipv4: Optional['outputs.InfrastructureAccessTargetIpIpv4'] = None,
                 ipv6: Optional['outputs.InfrastructureAccessTargetIpIpv6'] = None):
        """
        :param 'InfrastructureAccessTargetIpIpv4Args' ipv4: The target's IPv4 address.
        :param 'InfrastructureAccessTargetIpIpv6Args' ipv6: The target's IPv6 address.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.InfrastructureAccessTargetIpIpv4']:
        """
        The target's IPv4 address.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.InfrastructureAccessTargetIpIpv6']:
        """
        The target's IPv6 address.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class InfrastructureAccessTargetIpIpv4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddr":
            suggest = "ip_addr"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructureAccessTargetIpIpv4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructureAccessTargetIpIpv4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructureAccessTargetIpIpv4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addr: builtins.str,
                 virtual_network_id: builtins.str):
        """
        :param builtins.str ip_addr: The IP address of the target.
        :param builtins.str virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> builtins.str:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class InfrastructureAccessTargetIpIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddr":
            suggest = "ip_addr"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructureAccessTargetIpIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructureAccessTargetIpIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructureAccessTargetIpIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addr: builtins.str,
                 virtual_network_id: builtins.str):
        """
        :param builtins.str ip_addr: The IP address of the target.
        :param builtins.str virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> builtins.str:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class ListItem(dict):
    def __init__(__self__, *,
                 comment: Optional[builtins.str] = None,
                 value: Optional['outputs.ListItemValue'] = None):
        """
        :param builtins.str comment: An optional comment for the item.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[builtins.str]:
        """
        An optional comment for the item.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ListItemValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ListItemHostname(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlHostname":
            suggest = "url_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemHostname. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemHostname.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemHostname.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_hostname: builtins.str):
        """
        :param builtins.str url_hostname: The FQDN to match on.
        """
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> builtins.str:
        """
        The FQDN to match on.
        """
        return pulumi.get(self, "url_hostname")


@pulumi.output_type
class ListItemRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceUrl":
            suggest = "source_url"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "preservePathSuffix":
            suggest = "preserve_path_suffix"
        elif key == "preserveQueryString":
            suggest = "preserve_query_string"
        elif key == "statusCode":
            suggest = "status_code"
        elif key == "subpathMatching":
            suggest = "subpath_matching"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_url: builtins.str,
                 target_url: builtins.str,
                 include_subdomains: Optional[builtins.bool] = None,
                 preserve_path_suffix: Optional[builtins.bool] = None,
                 preserve_query_string: Optional[builtins.bool] = None,
                 status_code: Optional[builtins.int] = None,
                 subpath_matching: Optional[builtins.bool] = None):
        """
        :param builtins.str source_url: The source url of the redirect.
        :param builtins.str target_url: The target url of the redirect.
        :param builtins.bool include_subdomains: Whether the redirect also matches subdomains of the source url.
        :param builtins.bool preserve_path_suffix: Whether the redirect target url should keep the query string of the request's url.
        :param builtins.bool preserve_query_string: Whether the redirect target url should keep the query string of the request's url.
        :param builtins.int status_code: The status code to be used when redirecting a request.
        :param builtins.bool subpath_matching: Whether the redirect also matches subpaths of the source url.
        """
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> builtins.str:
        """
        The source url of the redirect.
        """
        return pulumi.get(self, "source_url")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> builtins.str:
        """
        The target url of the redirect.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[builtins.bool]:
        """
        Whether the redirect also matches subdomains of the source url.
        """
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[builtins.bool]:
        """
        Whether the redirect target url should keep the query string of the request's url.
        """
        return pulumi.get(self, "preserve_path_suffix")

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[builtins.bool]:
        """
        Whether the redirect target url should keep the query string of the request's url.
        """
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        The status code to be used when redirecting a request.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[builtins.bool]:
        """
        Whether the redirect also matches subpaths of the source url.
        """
        return pulumi.get(self, "subpath_matching")


@pulumi.output_type
class ListItemValue(dict):
    def __init__(__self__, *,
                 asn: Optional[builtins.int] = None,
                 hostnames: Optional[Sequence['outputs.ListItemValueHostname']] = None,
                 ip: Optional[builtins.str] = None,
                 redirects: Optional[Sequence['outputs.ListItemValueRedirect']] = None):
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def asn(self) -> Optional[builtins.int]:
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence['outputs.ListItemValueHostname']]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.ListItemValueRedirect']]:
        return pulumi.get(self, "redirects")


@pulumi.output_type
class ListItemValueHostname(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlHostname":
            suggest = "url_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemValueHostname. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemValueHostname.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemValueHostname.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_hostname: builtins.str):
        """
        :param builtins.str url_hostname: The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
        """
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> builtins.str:
        """
        The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
        """
        return pulumi.get(self, "url_hostname")


@pulumi.output_type
class ListItemValueRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceUrl":
            suggest = "source_url"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "preservePathSuffix":
            suggest = "preserve_path_suffix"
        elif key == "preserveQueryString":
            suggest = "preserve_query_string"
        elif key == "statusCode":
            suggest = "status_code"
        elif key == "subpathMatching":
            suggest = "subpath_matching"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListItemValueRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListItemValueRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListItemValueRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_url: builtins.str,
                 target_url: builtins.str,
                 include_subdomains: Optional[builtins.str] = None,
                 preserve_path_suffix: Optional[builtins.str] = None,
                 preserve_query_string: Optional[builtins.str] = None,
                 status_code: Optional[builtins.int] = None,
                 subpath_matching: Optional[builtins.str] = None):
        """
        :param builtins.str source_url: The source url of the redirect.
        :param builtins.str target_url: The target url of the redirect.
        :param builtins.str include_subdomains: Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        :param builtins.str preserve_path_suffix: Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        :param builtins.str preserve_query_string: Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        :param builtins.int status_code: The status code to be used when redirecting a request.
        :param builtins.str subpath_matching: Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> builtins.str:
        """
        The source url of the redirect.
        """
        return pulumi.get(self, "source_url")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> builtins.str:
        """
        The target url of the redirect.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[builtins.str]:
        """
        Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[builtins.str]:
        """
        Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_path_suffix")

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[builtins.str]:
        """
        Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        The status code to be used when redirecting a request.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[builtins.str]:
        """
        Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "subpath_matching")


@pulumi.output_type
class LoadBalancerAdaptiveRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverAcrossPools":
            suggest = "failover_across_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerAdaptiveRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerAdaptiveRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerAdaptiveRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_across_pools: Optional[builtins.bool] = None):
        """
        :param builtins.bool failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[builtins.bool]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
        """
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class LoadBalancerCountryPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerCountryPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerCountryPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerCountryPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country: builtins.str,
                 pool_ids: Sequence[builtins.str]):
        """
        :param builtins.str country: A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        :param Sequence[builtins.str] pool_ids: A list of pool IDs in failover priority to use in the given country.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "pool_ids", pool_ids)

    @property
    @pulumi.getter
    def country(self) -> builtins.str:
        """
        A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[builtins.str]:
        """
        A list of pool IDs in failover priority to use in the given country.
        """
        return pulumi.get(self, "pool_ids")


@pulumi.output_type
class LoadBalancerLocationStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferEcs":
            suggest = "prefer_ecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerLocationStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerLocationStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerLocationStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[builtins.str] = None,
                 prefer_ecs: Optional[builtins.str] = None):
        """
        :param builtins.str mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        :param builtins.str prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[builtins.str]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
        """
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class LoadBalancerMonitorHeader(dict):
    def __init__(__self__, *,
                 header: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str header: The header name.
        :param Sequence[builtins.str] values: A list of values for the header.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> builtins.str:
        """
        The header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        A list of values for the header.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LoadBalancerPoolLoadShedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPercent":
            suggest = "default_percent"
        elif key == "defaultPolicy":
            suggest = "default_policy"
        elif key == "sessionPercent":
            suggest = "session_percent"
        elif key == "sessionPolicy":
            suggest = "session_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPoolLoadShedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPoolLoadShedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPoolLoadShedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_percent: Optional[builtins.float] = None,
                 default_policy: Optional[builtins.str] = None,
                 session_percent: Optional[builtins.float] = None,
                 session_policy: Optional[builtins.str] = None):
        """
        :param builtins.float default_percent: Percent of traffic to shed 0 - 100. Defaults to `0`.
        :param builtins.str default_policy: Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        :param builtins.float session_percent: Percent of session traffic to shed 0 - 100. Defaults to `0`.
        :param builtins.str session_policy: Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[builtins.float]:
        """
        Percent of traffic to shed 0 - 100. Defaults to `0`.
        """
        return pulumi.get(self, "default_percent")

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[builtins.str]:
        """
        Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
        """
        return pulumi.get(self, "default_policy")

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[builtins.float]:
        """
        Percent of session traffic to shed 0 - 100. Defaults to `0`.
        """
        return pulumi.get(self, "session_percent")

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[builtins.str]:
        """
        Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
        """
        return pulumi.get(self, "session_policy")


@pulumi.output_type
class LoadBalancerPoolOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPoolOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPoolOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPoolOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: builtins.str,
                 name: builtins.str,
                 enabled: Optional[builtins.bool] = None,
                 headers: Optional[Sequence['outputs.LoadBalancerPoolOriginHeader']] = None,
                 virtual_network_id: Optional[builtins.str] = None,
                 weight: Optional[builtins.float] = None):
        """
        :param builtins.str address: The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        :param builtins.str name: A human-identifiable name for the origin.
        :param builtins.bool enabled: Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        :param Sequence['LoadBalancerPoolOriginHeaderArgs'] headers: HTTP request headers.
        :param builtins.str virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param builtins.float weight: The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections. Defaults to `1`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.LoadBalancerPoolOriginHeader']]:
        """
        HTTP request headers.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[builtins.str]:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @property
    @pulumi.getter
    def weight(self) -> Optional[builtins.float]:
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections. Defaults to `1`.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class LoadBalancerPoolOriginHeader(dict):
    def __init__(__self__, *,
                 header: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str header: HTTP Header name.
        :param Sequence[builtins.str] values: Values for the HTTP headers.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> builtins.str:
        """
        HTTP Header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        Values for the HTTP headers.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LoadBalancerPoolOriginSteering(dict):
    def __init__(__self__, *,
                 policy: Optional[builtins.str] = None):
        """
        :param builtins.str policy: Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `""`, `hash`, `random`, `least_outstanding_requests`, `least_connections`. Defaults to `random`.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[builtins.str]:
        """
        Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `""`, `hash`, `random`, `least_outstanding_requests`, `least_connections`. Defaults to `random`.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class LoadBalancerPopPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPopPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPopPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPopPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[builtins.str],
                 pop: builtins.str):
        """
        :param Sequence[builtins.str] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param builtins.str pop: A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[builtins.str]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def pop(self) -> builtins.str:
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        return pulumi.get(self, "pop")


@pulumi.output_type
class LoadBalancerRandomSteering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultWeight":
            suggest = "default_weight"
        elif key == "poolWeights":
            suggest = "pool_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRandomSteering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRandomSteering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRandomSteering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_weight: Optional[builtins.float] = None,
                 pool_weights: Optional[Mapping[str, builtins.float]] = None):
        """
        :param builtins.float default_weight: The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        :param Mapping[str, builtins.float] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[builtins.float]:
        """
        The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        """
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[Mapping[str, builtins.float]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class LoadBalancerRegionPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRegionPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRegionPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRegionPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[builtins.str],
                 region: builtins.str):
        """
        :param Sequence[builtins.str] pool_ids: A list of pool IDs in failover priority to use in the given region.
        :param builtins.str region: A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[builtins.str]:
        """
        A list of pool IDs in failover priority to use in the given region.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class LoadBalancerRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedResponse":
            suggest = "fixed_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 condition: Optional[builtins.str] = None,
                 disabled: Optional[builtins.bool] = None,
                 fixed_response: Optional['outputs.LoadBalancerRuleFixedResponse'] = None,
                 overrides: Optional[Sequence['outputs.LoadBalancerRuleOverride']] = None,
                 priority: Optional[builtins.int] = None,
                 terminates: Optional[builtins.bool] = None):
        """
        :param builtins.str name: Human readable name for this rule.
        :param builtins.str condition: The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        :param builtins.bool disabled: A disabled rule will not be executed.
        :param 'LoadBalancerRuleFixedResponseArgs' fixed_response: Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.
        :param Sequence['LoadBalancerRuleOverrideArgs'] overrides: The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.
        :param builtins.int priority: Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
        :param builtins.bool terminates: Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.
        """
        pulumi.set(__self__, "name", name)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if terminates is not None:
            pulumi.set(__self__, "terminates", terminates)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Human readable name for this rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def condition(self) -> Optional[builtins.str]:
        """
        The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[builtins.bool]:
        """
        A disabled rule will not be executed.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional['outputs.LoadBalancerRuleFixedResponse']:
        """
        Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.
        """
        return pulumi.get(self, "fixed_response")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverride']]:
        """
        The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def priority(self) -> Optional[builtins.int]:
        """
        Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def terminates(self) -> Optional[builtins.bool]:
        """
        Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.
        """
        return pulumi.get(self, "terminates")


@pulumi.output_type
class LoadBalancerRuleFixedResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleFixedResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleFixedResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleFixedResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[builtins.str] = None,
                 location: Optional[builtins.str] = None,
                 message_body: Optional[builtins.str] = None,
                 status_code: Optional[builtins.int] = None):
        """
        :param builtins.str content_type: The value of the HTTP context-type header for this fixed response.
        :param builtins.str location: The value of the HTTP location header for this fixed response.
        :param builtins.str message_body: The text used as the html body for this fixed response.
        :param builtins.int status_code: The HTTP status code used for this fixed response.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[builtins.str]:
        """
        The value of the HTTP context-type header for this fixed response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        The value of the HTTP location header for this fixed response.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[builtins.str]:
        """
        The text used as the html body for this fixed response.
        """
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        The HTTP status code used for this fixed response.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class LoadBalancerRuleOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveRoutings":
            suggest = "adaptive_routings"
        elif key == "countryPools":
            suggest = "country_pools"
        elif key == "defaultPools":
            suggest = "default_pools"
        elif key == "fallbackPool":
            suggest = "fallback_pool"
        elif key == "locationStrategies":
            suggest = "location_strategies"
        elif key == "popPools":
            suggest = "pop_pools"
        elif key == "randomSteerings":
            suggest = "random_steerings"
        elif key == "regionPools":
            suggest = "region_pools"
        elif key == "sessionAffinity":
            suggest = "session_affinity"
        elif key == "sessionAffinityAttributes":
            suggest = "session_affinity_attributes"
        elif key == "sessionAffinityTtl":
            suggest = "session_affinity_ttl"
        elif key == "steeringPolicy":
            suggest = "steering_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_routings: Optional[Sequence['outputs.LoadBalancerRuleOverrideAdaptiveRouting']] = None,
                 country_pools: Optional[Sequence['outputs.LoadBalancerRuleOverrideCountryPool']] = None,
                 default_pools: Optional[Sequence[builtins.str]] = None,
                 fallback_pool: Optional[builtins.str] = None,
                 location_strategies: Optional[Sequence['outputs.LoadBalancerRuleOverrideLocationStrategy']] = None,
                 pop_pools: Optional[Sequence['outputs.LoadBalancerRuleOverridePopPool']] = None,
                 random_steerings: Optional[Sequence['outputs.LoadBalancerRuleOverrideRandomSteering']] = None,
                 region_pools: Optional[Sequence['outputs.LoadBalancerRuleOverrideRegionPool']] = None,
                 session_affinity: Optional[builtins.str] = None,
                 session_affinity_attributes: Optional[Sequence['outputs.LoadBalancerRuleOverrideSessionAffinityAttribute']] = None,
                 session_affinity_ttl: Optional[builtins.int] = None,
                 steering_policy: Optional[builtins.str] = None,
                 ttl: Optional[builtins.int] = None):
        """
        :param Sequence['LoadBalancerRuleOverrideAdaptiveRoutingArgs'] adaptive_routings: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        :param Sequence['LoadBalancerRuleOverrideCountryPoolArgs'] country_pools: A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        :param Sequence[builtins.str] default_pools: A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        :param builtins.str fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param Sequence['LoadBalancerRuleOverrideLocationStrategyArgs'] location_strategies: Controls location-based steering for non-proxied requests.
        :param Sequence['LoadBalancerRuleOverridePopPoolArgs'] pop_pools: A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        :param Sequence['LoadBalancerRuleOverrideRandomSteeringArgs'] random_steerings: Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        :param Sequence['LoadBalancerRuleOverrideRegionPoolArgs'] region_pools: A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        :param builtins.str session_affinity: Configure attributes for session affinity.
        :param Sequence['LoadBalancerRuleOverrideSessionAffinityAttributeArgs'] session_affinity_attributes: Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        :param builtins.int session_affinity_ttl: Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        :param builtins.str steering_policy: The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        :param builtins.int ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        """
        if adaptive_routings is not None:
            pulumi.set(__self__, "adaptive_routings", adaptive_routings)
        if country_pools is not None:
            pulumi.set(__self__, "country_pools", country_pools)
        if default_pools is not None:
            pulumi.set(__self__, "default_pools", default_pools)
        if fallback_pool is not None:
            pulumi.set(__self__, "fallback_pool", fallback_pool)
        if location_strategies is not None:
            pulumi.set(__self__, "location_strategies", location_strategies)
        if pop_pools is not None:
            pulumi.set(__self__, "pop_pools", pop_pools)
        if random_steerings is not None:
            pulumi.set(__self__, "random_steerings", random_steerings)
        if region_pools is not None:
            pulumi.set(__self__, "region_pools", region_pools)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_affinity_attributes is not None:
            pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        if session_affinity_ttl is not None:
            pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        if steering_policy is not None:
            pulumi.set(__self__, "steering_policy", steering_policy)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRoutings")
    def adaptive_routings(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideAdaptiveRouting']]:
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        """
        return pulumi.get(self, "adaptive_routings")

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideCountryPool']]:
        """
        A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        """
        return pulumi.get(self, "country_pools")

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        """
        return pulumi.get(self, "default_pools")

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> Optional[builtins.str]:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @property
    @pulumi.getter(name="locationStrategies")
    def location_strategies(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideLocationStrategy']]:
        """
        Controls location-based steering for non-proxied requests.
        """
        return pulumi.get(self, "location_strategies")

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverridePopPool']]:
        """
        A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        """
        return pulumi.get(self, "pop_pools")

    @property
    @pulumi.getter(name="randomSteerings")
    def random_steerings(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideRandomSteering']]:
        """
        Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        """
        return pulumi.get(self, "random_steerings")

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideRegionPool']]:
        """
        A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        """
        return pulumi.get(self, "region_pools")

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[builtins.str]:
        """
        Configure attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity")

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> Optional[Sequence['outputs.LoadBalancerRuleOverrideSessionAffinityAttribute']]:
        """
        Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> Optional[builtins.int]:
        """
        Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        """
        return pulumi.get(self, "session_affinity_ttl")

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> Optional[builtins.str]:
        """
        The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        """
        return pulumi.get(self, "steering_policy")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[builtins.int]:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class LoadBalancerRuleOverrideAdaptiveRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverAcrossPools":
            suggest = "failover_across_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideAdaptiveRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideAdaptiveRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideAdaptiveRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_across_pools: Optional[builtins.bool] = None):
        """
        :param builtins.bool failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[builtins.bool]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool.
        """
        return pulumi.get(self, "failover_across_pools")


@pulumi.output_type
class LoadBalancerRuleOverrideCountryPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideCountryPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideCountryPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideCountryPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country: builtins.str,
                 pool_ids: Sequence[builtins.str]):
        """
        :param builtins.str country: A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        :param Sequence[builtins.str] pool_ids: A list of pool IDs in failover priority to use in the given country.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "pool_ids", pool_ids)

    @property
    @pulumi.getter
    def country(self) -> builtins.str:
        """
        A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[builtins.str]:
        """
        A list of pool IDs in failover priority to use in the given country.
        """
        return pulumi.get(self, "pool_ids")


@pulumi.output_type
class LoadBalancerRuleOverrideLocationStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferEcs":
            suggest = "prefer_ecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideLocationStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideLocationStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideLocationStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[builtins.str] = None,
                 prefer_ecs: Optional[builtins.str] = None):
        """
        :param builtins.str mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`.
        :param builtins.str prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[builtins.str]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`.
        """
        return pulumi.get(self, "prefer_ecs")


@pulumi.output_type
class LoadBalancerRuleOverridePopPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverridePopPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverridePopPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverridePopPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[builtins.str],
                 pop: builtins.str):
        """
        :param Sequence[builtins.str] pool_ids: A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        :param builtins.str pop: A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "pop", pop)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[builtins.str]:
        """
        A list of pool IDs in failover priority to use for traffic reaching the given PoP.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def pop(self) -> builtins.str:
        """
        A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
        """
        return pulumi.get(self, "pop")


@pulumi.output_type
class LoadBalancerRuleOverrideRandomSteering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultWeight":
            suggest = "default_weight"
        elif key == "poolWeights":
            suggest = "pool_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideRandomSteering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideRandomSteering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideRandomSteering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_weight: Optional[builtins.float] = None,
                 pool_weights: Optional[Mapping[str, builtins.float]] = None):
        """
        :param builtins.float default_weight: The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        :param Mapping[str, builtins.float] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[builtins.float]:
        """
        The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
        """
        return pulumi.get(self, "default_weight")

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[Mapping[str, builtins.float]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")


@pulumi.output_type
class LoadBalancerRuleOverrideRegionPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideRegionPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideRegionPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideRegionPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: Sequence[builtins.str],
                 region: builtins.str):
        """
        :param Sequence[builtins.str] pool_ids: A list of pool IDs in failover priority to use in the given region.
        :param builtins.str region: A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Sequence[builtins.str]:
        """
        A list of pool IDs in failover priority to use in the given region.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class LoadBalancerRuleOverrideSessionAffinityAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireAllHeaders":
            suggest = "require_all_headers"
        elif key == "zeroDowntimeFailover":
            suggest = "zero_downtime_failover"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerRuleOverrideSessionAffinityAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerRuleOverrideSessionAffinityAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerRuleOverrideSessionAffinityAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[builtins.str]] = None,
                 require_all_headers: Optional[builtins.bool] = None,
                 samesite: Optional[builtins.str] = None,
                 secure: Optional[builtins.str] = None,
                 zero_downtime_failover: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] headers: Configures the HTTP header names to use when header session affinity is enabled.
        :param builtins.bool require_all_headers: Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        :param builtins.str samesite: Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`.
        :param builtins.str secure: Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`.
        :param builtins.str zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[builtins.str]]:
        """
        Configures the HTTP header names to use when header session affinity is enabled.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[builtins.bool]:
        """
        Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        """
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> Optional[builtins.str]:
        """
        Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`.
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> Optional[builtins.str]:
        """
        Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`.
        """
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[builtins.str]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`.
        """
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class LoadBalancerSessionAffinityAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainDuration":
            suggest = "drain_duration"
        elif key == "requireAllHeaders":
            suggest = "require_all_headers"
        elif key == "zeroDowntimeFailover":
            suggest = "zero_downtime_failover"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerSessionAffinityAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerSessionAffinityAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerSessionAffinityAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_duration: Optional[builtins.int] = None,
                 headers: Optional[Sequence[builtins.str]] = None,
                 require_all_headers: Optional[builtins.bool] = None,
                 samesite: Optional[builtins.str] = None,
                 secure: Optional[builtins.str] = None,
                 zero_downtime_failover: Optional[builtins.str] = None):
        """
        :param builtins.int drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
        :param Sequence[builtins.str] headers: Configures the HTTP header names to use when header session affinity is enabled.
        :param builtins.bool require_all_headers: Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        :param builtins.str samesite: Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        :param builtins.str secure: Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        :param builtins.str zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[builtins.int]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
        """
        return pulumi.get(self, "drain_duration")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[builtins.str]]:
        """
        Configures the HTTP header names to use when header session affinity is enabled.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[builtins.bool]:
        """
        Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
        """
        return pulumi.get(self, "require_all_headers")

    @property
    @pulumi.getter
    def samesite(self) -> Optional[builtins.str]:
        """
        Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
        """
        return pulumi.get(self, "samesite")

    @property
    @pulumi.getter
    def secure(self) -> Optional[builtins.str]:
        """
        Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
        """
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[builtins.str]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
        """
        return pulumi.get(self, "zero_downtime_failover")


@pulumi.output_type
class LogpushJobOutputOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchPrefix":
            suggest = "batch_prefix"
        elif key == "batchSuffix":
            suggest = "batch_suffix"
        elif key == "fieldDelimiter":
            suggest = "field_delimiter"
        elif key == "fieldNames":
            suggest = "field_names"
        elif key == "outputType":
            suggest = "output_type"
        elif key == "recordDelimiter":
            suggest = "record_delimiter"
        elif key == "recordPrefix":
            suggest = "record_prefix"
        elif key == "recordSuffix":
            suggest = "record_suffix"
        elif key == "recordTemplate":
            suggest = "record_template"
        elif key == "sampleRate":
            suggest = "sample_rate"
        elif key == "timestampFormat":
            suggest = "timestamp_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogpushJobOutputOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogpushJobOutputOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogpushJobOutputOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_prefix: Optional[builtins.str] = None,
                 batch_suffix: Optional[builtins.str] = None,
                 cve20214428: Optional[builtins.bool] = None,
                 field_delimiter: Optional[builtins.str] = None,
                 field_names: Optional[Sequence[builtins.str]] = None,
                 output_type: Optional[builtins.str] = None,
                 record_delimiter: Optional[builtins.str] = None,
                 record_prefix: Optional[builtins.str] = None,
                 record_suffix: Optional[builtins.str] = None,
                 record_template: Optional[builtins.str] = None,
                 sample_rate: Optional[builtins.float] = None,
                 timestamp_format: Optional[builtins.str] = None):
        """
        :param builtins.str batch_prefix: String to be prepended before each batch.
        :param builtins.str batch_suffix: String to be appended after each batch.
        :param builtins.bool cve20214428: Mitigation for CVE-2021-44228. If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{. Defaults to `false`.
        :param builtins.str field_delimiter: String to join fields. This field be ignored when record_template is set. Defaults to `,`.
        :param Sequence[builtins.str] field_names: List of field names to be included in the Logpush output.
        :param builtins.str output_type: Specifies the output type. Available values: `ndjson`, `csv`. Defaults to `ndjson`.
        :param builtins.str record_delimiter: String to be inserted in-between the records as separator.
        :param builtins.str record_prefix: String to be prepended before each record. Defaults to `{`.
        :param builtins.str record_suffix: String to be appended after each record. Defaults to `}
               `.
        :param builtins.str record_template: String to use as template for each record instead of the default comma-separated list.
        :param builtins.float sample_rate: Specifies the sampling rate. Defaults to `1`.
        :param builtins.str timestamp_format: Specifies the format for timestamps. Available values: `unixnano`, `unix`, `rfc3339`. Defaults to `unixnano`.
        """
        if batch_prefix is not None:
            pulumi.set(__self__, "batch_prefix", batch_prefix)
        if batch_suffix is not None:
            pulumi.set(__self__, "batch_suffix", batch_suffix)
        if cve20214428 is not None:
            pulumi.set(__self__, "cve20214428", cve20214428)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)
        if output_type is not None:
            pulumi.set(__self__, "output_type", output_type)
        if record_delimiter is not None:
            pulumi.set(__self__, "record_delimiter", record_delimiter)
        if record_prefix is not None:
            pulumi.set(__self__, "record_prefix", record_prefix)
        if record_suffix is not None:
            pulumi.set(__self__, "record_suffix", record_suffix)
        if record_template is not None:
            pulumi.set(__self__, "record_template", record_template)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter(name="batchPrefix")
    def batch_prefix(self) -> Optional[builtins.str]:
        """
        String to be prepended before each batch.
        """
        return pulumi.get(self, "batch_prefix")

    @property
    @pulumi.getter(name="batchSuffix")
    def batch_suffix(self) -> Optional[builtins.str]:
        """
        String to be appended after each batch.
        """
        return pulumi.get(self, "batch_suffix")

    @property
    @pulumi.getter
    def cve20214428(self) -> Optional[builtins.bool]:
        """
        Mitigation for CVE-2021-44228. If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{. Defaults to `false`.
        """
        return pulumi.get(self, "cve20214428")

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[builtins.str]:
        """
        String to join fields. This field be ignored when record_template is set. Defaults to `,`.
        """
        return pulumi.get(self, "field_delimiter")

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[Sequence[builtins.str]]:
        """
        List of field names to be included in the Logpush output.
        """
        return pulumi.get(self, "field_names")

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> Optional[builtins.str]:
        """
        Specifies the output type. Available values: `ndjson`, `csv`. Defaults to `ndjson`.
        """
        return pulumi.get(self, "output_type")

    @property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> Optional[builtins.str]:
        """
        String to be inserted in-between the records as separator.
        """
        return pulumi.get(self, "record_delimiter")

    @property
    @pulumi.getter(name="recordPrefix")
    def record_prefix(self) -> Optional[builtins.str]:
        """
        String to be prepended before each record. Defaults to `{`.
        """
        return pulumi.get(self, "record_prefix")

    @property
    @pulumi.getter(name="recordSuffix")
    def record_suffix(self) -> Optional[builtins.str]:
        """
        String to be appended after each record. Defaults to `}
        `.
        """
        return pulumi.get(self, "record_suffix")

    @property
    @pulumi.getter(name="recordTemplate")
    def record_template(self) -> Optional[builtins.str]:
        """
        String to use as template for each record instead of the default comma-separated list.
        """
        return pulumi.get(self, "record_template")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[builtins.float]:
        """
        Specifies the sampling rate. Defaults to `1`.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[builtins.str]:
        """
        Specifies the format for timestamps. Available values: `unixnano`, `unix`, `rfc3339`. Defaults to `unixnano`.
        """
        return pulumi.get(self, "timestamp_format")


@pulumi.output_type
class ManagedHeadersManagedRequestHeader(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool,
                 id: builtins.str):
        """
        :param builtins.bool enabled: Whether the headers rule is active.
        :param builtins.str id: Unique headers rule identifier.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Unique headers rule identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ManagedHeadersManagedResponseHeader(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool,
                 id: builtins.str):
        """
        :param builtins.bool enabled: Whether the headers rule is active.
        :param builtins.str id: Unique headers rule identifier.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Unique headers rule identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NotificationPolicyEmailIntegration(dict):
    def __init__(__self__, *,
                 id: builtins.str,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NotificationPolicyFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedComponents":
            suggest = "affected_components"
        elif key == "airportCodes":
            suggest = "airport_codes"
        elif key == "alertTriggerPreferences":
            suggest = "alert_trigger_preferences"
        elif key == "eventSources":
            suggest = "event_sources"
        elif key == "eventTypes":
            suggest = "event_types"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "healthCheckIds":
            suggest = "health_check_ids"
        elif key == "incidentImpacts":
            suggest = "incident_impacts"
        elif key == "inputIds":
            suggest = "input_ids"
        elif key == "megabitsPerSeconds":
            suggest = "megabits_per_seconds"
        elif key == "newHealths":
            suggest = "new_healths"
        elif key == "newStatuses":
            suggest = "new_statuses"
        elif key == "packetsPerSeconds":
            suggest = "packets_per_seconds"
        elif key == "poolIds":
            suggest = "pool_ids"
        elif key == "projectIds":
            suggest = "project_ids"
        elif key == "requestsPerSeconds":
            suggest = "requests_per_seconds"
        elif key == "targetHostnames":
            suggest = "target_hostnames"
        elif key == "targetIps":
            suggest = "target_ips"
        elif key == "targetZoneNames":
            suggest = "target_zone_names"
        elif key == "tunnelIds":
            suggest = "tunnel_ids"
        elif key == "tunnelNames":
            suggest = "tunnel_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence[builtins.str]] = None,
                 affected_components: Optional[Sequence[builtins.str]] = None,
                 airport_codes: Optional[Sequence[builtins.str]] = None,
                 alert_trigger_preferences: Optional[Sequence[builtins.str]] = None,
                 enableds: Optional[Sequence[builtins.str]] = None,
                 environments: Optional[Sequence[builtins.str]] = None,
                 event_sources: Optional[Sequence[builtins.str]] = None,
                 event_types: Optional[Sequence[builtins.str]] = None,
                 events: Optional[Sequence[builtins.str]] = None,
                 group_bies: Optional[Sequence[builtins.str]] = None,
                 health_check_ids: Optional[Sequence[builtins.str]] = None,
                 incident_impacts: Optional[Sequence[builtins.str]] = None,
                 input_ids: Optional[Sequence[builtins.str]] = None,
                 limits: Optional[Sequence[builtins.str]] = None,
                 megabits_per_seconds: Optional[Sequence[builtins.str]] = None,
                 new_healths: Optional[Sequence[builtins.str]] = None,
                 new_statuses: Optional[Sequence[builtins.str]] = None,
                 packets_per_seconds: Optional[Sequence[builtins.str]] = None,
                 pool_ids: Optional[Sequence[builtins.str]] = None,
                 products: Optional[Sequence[builtins.str]] = None,
                 project_ids: Optional[Sequence[builtins.str]] = None,
                 protocols: Optional[Sequence[builtins.str]] = None,
                 requests_per_seconds: Optional[Sequence[builtins.str]] = None,
                 selectors: Optional[Sequence[builtins.str]] = None,
                 services: Optional[Sequence[builtins.str]] = None,
                 slos: Optional[Sequence[builtins.str]] = None,
                 statuses: Optional[Sequence[builtins.str]] = None,
                 target_hostnames: Optional[Sequence[builtins.str]] = None,
                 target_ips: Optional[Sequence[builtins.str]] = None,
                 target_zone_names: Optional[Sequence[builtins.str]] = None,
                 tunnel_ids: Optional[Sequence[builtins.str]] = None,
                 tunnel_names: Optional[Sequence[builtins.str]] = None,
                 wheres: Optional[Sequence[builtins.str]] = None,
                 zones: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] actions: Targeted actions for alert.
        :param Sequence[builtins.str] affected_components: Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `D1`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.
        :param Sequence[builtins.str] airport_codes: Filter on Points of Presence.
        :param Sequence[builtins.str] alert_trigger_preferences: Alert trigger preferences. Example: `slo`.
        :param Sequence[builtins.str] enableds: State of the pool to alert on.
        :param Sequence[builtins.str] environments: Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
        :param Sequence[builtins.str] event_sources: Source configuration to alert on for pool or origin.
        :param Sequence[builtins.str] event_types: Stream event type to alert on.
        :param Sequence[builtins.str] events: Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
        :param Sequence[builtins.str] group_bies: Alert grouping.
        :param Sequence[builtins.str] health_check_ids: Identifier health check. Required when using `filters.0.status`.
        :param Sequence[builtins.str] incident_impacts: The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.
        :param Sequence[builtins.str] input_ids: Stream input id to alert on.
        :param Sequence[builtins.str] limits: A numerical limit. Example: `100`.
        :param Sequence[builtins.str] megabits_per_seconds: Megabits per second threshold for dos alert.
        :param Sequence[builtins.str] new_healths: Health status to alert on for pool or origin.
        :param Sequence[builtins.str] new_statuses: Tunnel health status to alert on.
        :param Sequence[builtins.str] packets_per_seconds: Packets per second threshold for dos alert.
        :param Sequence[builtins.str] pool_ids: Load balancer pool identifier.
        :param Sequence[builtins.str] products: Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        :param Sequence[builtins.str] project_ids: Identifier of pages project.
        :param Sequence[builtins.str] protocols: Protocol to alert on for dos.
        :param Sequence[builtins.str] requests_per_seconds: Requests per second threshold for dos alert.
        :param Sequence[builtins.str] selectors: Selectors for alert. Valid options depend on the alert type.
        :param Sequence[builtins.str] slos: A numerical limit. Example: `99.9`.
        :param Sequence[builtins.str] statuses: Status to alert on.
        :param Sequence[builtins.str] target_hostnames: Target host to alert on for dos.
        :param Sequence[builtins.str] target_ips: Target ip to alert on for dos in CIDR notation.
        :param Sequence[builtins.str] target_zone_names: Target domain to alert on.
        :param Sequence[builtins.str] tunnel_ids: Tunnel IDs to alert on.
        :param Sequence[builtins.str] tunnel_names: Tunnel Names to alert on.
        :param Sequence[builtins.str] wheres: Filter for alert.
        :param Sequence[builtins.str] zones: A list of zone identifiers.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if affected_components is not None:
            pulumi.set(__self__, "affected_components", affected_components)
        if airport_codes is not None:
            pulumi.set(__self__, "airport_codes", airport_codes)
        if alert_trigger_preferences is not None:
            pulumi.set(__self__, "alert_trigger_preferences", alert_trigger_preferences)
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if event_sources is not None:
            pulumi.set(__self__, "event_sources", event_sources)
        if event_types is not None:
            pulumi.set(__self__, "event_types", event_types)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if health_check_ids is not None:
            pulumi.set(__self__, "health_check_ids", health_check_ids)
        if incident_impacts is not None:
            pulumi.set(__self__, "incident_impacts", incident_impacts)
        if input_ids is not None:
            pulumi.set(__self__, "input_ids", input_ids)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if megabits_per_seconds is not None:
            pulumi.set(__self__, "megabits_per_seconds", megabits_per_seconds)
        if new_healths is not None:
            pulumi.set(__self__, "new_healths", new_healths)
        if new_statuses is not None:
            pulumi.set(__self__, "new_statuses", new_statuses)
        if packets_per_seconds is not None:
            pulumi.set(__self__, "packets_per_seconds", packets_per_seconds)
        if pool_ids is not None:
            pulumi.set(__self__, "pool_ids", pool_ids)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if requests_per_seconds is not None:
            pulumi.set(__self__, "requests_per_seconds", requests_per_seconds)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if slos is not None:
            pulumi.set(__self__, "slos", slos)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if target_hostnames is not None:
            pulumi.set(__self__, "target_hostnames", target_hostnames)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if target_zone_names is not None:
            pulumi.set(__self__, "target_zone_names", target_zone_names)
        if tunnel_ids is not None:
            pulumi.set(__self__, "tunnel_ids", tunnel_ids)
        if tunnel_names is not None:
            pulumi.set(__self__, "tunnel_names", tunnel_names)
        if wheres is not None:
            pulumi.set(__self__, "wheres", wheres)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[builtins.str]]:
        """
        Targeted actions for alert.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="affectedComponents")
    def affected_components(self) -> Optional[Sequence[builtins.str]]:
        """
        Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `D1`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.
        """
        return pulumi.get(self, "affected_components")

    @property
    @pulumi.getter(name="airportCodes")
    def airport_codes(self) -> Optional[Sequence[builtins.str]]:
        """
        Filter on Points of Presence.
        """
        return pulumi.get(self, "airport_codes")

    @property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Optional[Sequence[builtins.str]]:
        """
        Alert trigger preferences. Example: `slo`.
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @property
    @pulumi.getter
    def enableds(self) -> Optional[Sequence[builtins.str]]:
        """
        State of the pool to alert on.
        """
        return pulumi.get(self, "enableds")

    @property
    @pulumi.getter
    def environments(self) -> Optional[Sequence[builtins.str]]:
        """
        Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
        """
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Optional[Sequence[builtins.str]]:
        """
        Source configuration to alert on for pool or origin.
        """
        return pulumi.get(self, "event_sources")

    @property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Optional[Sequence[builtins.str]]:
        """
        Stream event type to alert on.
        """
        return pulumi.get(self, "event_types")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence[builtins.str]]:
        """
        Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[builtins.str]]:
        """
        Alert grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Identifier health check. Required when using `filters.0.status`.
        """
        return pulumi.get(self, "health_check_ids")

    @property
    @pulumi.getter(name="incidentImpacts")
    def incident_impacts(self) -> Optional[Sequence[builtins.str]]:
        """
        The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.
        """
        return pulumi.get(self, "incident_impacts")

    @property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Stream input id to alert on.
        """
        return pulumi.get(self, "input_ids")

    @property
    @pulumi.getter
    def limits(self) -> Optional[Sequence[builtins.str]]:
        """
        A numerical limit. Example: `100`.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Optional[Sequence[builtins.str]]:
        """
        Megabits per second threshold for dos alert.
        """
        return pulumi.get(self, "megabits_per_seconds")

    @property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Optional[Sequence[builtins.str]]:
        """
        Health status to alert on for pool or origin.
        """
        return pulumi.get(self, "new_healths")

    @property
    @pulumi.getter(name="newStatuses")
    def new_statuses(self) -> Optional[Sequence[builtins.str]]:
        """
        Tunnel health status to alert on.
        """
        return pulumi.get(self, "new_statuses")

    @property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Optional[Sequence[builtins.str]]:
        """
        Packets per second threshold for dos alert.
        """
        return pulumi.get(self, "packets_per_seconds")

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Load balancer pool identifier.
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[builtins.str]]:
        """
        Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Identifier of pages project.
        """
        return pulumi.get(self, "project_ids")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[builtins.str]]:
        """
        Protocol to alert on for dos.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Optional[Sequence[builtins.str]]:
        """
        Requests per second threshold for dos alert.
        """
        return pulumi.get(self, "requests_per_seconds")

    @property
    @pulumi.getter
    def selectors(self) -> Optional[Sequence[builtins.str]]:
        """
        Selectors for alert. Valid options depend on the alert type.
        """
        return pulumi.get(self, "selectors")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def slos(self) -> Optional[Sequence[builtins.str]]:
        """
        A numerical limit. Example: `99.9`.
        """
        return pulumi.get(self, "slos")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[builtins.str]]:
        """
        Status to alert on.
        """
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Optional[Sequence[builtins.str]]:
        """
        Target host to alert on for dos.
        """
        return pulumi.get(self, "target_hostnames")

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[Sequence[builtins.str]]:
        """
        Target ip to alert on for dos in CIDR notation.
        """
        return pulumi.get(self, "target_ips")

    @property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Target domain to alert on.
        """
        return pulumi.get(self, "target_zone_names")

    @property
    @pulumi.getter(name="tunnelIds")
    def tunnel_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Tunnel IDs to alert on.
        """
        return pulumi.get(self, "tunnel_ids")

    @property
    @pulumi.getter(name="tunnelNames")
    def tunnel_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Tunnel Names to alert on.
        """
        return pulumi.get(self, "tunnel_names")

    @property
    @pulumi.getter
    def wheres(self) -> Optional[Sequence[builtins.str]]:
        """
        Filter for alert.
        """
        return pulumi.get(self, "wheres")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of zone identifiers.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class NotificationPolicyPagerdutyIntegration(dict):
    def __init__(__self__, *,
                 id: builtins.str,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NotificationPolicyWebhooksIntegration(dict):
    def __init__(__self__, *,
                 id: builtins.str,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class PageRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "bypassCacheOnCookie":
            suggest = "bypass_cache_on_cookie"
        elif key == "cacheByDeviceType":
            suggest = "cache_by_device_type"
        elif key == "cacheDeceptionArmor":
            suggest = "cache_deception_armor"
        elif key == "cacheKeyFields":
            suggest = "cache_key_fields"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "cacheOnCookie":
            suggest = "cache_on_cookie"
        elif key == "cacheTtlByStatuses":
            suggest = "cache_ttl_by_statuses"
        elif key == "disableApps":
            suggest = "disable_apps"
        elif key == "disablePerformance":
            suggest = "disable_performance"
        elif key == "disableRailgun":
            suggest = "disable_railgun"
        elif key == "disableSecurity":
            suggest = "disable_security"
        elif key == "disableZaraz":
            suggest = "disable_zaraz"
        elif key == "edgeCacheTtl":
            suggest = "edge_cache_ttl"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "explicitCacheControl":
            suggest = "explicit_cache_control"
        elif key == "forwardingUrl":
            suggest = "forwarding_url"
        elif key == "hostHeaderOverride":
            suggest = "host_header_override"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "resolveOverride":
            suggest = "resolve_override"
        elif key == "respectStrongEtag":
            suggest = "respect_strong_etag"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_use_https: Optional[builtins.bool] = None,
                 automatic_https_rewrites: Optional[builtins.str] = None,
                 browser_cache_ttl: Optional[builtins.str] = None,
                 browser_check: Optional[builtins.str] = None,
                 bypass_cache_on_cookie: Optional[builtins.str] = None,
                 cache_by_device_type: Optional[builtins.str] = None,
                 cache_deception_armor: Optional[builtins.str] = None,
                 cache_key_fields: Optional['outputs.PageRuleActionsCacheKeyFields'] = None,
                 cache_level: Optional[builtins.str] = None,
                 cache_on_cookie: Optional[builtins.str] = None,
                 cache_ttl_by_statuses: Optional[Sequence['outputs.PageRuleActionsCacheTtlByStatus']] = None,
                 disable_apps: Optional[builtins.bool] = None,
                 disable_performance: Optional[builtins.bool] = None,
                 disable_railgun: Optional[builtins.bool] = None,
                 disable_security: Optional[builtins.bool] = None,
                 disable_zaraz: Optional[builtins.bool] = None,
                 edge_cache_ttl: Optional[builtins.int] = None,
                 email_obfuscation: Optional[builtins.str] = None,
                 explicit_cache_control: Optional[builtins.str] = None,
                 forwarding_url: Optional['outputs.PageRuleActionsForwardingUrl'] = None,
                 host_header_override: Optional[builtins.str] = None,
                 ip_geolocation: Optional[builtins.str] = None,
                 minifies: Optional[Sequence['outputs.PageRuleActionsMinify']] = None,
                 mirage: Optional[builtins.str] = None,
                 opportunistic_encryption: Optional[builtins.str] = None,
                 origin_error_page_pass_thru: Optional[builtins.str] = None,
                 polish: Optional[builtins.str] = None,
                 resolve_override: Optional[builtins.str] = None,
                 respect_strong_etag: Optional[builtins.str] = None,
                 response_buffering: Optional[builtins.str] = None,
                 rocket_loader: Optional[builtins.str] = None,
                 security_level: Optional[builtins.str] = None,
                 server_side_exclude: Optional[builtins.str] = None,
                 sort_query_string_for_cache: Optional[builtins.str] = None,
                 ssl: Optional[builtins.str] = None,
                 true_client_ip_header: Optional[builtins.str] = None,
                 waf: Optional[builtins.str] = None):
        """
        :param builtins.bool always_use_https: Boolean of whether this action is enabled. Default: false.
        :param builtins.str automatic_https_rewrites: Whether this action is `"on"` or `"off"`.
        :param builtins.str browser_cache_ttl: The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        :param builtins.str browser_check: Whether this action is `"on"` or `"off"`.
        :param builtins.str bypass_cache_on_cookie: String value of cookie name to conditionally bypass cache the page.
        :param builtins.str cache_by_device_type: Whether this action is `"on"` or `"off"`.
        :param builtins.str cache_deception_armor: Whether this action is `"on"` or `"off"`.
        :param 'PageRuleActionsCacheKeyFieldsArgs' cache_key_fields: Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        :param builtins.str cache_level: Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        :param builtins.str cache_on_cookie: String value of cookie name to conditionally cache the page.
        :param Sequence['PageRuleActionsCacheTtlByStatusArgs'] cache_ttl_by_statuses: Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        :param builtins.bool disable_apps: Boolean of whether this action is enabled. Default: false.
        :param builtins.bool disable_performance: Boolean of whether this action is enabled. Default: false.
        :param builtins.bool disable_railgun: Boolean of whether this action is enabled. Default: false.
        :param builtins.bool disable_security: Boolean of whether this action is enabled. Default: false.
        :param builtins.bool disable_zaraz: Boolean of whether this action is enabled. Default: false.
        :param builtins.int edge_cache_ttl: The Time To Live for the edge cache.
        :param builtins.str email_obfuscation: Whether this action is `"on"` or `"off"`.
        :param builtins.str explicit_cache_control: Whether origin Cache-Control action is `"on"` or `"off"`.
        :param 'PageRuleActionsForwardingUrlArgs' forwarding_url: The URL to forward to, and with what status. See below.
        :param builtins.str host_header_override: Value of the Host header to send.
        :param builtins.str ip_geolocation: Whether this action is `"on"` or `"off"`.
        :param Sequence['PageRuleActionsMinifyArgs'] minifies: The configuration for HTML, CSS and JS minification. See below for full list of options.
        :param builtins.str mirage: Whether this action is `"on"` or `"off"`.
        :param builtins.str opportunistic_encryption: Whether this action is `"on"` or `"off"`.
        :param builtins.str origin_error_page_pass_thru: Whether this action is `"on"` or `"off"`.
        :param builtins.str polish: Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        :param builtins.str resolve_override: Overridden origin server name.
        :param builtins.str respect_strong_etag: Whether this action is `"on"` or `"off"`.
        :param builtins.str response_buffering: Whether this action is `"on"` or `"off"`.
        :param builtins.str rocket_loader: Whether to set the rocket loader to `"on"`, `"off"`.
        :param builtins.str security_level: Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        :param builtins.str server_side_exclude: Whether this action is `"on"` or `"off"`.
        :param builtins.str sort_query_string_for_cache: Whether this action is `"on"` or `"off"`.
        :param builtins.str ssl: Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        :param builtins.str true_client_ip_header: Whether this action is `"on"` or `"off"`.
        :param builtins.str waf: Whether this action is `"on"` or `"off"`.
        """
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if bypass_cache_on_cookie is not None:
            pulumi.set(__self__, "bypass_cache_on_cookie", bypass_cache_on_cookie)
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if cache_key_fields is not None:
            pulumi.set(__self__, "cache_key_fields", cache_key_fields)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if cache_on_cookie is not None:
            pulumi.set(__self__, "cache_on_cookie", cache_on_cookie)
        if cache_ttl_by_statuses is not None:
            pulumi.set(__self__, "cache_ttl_by_statuses", cache_ttl_by_statuses)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_performance is not None:
            pulumi.set(__self__, "disable_performance", disable_performance)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_security is not None:
            pulumi.set(__self__, "disable_security", disable_security)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_cache_ttl is not None:
            pulumi.set(__self__, "edge_cache_ttl", edge_cache_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if explicit_cache_control is not None:
            pulumi.set(__self__, "explicit_cache_control", explicit_cache_control)
        if forwarding_url is not None:
            pulumi.set(__self__, "forwarding_url", forwarding_url)
        if host_header_override is not None:
            pulumi.set(__self__, "host_header_override", host_header_override)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if minifies is not None:
            pulumi.set(__self__, "minifies", minifies)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if resolve_override is not None:
            pulumi.set(__self__, "resolve_override", resolve_override)
        if respect_strong_etag is not None:
            pulumi.set(__self__, "respect_strong_etag", respect_strong_etag)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[builtins.bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[builtins.str]:
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="bypassCacheOnCookie")
    def bypass_cache_on_cookie(self) -> Optional[builtins.str]:
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        return pulumi.get(self, "bypass_cache_on_cookie")

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="cacheKeyFields")
    def cache_key_fields(self) -> Optional['outputs.PageRuleActionsCacheKeyFields']:
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        return pulumi.get(self, "cache_key_fields")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[builtins.str]:
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="cacheOnCookie")
    def cache_on_cookie(self) -> Optional[builtins.str]:
        """
        String value of cookie name to conditionally cache the page.
        """
        return pulumi.get(self, "cache_on_cookie")

    @property
    @pulumi.getter(name="cacheTtlByStatuses")
    def cache_ttl_by_statuses(self) -> Optional[Sequence['outputs.PageRuleActionsCacheTtlByStatus']]:
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        return pulumi.get(self, "cache_ttl_by_statuses")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[builtins.bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disablePerformance")
    def disable_performance(self) -> Optional[builtins.bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_performance")

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[builtins.bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_railgun")

    @property
    @pulumi.getter(name="disableSecurity")
    def disable_security(self) -> Optional[builtins.bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_security")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[builtins.bool]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeCacheTtl")
    def edge_cache_ttl(self) -> Optional[builtins.int]:
        """
        The Time To Live for the edge cache.
        """
        return pulumi.get(self, "edge_cache_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="explicitCacheControl")
    def explicit_cache_control(self) -> Optional[builtins.str]:
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "explicit_cache_control")

    @property
    @pulumi.getter(name="forwardingUrl")
    def forwarding_url(self) -> Optional['outputs.PageRuleActionsForwardingUrl']:
        """
        The URL to forward to, and with what status. See below.
        """
        return pulumi.get(self, "forwarding_url")

    @property
    @pulumi.getter(name="hostHeaderOverride")
    def host_header_override(self) -> Optional[builtins.str]:
        """
        Value of the Host header to send.
        """
        return pulumi.get(self, "host_header_override")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def minifies(self) -> Optional[Sequence['outputs.PageRuleActionsMinify']]:
        """
        The configuration for HTML, CSS and JS minification. See below for full list of options.
        """
        return pulumi.get(self, "minifies")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter
    def polish(self) -> Optional[builtins.str]:
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="resolveOverride")
    def resolve_override(self) -> Optional[builtins.str]:
        """
        Overridden origin server name.
        """
        return pulumi.get(self, "resolve_override")

    @property
    @pulumi.getter(name="respectStrongEtag")
    def respect_strong_etag(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "respect_strong_etag")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[builtins.str]:
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[builtins.str]:
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[builtins.str]:
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter
    def waf(self) -> Optional[builtins.str]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "waf")


@pulumi.output_type
class PageRuleActionsCacheKeyFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: 'outputs.PageRuleActionsCacheKeyFieldsHost',
                 query_string: 'outputs.PageRuleActionsCacheKeyFieldsQueryString',
                 user: 'outputs.PageRuleActionsCacheKeyFieldsUser',
                 cookie: Optional['outputs.PageRuleActionsCacheKeyFieldsCookie'] = None,
                 header: Optional['outputs.PageRuleActionsCacheKeyFieldsHeader'] = None):
        """
        :param 'PageRuleActionsCacheKeyFieldsHostArgs' host: Controls which Host header goes into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsQueryStringArgs' query_string: Controls which URL query string parameters go into the Cache Key.
        :param 'PageRuleActionsCacheKeyFieldsUserArgs' user: Controls which end user-related features go into the Cache Key.
        :param 'PageRuleActionsCacheKeyFieldsCookieArgs' cookie: Controls what cookies go into Cache Key:
        :param 'PageRuleActionsCacheKeyFieldsHeaderArgs' header: Controls what HTTP headers go into Cache Key:
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "user", user)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def host(self) -> 'outputs.PageRuleActionsCacheKeyFieldsHost':
        """
        Controls which Host header goes into Cache Key:
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> 'outputs.PageRuleActionsCacheKeyFieldsQueryString':
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> 'outputs.PageRuleActionsCacheKeyFieldsUser':
        """
        Controls which end user-related features go into the Cache Key.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsCookie']:
        """
        Controls what cookies go into Cache Key:
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.PageRuleActionsCacheKeyFieldsHeader']:
        """
        Controls what HTTP headers go into Cache Key:
        """
        return pulumi.get(self, "header")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[builtins.str]] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] check_presences: Check for presence of specified cookies, without including their actual values.
        :param Sequence[builtins.str] includes: Use values of specified cookies in Cache Key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[builtins.str]]:
        """
        Check for presence of specified cookies, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        Use values of specified cookies in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[builtins.str]] = None,
                 excludes: Optional[Sequence[builtins.str]] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] check_presences: Check for presence of specified HTTP headers, without including their actual values.
        :param Sequence[builtins.str] excludes: Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        :param Sequence[builtins.str] includes: Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[builtins.str]]:
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[builtins.str]]:
        """
        Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsHost(dict):
    def __init__(__self__, *,
                 resolved: Optional[builtins.bool] = None):
        """
        :param builtins.bool resolved: `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[builtins.bool]:
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        return pulumi.get(self, "resolved")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsQueryString(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[builtins.str]] = None,
                 ignore: Optional[builtins.bool] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] excludes: Exclude these query string parameters from Cache Key.
        :param builtins.bool ignore: `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        :param Sequence[builtins.str] includes: Only use values of specified query string parameters in Cache Key.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if ignore is not None:
            pulumi.set(__self__, "ignore", ignore)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[builtins.str]]:
        """
        Exclude these query string parameters from Cache Key.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def ignore(self) -> Optional[builtins.bool]:
        """
        `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
        """
        return pulumi.get(self, "ignore")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PageRuleActionsCacheKeyFieldsUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsCacheKeyFieldsUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsCacheKeyFieldsUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsCacheKeyFieldsUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_type: Optional[builtins.bool] = None,
                 geo: Optional[builtins.bool] = None,
                 lang: Optional[builtins.bool] = None):
        """
        :param builtins.bool device_type: `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
        :param builtins.bool geo: `true` - includes the clients country, derived from the IP address; defaults to `false`.
        :param builtins.bool lang: `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
               
               Example:
               
               ```python
               import pulumi
               import pulumi_cloudflare as cloudflare
               
               # Unrealistic example with all features used
               foobar = cloudflare.PageRule("foobar",
                   zone_id=cloudflare_zone_id,
                   target=f"{cloudflare_zone}/app/*",
                   priority=1,
                   actions={
                       "cache_key_fields": {
                           "cookie": {
                               "check_presences": ["wordpress_test_cookie"],
                           },
                           "header": {
                               "check_presences": ["header_present"],
                               "excludes": ["origin"],
                               "includes": [
                                   "api-key",
                                   "dnt",
                               ],
                           },
                           "host": {
                               "resolved": True,
                           },
                           "query_string": {
                               "ignore": True,
                           },
                           "user": {
                               "device_type": False,
                               "geo": True,
                               "lang": True,
                           },
                       },
                   })
               ```
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[builtins.bool]:
        """
        `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[builtins.bool]:
        """
        `true` - includes the clients country, derived from the IP address; defaults to `false`.
        """
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[builtins.bool]:
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.

        Example:

        ```python
        import pulumi
        import pulumi_cloudflare as cloudflare

        # Unrealistic example with all features used
        foobar = cloudflare.PageRule("foobar",
            zone_id=cloudflare_zone_id,
            target=f"{cloudflare_zone}/app/*",
            priority=1,
            actions={
                "cache_key_fields": {
                    "cookie": {
                        "check_presences": ["wordpress_test_cookie"],
                    },
                    "header": {
                        "check_presences": ["header_present"],
                        "excludes": ["origin"],
                        "includes": [
                            "api-key",
                            "dnt",
                        ],
                    },
                    "host": {
                        "resolved": True,
                    },
                    "query_string": {
                        "ignore": True,
                    },
                    "user": {
                        "device_type": False,
                        "geo": True,
                        "lang": True,
                    },
                },
            })
        ```
        """
        return pulumi.get(self, "lang")


@pulumi.output_type
class PageRuleActionsCacheTtlByStatus(dict):
    def __init__(__self__, *,
                 codes: builtins.str,
                 ttl: builtins.int):
        """
        :param builtins.str codes: A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        :param builtins.int ttl: Duration a resource lives in the Cloudflare cache.
               - positive number - cache for specified duration in seconds
        """
        pulumi.set(__self__, "codes", codes)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def codes(self) -> builtins.str:
        """
        A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
        """
        return pulumi.get(self, "codes")

    @property
    @pulumi.getter
    def ttl(self) -> builtins.int:
        """
        Duration a resource lives in the Cloudflare cache.
        - positive number - cache for specified duration in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class PageRuleActionsForwardingUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PageRuleActionsForwardingUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PageRuleActionsForwardingUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PageRuleActionsForwardingUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: builtins.int,
                 url: builtins.str):
        """
        :param builtins.int status_code: The status code to use for the redirection.
        :param builtins.str url: The URL to which the page rule should forward.
        """
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> builtins.int:
        """
        The status code to use for the redirection.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def url(self) -> builtins.str:
        """
        The URL to which the page rule should forward.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PageRuleActionsMinify(dict):
    def __init__(__self__, *,
                 css: builtins.str,
                 html: builtins.str,
                 js: builtins.str):
        """
        :param builtins.str css: Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        :param builtins.str html: Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        :param builtins.str js: Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> builtins.str:
        """
        Whether CSS should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> builtins.str:
        """
        Whether HTML should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> builtins.str:
        """
        Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class PagesProjectBuildConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCaching":
            suggest = "build_caching"
        elif key == "buildCommand":
            suggest = "build_command"
        elif key == "destinationDir":
            suggest = "destination_dir"
        elif key == "rootDir":
            suggest = "root_dir"
        elif key == "webAnalyticsTag":
            suggest = "web_analytics_tag"
        elif key == "webAnalyticsToken":
            suggest = "web_analytics_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectBuildConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectBuildConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectBuildConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_caching: Optional[builtins.bool] = None,
                 build_command: Optional[builtins.str] = None,
                 destination_dir: Optional[builtins.str] = None,
                 root_dir: Optional[builtins.str] = None,
                 web_analytics_tag: Optional[builtins.str] = None,
                 web_analytics_token: Optional[builtins.str] = None):
        """
        :param builtins.bool build_caching: Enable build caching for the project.
        :param builtins.str build_command: Command used to build project.
        :param builtins.str destination_dir: Output directory of the build.
        :param builtins.str root_dir: Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        :param builtins.str web_analytics_tag: The classifying tag for analytics.
        :param builtins.str web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[builtins.bool]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[builtins.str]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[builtins.str]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[builtins.str]:
        """
        Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
        """
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[builtins.str]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[builtins.str]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")


@pulumi.output_type
class PagesProjectDeploymentConfigs(dict):
    def __init__(__self__, *,
                 preview: Optional['outputs.PagesProjectDeploymentConfigsPreview'] = None,
                 production: Optional['outputs.PagesProjectDeploymentConfigsProduction'] = None):
        """
        :param 'PagesProjectDeploymentConfigsPreviewArgs' preview: Configuration for preview deploys.
        :param 'PagesProjectDeploymentConfigsProductionArgs' production: Configuration for production deploys.
        """
        if preview is not None:
            pulumi.set(__self__, "preview", preview)
        if production is not None:
            pulumi.set(__self__, "production", production)

    @property
    @pulumi.getter
    def preview(self) -> Optional['outputs.PagesProjectDeploymentConfigsPreview']:
        """
        Configuration for preview deploys.
        """
        return pulumi.get(self, "preview")

    @property
    @pulumi.getter
    def production(self) -> Optional['outputs.PagesProjectDeploymentConfigsProduction']:
        """
        Configuration for production deploys.
        """
        return pulumi.get(self, "production")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreview(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysUseLatestCompatibilityDate":
            suggest = "always_use_latest_compatibility_date"
        elif key == "compatibilityDate":
            suggest = "compatibility_date"
        elif key == "compatibilityFlags":
            suggest = "compatibility_flags"
        elif key == "d1Databases":
            suggest = "d1_databases"
        elif key == "durableObjectNamespaces":
            suggest = "durable_object_namespaces"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "failOpen":
            suggest = "fail_open"
        elif key == "kvNamespaces":
            suggest = "kv_namespaces"
        elif key == "r2Buckets":
            suggest = "r2_buckets"
        elif key == "serviceBindings":
            suggest = "service_bindings"
        elif key == "usageModel":
            suggest = "usage_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsPreview. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsPreview.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsPreview.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_use_latest_compatibility_date: Optional[builtins.bool] = None,
                 compatibility_date: Optional[builtins.str] = None,
                 compatibility_flags: Optional[Sequence[builtins.str]] = None,
                 d1_databases: Optional[Mapping[str, builtins.str]] = None,
                 durable_object_namespaces: Optional[Mapping[str, builtins.str]] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 fail_open: Optional[builtins.bool] = None,
                 kv_namespaces: Optional[Mapping[str, builtins.str]] = None,
                 placement: Optional['outputs.PagesProjectDeploymentConfigsPreviewPlacement'] = None,
                 r2_buckets: Optional[Mapping[str, builtins.str]] = None,
                 secrets: Optional[Mapping[str, builtins.str]] = None,
                 service_bindings: Optional[Sequence['outputs.PagesProjectDeploymentConfigsPreviewServiceBinding']] = None,
                 usage_model: Optional[builtins.str] = None):
        """
        :param builtins.bool always_use_latest_compatibility_date: Use latest compatibility date for Pages Functions. Defaults to `false`.
        :param builtins.str compatibility_date: Compatibility date used for Pages Functions.
        :param Sequence[builtins.str] compatibility_flags: Compatibility flags used for Pages Functions.
        :param Mapping[str, builtins.str] d1_databases: D1 Databases used for Pages Functions. Defaults to `map[]`.
        :param Mapping[str, builtins.str] durable_object_namespaces: Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        :param Mapping[str, builtins.str] environment_variables: Environment variables for Pages Functions. Defaults to `map[]`.
        :param builtins.bool fail_open: Fail open used for Pages Functions. Defaults to `false`.
        :param Mapping[str, builtins.str] kv_namespaces: KV namespaces used for Pages Functions. Defaults to `map[]`.
        :param 'PagesProjectDeploymentConfigsPreviewPlacementArgs' placement: Configuration for placement in the Cloudflare Pages project.
        :param Mapping[str, builtins.str] r2_buckets: R2 Buckets used for Pages Functions. Defaults to `map[]`.
        :param Mapping[str, builtins.str] secrets: Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        :param Sequence['PagesProjectDeploymentConfigsPreviewServiceBindingArgs'] service_bindings: Services used for Pages Functions.
        :param builtins.str usage_model: Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
        if always_use_latest_compatibility_date is not None:
            pulumi.set(__self__, "always_use_latest_compatibility_date", always_use_latest_compatibility_date)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_bindings is not None:
            pulumi.set(__self__, "service_bindings", service_bindings)
        if usage_model is not None:
            pulumi.set(__self__, "usage_model", usage_model)

    @property
    @pulumi.getter(name="alwaysUseLatestCompatibilityDate")
    def always_use_latest_compatibility_date(self) -> Optional[builtins.bool]:
        """
        Use latest compatibility date for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "always_use_latest_compatibility_date")

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[builtins.str]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[Sequence[builtins.str]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[Mapping[str, builtins.str]]:
        """
        D1 Databases used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "d1_databases")

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[builtins.bool]:
        """
        Fail open used for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "fail_open")

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[Mapping[str, builtins.str]]:
        """
        KV namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "kv_namespaces")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.PagesProjectDeploymentConfigsPreviewPlacement']:
        """
        Configuration for placement in the Cloudflare Pages project.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[Mapping[str, builtins.str]]:
        """
        R2 Buckets used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "r2_buckets")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceBindings")
    def service_bindings(self) -> Optional[Sequence['outputs.PagesProjectDeploymentConfigsPreviewServiceBinding']]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "service_bindings")

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[builtins.str]:
        """
        Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
        return pulumi.get(self, "usage_model")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewPlacement(dict):
    def __init__(__self__, *,
                 mode: Optional[builtins.str] = None):
        """
        :param builtins.str mode: Placement Mode for the Pages Function.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Placement Mode for the Pages Function.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class PagesProjectDeploymentConfigsPreviewServiceBinding(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 service: builtins.str,
                 environment: Optional[builtins.str] = None):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str service: The name of the Worker to bind to.
        :param builtins.str environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> builtins.str:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")


@pulumi.output_type
class PagesProjectDeploymentConfigsProduction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysUseLatestCompatibilityDate":
            suggest = "always_use_latest_compatibility_date"
        elif key == "compatibilityDate":
            suggest = "compatibility_date"
        elif key == "compatibilityFlags":
            suggest = "compatibility_flags"
        elif key == "d1Databases":
            suggest = "d1_databases"
        elif key == "durableObjectNamespaces":
            suggest = "durable_object_namespaces"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "failOpen":
            suggest = "fail_open"
        elif key == "kvNamespaces":
            suggest = "kv_namespaces"
        elif key == "r2Buckets":
            suggest = "r2_buckets"
        elif key == "serviceBindings":
            suggest = "service_bindings"
        elif key == "usageModel":
            suggest = "usage_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectDeploymentConfigsProduction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectDeploymentConfigsProduction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectDeploymentConfigsProduction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_use_latest_compatibility_date: Optional[builtins.bool] = None,
                 compatibility_date: Optional[builtins.str] = None,
                 compatibility_flags: Optional[Sequence[builtins.str]] = None,
                 d1_databases: Optional[Mapping[str, builtins.str]] = None,
                 durable_object_namespaces: Optional[Mapping[str, builtins.str]] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 fail_open: Optional[builtins.bool] = None,
                 kv_namespaces: Optional[Mapping[str, builtins.str]] = None,
                 placement: Optional['outputs.PagesProjectDeploymentConfigsProductionPlacement'] = None,
                 r2_buckets: Optional[Mapping[str, builtins.str]] = None,
                 secrets: Optional[Mapping[str, builtins.str]] = None,
                 service_bindings: Optional[Sequence['outputs.PagesProjectDeploymentConfigsProductionServiceBinding']] = None,
                 usage_model: Optional[builtins.str] = None):
        """
        :param builtins.bool always_use_latest_compatibility_date: Use latest compatibility date for Pages Functions. Defaults to `false`.
        :param builtins.str compatibility_date: Compatibility date used for Pages Functions.
        :param Sequence[builtins.str] compatibility_flags: Compatibility flags used for Pages Functions.
        :param Mapping[str, builtins.str] d1_databases: D1 Databases used for Pages Functions. Defaults to `map[]`.
        :param Mapping[str, builtins.str] durable_object_namespaces: Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        :param Mapping[str, builtins.str] environment_variables: Environment variables for Pages Functions. Defaults to `map[]`.
        :param builtins.bool fail_open: Fail open used for Pages Functions. Defaults to `false`.
        :param Mapping[str, builtins.str] kv_namespaces: KV namespaces used for Pages Functions. Defaults to `map[]`.
        :param 'PagesProjectDeploymentConfigsProductionPlacementArgs' placement: Configuration for placement in the Cloudflare Pages project.
        :param Mapping[str, builtins.str] r2_buckets: R2 Buckets used for Pages Functions. Defaults to `map[]`.
        :param Mapping[str, builtins.str] secrets: Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        :param Sequence['PagesProjectDeploymentConfigsProductionServiceBindingArgs'] service_bindings: Services used for Pages Functions.
        :param builtins.str usage_model: Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
        if always_use_latest_compatibility_date is not None:
            pulumi.set(__self__, "always_use_latest_compatibility_date", always_use_latest_compatibility_date)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_bindings is not None:
            pulumi.set(__self__, "service_bindings", service_bindings)
        if usage_model is not None:
            pulumi.set(__self__, "usage_model", usage_model)

    @property
    @pulumi.getter(name="alwaysUseLatestCompatibilityDate")
    def always_use_latest_compatibility_date(self) -> Optional[builtins.bool]:
        """
        Use latest compatibility date for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "always_use_latest_compatibility_date")

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[builtins.str]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[Sequence[builtins.str]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[Mapping[str, builtins.str]]:
        """
        D1 Databases used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "d1_databases")

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[builtins.bool]:
        """
        Fail open used for Pages Functions. Defaults to `false`.
        """
        return pulumi.get(self, "fail_open")

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[Mapping[str, builtins.str]]:
        """
        KV namespaces used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "kv_namespaces")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.PagesProjectDeploymentConfigsProductionPlacement']:
        """
        Configuration for placement in the Cloudflare Pages project.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[Mapping[str, builtins.str]]:
        """
        R2 Buckets used for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "r2_buckets")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Encrypted environment variables for Pages Functions. Defaults to `map[]`.
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceBindings")
    def service_bindings(self) -> Optional[Sequence['outputs.PagesProjectDeploymentConfigsProductionServiceBinding']]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "service_bindings")

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[builtins.str]:
        """
        Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
        """
        return pulumi.get(self, "usage_model")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionPlacement(dict):
    def __init__(__self__, *,
                 mode: Optional[builtins.str] = None):
        """
        :param builtins.str mode: Placement Mode for the Pages Function.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Placement Mode for the Pages Function.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class PagesProjectDeploymentConfigsProductionServiceBinding(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 service: builtins.str,
                 environment: Optional[builtins.str] = None):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str service: The name of the Worker to bind to.
        :param builtins.str environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> builtins.str:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")


@pulumi.output_type
class PagesProjectSource(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.PagesProjectSourceConfig'] = None,
                 type: Optional[builtins.str] = None):
        """
        :param 'PagesProjectSourceConfigArgs' config: Configuration for the source of the Cloudflare Pages project.
        :param builtins.str type: Project host type.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.PagesProjectSourceConfig']:
        """
        Configuration for the source of the Cloudflare Pages project.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Project host type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PagesProjectSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productionBranch":
            suggest = "production_branch"
        elif key == "deploymentsEnabled":
            suggest = "deployments_enabled"
        elif key == "prCommentsEnabled":
            suggest = "pr_comments_enabled"
        elif key == "previewBranchExcludes":
            suggest = "preview_branch_excludes"
        elif key == "previewBranchIncludes":
            suggest = "preview_branch_includes"
        elif key == "previewDeploymentSetting":
            suggest = "preview_deployment_setting"
        elif key == "productionDeploymentEnabled":
            suggest = "production_deployment_enabled"
        elif key == "repoName":
            suggest = "repo_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesProjectSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesProjectSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesProjectSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 production_branch: builtins.str,
                 deployments_enabled: Optional[builtins.bool] = None,
                 owner: Optional[builtins.str] = None,
                 pr_comments_enabled: Optional[builtins.bool] = None,
                 preview_branch_excludes: Optional[Sequence[builtins.str]] = None,
                 preview_branch_includes: Optional[Sequence[builtins.str]] = None,
                 preview_deployment_setting: Optional[builtins.str] = None,
                 production_deployment_enabled: Optional[builtins.bool] = None,
                 repo_name: Optional[builtins.str] = None):
        """
        :param builtins.str production_branch: Project production branch name.
        :param builtins.bool deployments_enabled: Toggle deployments on this repo. Defaults to `true`.
        :param builtins.str owner: Project owner username. **Modifying this attribute will force creation of a new resource.**
        :param builtins.bool pr_comments_enabled: Enable Pages to comment on Pull Requests. Defaults to `true`.
        :param Sequence[builtins.str] preview_branch_excludes: Branches will be excluded from automatic deployment.
        :param Sequence[builtins.str] preview_branch_includes: Branches will be included for automatic deployment.
        :param builtins.str preview_deployment_setting: Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.
        :param builtins.bool production_deployment_enabled: Enable production deployments. Defaults to `true`.
        :param builtins.str repo_name: Project repository name. **Modifying this attribute will force creation of a new resource.**
        """
        pulumi.set(__self__, "production_branch", production_branch)
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_deployment_enabled is not None:
            pulumi.set(__self__, "production_deployment_enabled", production_deployment_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> builtins.str:
        """
        Project production branch name.
        """
        return pulumi.get(self, "production_branch")

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[builtins.bool]:
        """
        Toggle deployments on this repo. Defaults to `true`.
        """
        return pulumi.get(self, "deployments_enabled")

    @property
    @pulumi.getter
    def owner(self) -> Optional[builtins.str]:
        """
        Project owner username. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[builtins.bool]:
        """
        Enable Pages to comment on Pull Requests. Defaults to `true`.
        """
        return pulumi.get(self, "pr_comments_enabled")

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[Sequence[builtins.str]]:
        """
        Branches will be excluded from automatic deployment.
        """
        return pulumi.get(self, "preview_branch_excludes")

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[Sequence[builtins.str]]:
        """
        Branches will be included for automatic deployment.
        """
        return pulumi.get(self, "preview_branch_includes")

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[builtins.str]:
        """
        Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.
        """
        return pulumi.get(self, "preview_deployment_setting")

    @property
    @pulumi.getter(name="productionDeploymentEnabled")
    def production_deployment_enabled(self) -> Optional[builtins.bool]:
        """
        Enable production deployments. Defaults to `true`.
        """
        return pulumi.get(self, "production_deployment_enabled")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[builtins.str]:
        """
        Project repository name. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class RateLimitAction(dict):
    def __init__(__self__, *,
                 mode: builtins.str,
                 response: Optional['outputs.RateLimitActionResponse'] = None,
                 timeout: Optional[builtins.int] = None):
        """
        :param builtins.str mode: The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        :param 'RateLimitActionResponseArgs' response: Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        :param builtins.int timeout: The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
        pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RateLimitActionResponse']:
        """
        Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.int]:
        """
        The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RateLimitActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: builtins.str,
                 content_type: builtins.str):
        """
        :param builtins.str body: The body to return, the content here should conform to the `content_type`.
        :param builtins.str content_type: The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> builtins.str:
        """
        The body to return, the content here should conform to the `content_type`.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> builtins.str:
        """
        The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
        """
        return pulumi.get(self, "content_type")


@pulumi.output_type
class RateLimitCorrelate(dict):
    def __init__(__self__, *,
                 by: Optional[builtins.str] = None):
        """
        :param builtins.str by: If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
        if by is not None:
            pulumi.set(__self__, "by", by)

    @property
    @pulumi.getter
    def by(self) -> Optional[builtins.str]:
        """
        If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
        """
        return pulumi.get(self, "by")


@pulumi.output_type
class RateLimitMatch(dict):
    def __init__(__self__, *,
                 request: Optional['outputs.RateLimitMatchRequest'] = None,
                 response: Optional['outputs.RateLimitMatchResponse'] = None):
        """
        :param 'RateLimitMatchRequestArgs' request: Matches HTTP requests (from the client to Cloudflare).
        :param 'RateLimitMatchResponseArgs' response: Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.RateLimitMatchRequest']:
        """
        Matches HTTP requests (from the client to Cloudflare).
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.RateLimitMatchResponse']:
        """
        Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class RateLimitMatchRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlPattern":
            suggest = "url_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitMatchRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitMatchRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitMatchRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 methods: Optional[Sequence[builtins.str]] = None,
                 schemes: Optional[Sequence[builtins.str]] = None,
                 url_pattern: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] methods: HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
        :param Sequence[builtins.str] schemes: HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
        :param builtins.str url_pattern: The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
        """
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if schemes is not None:
            pulumi.set(__self__, "schemes", schemes)
        if url_pattern is not None:
            pulumi.set(__self__, "url_pattern", url_pattern)

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[builtins.str]]:
        """
        HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def schemes(self) -> Optional[Sequence[builtins.str]]:
        """
        HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
        """
        return pulumi.get(self, "schemes")

    @property
    @pulumi.getter(name="urlPattern")
    def url_pattern(self) -> Optional[builtins.str]:
        """
        The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
        """
        return pulumi.get(self, "url_pattern")


@pulumi.output_type
class RateLimitMatchResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originTraffic":
            suggest = "origin_traffic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitMatchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitMatchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitMatchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[Mapping[str, builtins.str]]] = None,
                 origin_traffic: Optional[builtins.bool] = None,
                 statuses: Optional[Sequence[builtins.int]] = None):
        """
        :param Sequence[Mapping[str, builtins.str]] headers: List of HTTP headers maps to match the origin response on.
        :param builtins.bool origin_traffic: Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
        :param Sequence[builtins.int] statuses: HTTP Status codes, can be one, many or indicate all by not providing this value.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if origin_traffic is not None:
            pulumi.set(__self__, "origin_traffic", origin_traffic)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[Mapping[str, builtins.str]]]:
        """
        List of HTTP headers maps to match the origin response on.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> Optional[builtins.bool]:
        """
        Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
        """
        return pulumi.get(self, "origin_traffic")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[builtins.int]]:
        """
        HTTP Status codes, can be one, many or indicate all by not providing this value.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class RecordData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "digestType":
            suggest = "digest_type"
        elif key == "keyTag":
            suggest = "key_tag"
        elif key == "latDegrees":
            suggest = "lat_degrees"
        elif key == "latDirection":
            suggest = "lat_direction"
        elif key == "latMinutes":
            suggest = "lat_minutes"
        elif key == "latSeconds":
            suggest = "lat_seconds"
        elif key == "longDegrees":
            suggest = "long_degrees"
        elif key == "longDirection":
            suggest = "long_direction"
        elif key == "longMinutes":
            suggest = "long_minutes"
        elif key == "longSeconds":
            suggest = "long_seconds"
        elif key == "matchingType":
            suggest = "matching_type"
        elif key == "precisionHorz":
            suggest = "precision_horz"
        elif key == "precisionVert":
            suggest = "precision_vert"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[builtins.int] = None,
                 altitude: Optional[builtins.float] = None,
                 certificate: Optional[builtins.str] = None,
                 content: Optional[builtins.str] = None,
                 digest: Optional[builtins.str] = None,
                 digest_type: Optional[builtins.int] = None,
                 fingerprint: Optional[builtins.str] = None,
                 flags: Optional[builtins.str] = None,
                 key_tag: Optional[builtins.int] = None,
                 lat_degrees: Optional[builtins.int] = None,
                 lat_direction: Optional[builtins.str] = None,
                 lat_minutes: Optional[builtins.int] = None,
                 lat_seconds: Optional[builtins.float] = None,
                 long_degrees: Optional[builtins.int] = None,
                 long_direction: Optional[builtins.str] = None,
                 long_minutes: Optional[builtins.int] = None,
                 long_seconds: Optional[builtins.float] = None,
                 matching_type: Optional[builtins.int] = None,
                 name: Optional[builtins.str] = None,
                 order: Optional[builtins.int] = None,
                 port: Optional[builtins.int] = None,
                 precision_horz: Optional[builtins.float] = None,
                 precision_vert: Optional[builtins.float] = None,
                 preference: Optional[builtins.int] = None,
                 priority: Optional[builtins.int] = None,
                 proto: Optional[builtins.str] = None,
                 protocol: Optional[builtins.int] = None,
                 public_key: Optional[builtins.str] = None,
                 regex: Optional[builtins.str] = None,
                 replacement: Optional[builtins.str] = None,
                 selector: Optional[builtins.int] = None,
                 service: Optional[builtins.str] = None,
                 size: Optional[builtins.float] = None,
                 tag: Optional[builtins.str] = None,
                 target: Optional[builtins.str] = None,
                 type: Optional[builtins.int] = None,
                 usage: Optional[builtins.int] = None,
                 value: Optional[builtins.str] = None,
                 weight: Optional[builtins.int] = None):
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if proto is not None:
            pulumi.set(__self__, "proto", proto)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[builtins.int]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def altitude(self) -> Optional[builtins.float]:
        return pulumi.get(self, "altitude")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def digest(self) -> Optional[builtins.str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[builtins.int]:
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[builtins.str]:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def flags(self) -> Optional[builtins.str]:
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[builtins.int]:
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[builtins.int]:
        return pulumi.get(self, "lat_degrees")

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[builtins.str]:
        return pulumi.get(self, "lat_direction")

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[builtins.int]:
        return pulumi.get(self, "lat_minutes")

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[builtins.float]:
        return pulumi.get(self, "lat_seconds")

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[builtins.int]:
        return pulumi.get(self, "long_degrees")

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[builtins.str]:
        return pulumi.get(self, "long_direction")

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[builtins.int]:
        return pulumi.get(self, "long_minutes")

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[builtins.float]:
        return pulumi.get(self, "long_seconds")

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[builtins.int]:
        return pulumi.get(self, "matching_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> Optional[builtins.int]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[builtins.float]:
        return pulumi.get(self, "precision_horz")

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[builtins.float]:
        return pulumi.get(self, "precision_vert")

    @property
    @pulumi.getter
    def preference(self) -> Optional[builtins.int]:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def priority(self) -> Optional[builtins.int]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def proto(self) -> Optional[builtins.str]:
        return pulumi.get(self, "proto")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.int]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.str]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[builtins.str]:
        return pulumi.get(self, "replacement")

    @property
    @pulumi.getter
    def selector(self) -> Optional[builtins.int]:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def service(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tag(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.int]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> Optional[builtins.int]:
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def weight(self) -> Optional[builtins.int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class RiskBehaviorBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "riskLevel":
            suggest = "risk_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskBehaviorBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskBehaviorBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskBehaviorBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 name: builtins.str,
                 risk_level: builtins.str):
        """
        :param builtins.bool enabled: Whether this risk behavior type is enabled.
        :param builtins.str name: Name of this risk behavior type
        :param builtins.str risk_level: Risk level. Available values: `low`, `medium`, `high`
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether this risk behavior type is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of this risk behavior type
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> builtins.str:
        """
        Risk level. Available values: `low`, `medium`, `high`
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class RulesetRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionParameters":
            suggest = "action_parameters"
        elif key == "exposedCredentialCheck":
            suggest = "exposed_credential_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: builtins.str,
                 action: Optional[builtins.str] = None,
                 action_parameters: Optional['outputs.RulesetRuleActionParameters'] = None,
                 description: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 exposed_credential_check: Optional['outputs.RulesetRuleExposedCredentialCheck'] = None,
                 id: Optional[builtins.str] = None,
                 logging: Optional['outputs.RulesetRuleLogging'] = None,
                 ratelimit: Optional['outputs.RulesetRuleRatelimit'] = None,
                 ref: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param builtins.str action: Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param 'RulesetRuleActionParametersArgs' action_parameters: List of parameters that configure the behavior of the ruleset rule action.
        :param builtins.str description: Brief summary of the ruleset rule and its intended use.
        :param builtins.bool enabled: Whether the rule is active.
        :param 'RulesetRuleExposedCredentialCheckArgs' exposed_credential_check: List of parameters that configure exposed credential checks.
        :param builtins.str id: Unique rule identifier.
        :param 'RulesetRuleLoggingArgs' logging: List parameters to configure how the rule generates logs. Only valid for skip action.
        :param 'RulesetRuleRatelimitArgs' ratelimit: List of parameters that configure HTTP rate limiting behaviour.
        :param builtins.str ref: Rule reference.
        """
        pulumi.set(__self__, "expression", expression)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional['outputs.RulesetRuleActionParameters']:
        """
        List of parameters that configure the behavior of the ruleset rule action.
        """
        return pulumi.get(self, "action_parameters")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Brief summary of the ruleset rule and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether the rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional['outputs.RulesetRuleExposedCredentialCheck']:
        """
        List of parameters that configure exposed credential checks.
        """
        return pulumi.get(self, "exposed_credential_check")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.RulesetRuleLogging']:
        """
        List parameters to configure how the rule generates logs. Only valid for skip action.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional['outputs.RulesetRuleRatelimit']:
        """
        List of parameters that configure HTTP rate limiting behaviour.
        """
        return pulumi.get(self, "ratelimit")

    @property
    @pulumi.getter
    def ref(self) -> Optional[builtins.str]:
        """
        Rule reference.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class RulesetRuleActionParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalCacheablePorts":
            suggest = "additional_cacheable_ports"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "browserTtl":
            suggest = "browser_ttl"
        elif key == "cacheKey":
            suggest = "cache_key"
        elif key == "cacheReserve":
            suggest = "cache_reserve"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "cookieFields":
            suggest = "cookie_fields"
        elif key == "disableApps":
            suggest = "disable_apps"
        elif key == "disableRailgun":
            suggest = "disable_railgun"
        elif key == "disableRum":
            suggest = "disable_rum"
        elif key == "disableZaraz":
            suggest = "disable_zaraz"
        elif key == "edgeTtl":
            suggest = "edge_ttl"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "fromList":
            suggest = "from_list"
        elif key == "fromValue":
            suggest = "from_value"
        elif key == "hostHeader":
            suggest = "host_header"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "matchedData":
            suggest = "matched_data"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "originCacheControl":
            suggest = "origin_cache_control"
        elif key == "originErrorPagePassthru":
            suggest = "origin_error_page_passthru"
        elif key == "readTimeout":
            suggest = "read_timeout"
        elif key == "requestFields":
            suggest = "request_fields"
        elif key == "respectStrongEtags":
            suggest = "respect_strong_etags"
        elif key == "responseFields":
            suggest = "response_fields"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serveStale":
            suggest = "serve_stale"
        elif key == "serverSideExcludes":
            suggest = "server_side_excludes"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_cacheable_ports: Optional[Sequence[builtins.int]] = None,
                 algorithms: Optional[Sequence['outputs.RulesetRuleActionParametersAlgorithm']] = None,
                 automatic_https_rewrites: Optional[builtins.bool] = None,
                 autominifies: Optional[Sequence['outputs.RulesetRuleActionParametersAutominify']] = None,
                 bic: Optional[builtins.bool] = None,
                 browser_ttl: Optional['outputs.RulesetRuleActionParametersBrowserTtl'] = None,
                 cache: Optional[builtins.bool] = None,
                 cache_key: Optional['outputs.RulesetRuleActionParametersCacheKey'] = None,
                 cache_reserve: Optional['outputs.RulesetRuleActionParametersCacheReserve'] = None,
                 content: Optional[builtins.str] = None,
                 content_type: Optional[builtins.str] = None,
                 cookie_fields: Optional[Sequence[builtins.str]] = None,
                 disable_apps: Optional[builtins.bool] = None,
                 disable_railgun: Optional[builtins.bool] = None,
                 disable_rum: Optional[builtins.bool] = None,
                 disable_zaraz: Optional[builtins.bool] = None,
                 edge_ttl: Optional['outputs.RulesetRuleActionParametersEdgeTtl'] = None,
                 email_obfuscation: Optional[builtins.bool] = None,
                 fonts: Optional[builtins.bool] = None,
                 from_list: Optional['outputs.RulesetRuleActionParametersFromList'] = None,
                 from_value: Optional['outputs.RulesetRuleActionParametersFromValue'] = None,
                 headers: Optional[Sequence['outputs.RulesetRuleActionParametersHeader']] = None,
                 host_header: Optional[builtins.str] = None,
                 hotlink_protection: Optional[builtins.bool] = None,
                 id: Optional[builtins.str] = None,
                 increment: Optional[builtins.int] = None,
                 matched_data: Optional['outputs.RulesetRuleActionParametersMatchedData'] = None,
                 mirage: Optional[builtins.bool] = None,
                 opportunistic_encryption: Optional[builtins.bool] = None,
                 origin: Optional['outputs.RulesetRuleActionParametersOrigin'] = None,
                 origin_cache_control: Optional[builtins.bool] = None,
                 origin_error_page_passthru: Optional[builtins.bool] = None,
                 overrides: Optional['outputs.RulesetRuleActionParametersOverrides'] = None,
                 phases: Optional[Sequence[builtins.str]] = None,
                 polish: Optional[builtins.str] = None,
                 products: Optional[Sequence[builtins.str]] = None,
                 read_timeout: Optional[builtins.int] = None,
                 request_fields: Optional[Sequence[builtins.str]] = None,
                 respect_strong_etags: Optional[builtins.bool] = None,
                 response_fields: Optional[Sequence[builtins.str]] = None,
                 responses: Optional[Sequence['outputs.RulesetRuleActionParametersResponse']] = None,
                 rocket_loader: Optional[builtins.bool] = None,
                 rules: Optional[Mapping[str, builtins.str]] = None,
                 ruleset: Optional[builtins.str] = None,
                 rulesets: Optional[Sequence[builtins.str]] = None,
                 security_level: Optional[builtins.str] = None,
                 serve_stale: Optional['outputs.RulesetRuleActionParametersServeStale'] = None,
                 server_side_excludes: Optional[builtins.bool] = None,
                 sni: Optional['outputs.RulesetRuleActionParametersSni'] = None,
                 ssl: Optional[builtins.str] = None,
                 status_code: Optional[builtins.int] = None,
                 sxg: Optional[builtins.bool] = None,
                 uri: Optional['outputs.RulesetRuleActionParametersUri'] = None):
        """
        :param Sequence[builtins.int] additional_cacheable_ports: Specifies uncommon ports to allow cacheable assets to be served from.
        :param Sequence['RulesetRuleActionParametersAlgorithmArgs'] algorithms: Compression algorithms to use in order of preference.
        :param builtins.bool automatic_https_rewrites: Turn on or off Cloudflare Automatic HTTPS rewrites.
        :param Sequence['RulesetRuleActionParametersAutominifyArgs'] autominifies: Indicate which file extensions to minify automatically.
        :param builtins.bool bic: Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        :param 'RulesetRuleActionParametersBrowserTtlArgs' browser_ttl: List of browser TTL parameters to apply to the request.
        :param builtins.bool cache: Whether to cache if expression matches.
        :param 'RulesetRuleActionParametersCacheKeyArgs' cache_key: List of cache key parameters to apply to the request.
        :param 'RulesetRuleActionParametersCacheReserveArgs' cache_reserve: List of cache reserve parameters to apply to the request.
        :param builtins.str content: Content of the custom error response.
        :param builtins.str content_type: Content-Type of the custom error response.
        :param Sequence[builtins.str] cookie_fields: List of cookie values to include as part of custom fields logging.
        :param builtins.bool disable_apps: Turn off all active Cloudflare Apps.
        :param builtins.bool disable_railgun: Turn off railgun feature of the Cloudflare Speed app.
        :param builtins.bool disable_rum: Turn off RUM feature.
        :param builtins.bool disable_zaraz: Turn off zaraz feature.
        :param 'RulesetRuleActionParametersEdgeTtlArgs' edge_ttl: List of edge TTL parameters to apply to the request.
        :param builtins.bool email_obfuscation: Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        :param builtins.bool fonts: Toggle fonts.
        :param 'RulesetRuleActionParametersFromListArgs' from_list: Use a list to lookup information for the action.
        :param 'RulesetRuleActionParametersFromValueArgs' from_value: Use a value to lookup information for the action.
        :param Sequence['RulesetRuleActionParametersHeaderArgs'] headers: List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
        :param builtins.str host_header: Host Header that request origin receives.
        :param builtins.bool hotlink_protection: Turn on or off the hotlink protection feature.
        :param builtins.str id: Identifier of the action parameter to modify.
        :param 'RulesetRuleActionParametersMatchedDataArgs' matched_data: List of properties to configure WAF payload logging.
        :param builtins.bool mirage: Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        :param builtins.bool opportunistic_encryption: Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        :param 'RulesetRuleActionParametersOriginArgs' origin: List of properties to change request origin.
        :param builtins.bool origin_cache_control: Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
        :param builtins.bool origin_error_page_passthru: Pass-through error page for origin.
        :param 'RulesetRuleActionParametersOverridesArgs' overrides: List of override configurations to apply to the ruleset.
        :param Sequence[builtins.str] phases: Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        :param builtins.str polish: Apply options from the Polish feature of the Cloudflare Speed app.
        :param Sequence[builtins.str] products: Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
        :param builtins.int read_timeout: Specifies a maximum timeout for reading content from an origin server.
        :param Sequence[builtins.str] request_fields: List of request headers to include as part of custom fields logging, in lowercase.
        :param builtins.bool respect_strong_etags: Respect strong ETags.
        :param Sequence[builtins.str] response_fields: List of response headers to include as part of custom fields logging, in lowercase.
        :param Sequence['RulesetRuleActionParametersResponseArgs'] responses: List of parameters that configure the response given to end users.
        :param builtins.bool rocket_loader: Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        :param Mapping[str, builtins.str] rules: Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`.
        :param builtins.str ruleset: Which ruleset ID to target.
        :param Sequence[builtins.str] rulesets: List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
        :param builtins.str security_level: Control options for the Security Level feature from the Security app.
        :param 'RulesetRuleActionParametersServeStaleArgs' serve_stale: List of serve stale parameters to apply to the request.
        :param builtins.bool server_side_excludes: Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        :param 'RulesetRuleActionParametersSniArgs' sni: List of properties to manange Server Name Indication.
        :param builtins.str ssl: Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        :param builtins.int status_code: HTTP status code of the custom error response.
        :param builtins.bool sxg: Turn on or off the SXG feature.
        :param 'RulesetRuleActionParametersUriArgs' uri: List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        """
        if additional_cacheable_ports is not None:
            pulumi.set(__self__, "additional_cacheable_ports", additional_cacheable_ports)
        if algorithms is not None:
            pulumi.set(__self__, "algorithms", algorithms)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if autominifies is not None:
            pulumi.set(__self__, "autominifies", autominifies)
        if bic is not None:
            pulumi.set(__self__, "bic", bic)
        if browser_ttl is not None:
            pulumi.set(__self__, "browser_ttl", browser_ttl)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if cache_key is not None:
            pulumi.set(__self__, "cache_key", cache_key)
        if cache_reserve is not None:
            pulumi.set(__self__, "cache_reserve", cache_reserve)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if cookie_fields is not None:
            pulumi.set(__self__, "cookie_fields", cookie_fields)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_rum is not None:
            pulumi.set(__self__, "disable_rum", disable_rum)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            pulumi.set(__self__, "edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if from_list is not None:
            pulumi.set(__self__, "from_list", from_list)
        if from_value is not None:
            pulumi.set(__self__, "from_value", from_value)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_cache_control is not None:
            pulumi.set(__self__, "origin_cache_control", origin_cache_control)
        if origin_error_page_passthru is not None:
            pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if request_fields is not None:
            pulumi.set(__self__, "request_fields", request_fields)
        if respect_strong_etags is not None:
            pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        if response_fields is not None:
            pulumi.set(__self__, "response_fields", response_fields)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if serve_stale is not None:
            pulumi.set(__self__, "serve_stale", serve_stale)
        if server_side_excludes is not None:
            pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if sxg is not None:
            pulumi.set(__self__, "sxg", sxg)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="additionalCacheablePorts")
    def additional_cacheable_ports(self) -> Optional[Sequence[builtins.int]]:
        """
        Specifies uncommon ports to allow cacheable assets to be served from.
        """
        return pulumi.get(self, "additional_cacheable_ports")

    @property
    @pulumi.getter
    def algorithms(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersAlgorithm']]:
        """
        Compression algorithms to use in order of preference.
        """
        return pulumi.get(self, "algorithms")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[builtins.bool]:
        """
        Turn on or off Cloudflare Automatic HTTPS rewrites.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter
    def autominifies(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersAutominify']]:
        """
        Indicate which file extensions to minify automatically.
        """
        return pulumi.get(self, "autominifies")

    @property
    @pulumi.getter
    def bic(self) -> Optional[builtins.bool]:
        """
        Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        """
        return pulumi.get(self, "bic")

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional['outputs.RulesetRuleActionParametersBrowserTtl']:
        """
        List of browser TTL parameters to apply to the request.
        """
        return pulumi.get(self, "browser_ttl")

    @property
    @pulumi.getter
    def cache(self) -> Optional[builtins.bool]:
        """
        Whether to cache if expression matches.
        """
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional['outputs.RulesetRuleActionParametersCacheKey']:
        """
        List of cache key parameters to apply to the request.
        """
        return pulumi.get(self, "cache_key")

    @property
    @pulumi.getter(name="cacheReserve")
    def cache_reserve(self) -> Optional['outputs.RulesetRuleActionParametersCacheReserve']:
        """
        List of cache reserve parameters to apply to the request.
        """
        return pulumi.get(self, "cache_reserve")

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        """
        Content of the custom error response.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[builtins.str]:
        """
        Content-Type of the custom error response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[Sequence[builtins.str]]:
        """
        List of cookie values to include as part of custom fields logging.
        """
        return pulumi.get(self, "cookie_fields")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[builtins.bool]:
        """
        Turn off all active Cloudflare Apps.
        """
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[builtins.bool]:
        """
        Turn off railgun feature of the Cloudflare Speed app.
        """
        return pulumi.get(self, "disable_railgun")

    @property
    @pulumi.getter(name="disableRum")
    def disable_rum(self) -> Optional[builtins.bool]:
        """
        Turn off RUM feature.
        """
        return pulumi.get(self, "disable_rum")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[builtins.bool]:
        """
        Turn off zaraz feature.
        """
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional['outputs.RulesetRuleActionParametersEdgeTtl']:
        """
        List of edge TTL parameters to apply to the request.
        """
        return pulumi.get(self, "edge_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[builtins.bool]:
        """
        Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        """
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter
    def fonts(self) -> Optional[builtins.bool]:
        """
        Toggle fonts.
        """
        return pulumi.get(self, "fonts")

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional['outputs.RulesetRuleActionParametersFromList']:
        """
        Use a list to lookup information for the action.
        """
        return pulumi.get(self, "from_list")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional['outputs.RulesetRuleActionParametersFromValue']:
        """
        Use a value to lookup information for the action.
        """
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersHeader']]:
        """
        List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[builtins.str]:
        """
        Host Header that request origin receives.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[builtins.bool]:
        """
        Turn on or off the hotlink protection feature.
        """
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Identifier of the action parameter to modify.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def increment(self) -> Optional[builtins.int]:
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional['outputs.RulesetRuleActionParametersMatchedData']:
        """
        List of properties to configure WAF payload logging.
        """
        return pulumi.get(self, "matched_data")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[builtins.bool]:
        """
        Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        """
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[builtins.bool]:
        """
        Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter
    def origin(self) -> Optional['outputs.RulesetRuleActionParametersOrigin']:
        """
        List of properties to change request origin.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="originCacheControl")
    def origin_cache_control(self) -> Optional[builtins.bool]:
        """
        Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
        """
        return pulumi.get(self, "origin_cache_control")

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[builtins.bool]:
        """
        Pass-through error page for origin.
        """
        return pulumi.get(self, "origin_error_page_passthru")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.RulesetRuleActionParametersOverrides']:
        """
        List of override configurations to apply to the ruleset.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def phases(self) -> Optional[Sequence[builtins.str]]:
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        """
        return pulumi.get(self, "phases")

    @property
    @pulumi.getter
    def polish(self) -> Optional[builtins.str]:
        """
        Apply options from the Polish feature of the Cloudflare Speed app.
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[builtins.str]]:
        """
        Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[builtins.int]:
        """
        Specifies a maximum timeout for reading content from an origin server.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[Sequence[builtins.str]]:
        """
        List of request headers to include as part of custom fields logging, in lowercase.
        """
        return pulumi.get(self, "request_fields")

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[builtins.bool]:
        """
        Respect strong ETags.
        """
        return pulumi.get(self, "respect_strong_etags")

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[Sequence[builtins.str]]:
        """
        List of response headers to include as part of custom fields logging, in lowercase.
        """
        return pulumi.get(self, "response_fields")

    @property
    @pulumi.getter
    def responses(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersResponse']]:
        """
        List of parameters that configure the response given to end users.
        """
        return pulumi.get(self, "responses")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[builtins.bool]:
        """
        Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        """
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[builtins.str]:
        """
        Which ruleset ID to target.
        """
        return pulumi.get(self, "ruleset")

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[Sequence[builtins.str]]:
        """
        List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
        """
        return pulumi.get(self, "rulesets")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[builtins.str]:
        """
        Control options for the Security Level feature from the Security app.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional['outputs.RulesetRuleActionParametersServeStale']:
        """
        List of serve stale parameters to apply to the request.
        """
        return pulumi.get(self, "serve_stale")

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[builtins.bool]:
        """
        Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        """
        return pulumi.get(self, "server_side_excludes")

    @property
    @pulumi.getter
    def sni(self) -> Optional['outputs.RulesetRuleActionParametersSni']:
        """
        List of properties to manange Server Name Indication.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[builtins.str]:
        """
        Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        HTTP status code of the custom error response.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def sxg(self) -> Optional[builtins.bool]:
        """
        Turn on or off the SXG feature.
        """
        return pulumi.get(self, "sxg")

    @property
    @pulumi.getter
    def uri(self) -> Optional['outputs.RulesetRuleActionParametersUri']:
        """
        List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class RulesetRuleActionParametersAlgorithm(dict):
    def __init__(__self__, *,
                 name: builtins.str):
        """
        :param builtins.str name: Name of the compression algorithm to use. Available values: `zstd`, `gzip`, `brotli`, `auto`, `default`, `none`
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the compression algorithm to use. Available values: `zstd`, `gzip`, `brotli`, `auto`, `default`, `none`
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersAutominify(dict):
    def __init__(__self__, *,
                 css: Optional[builtins.bool] = None,
                 html: Optional[builtins.bool] = None,
                 js: Optional[builtins.bool] = None):
        """
        :param builtins.bool css: CSS minification.
        :param builtins.bool html: HTML minification.
        :param builtins.bool js: JS minification.
        """
        if css is not None:
            pulumi.set(__self__, "css", css)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if js is not None:
            pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> Optional[builtins.bool]:
        """
        CSS minification.
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> Optional[builtins.bool]:
        """
        HTML minification.
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> Optional[builtins.bool]:
        """
        JS minification.
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class RulesetRuleActionParametersBrowserTtl(dict):
    def __init__(__self__, *,
                 mode: builtins.str,
                 default: Optional[builtins.int] = None):
        """
        :param builtins.str mode: Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        :param builtins.int default: Default browser TTL. This value is required when override_origin is set
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[builtins.int]:
        """
        Default browser TTL. This value is required when override_origin is set
        """
        return pulumi.get(self, "default")


@pulumi.output_type
class RulesetRuleActionParametersCacheKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheByDeviceType":
            suggest = "cache_by_device_type"
        elif key == "cacheDeceptionArmor":
            suggest = "cache_deception_armor"
        elif key == "customKey":
            suggest = "custom_key"
        elif key == "ignoreQueryStringsOrder":
            suggest = "ignore_query_strings_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_by_device_type: Optional[builtins.bool] = None,
                 cache_deception_armor: Optional[builtins.bool] = None,
                 custom_key: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKey'] = None,
                 ignore_query_strings_order: Optional[builtins.bool] = None):
        """
        :param builtins.bool cache_by_device_type: Cache by device type.
        :param builtins.bool cache_deception_armor: Cache deception armor.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyArgs' custom_key: Custom key parameters for the request.
        :param builtins.bool ignore_query_strings_order: Ignore query strings order.
        """
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if ignore_query_strings_order is not None:
            pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[builtins.bool]:
        """
        Cache by device type.
        """
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[builtins.bool]:
        """
        Cache deception armor.
        """
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKey']:
        """
        Custom key parameters for the request.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[builtins.bool]:
        """
        Ignore query strings order.
        """
        return pulumi.get(self, "ignore_query_strings_order")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie'] = None,
                 header: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader'] = None,
                 host: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost'] = None,
                 query_string: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString'] = None,
                 user: Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser'] = None):
        """
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs' cookie: Cookie parameters for the custom key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs' header: Header parameters for the custom key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyHostArgs' host: Host parameters for the custom key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs' query_string: Query string parameters for the custom key.
        :param 'RulesetRuleActionParametersCacheKeyCustomKeyUserArgs' user: User parameters for the custom key.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie']:
        """
        Cookie parameters for the custom key.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader']:
        """
        Header parameters for the custom key.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def host(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost']:
        """
        Host parameters for the custom key.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString']:
        """
        Query string parameters for the custom key.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> Optional['outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser']:
        """
        User parameters for the custom key.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[builtins.str]] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] check_presences: List of cookies to check for presence in the custom key.
        :param Sequence[builtins.str] includes: List of cookies to include in the custom key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[builtins.str]]:
        """
        List of cookies to check for presence in the custom key.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of cookies to include in the custom key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresences":
            suggest = "check_presences"
        elif key == "excludeOrigin":
            suggest = "exclude_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presences: Optional[Sequence[builtins.str]] = None,
                 contains: Optional[Mapping[str, Sequence[builtins.str]]] = None,
                 exclude_origin: Optional[builtins.bool] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] check_presences: List of headers to check for presence in the custom key.
        :param Mapping[str, Sequence[builtins.str]] contains: Dictionary of headers mapping to lists of values to check for presence in the custom key.
        :param builtins.bool exclude_origin: Exclude the origin header from the custom key.
        :param Sequence[builtins.str] includes: List of headers to include in the custom key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exclude_origin is not None:
            pulumi.set(__self__, "exclude_origin", exclude_origin)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[builtins.str]]:
        """
        List of headers to check for presence in the custom key.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def contains(self) -> Optional[Mapping[str, Sequence[builtins.str]]]:
        """
        Dictionary of headers mapping to lists of values to check for presence in the custom key.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[builtins.bool]:
        """
        Exclude the origin header from the custom key.
        """
        return pulumi.get(self, "exclude_origin")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of headers to include in the custom key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyHost(dict):
    def __init__(__self__, *,
                 resolved: Optional[builtins.bool] = None):
        """
        :param builtins.bool resolved: Resolve hostname to IP address.
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[builtins.bool]:
        """
        Resolve hostname to IP address.
        """
        return pulumi.get(self, "resolved")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryString(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[builtins.str]] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] excludes: List of query string parameters to exclude from the custom key.
        :param Sequence[builtins.str] includes: List of query string parameters to include in the custom key.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of query string parameters to exclude from the custom key.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of query string parameters to include in the custom key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class RulesetRuleActionParametersCacheKeyCustomKeyUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheKeyCustomKeyUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheKeyCustomKeyUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_type: Optional[builtins.bool] = None,
                 geo: Optional[builtins.bool] = None,
                 lang: Optional[builtins.bool] = None):
        """
        :param builtins.bool device_type: Add device type to the custom key.
        :param builtins.bool geo: Add geo data to the custom key.
        :param builtins.bool lang: Add language data to the custom key.
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[builtins.bool]:
        """
        Add device type to the custom key.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[builtins.bool]:
        """
        Add geo data to the custom key.
        """
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[builtins.bool]:
        """
        Add language data to the custom key.
        """
        return pulumi.get(self, "lang")


@pulumi.output_type
class RulesetRuleActionParametersCacheReserve(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumFileSize":
            suggest = "minimum_file_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersCacheReserve. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersCacheReserve.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersCacheReserve.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eligible: builtins.bool,
                 minimum_file_size: Optional[builtins.int] = None):
        """
        :param builtins.bool eligible: Determines whether Cloudflare will write the eligible resource to cache reserve.
        :param builtins.int minimum_file_size: The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and "eligible" is true, Cloudflare will use 0 bytes by default.
        """
        pulumi.set(__self__, "eligible", eligible)
        if minimum_file_size is not None:
            pulumi.set(__self__, "minimum_file_size", minimum_file_size)

    @property
    @pulumi.getter
    def eligible(self) -> builtins.bool:
        """
        Determines whether Cloudflare will write the eligible resource to cache reserve.
        """
        return pulumi.get(self, "eligible")

    @property
    @pulumi.getter(name="minimumFileSize")
    def minimum_file_size(self) -> Optional[builtins.int]:
        """
        The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and "eligible" is true, Cloudflare will use 0 bytes by default.
        """
        return pulumi.get(self, "minimum_file_size")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeTtls":
            suggest = "status_code_ttls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: builtins.str,
                 default: Optional[builtins.int] = None,
                 status_code_ttls: Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl']] = None):
        """
        :param builtins.str mode: Mode of the edge TTL. Available values: `override_origin`, `respect_origin`, `bypass_by_default`
        :param builtins.int default: Default edge TTL.
        :param Sequence['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs'] status_code_ttls: Edge TTL for the status codes.
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if status_code_ttls is not None:
            pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Mode of the edge TTL. Available values: `override_origin`, `respect_origin`, `bypass_by_default`
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[builtins.int]:
        """
        Default edge TTL.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl']]:
        """
        Edge TTL for the status codes.
        """
        return pulumi.get(self, "status_code_ttls")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"
        elif key == "statusCodeRanges":
            suggest = "status_code_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtlStatusCodeTtl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: Optional[builtins.int] = None,
                 status_code_ranges: Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange']] = None,
                 value: Optional[builtins.int] = None):
        """
        :param builtins.int status_code: Status code for which the edge TTL is applied.
        :param Sequence['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs'] status_code_ranges: Status code range for which the edge TTL is applied.
        :param builtins.int value: Status code edge TTL value.
        """
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if status_code_ranges is not None:
            pulumi.set(__self__, "status_code_ranges", status_code_ranges)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        Status code for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange']]:
        """
        Status code range for which the edge TTL is applied.
        """
        return pulumi.get(self, "status_code_ranges")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.int]:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[builtins.int] = None,
                 to: Optional[builtins.int] = None):
        """
        :param builtins.int from_: From status code.
        :param builtins.int to: To status code.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[builtins.int]:
        """
        From status code.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[builtins.int]:
        """
        To status code.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class RulesetRuleActionParametersFromList(dict):
    def __init__(__self__, *,
                 key: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str key: Expression to use for the list lookup.
        :param builtins.str name: Name of the list.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Expression to use for the list lookup.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the list.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RulesetRuleActionParametersFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preserveQueryString":
            suggest = "preserve_query_string"
        elif key == "statusCode":
            suggest = "status_code"
        elif key == "targetUrl":
            suggest = "target_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preserve_query_string: Optional[builtins.bool] = None,
                 status_code: Optional[builtins.int] = None,
                 target_url: Optional['outputs.RulesetRuleActionParametersFromValueTargetUrl'] = None):
        """
        :param builtins.bool preserve_query_string: Preserve query string for redirect URL.
        :param builtins.int status_code: Status code for redirect.
        :param 'RulesetRuleActionParametersFromValueTargetUrlArgs' target_url: Target URL for redirect.
        """
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[builtins.bool]:
        """
        Preserve query string for redirect URL.
        """
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        Status code for redirect.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional['outputs.RulesetRuleActionParametersFromValueTargetUrl']:
        """
        Target URL for redirect.
        """
        return pulumi.get(self, "target_url")


@pulumi.output_type
class RulesetRuleActionParametersFromValueTargetUrl(dict):
    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param builtins.str value: Static value to provide as the HTTP request header value.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Static value to provide as the HTTP request header value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersHeader(dict):
    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 operation: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param builtins.str name: Name of the HTTP request header to target.
        :param builtins.str operation: Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
        :param builtins.str value: Static value to provide as the HTTP request header value.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the HTTP request header to target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operation(self) -> Optional[builtins.str]:
        """
        Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Static value to provide as the HTTP request header value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersMatchedData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersMatchedData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersMatchedData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersMatchedData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: Optional[builtins.str] = None):
        """
        :param builtins.str public_key: Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[builtins.str]:
        """
        Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class RulesetRuleActionParametersOrigin(dict):
    def __init__(__self__, *,
                 host: Optional[builtins.str] = None,
                 port: Optional[builtins.int] = None):
        """
        :param builtins.str host: Origin Hostname where request is sent.
        :param builtins.int port: Origin Port where request is sent.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[builtins.str]:
        """
        Origin Hostname where request is sent.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        Origin Port where request is sent.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RulesetRuleActionParametersOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 categories: Optional[Sequence['outputs.RulesetRuleActionParametersOverridesCategory']] = None,
                 enabled: Optional[builtins.bool] = None,
                 rules: Optional[Sequence['outputs.RulesetRuleActionParametersOverridesRule']] = None,
                 sensitivity_level: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param Sequence['RulesetRuleActionParametersOverridesCategoryArgs'] categories: List of tag-based overrides.
        :param builtins.bool enabled: Defines if the current ruleset-level override enables or disables the ruleset.
        :param Sequence['RulesetRuleActionParametersOverridesRuleArgs'] rules: List of rule-based overrides.
        :param builtins.str sensitivity_level: Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersOverridesCategory']]:
        """
        List of tag-based overrides.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Defines if the current ruleset-level override enables or disables the ruleset.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.RulesetRuleActionParametersOverridesRule']]:
        """
        List of rule-based overrides.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[builtins.str]:
        """
        Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RulesetRuleActionParametersOverridesCategory(dict):
    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 category: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str action: Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param builtins.str category: Tag name to apply the ruleset rule override to.
        :param builtins.bool enabled: Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Tag name to apply the ruleset rule override to.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RulesetRuleActionParametersOverridesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoreThreshold":
            suggest = "score_threshold"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersOverridesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersOverridesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersOverridesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 id: Optional[builtins.str] = None,
                 score_threshold: Optional[builtins.int] = None,
                 sensitivity_level: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        :param builtins.bool enabled: Defines if the current rule-level override enables or disables the rule.
        :param builtins.str id: Rule ID to apply the override to.
        :param builtins.int score_threshold: Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        :param builtins.str sensitivity_level: Sensitivity level for a ruleset rule override.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Defines if the current rule-level override enables or disables the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Rule ID to apply the override to.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[builtins.int]:
        """
        Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        """
        return pulumi.get(self, "score_threshold")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[builtins.str]:
        """
        Sensitivity level for a ruleset rule override.
        """
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RulesetRuleActionParametersResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: Optional[builtins.str] = None,
                 content_type: Optional[builtins.str] = None,
                 status_code: Optional[builtins.int] = None):
        """
        :param builtins.str content: Body content to include in the response.
        :param builtins.str content_type: HTTP content type to send in the response.
        :param builtins.int status_code: HTTP status code to send in the response.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        """
        Body content to include in the response.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[builtins.str]:
        """
        HTTP content type to send in the response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        HTTP status code to send in the response.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class RulesetRuleActionParametersServeStale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableStaleWhileUpdating":
            suggest = "disable_stale_while_updating"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionParametersServeStale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionParametersServeStale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionParametersServeStale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_stale_while_updating: Optional[builtins.bool] = None):
        """
        :param builtins.bool disable_stale_while_updating: Disable stale while updating.
        """
        if disable_stale_while_updating is not None:
            pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> Optional[builtins.bool]:
        """
        Disable stale while updating.
        """
        return pulumi.get(self, "disable_stale_while_updating")


@pulumi.output_type
class RulesetRuleActionParametersSni(dict):
    def __init__(__self__, *,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str value: Value to define for SNI.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value to define for SNI.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersUri(dict):
    def __init__(__self__, *,
                 origin: Optional[builtins.bool] = None,
                 path: Optional['outputs.RulesetRuleActionParametersUriPath'] = None,
                 query: Optional['outputs.RulesetRuleActionParametersUriQuery'] = None):
        """
        :param 'RulesetRuleActionParametersUriPathArgs' path: URI path configuration when performing a URL rewrite.
        :param 'RulesetRuleActionParametersUriQueryArgs' query: Query string configuration when performing a URL rewrite.
        """
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def origin(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.RulesetRuleActionParametersUriPath']:
        """
        URI path configuration when performing a URL rewrite.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> Optional['outputs.RulesetRuleActionParametersUriQuery']:
        """
        Query string configuration when performing a URL rewrite.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class RulesetRuleActionParametersUriPath(dict):
    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param builtins.str value: Static string value of the updated URI path or query string component.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Static string value of the updated URI path or query string component.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionParametersUriQuery(dict):
    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param builtins.str value: Static string value of the updated URI path or query string component.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Static string value of the updated URI path or query string component.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleExposedCredentialCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordExpression":
            suggest = "password_expression"
        elif key == "usernameExpression":
            suggest = "username_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleExposedCredentialCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleExposedCredentialCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleExposedCredentialCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_expression: Optional[builtins.str] = None,
                 username_expression: Optional[builtins.str] = None):
        """
        :param builtins.str password_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        :param builtins.str username_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        if password_expression is not None:
            pulumi.set(__self__, "password_expression", password_expression)
        if username_expression is not None:
            pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> Optional[builtins.str]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "password_expression")

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> Optional[builtins.str]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "username_expression")


@pulumi.output_type
class RulesetRuleLogging(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: Override the default logging behavior when a rule is matched.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Override the default logging behavior when a rule is matched.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RulesetRuleRatelimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countingExpression":
            suggest = "counting_expression"
        elif key == "mitigationTimeout":
            suggest = "mitigation_timeout"
        elif key == "requestsPerPeriod":
            suggest = "requests_per_period"
        elif key == "requestsToOrigin":
            suggest = "requests_to_origin"
        elif key == "scorePerPeriod":
            suggest = "score_per_period"
        elif key == "scoreResponseHeaderName":
            suggest = "score_response_header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleRatelimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleRatelimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleRatelimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 characteristics: Optional[Sequence[builtins.str]] = None,
                 counting_expression: Optional[builtins.str] = None,
                 mitigation_timeout: Optional[builtins.int] = None,
                 period: Optional[builtins.int] = None,
                 requests_per_period: Optional[builtins.int] = None,
                 requests_to_origin: Optional[builtins.bool] = None,
                 score_per_period: Optional[builtins.int] = None,
                 score_response_header_name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] characteristics: List of parameters that define how Cloudflare tracks the request rate for this rule.
        :param builtins.str counting_expression: Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param builtins.int mitigation_timeout: Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        :param builtins.int period: The period of time to consider (in seconds) when evaluating the request rate.
        :param builtins.int requests_per_period: The number of requests over the period of time that will trigger the Rate Limiting rule.
        :param builtins.bool requests_to_origin: Whether to include requests to origin within the Rate Limiting count.
        :param builtins.int score_per_period: The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        :param builtins.str score_response_header_name: Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if counting_expression is not None:
            pulumi.set(__self__, "counting_expression", counting_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)
        if requests_to_origin is not None:
            pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        if score_per_period is not None:
            pulumi.set(__self__, "score_per_period", score_per_period)
        if score_response_header_name is not None:
            pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter
    def characteristics(self) -> Optional[Sequence[builtins.str]]:
        """
        List of parameters that define how Cloudflare tracks the request rate for this rule.
        """
        return pulumi.get(self, "characteristics")

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[builtins.str]:
        """
        Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "counting_expression")

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[builtins.int]:
        """
        Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        """
        return pulumi.get(self, "mitigation_timeout")

    @property
    @pulumi.getter
    def period(self) -> Optional[builtins.int]:
        """
        The period of time to consider (in seconds) when evaluating the request rate.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[builtins.int]:
        """
        The number of requests over the period of time that will trigger the Rate Limiting rule.
        """
        return pulumi.get(self, "requests_per_period")

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> Optional[builtins.bool]:
        """
        Whether to include requests to origin within the Rate Limiting count.
        """
        return pulumi.get(self, "requests_to_origin")

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[builtins.int]:
        """
        The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        """
        return pulumi.get(self, "score_per_period")

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[builtins.str]:
        """
        Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
        return pulumi.get(self, "score_response_header_name")


@pulumi.output_type
class SnippetFile(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 content: Optional[builtins.str] = None):
        """
        :param builtins.str name: Name of the snippet file.
        :param builtins.str content: Content of the snippet file.
        """
        pulumi.set(__self__, "name", name)
        if content is not None:
            pulumi.set(__self__, "content", content)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the snippet file.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        """
        Content of the snippet file.
        """
        return pulumi.get(self, "content")


@pulumi.output_type
class SnippetRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snippetName":
            suggest = "snippet_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnippetRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnippetRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnippetRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: builtins.str,
                 snippet_name: builtins.str,
                 description: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str expression: Criteria for an HTTP request to trigger the snippet rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        :param builtins.str snippet_name: Name of the snippet invoked by this rule.
        :param builtins.str description: Brief summary of the snippet rule and its intended use.
        :param builtins.bool enabled: Whether the headers rule is active.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "snippet_name", snippet_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        Criteria for an HTTP request to trigger the snippet rule. Uses the Firewall Rules expression language based on Wireshark display filters.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="snippetName")
    def snippet_name(self) -> builtins.str:
        """
        Name of the snippet invoked by this rule.
        """
        return pulumi.get(self, "snippet_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Brief summary of the snippet rule and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether the headers rule is active.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SpectrumApplicationDns(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str name: The name of the DNS record associated with the application.
        :param builtins.str type: The type of DNS record associated with the application.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the DNS record associated with the application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of DNS record associated with the application.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SpectrumApplicationEdgeIps(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 connectivity: Optional[builtins.str] = None,
                 ips: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str type: The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        :param builtins.str connectivity: The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        :param Sequence[builtins.str] ips: The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
        pulumi.set(__self__, "type", type)
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of edge IP configuration specified. Available values: `dynamic`, `static`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def connectivity(self) -> Optional[builtins.str]:
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
        """
        return pulumi.get(self, "connectivity")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
        """
        return pulumi.get(self, "ips")


@pulumi.output_type
class SpectrumApplicationOriginDns(dict):
    def __init__(__self__, *,
                 name: builtins.str):
        """
        :param builtins.str name: Fully qualified domain name of the origin.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Fully qualified domain name of the origin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SpectrumApplicationOriginPortRange(dict):
    def __init__(__self__, *,
                 end: builtins.int,
                 start: builtins.int):
        """
        :param builtins.int end: Upper bound of the origin port range.
        :param builtins.int start: Lower bound of the origin port range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> builtins.int:
        """
        Upper bound of the origin port range.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> builtins.int:
        """
        Lower bound of the origin port range.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class SplitTunnelTunnel(dict):
    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 host: Optional[builtins.str] = None):
        """
        :param builtins.str address: The address for the tunnel.
        :param builtins.str description: A description for the tunnel.
        :param builtins.str host: The domain name for the tunnel.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        The address for the tunnel.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A description for the tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> Optional[builtins.str]:
        """
        The domain name for the tunnel.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class TeamsAccountAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledDownloadPhase":
            suggest = "enabled_download_phase"
        elif key == "enabledUploadPhase":
            suggest = "enabled_upload_phase"
        elif key == "failClosed":
            suggest = "fail_closed"
        elif key == "notificationSettings":
            suggest = "notification_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_download_phase: builtins.bool,
                 enabled_upload_phase: builtins.bool,
                 fail_closed: builtins.bool,
                 notification_settings: Optional['outputs.TeamsAccountAntivirusNotificationSettings'] = None):
        """
        :param builtins.bool enabled_download_phase: Scan on file download.
        :param builtins.bool enabled_upload_phase: Scan on file upload.
        :param builtins.bool fail_closed: Block requests for files that cannot be scanned.
        :param 'TeamsAccountAntivirusNotificationSettingsArgs' notification_settings: Set notifications for antivirus.
        """
        pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        pulumi.set(__self__, "fail_closed", fail_closed)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> builtins.bool:
        """
        Scan on file download.
        """
        return pulumi.get(self, "enabled_download_phase")

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> builtins.bool:
        """
        Scan on file upload.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> builtins.bool:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.TeamsAccountAntivirusNotificationSettings']:
        """
        Set notifications for antivirus.
        """
        return pulumi.get(self, "notification_settings")


@pulumi.output_type
class TeamsAccountAntivirusNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportUrl":
            suggest = "support_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountAntivirusNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountAntivirusNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountAntivirusNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 message: Optional[builtins.str] = None,
                 support_url: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Enable notification settings.
        :param builtins.str message: Notification content.
        :param builtins.str support_url: Support URL to show in the notification.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Enable notification settings.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Notification content.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[builtins.str]:
        """
        Support URL to show in the notification.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class TeamsAccountBlockPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"
        elif key == "mailtoAddress":
            suggest = "mailto_address"
        elif key == "mailtoSubject":
            suggest = "mailto_subject"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountBlockPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountBlockPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountBlockPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 footer_text: Optional[builtins.str] = None,
                 header_text: Optional[builtins.str] = None,
                 logo_path: Optional[builtins.str] = None,
                 mailto_address: Optional[builtins.str] = None,
                 mailto_subject: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str background_color: Hex code of block page background color.
        :param builtins.bool enabled: Indicator of enablement.
        :param builtins.str footer_text: Block page footer text.
        :param builtins.str header_text: Block page header text.
        :param builtins.str logo_path: URL of block page logo.
        :param builtins.str mailto_address: Admin email for users to contact.
        :param builtins.str mailto_subject: Subject line for emails created from block page.
        :param builtins.str name: Name of block page configuration.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[builtins.str]:
        """
        Hex code of block page background color.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Indicator of enablement.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[builtins.str]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[builtins.str]:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[builtins.str]:
        """
        URL of block page logo.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[builtins.str]:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[builtins.str]:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of block page configuration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TeamsAccountBodyScanning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectionMode":
            suggest = "inspection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountBodyScanning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountBodyScanning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountBodyScanning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspection_mode: builtins.str):
        """
        :param builtins.str inspection_mode: Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
        pulumi.set(__self__, "inspection_mode", inspection_mode)

    @property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> builtins.str:
        """
        Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
        return pulumi.get(self, "inspection_mode")


@pulumi.output_type
class TeamsAccountCertificate(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: ID of certificate for TLS interception.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of certificate for TLS interception.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class TeamsAccountCustomCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountCustomCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountCustomCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountCustomCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 id: Optional[builtins.str] = None,
                 updated_at: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Whether TLS encryption should use a custom certificate.
        :param builtins.str id: ID of custom certificate.
        """
        pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether TLS encryption should use a custom certificate.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of custom certificate.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[builtins.str]:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class TeamsAccountExtendedEmailMatching(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class TeamsAccountFips(dict):
    def __init__(__self__, *,
                 tls: Optional[builtins.bool] = None):
        """
        :param builtins.bool tls: Only allow FIPS-compliant TLS configuration.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[builtins.bool]:
        """
        Only allow FIPS-compliant TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class TeamsAccountLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redactPii":
            suggest = "redact_pii"
        elif key == "settingsByRuleType":
            suggest = "settings_by_rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redact_pii: builtins.bool,
                 settings_by_rule_type: 'outputs.TeamsAccountLoggingSettingsByRuleType'):
        """
        :param builtins.bool redact_pii: Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        :param 'TeamsAccountLoggingSettingsByRuleTypeArgs' settings_by_rule_type: Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        pulumi.set(__self__, "redact_pii", redact_pii)
        pulumi.set(__self__, "settings_by_rule_type", settings_by_rule_type)

    @property
    @pulumi.getter(name="redactPii")
    def redact_pii(self) -> builtins.bool:
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        """
        return pulumi.get(self, "redact_pii")

    @property
    @pulumi.getter(name="settingsByRuleType")
    def settings_by_rule_type(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleType':
        """
        Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        return pulumi.get(self, "settings_by_rule_type")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleType(dict):
    def __init__(__self__, *,
                 dns: 'outputs.TeamsAccountLoggingSettingsByRuleTypeDns',
                 http: 'outputs.TeamsAccountLoggingSettingsByRuleTypeHttp',
                 l4: 'outputs.TeamsAccountLoggingSettingsByRuleTypeL4'):
        """
        :param 'TeamsAccountLoggingSettingsByRuleTypeDnsArgs' dns: Logging configuration for DNS requests.
        :param 'TeamsAccountLoggingSettingsByRuleTypeHttpArgs' http: Logging configuration for HTTP requests.
        :param 'TeamsAccountLoggingSettingsByRuleTypeL4Args' l4: Logging configuration for layer 4 requests.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "http", http)
        pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeDns':
        """
        Logging configuration for DNS requests.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def http(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeHttp':
        """
        Logging configuration for HTTP requests.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def l4(self) -> 'outputs.TeamsAccountLoggingSettingsByRuleTypeL4':
        """
        Logging configuration for layer 4 requests.
        """
        return pulumi.get(self, "l4")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: builtins.bool,
                 log_blocks: builtins.bool):
        """
        :param builtins.bool log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> builtins.bool:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> builtins.bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: builtins.bool,
                 log_blocks: builtins.bool):
        """
        :param builtins.bool log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> builtins.bool:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> builtins.bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountLoggingSettingsByRuleTypeL4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountLoggingSettingsByRuleTypeL4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeL4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountLoggingSettingsByRuleTypeL4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: builtins.bool,
                 log_blocks: builtins.bool):
        """
        :param builtins.bool log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> builtins.bool:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> builtins.bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class TeamsAccountPayloadLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountPayloadLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountPayloadLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountPayloadLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: builtins.str):
        """
        :param builtins.str public_key: Public key used to encrypt matched payloads.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> builtins.str:
        """
        Public key used to encrypt matched payloads.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class TeamsAccountProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableForTime":
            suggest = "disable_for_time"
        elif key == "rootCa":
            suggest = "root_ca"
        elif key == "virtualIp":
            suggest = "virtual_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_for_time: builtins.int,
                 root_ca: builtins.bool,
                 tcp: builtins.bool,
                 udp: builtins.bool,
                 virtual_ip: builtins.bool):
        """
        :param builtins.int disable_for_time: Sets the time limit in seconds that a user can use an override code to bypass WARP.
        :param builtins.bool root_ca: Whether root ca is enabled account wide for ZT clients.
        :param builtins.bool tcp: Whether gateway proxy is enabled on gateway devices for TCP traffic.
        :param builtins.bool udp: Whether gateway proxy is enabled on gateway devices for UDP traffic.
        :param builtins.bool virtual_ip: Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
        pulumi.set(__self__, "disable_for_time", disable_for_time)
        pulumi.set(__self__, "root_ca", root_ca)
        pulumi.set(__self__, "tcp", tcp)
        pulumi.set(__self__, "udp", udp)
        pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="disableForTime")
    def disable_for_time(self) -> builtins.int:
        """
        Sets the time limit in seconds that a user can use an override code to bypass WARP.
        """
        return pulumi.get(self, "disable_for_time")

    @property
    @pulumi.getter(name="rootCa")
    def root_ca(self) -> builtins.bool:
        """
        Whether root ca is enabled account wide for ZT clients.
        """
        return pulumi.get(self, "root_ca")

    @property
    @pulumi.getter
    def tcp(self) -> builtins.bool:
        """
        Whether gateway proxy is enabled on gateway devices for TCP traffic.
        """
        return pulumi.get(self, "tcp")

    @property
    @pulumi.getter
    def udp(self) -> builtins.bool:
        """
        Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        return pulumi.get(self, "udp")

    @property
    @pulumi.getter(name="virtualIp")
    def virtual_ip(self) -> builtins.bool:
        """
        Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
        return pulumi.get(self, "virtual_ip")


@pulumi.output_type
class TeamsAccountSshSessionLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsAccountSshSessionLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsAccountSshSessionLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsAccountSshSessionLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: builtins.str):
        """
        :param builtins.str public_key: Public key used to encrypt ssh session.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> builtins.str:
        """
        Public key used to encrypt ssh session.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class TeamsListItemsWithDescription(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 value: builtins.str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TeamsLocationEndpoints(dict):
    def __init__(__self__, *,
                 doh: Optional['outputs.TeamsLocationEndpointsDoh'] = None,
                 dot: Optional['outputs.TeamsLocationEndpointsDot'] = None,
                 ipv4: Optional['outputs.TeamsLocationEndpointsIpv4'] = None,
                 ipv6: Optional['outputs.TeamsLocationEndpointsIpv6'] = None):
        if doh is not None:
            pulumi.set(__self__, "doh", doh)
        if dot is not None:
            pulumi.set(__self__, "dot", dot)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def doh(self) -> Optional['outputs.TeamsLocationEndpointsDoh']:
        return pulumi.get(self, "doh")

    @property
    @pulumi.getter
    def dot(self) -> Optional['outputs.TeamsLocationEndpointsDot']:
        return pulumi.get(self, "dot")

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.TeamsLocationEndpointsIpv4']:
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.TeamsLocationEndpointsIpv6']:
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class TeamsLocationEndpointsDoh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationEnabled":
            suggest = "authentication_enabled"
        elif key == "requireToken":
            suggest = "require_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsLocationEndpointsDoh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsLocationEndpointsDoh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsLocationEndpointsDoh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 authentication_enabled: Optional[builtins.bool] = None,
                 networks: Optional[Sequence['outputs.TeamsLocationEndpointsDohNetwork']] = None,
                 require_token: Optional[builtins.bool] = None):
        pulumi.set(__self__, "enabled", enabled)
        if authentication_enabled is not None:
            pulumi.set(__self__, "authentication_enabled", authentication_enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if require_token is not None:
            pulumi.set(__self__, "require_token", require_token)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authenticationEnabled")
    def authentication_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "authentication_enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.TeamsLocationEndpointsDohNetwork']]:
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "require_token")


@pulumi.output_type
class TeamsLocationEndpointsDohNetwork(dict):
    def __init__(__self__, *,
                 network: builtins.str):
        """
        :param builtins.str network: CIDR notation representation of the network IP.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> builtins.str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class TeamsLocationEndpointsDot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationEnabled":
            suggest = "authentication_enabled"
        elif key == "requireToken":
            suggest = "require_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsLocationEndpointsDot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsLocationEndpointsDot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsLocationEndpointsDot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 authentication_enabled: Optional[builtins.bool] = None,
                 networks: Optional[Sequence['outputs.TeamsLocationEndpointsDotNetwork']] = None,
                 require_token: Optional[builtins.bool] = None):
        pulumi.set(__self__, "enabled", enabled)
        if authentication_enabled is not None:
            pulumi.set(__self__, "authentication_enabled", authentication_enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if require_token is not None:
            pulumi.set(__self__, "require_token", require_token)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authenticationEnabled")
    def authentication_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "authentication_enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.TeamsLocationEndpointsDotNetwork']]:
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "require_token")


@pulumi.output_type
class TeamsLocationEndpointsDotNetwork(dict):
    def __init__(__self__, *,
                 network: builtins.str):
        """
        :param builtins.str network: CIDR notation representation of the network IP.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> builtins.str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class TeamsLocationEndpointsIpv4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationEnabled":
            suggest = "authentication_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsLocationEndpointsIpv4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsLocationEndpointsIpv4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsLocationEndpointsIpv4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 authentication_enabled: Optional[builtins.bool] = None):
        pulumi.set(__self__, "enabled", enabled)
        if authentication_enabled is not None:
            pulumi.set(__self__, "authentication_enabled", authentication_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authenticationEnabled")
    def authentication_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "authentication_enabled")


@pulumi.output_type
class TeamsLocationEndpointsIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationEnabled":
            suggest = "authentication_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsLocationEndpointsIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsLocationEndpointsIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsLocationEndpointsIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 authentication_enabled: Optional[builtins.bool] = None,
                 networks: Optional[Sequence['outputs.TeamsLocationEndpointsIpv6Network']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if authentication_enabled is not None:
            pulumi.set(__self__, "authentication_enabled", authentication_enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authenticationEnabled")
    def authentication_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "authentication_enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.TeamsLocationEndpointsIpv6Network']]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class TeamsLocationEndpointsIpv6Network(dict):
    def __init__(__self__, *,
                 network: builtins.str):
        """
        :param builtins.str network: CIDR notation representation of the network IP.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> builtins.str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class TeamsLocationNetwork(dict):
    def __init__(__self__, *,
                 network: builtins.str):
        """
        :param builtins.str network: CIDR notation representation of the network IP.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> builtins.str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class TeamsRuleRuleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addHeaders":
            suggest = "add_headers"
        elif key == "allowChildBypass":
            suggest = "allow_child_bypass"
        elif key == "auditSsh":
            suggest = "audit_ssh"
        elif key == "bisoAdminControls":
            suggest = "biso_admin_controls"
        elif key == "blockPageEnabled":
            suggest = "block_page_enabled"
        elif key == "blockPageReason":
            suggest = "block_page_reason"
        elif key == "bypassParentRule":
            suggest = "bypass_parent_rule"
        elif key == "checkSession":
            suggest = "check_session"
        elif key == "dnsResolvers":
            suggest = "dns_resolvers"
        elif key == "ignoreCnameCategoryMatches":
            suggest = "ignore_cname_category_matches"
        elif key == "insecureDisableDnssecValidation":
            suggest = "insecure_disable_dnssec_validation"
        elif key == "ipCategories":
            suggest = "ip_categories"
        elif key == "notificationSettings":
            suggest = "notification_settings"
        elif key == "overrideHost":
            suggest = "override_host"
        elif key == "overrideIps":
            suggest = "override_ips"
        elif key == "payloadLog":
            suggest = "payload_log"
        elif key == "resolveDnsInternally":
            suggest = "resolve_dns_internally"
        elif key == "resolveDnsThroughCloudflare":
            suggest = "resolve_dns_through_cloudflare"
        elif key == "untrustedCert":
            suggest = "untrusted_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_headers: Optional[Mapping[str, builtins.str]] = None,
                 allow_child_bypass: Optional[builtins.bool] = None,
                 audit_ssh: Optional['outputs.TeamsRuleRuleSettingsAuditSsh'] = None,
                 biso_admin_controls: Optional['outputs.TeamsRuleRuleSettingsBisoAdminControls'] = None,
                 block_page_enabled: Optional[builtins.bool] = None,
                 block_page_reason: Optional[builtins.str] = None,
                 bypass_parent_rule: Optional[builtins.bool] = None,
                 check_session: Optional['outputs.TeamsRuleRuleSettingsCheckSession'] = None,
                 dns_resolvers: Optional['outputs.TeamsRuleRuleSettingsDnsResolvers'] = None,
                 egress: Optional['outputs.TeamsRuleRuleSettingsEgress'] = None,
                 ignore_cname_category_matches: Optional[builtins.bool] = None,
                 insecure_disable_dnssec_validation: Optional[builtins.bool] = None,
                 ip_categories: Optional[builtins.bool] = None,
                 l4override: Optional['outputs.TeamsRuleRuleSettingsL4override'] = None,
                 notification_settings: Optional['outputs.TeamsRuleRuleSettingsNotificationSettings'] = None,
                 override_host: Optional[builtins.str] = None,
                 override_ips: Optional[Sequence[builtins.str]] = None,
                 payload_log: Optional['outputs.TeamsRuleRuleSettingsPayloadLog'] = None,
                 resolve_dns_internally: Optional['outputs.TeamsRuleRuleSettingsResolveDnsInternally'] = None,
                 resolve_dns_through_cloudflare: Optional[builtins.bool] = None,
                 untrusted_cert: Optional['outputs.TeamsRuleRuleSettingsUntrustedCert'] = None):
        """
        :param Mapping[str, builtins.str] add_headers: Add custom headers to allowed requests in the form of key-value pairs.
        :param builtins.bool allow_child_bypass: Allow parent MSP accounts to enable bypass their children's rules.
        :param 'TeamsRuleRuleSettingsAuditSshArgs' audit_ssh: Settings for auditing SSH usage.
        :param 'TeamsRuleRuleSettingsBisoAdminControlsArgs' biso_admin_controls: Configure how browser isolation behaves.
        :param builtins.bool block_page_enabled: Indicator of block page enablement.
        :param builtins.str block_page_reason: The displayed reason for a user being blocked.
        :param builtins.bool bypass_parent_rule: Allow child MSP accounts to bypass their parent's rule.
        :param 'TeamsRuleRuleSettingsCheckSessionArgs' check_session: Configure how session check behaves.
        :param 'TeamsRuleRuleSettingsDnsResolversArgs' dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        :param 'TeamsRuleRuleSettingsEgressArgs' egress: Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        :param builtins.bool ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response.
        :param builtins.bool insecure_disable_dnssec_validation: Disable DNSSEC validation (must be Allow rule).
        :param builtins.bool ip_categories: Turns on IP category based filter on dns if the rule contains dns category checks.
        :param 'TeamsRuleRuleSettingsL4overrideArgs' l4override: Settings to forward layer 4 traffic.
        :param 'TeamsRuleRuleSettingsNotificationSettingsArgs' notification_settings: Notification settings on a block rule.
        :param builtins.str override_host: The host to override matching DNS queries with.
        :param Sequence[builtins.str] override_ips: The IPs to override matching DNS queries with.
        :param 'TeamsRuleRuleSettingsPayloadLogArgs' payload_log: Configure DLP Payload Logging settings for this rule.
        :param 'TeamsRuleRuleSettingsResolveDnsInternallyArgs' resolve_dns_internally: Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        :param builtins.bool resolve_dns_through_cloudflare: Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        :param 'TeamsRuleRuleSettingsUntrustedCertArgs' untrusted_cert: Configure untrusted certificate settings for this rule.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_page_reason is not None:
            pulumi.set(__self__, "block_page_reason", block_page_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if dns_resolvers is not None:
            pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ignore_cname_category_matches is not None:
            pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if resolve_dns_internally is not None:
            pulumi.set(__self__, "resolve_dns_internally", resolve_dns_internally)
        if resolve_dns_through_cloudflare is not None:
            pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        return pulumi.get(self, "add_headers")

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[builtins.bool]:
        """
        Allow parent MSP accounts to enable bypass their children's rules.
        """
        return pulumi.get(self, "allow_child_bypass")

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional['outputs.TeamsRuleRuleSettingsAuditSsh']:
        """
        Settings for auditing SSH usage.
        """
        return pulumi.get(self, "audit_ssh")

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional['outputs.TeamsRuleRuleSettingsBisoAdminControls']:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[builtins.bool]:
        """
        Indicator of block page enablement.
        """
        return pulumi.get(self, "block_page_enabled")

    @property
    @pulumi.getter(name="blockPageReason")
    def block_page_reason(self) -> Optional[builtins.str]:
        """
        The displayed reason for a user being blocked.
        """
        return pulumi.get(self, "block_page_reason")

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[builtins.bool]:
        """
        Allow child MSP accounts to bypass their parent's rule.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional['outputs.TeamsRuleRuleSettingsCheckSession']:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> Optional['outputs.TeamsRuleRuleSettingsDnsResolvers']:
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        """
        return pulumi.get(self, "dns_resolvers")

    @property
    @pulumi.getter
    def egress(self) -> Optional['outputs.TeamsRuleRuleSettingsEgress']:
        """
        Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        """
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> Optional[builtins.bool]:
        """
        Set to true, to ignore the category matches at CNAME domains in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[builtins.bool]:
        """
        Disable DNSSEC validation (must be Allow rule).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[builtins.bool]:
        """
        Turns on IP category based filter on dns if the rule contains dns category checks.
        """
        return pulumi.get(self, "ip_categories")

    @property
    @pulumi.getter
    def l4override(self) -> Optional['outputs.TeamsRuleRuleSettingsL4override']:
        """
        Settings to forward layer 4 traffic.
        """
        return pulumi.get(self, "l4override")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.TeamsRuleRuleSettingsNotificationSettings']:
        """
        Notification settings on a block rule.
        """
        return pulumi.get(self, "notification_settings")

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[builtins.str]:
        """
        The host to override matching DNS queries with.
        """
        return pulumi.get(self, "override_host")

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[Sequence[builtins.str]]:
        """
        The IPs to override matching DNS queries with.
        """
        return pulumi.get(self, "override_ips")

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional['outputs.TeamsRuleRuleSettingsPayloadLog']:
        """
        Configure DLP Payload Logging settings for this rule.
        """
        return pulumi.get(self, "payload_log")

    @property
    @pulumi.getter(name="resolveDnsInternally")
    def resolve_dns_internally(self) -> Optional['outputs.TeamsRuleRuleSettingsResolveDnsInternally']:
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_internally")

    @property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> Optional[builtins.bool]:
        """
        Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional['outputs.TeamsRuleRuleSettingsUntrustedCert']:
        """
        Configure untrusted certificate settings for this rule.
        """
        return pulumi.get(self, "untrusted_cert")


@pulumi.output_type
class TeamsRuleRuleSettingsAuditSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandLogging":
            suggest = "command_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsAuditSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsAuditSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsAuditSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_logging: builtins.bool):
        """
        :param builtins.bool command_logging: Log all SSH commands.
        """
        pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> builtins.bool:
        """
        Log all SSH commands.
        """
        return pulumi.get(self, "command_logging")


@pulumi.output_type
class TeamsRuleRuleSettingsBisoAdminControls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableClipboardRedirection":
            suggest = "disable_clipboard_redirection"
        elif key == "disableCopyPaste":
            suggest = "disable_copy_paste"
        elif key == "disableDownload":
            suggest = "disable_download"
        elif key == "disableKeyboard":
            suggest = "disable_keyboard"
        elif key == "disablePrinting":
            suggest = "disable_printing"
        elif key == "disableUpload":
            suggest = "disable_upload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsBisoAdminControls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsBisoAdminControls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsBisoAdminControls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_clipboard_redirection: Optional[builtins.bool] = None,
                 disable_copy_paste: Optional[builtins.bool] = None,
                 disable_download: Optional[builtins.bool] = None,
                 disable_keyboard: Optional[builtins.bool] = None,
                 disable_printing: Optional[builtins.bool] = None,
                 disable_upload: Optional[builtins.bool] = None):
        """
        :param builtins.bool disable_clipboard_redirection: Disable clipboard redirection.
        :param builtins.bool disable_copy_paste: Disable copy-paste.
        :param builtins.bool disable_download: Disable download.
        :param builtins.bool disable_keyboard: Disable keyboard usage.
        :param builtins.bool disable_printing: Disable printing.
        :param builtins.bool disable_upload: Disable upload.
        """
        if disable_clipboard_redirection is not None:
            pulumi.set(__self__, "disable_clipboard_redirection", disable_clipboard_redirection)
        if disable_copy_paste is not None:
            pulumi.set(__self__, "disable_copy_paste", disable_copy_paste)
        if disable_download is not None:
            pulumi.set(__self__, "disable_download", disable_download)
        if disable_keyboard is not None:
            pulumi.set(__self__, "disable_keyboard", disable_keyboard)
        if disable_printing is not None:
            pulumi.set(__self__, "disable_printing", disable_printing)
        if disable_upload is not None:
            pulumi.set(__self__, "disable_upload", disable_upload)

    @property
    @pulumi.getter(name="disableClipboardRedirection")
    def disable_clipboard_redirection(self) -> Optional[builtins.bool]:
        """
        Disable clipboard redirection.
        """
        return pulumi.get(self, "disable_clipboard_redirection")

    @property
    @pulumi.getter(name="disableCopyPaste")
    def disable_copy_paste(self) -> Optional[builtins.bool]:
        """
        Disable copy-paste.
        """
        return pulumi.get(self, "disable_copy_paste")

    @property
    @pulumi.getter(name="disableDownload")
    def disable_download(self) -> Optional[builtins.bool]:
        """
        Disable download.
        """
        return pulumi.get(self, "disable_download")

    @property
    @pulumi.getter(name="disableKeyboard")
    def disable_keyboard(self) -> Optional[builtins.bool]:
        """
        Disable keyboard usage.
        """
        return pulumi.get(self, "disable_keyboard")

    @property
    @pulumi.getter(name="disablePrinting")
    def disable_printing(self) -> Optional[builtins.bool]:
        """
        Disable printing.
        """
        return pulumi.get(self, "disable_printing")

    @property
    @pulumi.getter(name="disableUpload")
    def disable_upload(self) -> Optional[builtins.bool]:
        """
        Disable upload.
        """
        return pulumi.get(self, "disable_upload")


@pulumi.output_type
class TeamsRuleRuleSettingsCheckSession(dict):
    def __init__(__self__, *,
                 duration: builtins.str,
                 enforce: builtins.bool):
        """
        :param builtins.str duration: Configure how fresh the session needs to be to be considered valid.
        :param builtins.bool enforce: Enable session enforcement for this rule.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> builtins.str:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enforce(self) -> builtins.bool:
        """
        Enable session enforcement for this rule.
        """
        return pulumi.get(self, "enforce")


@pulumi.output_type
class TeamsRuleRuleSettingsDnsResolvers(dict):
    def __init__(__self__, *,
                 ipv4s: Optional[Sequence['outputs.TeamsRuleRuleSettingsDnsResolversIpv4']] = None,
                 ipv6s: Optional[Sequence['outputs.TeamsRuleRuleSettingsDnsResolversIpv6']] = None):
        """
        :param Sequence['TeamsRuleRuleSettingsDnsResolversIpv4Args'] ipv4s: IPv4 resolvers.
        :param Sequence['TeamsRuleRuleSettingsDnsResolversIpv6Args'] ipv6s: IPv6 resolvers.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[Sequence['outputs.TeamsRuleRuleSettingsDnsResolversIpv4']]:
        """
        IPv4 resolvers.
        """
        return pulumi.get(self, "ipv4s")

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[Sequence['outputs.TeamsRuleRuleSettingsDnsResolversIpv6']]:
        """
        IPv6 resolvers.
        """
        return pulumi.get(self, "ipv6s")


@pulumi.output_type
class TeamsRuleRuleSettingsDnsResolversIpv4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeThroughPrivateNetwork":
            suggest = "route_through_private_network"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsDnsResolversIpv4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsDnsResolversIpv4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsDnsResolversIpv4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: builtins.str,
                 port: Optional[builtins.int] = None,
                 route_through_private_network: Optional[builtins.bool] = None,
                 vnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str ip: The IPv4 or IPv6 address of the upstream resolver.
        :param builtins.int port: A port number to use for the upstream resolver. Defaults to `53`.
        :param builtins.bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        :param builtins.str vnet_id: specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[builtins.bool]:
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[builtins.str]:
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class TeamsRuleRuleSettingsDnsResolversIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeThroughPrivateNetwork":
            suggest = "route_through_private_network"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsDnsResolversIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsDnsResolversIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsDnsResolversIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: builtins.str,
                 port: Optional[builtins.int] = None,
                 route_through_private_network: Optional[builtins.bool] = None,
                 vnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str ip: The IPv4 or IPv6 address of the upstream resolver.
        :param builtins.int port: A port number to use for the upstream resolver. Defaults to `53`.
        :param builtins.bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        :param builtins.str vnet_id: specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[builtins.bool]:
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[builtins.str]:
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class TeamsRuleRuleSettingsEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Fallback":
            suggest = "ipv4_fallback"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4: builtins.str,
                 ipv6: builtins.str,
                 ipv4_fallback: Optional[builtins.str] = None):
        """
        :param builtins.str ipv4: The IPv4 address to be used for egress.
        :param builtins.str ipv6: The IPv6 range to be used for egress.
        :param builtins.str ipv4_fallback: The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)

    @property
    @pulumi.getter
    def ipv4(self) -> builtins.str:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> builtins.str:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[builtins.str]:
        """
        The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        return pulumi.get(self, "ipv4_fallback")


@pulumi.output_type
class TeamsRuleRuleSettingsL4override(dict):
    def __init__(__self__, *,
                 ip: builtins.str,
                 port: builtins.int):
        """
        :param builtins.str ip: Override IP to forward traffic to.
        :param builtins.int port: Override Port to forward traffic to.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        Override IP to forward traffic to.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        Override Port to forward traffic to.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class TeamsRuleRuleSettingsNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportUrl":
            suggest = "support_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 message: Optional[builtins.str] = None,
                 support_url: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Enable notification settings.
        :param builtins.str message: Notification content.
        :param builtins.str support_url: Support URL to show in the notification.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Enable notification settings.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Notification content.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[builtins.str]:
        """
        Support URL to show in the notification.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class TeamsRuleRuleSettingsPayloadLog(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Enable or disable DLP Payload Logging for this rule.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Enable or disable DLP Payload Logging for this rule.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class TeamsRuleRuleSettingsResolveDnsInternally(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewId":
            suggest = "view_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamsRuleRuleSettingsResolveDnsInternally. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamsRuleRuleSettingsResolveDnsInternally.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamsRuleRuleSettingsResolveDnsInternally.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback: Optional[builtins.str] = None,
                 view_id: Optional[builtins.str] = None):
        """
        :param builtins.str fallback: The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        :param builtins.str view_id: The internal DNS view identifier that's passed to the internal DNS service.
        """
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if view_id is not None:
            pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter
    def fallback(self) -> Optional[builtins.str]:
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        """
        return pulumi.get(self, "fallback")

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> Optional[builtins.str]:
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
        return pulumi.get(self, "view_id")


@pulumi.output_type
class TeamsRuleRuleSettingsUntrustedCert(dict):
    def __init__(__self__, *,
                 action: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class TunnelConfigConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingressRules":
            suggest = "ingress_rules"
        elif key == "originRequest":
            suggest = "origin_request"
        elif key == "warpRouting":
            suggest = "warp_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingress_rules: Sequence['outputs.TunnelConfigConfigIngressRule'],
                 origin_request: Optional['outputs.TunnelConfigConfigOriginRequest'] = None,
                 warp_routing: Optional['outputs.TunnelConfigConfigWarpRouting'] = None):
        """
        :param Sequence['TunnelConfigConfigIngressRuleArgs'] ingress_rules: Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        :param 'TunnelConfigConfigWarpRoutingArgs' warp_routing: If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        pulumi.set(__self__, "ingress_rules", ingress_rules)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @property
    @pulumi.getter(name="ingressRules")
    def ingress_rules(self) -> Sequence['outputs.TunnelConfigConfigIngressRule']:
        """
        Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        """
        return pulumi.get(self, "ingress_rules")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional['outputs.TunnelConfigConfigOriginRequest']:
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional['outputs.TunnelConfigConfigWarpRouting']:
        """
        If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        return pulumi.get(self, "warp_routing")


@pulumi.output_type
class TunnelConfigConfigIngressRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originRequest":
            suggest = "origin_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigIngressRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigIngressRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigIngressRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: builtins.str,
                 hostname: Optional[builtins.str] = None,
                 origin_request: Optional['outputs.TunnelConfigConfigIngressRuleOriginRequest'] = None,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str service: Name of the service to which the request will be sent.
        :param builtins.str hostname: Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        :param builtins.str path: Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def service(self) -> builtins.str:
        """
        Name of the service to which the request will be sent.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[builtins.str]:
        """
        Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional['outputs.TunnelConfigConfigIngressRuleOriginRequest']:
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class TunnelConfigConfigIngressRuleOriginRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bastionMode":
            suggest = "bastion_mode"
        elif key == "caPool":
            suggest = "ca_pool"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "disableChunkedEncoding":
            suggest = "disable_chunked_encoding"
        elif key == "http2Origin":
            suggest = "http2_origin"
        elif key == "httpHostHeader":
            suggest = "http_host_header"
        elif key == "ipRules":
            suggest = "ip_rules"
        elif key == "keepAliveConnections":
            suggest = "keep_alive_connections"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "noHappyEyeballs":
            suggest = "no_happy_eyeballs"
        elif key == "noTlsVerify":
            suggest = "no_tls_verify"
        elif key == "originServerName":
            suggest = "origin_server_name"
        elif key == "proxyAddress":
            suggest = "proxy_address"
        elif key == "proxyPort":
            suggest = "proxy_port"
        elif key == "proxyType":
            suggest = "proxy_type"
        elif key == "tcpKeepAlive":
            suggest = "tcp_keep_alive"
        elif key == "tlsTimeout":
            suggest = "tls_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigIngressRuleOriginRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigIngressRuleOriginRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigIngressRuleOriginRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: Optional['outputs.TunnelConfigConfigIngressRuleOriginRequestAccess'] = None,
                 bastion_mode: Optional[builtins.bool] = None,
                 ca_pool: Optional[builtins.str] = None,
                 connect_timeout: Optional[builtins.str] = None,
                 disable_chunked_encoding: Optional[builtins.bool] = None,
                 http2_origin: Optional[builtins.bool] = None,
                 http_host_header: Optional[builtins.str] = None,
                 ip_rules: Optional[Sequence['outputs.TunnelConfigConfigIngressRuleOriginRequestIpRule']] = None,
                 keep_alive_connections: Optional[builtins.int] = None,
                 keep_alive_timeout: Optional[builtins.str] = None,
                 no_happy_eyeballs: Optional[builtins.bool] = None,
                 no_tls_verify: Optional[builtins.bool] = None,
                 origin_server_name: Optional[builtins.str] = None,
                 proxy_address: Optional[builtins.str] = None,
                 proxy_port: Optional[builtins.int] = None,
                 proxy_type: Optional[builtins.str] = None,
                 tcp_keep_alive: Optional[builtins.str] = None,
                 tls_timeout: Optional[builtins.str] = None):
        """
        :param 'TunnelConfigConfigIngressRuleOriginRequestAccessArgs' access: Access rules for the ingress service.
        :param builtins.bool bastion_mode: Runs as jump host.
        :param builtins.str ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param builtins.str connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param builtins.bool disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param builtins.bool http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param builtins.str http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param Sequence['TunnelConfigConfigIngressRuleOriginRequestIpRuleArgs'] ip_rules: IP rules for the proxy service.
        :param builtins.int keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param builtins.str keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param builtins.bool no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param builtins.bool no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param builtins.str origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param builtins.str proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param builtins.int proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param builtins.str proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param builtins.str tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param builtins.str tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.TunnelConfigConfigIngressRuleOriginRequestAccess']:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[builtins.bool]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[builtins.str]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[builtins.str]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[builtins.bool]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[builtins.bool]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[builtins.str]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.TunnelConfigConfigIngressRuleOriginRequestIpRule']]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[builtins.int]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[builtins.str]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[builtins.bool]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[builtins.bool]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[builtins.str]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[builtins.str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[builtins.int]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[builtins.str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[builtins.str]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[builtins.str]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class TunnelConfigConfigIngressRuleOriginRequestAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audTags":
            suggest = "aud_tags"
        elif key == "teamName":
            suggest = "team_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigIngressRuleOriginRequestAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigIngressRuleOriginRequestAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigIngressRuleOriginRequestAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aud_tags: Optional[Sequence[builtins.str]] = None,
                 required: Optional[builtins.bool] = None,
                 team_name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] aud_tags: Audience tags of the access rule.
        :param builtins.bool required: Whether the access rule is required.
        :param builtins.str team_name: Name of the team to which the access rule applies.
        """
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[builtins.str]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")


@pulumi.output_type
class TunnelConfigConfigIngressRuleOriginRequestIpRule(dict):
    def __init__(__self__, *,
                 allow: Optional[builtins.bool] = None,
                 ports: Optional[Sequence[builtins.int]] = None,
                 prefix: Optional[builtins.str] = None):
        """
        :param builtins.bool allow: Whether to allow the IP prefix.
        :param Sequence[builtins.int] ports: Ports to use within the IP rule.
        :param builtins.str prefix: IP rule prefix.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[builtins.bool]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.int]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[builtins.str]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class TunnelConfigConfigOriginRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bastionMode":
            suggest = "bastion_mode"
        elif key == "caPool":
            suggest = "ca_pool"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "disableChunkedEncoding":
            suggest = "disable_chunked_encoding"
        elif key == "http2Origin":
            suggest = "http2_origin"
        elif key == "httpHostHeader":
            suggest = "http_host_header"
        elif key == "ipRules":
            suggest = "ip_rules"
        elif key == "keepAliveConnections":
            suggest = "keep_alive_connections"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "noHappyEyeballs":
            suggest = "no_happy_eyeballs"
        elif key == "noTlsVerify":
            suggest = "no_tls_verify"
        elif key == "originServerName":
            suggest = "origin_server_name"
        elif key == "proxyAddress":
            suggest = "proxy_address"
        elif key == "proxyPort":
            suggest = "proxy_port"
        elif key == "proxyType":
            suggest = "proxy_type"
        elif key == "tcpKeepAlive":
            suggest = "tcp_keep_alive"
        elif key == "tlsTimeout":
            suggest = "tls_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigOriginRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigOriginRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigOriginRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: Optional['outputs.TunnelConfigConfigOriginRequestAccess'] = None,
                 bastion_mode: Optional[builtins.bool] = None,
                 ca_pool: Optional[builtins.str] = None,
                 connect_timeout: Optional[builtins.str] = None,
                 disable_chunked_encoding: Optional[builtins.bool] = None,
                 http2_origin: Optional[builtins.bool] = None,
                 http_host_header: Optional[builtins.str] = None,
                 ip_rules: Optional[Sequence['outputs.TunnelConfigConfigOriginRequestIpRule']] = None,
                 keep_alive_connections: Optional[builtins.int] = None,
                 keep_alive_timeout: Optional[builtins.str] = None,
                 no_happy_eyeballs: Optional[builtins.bool] = None,
                 no_tls_verify: Optional[builtins.bool] = None,
                 origin_server_name: Optional[builtins.str] = None,
                 proxy_address: Optional[builtins.str] = None,
                 proxy_port: Optional[builtins.int] = None,
                 proxy_type: Optional[builtins.str] = None,
                 tcp_keep_alive: Optional[builtins.str] = None,
                 tls_timeout: Optional[builtins.str] = None):
        """
        :param 'TunnelConfigConfigOriginRequestAccessArgs' access: Access rules for the ingress service.
        :param builtins.bool bastion_mode: Runs as jump host.
        :param builtins.str ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param builtins.str connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param builtins.bool disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param builtins.bool http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param builtins.str http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param Sequence['TunnelConfigConfigOriginRequestIpRuleArgs'] ip_rules: IP rules for the proxy service.
        :param builtins.int keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param builtins.str keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param builtins.bool no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param builtins.bool no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param builtins.str origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param builtins.str proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param builtins.int proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param builtins.str proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param builtins.str tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param builtins.str tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.TunnelConfigConfigOriginRequestAccess']:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[builtins.bool]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[builtins.str]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[builtins.str]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[builtins.bool]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[builtins.bool]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[builtins.str]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.TunnelConfigConfigOriginRequestIpRule']]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[builtins.int]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[builtins.str]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[builtins.bool]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[builtins.bool]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[builtins.str]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[builtins.str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[builtins.int]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[builtins.str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[builtins.str]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[builtins.str]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class TunnelConfigConfigOriginRequestAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audTags":
            suggest = "aud_tags"
        elif key == "teamName":
            suggest = "team_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TunnelConfigConfigOriginRequestAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TunnelConfigConfigOriginRequestAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TunnelConfigConfigOriginRequestAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aud_tags: Optional[Sequence[builtins.str]] = None,
                 required: Optional[builtins.bool] = None,
                 team_name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] aud_tags: Audience tags of the access rule.
        :param builtins.bool required: Whether the access rule is required.
        :param builtins.str team_name: Name of the team to which the access rule applies.
        """
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[builtins.str]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")


@pulumi.output_type
class TunnelConfigConfigOriginRequestIpRule(dict):
    def __init__(__self__, *,
                 allow: Optional[builtins.bool] = None,
                 ports: Optional[Sequence[builtins.int]] = None,
                 prefix: Optional[builtins.str] = None):
        """
        :param builtins.bool allow: Whether to allow the IP prefix.
        :param Sequence[builtins.int] ports: Ports to use within the IP rule.
        :param builtins.str prefix: IP rule prefix.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[builtins.bool]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.int]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[builtins.str]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class TunnelConfigConfigWarpRouting(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: Whether WARP routing is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether WARP routing is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class UserAgentBlockingRuleConfiguration(dict):
    def __init__(__self__, *,
                 target: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str target: The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        :param builtins.str value: The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WaitingRoomAdditionalRoute(dict):
    def __init__(__self__, *,
                 host: builtins.str,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str host: The additional host name for which the waiting room to be applied on (no wildcards).
        :param builtins.str path: The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
        pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        The additional host name for which the waiting room to be applied on (no wildcards).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The path within the additional host to enable the waiting room on. Defaults to `/`.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class WaitingRoomRulesRule(dict):
    def __init__(__self__, *,
                 action: builtins.str,
                 expression: builtins.str,
                 description: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        :param builtins.str expression: Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        :param builtins.str description: Brief summary of the waiting room rule and its intended use.
        :param builtins.str id: Unique rule identifier.
        :param builtins.str status: Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        :param builtins.str version: Version of the waiting room rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Brief summary of the waiting room rule and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the waiting room rule.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WorkerScriptAnalyticsEngineBinding(dict):
    def __init__(__self__, *,
                 dataset: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str dataset: The name of the Analytics Engine dataset to write to.
        :param builtins.str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def dataset(self) -> builtins.str:
        """
        The name of the Analytics Engine dataset to write to.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkerScriptD1DatabaseBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseId":
            suggest = "database_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkerScriptD1DatabaseBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkerScriptD1DatabaseBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkerScriptD1DatabaseBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_id: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str database_id: Database ID of D1 database to use.
        :param builtins.str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> builtins.str:
        """
        Database ID of D1 database to use.
        """
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkerScriptHyperdriveConfigBinding(dict):
    def __init__(__self__, *,
                 binding: builtins.str,
                 id: builtins.str):
        """
        :param builtins.str binding: The global variable for the binding in your Worker code.
        :param builtins.str id: The ID of the Hyperdrive config to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def binding(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Hyperdrive config to use.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class WorkerScriptKvNamespaceBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkerScriptKvNamespaceBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkerScriptKvNamespaceBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkerScriptKvNamespaceBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 namespace_id: builtins.str):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str namespace_id: ID of the KV namespace you want to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> builtins.str:
        """
        ID of the KV namespace you want to use.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class WorkerScriptPlacement(dict):
    def __init__(__self__, *,
                 mode: builtins.str):
        """
        :param builtins.str mode: The placement mode for the Worker. Available values: `smart`.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        The placement mode for the Worker. Available values: `smart`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class WorkerScriptPlainTextBinding(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 text: builtins.str):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str text: The plain text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def text(self) -> builtins.str:
        """
        The plain text you want to store.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkerScriptQueueBinding(dict):
    def __init__(__self__, *,
                 binding: builtins.str,
                 queue: builtins.str):
        """
        :param builtins.str binding: The name of the global variable for the binding in your Worker code.
        :param builtins.str queue: Name of the queue you want to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "queue", queue)

    @property
    @pulumi.getter
    def binding(self) -> builtins.str:
        """
        The name of the global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @property
    @pulumi.getter
    def queue(self) -> builtins.str:
        """
        Name of the queue you want to use.
        """
        return pulumi.get(self, "queue")


@pulumi.output_type
class WorkerScriptR2BucketBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkerScriptR2BucketBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkerScriptR2BucketBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkerScriptR2BucketBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str bucket_name: The name of the Bucket to bind to.
        :param builtins.str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> builtins.str:
        """
        The name of the Bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkerScriptSecretTextBinding(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 text: builtins.str):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str text: The secret text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def text(self) -> builtins.str:
        """
        The secret text you want to store.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkerScriptServiceBinding(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 service: builtins.str,
                 environment: Optional[builtins.str] = None):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str service: The name of the Worker to bind to.
        :param builtins.str environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> builtins.str:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")


@pulumi.output_type
class WorkerScriptWebassemblyBinding(dict):
    def __init__(__self__, *,
                 module: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str module: The base64 encoded wasm module you want to store.
        :param builtins.str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "module", module)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def module(self) -> builtins.str:
        """
        The base64 encoded wasm module you want to store.
        """
        return pulumi.get(self, "module")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkersScriptAnalyticsEngineBinding(dict):
    def __init__(__self__, *,
                 dataset: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str dataset: The name of the Analytics Engine dataset to write to.
        :param builtins.str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def dataset(self) -> builtins.str:
        """
        The name of the Analytics Engine dataset to write to.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkersScriptD1DatabaseBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseId":
            suggest = "database_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptD1DatabaseBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptD1DatabaseBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptD1DatabaseBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_id: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str database_id: Database ID of D1 database to use.
        :param builtins.str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> builtins.str:
        """
        Database ID of D1 database to use.
        """
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkersScriptHyperdriveConfigBinding(dict):
    def __init__(__self__, *,
                 binding: builtins.str,
                 id: builtins.str):
        """
        :param builtins.str binding: The global variable for the binding in your Worker code.
        :param builtins.str id: The ID of the Hyperdrive config to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def binding(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Hyperdrive config to use.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class WorkersScriptKvNamespaceBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptKvNamespaceBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptKvNamespaceBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptKvNamespaceBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 namespace_id: builtins.str):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str namespace_id: ID of the KV namespace you want to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> builtins.str:
        """
        ID of the KV namespace you want to use.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class WorkersScriptPlacement(dict):
    def __init__(__self__, *,
                 mode: builtins.str):
        """
        :param builtins.str mode: The placement mode for the Worker. Available values: `smart`.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        The placement mode for the Worker. Available values: `smart`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class WorkersScriptPlainTextBinding(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 text: builtins.str):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str text: The plain text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def text(self) -> builtins.str:
        """
        The plain text you want to store.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkersScriptQueueBinding(dict):
    def __init__(__self__, *,
                 binding: builtins.str,
                 queue: builtins.str):
        """
        :param builtins.str binding: The name of the global variable for the binding in your Worker code.
        :param builtins.str queue: Name of the queue you want to use.
        """
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "queue", queue)

    @property
    @pulumi.getter
    def binding(self) -> builtins.str:
        """
        The name of the global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "binding")

    @property
    @pulumi.getter
    def queue(self) -> builtins.str:
        """
        Name of the queue you want to use.
        """
        return pulumi.get(self, "queue")


@pulumi.output_type
class WorkersScriptR2BucketBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkersScriptR2BucketBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkersScriptR2BucketBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkersScriptR2BucketBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str bucket_name: The name of the Bucket to bind to.
        :param builtins.str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> builtins.str:
        """
        The name of the Bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkersScriptSecretTextBinding(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 text: builtins.str):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str text: The secret text you want to store.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def text(self) -> builtins.str:
        """
        The secret text you want to store.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WorkersScriptServiceBinding(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 service: builtins.str,
                 environment: Optional[builtins.str] = None):
        """
        :param builtins.str name: The global variable for the binding in your Worker code.
        :param builtins.str service: The name of the Worker to bind to.
        :param builtins.str environment: The name of the Worker environment to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> builtins.str:
        """
        The name of the Worker to bind to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        """
        The name of the Worker environment to bind to.
        """
        return pulumi.get(self, "environment")


@pulumi.output_type
class WorkersScriptWebassemblyBinding(dict):
    def __init__(__self__, *,
                 module: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str module: The base64 encoded wasm module you want to store.
        :param builtins.str name: The global variable for the binding in your Worker code.
        """
        pulumi.set(__self__, "module", module)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def module(self) -> builtins.str:
        """
        The base64 encoded wasm module you want to store.
        """
        return pulumi.get(self, "module")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The global variable for the binding in your Worker code.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustAccessApplicationCorsHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllHeaders":
            suggest = "allow_all_headers"
        elif key == "allowAllMethods":
            suggest = "allow_all_methods"
        elif key == "allowAllOrigins":
            suggest = "allow_all_origins"
        elif key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationCorsHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationCorsHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationCorsHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_headers: Optional[builtins.bool] = None,
                 allow_all_methods: Optional[builtins.bool] = None,
                 allow_all_origins: Optional[builtins.bool] = None,
                 allow_credentials: Optional[builtins.bool] = None,
                 allowed_headers: Optional[Sequence[builtins.str]] = None,
                 allowed_methods: Optional[Sequence[builtins.str]] = None,
                 allowed_origins: Optional[Sequence[builtins.str]] = None,
                 max_age: Optional[builtins.int] = None):
        """
        :param builtins.bool allow_all_headers: Value to determine whether all HTTP headers are exposed.
        :param builtins.bool allow_all_methods: Value to determine whether all methods are exposed.
        :param builtins.bool allow_all_origins: Value to determine whether all origins are permitted to make CORS requests.
        :param builtins.bool allow_credentials: Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        :param Sequence[builtins.str] allowed_headers: List of HTTP headers to expose via CORS.
        :param Sequence[builtins.str] allowed_methods: List of methods to expose via CORS.
        :param Sequence[builtins.str] allowed_origins: List of origins permitted to make CORS requests.
        :param builtins.int max_age: The maximum time a preflight request will be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[builtins.bool]:
        """
        Value to determine whether all HTTP headers are exposed.
        """
        return pulumi.get(self, "allow_all_headers")

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[builtins.bool]:
        """
        Value to determine whether all methods are exposed.
        """
        return pulumi.get(self, "allow_all_methods")

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[builtins.bool]:
        """
        Value to determine whether all origins are permitted to make CORS requests.
        """
        return pulumi.get(self, "allow_all_origins")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[builtins.bool]:
        """
        Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[builtins.str]]:
        """
        List of HTTP headers to expose via CORS.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        List of methods to expose via CORS.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[builtins.str]]:
        """
        List of origins permitted to make CORS requests.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[builtins.int]:
        """
        The maximum time a preflight request will be cached.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class ZeroTrustAccessApplicationDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "l4Protocol":
            suggest = "l4_protocol"
        elif key == "portRange":
            suggest = "port_range"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[builtins.str] = None,
                 hostname: Optional[builtins.str] = None,
                 l4_protocol: Optional[builtins.str] = None,
                 port_range: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None,
                 vnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: The private CIDR of the destination. Only valid when type=private. IPs are computed as /32 cidr. Private destinations are an early access feature and gated behind a feature flag.
        :param builtins.str hostname: The private hostname of the destination. Only valid when type=private. Private hostnames currently match only Server Name Indications (SNI). Private destinations are an early access feature and gated behind a feature flag.
        :param builtins.str l4_protocol: The l4 protocol that matches this destination. Only valid when type=private. Private destinations are an early access feature and gated behind a feature flag.
        :param builtins.str port_range: The port range of the destination. Only valid when type=private. Single ports are supported. Private destinations are an early access feature and gated behind a feature flag.
        :param builtins.str type: The destination type. Available values: `public`, `private`. Defaults to `public`.
        :param builtins.str uri: The public URI of the destination. Can include a domain and path with wildcards. Only valid when type=public.
        :param builtins.str vnet_id: The VNet ID of the destination. Only valid when type=private. Private destinations are an early access feature and gated behind a feature flag.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if l4_protocol is not None:
            pulumi.set(__self__, "l4_protocol", l4_protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[builtins.str]:
        """
        The private CIDR of the destination. Only valid when type=private. IPs are computed as /32 cidr. Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[builtins.str]:
        """
        The private hostname of the destination. Only valid when type=private. Private hostnames currently match only Server Name Indications (SNI). Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="l4Protocol")
    def l4_protocol(self) -> Optional[builtins.str]:
        """
        The l4 protocol that matches this destination. Only valid when type=private. Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "l4_protocol")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[builtins.str]:
        """
        The port range of the destination. Only valid when type=private. Single ports are supported. Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The destination type. Available values: `public`, `private`. Defaults to `public`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        The public URI of the destination. Can include a domain and path with wildcards. Only valid when type=public.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[builtins.str]:
        """
        The VNet ID of the destination. Only valid when type=private. Private destinations are an early access feature and gated behind a feature flag.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class ZeroTrustAccessApplicationFooterLink(dict):
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 url: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the footer link.
        :param builtins.str url: The URL of the footer link.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the footer link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        The URL of the footer link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ZeroTrustAccessApplicationLandingPageDesign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buttonColor":
            suggest = "button_color"
        elif key == "buttonTextColor":
            suggest = "button_text_color"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationLandingPageDesign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationLandingPageDesign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationLandingPageDesign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 button_color: Optional[builtins.str] = None,
                 button_text_color: Optional[builtins.str] = None,
                 image_url: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 title: Optional[builtins.str] = None):
        """
        :param builtins.str button_color: The button color of the landing page.
        :param builtins.str button_text_color: The button text color of the landing page.
        :param builtins.str image_url: The URL of the image to be displayed in the landing page.
        :param builtins.str message: The message of the landing page.
        :param builtins.str title: The title of the landing page.
        """
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[builtins.str]:
        """
        The button color of the landing page.
        """
        return pulumi.get(self, "button_color")

    @property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[builtins.str]:
        """
        The button text color of the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[builtins.str]:
        """
        The URL of the image to be displayed in the landing page.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        The message of the landing page.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        The title of the landing page.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenLifetime":
            suggest = "access_token_lifetime"
        elif key == "allowPkceWithoutClientSecret":
            suggest = "allow_pkce_without_client_secret"
        elif key == "appLauncherUrl":
            suggest = "app_launcher_url"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "consumerServiceUrl":
            suggest = "consumer_service_url"
        elif key == "customAttributes":
            suggest = "custom_attributes"
        elif key == "customClaims":
            suggest = "custom_claims"
        elif key == "defaultRelayState":
            suggest = "default_relay_state"
        elif key == "grantTypes":
            suggest = "grant_types"
        elif key == "groupFilterRegex":
            suggest = "group_filter_regex"
        elif key == "hybridAndImplicitOptions":
            suggest = "hybrid_and_implicit_options"
        elif key == "idpEntityId":
            suggest = "idp_entity_id"
        elif key == "nameIdFormat":
            suggest = "name_id_format"
        elif key == "nameIdTransformJsonata":
            suggest = "name_id_transform_jsonata"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "redirectUris":
            suggest = "redirect_uris"
        elif key == "refreshTokenOptions":
            suggest = "refresh_token_options"
        elif key == "samlAttributeTransformJsonata":
            suggest = "saml_attribute_transform_jsonata"
        elif key == "spEntityId":
            suggest = "sp_entity_id"
        elif key == "ssoEndpoint":
            suggest = "sso_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_lifetime: Optional[builtins.str] = None,
                 allow_pkce_without_client_secret: Optional[builtins.bool] = None,
                 app_launcher_url: Optional[builtins.str] = None,
                 auth_type: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 consumer_service_url: Optional[builtins.str] = None,
                 custom_attributes: Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomAttribute']] = None,
                 custom_claims: Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomClaim']] = None,
                 default_relay_state: Optional[builtins.str] = None,
                 grant_types: Optional[Sequence[builtins.str]] = None,
                 group_filter_regex: Optional[builtins.str] = None,
                 hybrid_and_implicit_options: Optional['outputs.ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions'] = None,
                 idp_entity_id: Optional[builtins.str] = None,
                 name_id_format: Optional[builtins.str] = None,
                 name_id_transform_jsonata: Optional[builtins.str] = None,
                 public_key: Optional[builtins.str] = None,
                 redirect_uris: Optional[Sequence[builtins.str]] = None,
                 refresh_token_options: Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppRefreshTokenOption']] = None,
                 saml_attribute_transform_jsonata: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None,
                 sp_entity_id: Optional[builtins.str] = None,
                 sso_endpoint: Optional[builtins.str] = None):
        """
        :param builtins.str access_token_lifetime: The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        :param builtins.bool allow_pkce_without_client_secret: Allow PKCE flow without a client secret.
        :param builtins.str app_launcher_url: The URL where this applications tile redirects users.
        :param builtins.str auth_type: **Modifying this attribute will force creation of a new resource.**
        :param builtins.str client_id: The application client id.
        :param builtins.str client_secret: The application client secret, only returned on initial apply.
        :param builtins.str consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param Sequence['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs'] custom_attributes: Custom attribute mapped from IDPs.
        :param Sequence['ZeroTrustAccessApplicationSaasAppCustomClaimArgs'] custom_claims: Custom claim mapped from IDPs.
        :param builtins.str default_relay_state: The relay state used if not provided by the identity provider.
        :param Sequence[builtins.str] grant_types: The OIDC flows supported by this application.
        :param builtins.str group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        :param 'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs' hybrid_and_implicit_options: Hybrid and Implicit Flow options.
        :param builtins.str idp_entity_id: The unique identifier for the SaaS application.
        :param builtins.str name_id_format: The format of the name identifier sent to the SaaS application.
        :param builtins.str name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param builtins.str public_key: The public certificate that will be used to verify identities.
        :param Sequence[builtins.str] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        :param Sequence['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionArgs'] refresh_token_options: Refresh token grant options.
        :param builtins.str saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param Sequence[builtins.str] scopes: Define the user information shared with access.
        :param builtins.str sp_entity_id: A globally unique name for an identity or service provider.
        :param builtins.str sso_endpoint: The endpoint where the SaaS application will send login requests.
        """
        if access_token_lifetime is not None:
            pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        if allow_pkce_without_client_secret is not None:
            pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        if app_launcher_url is not None:
            pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if consumer_service_url is not None:
            pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if custom_claims is not None:
            pulumi.set(__self__, "custom_claims", custom_claims)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if group_filter_regex is not None:
            pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        if hybrid_and_implicit_options is not None:
            pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if name_id_transform_jsonata is not None:
            pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if refresh_token_options is not None:
            pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        if saml_attribute_transform_jsonata is not None:
            pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sso_endpoint is not None:
            pulumi.set(__self__, "sso_endpoint", sso_endpoint)

    @property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> Optional[builtins.str]:
        """
        The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> Optional[builtins.bool]:
        """
        Allow PKCE flow without a client secret.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> Optional[builtins.str]:
        """
        The URL where this applications tile redirects users.
        """
        return pulumi.get(self, "app_launcher_url")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[builtins.str]:
        """
        **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The application client id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The application client secret, only returned on initial apply.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> Optional[builtins.str]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomAttribute']]:
        """
        Custom attribute mapped from IDPs.
        """
        return pulumi.get(self, "custom_attributes")

    @property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppCustomClaim']]:
        """
        Custom claim mapped from IDPs.
        """
        return pulumi.get(self, "custom_claims")

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[builtins.str]:
        """
        The relay state used if not provided by the identity provider.
        """
        return pulumi.get(self, "default_relay_state")

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The OIDC flows supported by this application.
        """
        return pulumi.get(self, "grant_types")

    @property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> Optional[builtins.str]:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
        """
        return pulumi.get(self, "group_filter_regex")

    @property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> Optional['outputs.ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions']:
        """
        Hybrid and Implicit Flow options.
        """
        return pulumi.get(self, "hybrid_and_implicit_options")

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[builtins.str]:
        """
        The unique identifier for the SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[builtins.str]:
        """
        The format of the name identifier sent to the SaaS application.
        """
        return pulumi.get(self, "name_id_format")

    @property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> Optional[builtins.str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[builtins.str]:
        """
        The public certificate that will be used to verify identities.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationSaasAppRefreshTokenOption']]:
        """
        Refresh token grant options.
        """
        return pulumi.get(self, "refresh_token_options")

    @property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> Optional[builtins.str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        Define the user information shared with access.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[builtins.str]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> Optional[builtins.str]:
        """
        The endpoint where the SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "friendlyName":
            suggest = "friendly_name"
        elif key == "nameFormat":
            suggest = "name_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppCustomAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: 'outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSource',
                 friendly_name: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 name_format: Optional[builtins.str] = None,
                 required: Optional[builtins.bool] = None):
        """
        :param builtins.str friendly_name: A friendly name for the attribute as provided to the SaaS app.
        :param builtins.str name: The name of the attribute as provided to the SaaS app.
        :param builtins.str name_format: A globally unique name for an identity or service provider.
        :param builtins.bool required: True if the attribute must be always present.
        """
        pulumi.set(__self__, "source", source)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_format is not None:
            pulumi.set(__self__, "name_format", name_format)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def source(self) -> 'outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSource':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[builtins.str]:
        """
        A friendly name for the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[builtins.str]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameByIdp":
            suggest = "name_by_idp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppCustomAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 name_by_idp: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name of the attribute as provided by the IDP.
        :param Mapping[str, builtins.str] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the attribute as provided by the IDP.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomClaim(dict):
    def __init__(__self__, *,
                 source: 'outputs.ZeroTrustAccessApplicationSaasAppCustomClaimSource',
                 name: Optional[builtins.str] = None,
                 required: Optional[builtins.bool] = None,
                 scope: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the attribute as provided to the SaaS app.
        :param builtins.bool required: True if the attribute must be always present.
        :param builtins.str scope: The scope of the claim.
        """
        pulumi.set(__self__, "source", source)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def source(self) -> 'outputs.ZeroTrustAccessApplicationSaasAppCustomClaimSource':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the attribute as provided to the SaaS app.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        True if the attribute must be always present.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def scope(self) -> Optional[builtins.str]:
        """
        The scope of the claim.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppCustomClaimSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameByIdp":
            suggest = "name_by_idp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppCustomClaimSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomClaimSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppCustomClaimSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 name_by_idp: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name of the attribute as provided by the IDP.
        :param Mapping[str, builtins.str] name_by_idp: A mapping from IdP ID to claim name.
        """
        pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the attribute as provided by the IDP.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "returnAccessTokenFromAuthorizationEndpoint":
            suggest = "return_access_token_from_authorization_endpoint"
        elif key == "returnIdTokenFromAuthorizationEndpoint":
            suggest = "return_id_token_from_authorization_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: Optional[builtins.bool] = None,
                 return_id_token_from_authorization_endpoint: Optional[builtins.bool] = None):
        """
        :param builtins.bool return_access_token_from_authorization_endpoint: If true, the authorization endpoint will return an access token.
        :param builtins.bool return_id_token_from_authorization_endpoint: If true, the authorization endpoint will return an id token.
        """
        if return_access_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        if return_id_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> Optional[builtins.bool]:
        """
        If true, the authorization endpoint will return an access token.
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> Optional[builtins.bool]:
        """
        If true, the authorization endpoint will return an id token.
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")


@pulumi.output_type
class ZeroTrustAccessApplicationSaasAppRefreshTokenOption(dict):
    def __init__(__self__, *,
                 lifetime: Optional[builtins.str] = None):
        """
        :param builtins.str lifetime: How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
        if lifetime is not None:
            pulumi.set(__self__, "lifetime", lifetime)

    @property
    @pulumi.getter
    def lifetime(self) -> Optional[builtins.str]:
        """
        How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")


@pulumi.output_type
class ZeroTrustAccessApplicationScimConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idpUid":
            suggest = "idp_uid"
        elif key == "remoteUri":
            suggest = "remote_uri"
        elif key == "deactivateOnDelete":
            suggest = "deactivate_on_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationScimConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationScimConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationScimConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idp_uid: builtins.str,
                 remote_uri: builtins.str,
                 authentication: Optional['outputs.ZeroTrustAccessApplicationScimConfigAuthentication'] = None,
                 deactivate_on_delete: Optional[builtins.bool] = None,
                 enabled: Optional[builtins.bool] = None,
                 mappings: Optional[Sequence['outputs.ZeroTrustAccessApplicationScimConfigMapping']] = None):
        """
        :param builtins.str idp_uid: The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        :param builtins.str remote_uri: The base URI for the application's SCIM-compatible API.
        :param 'ZeroTrustAccessApplicationScimConfigAuthenticationArgs' authentication: Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        :param builtins.bool deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param builtins.bool enabled: Whether SCIM provisioning is turned on for this application.
        :param Sequence['ZeroTrustAccessApplicationScimConfigMappingArgs'] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "remote_uri", remote_uri)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if deactivate_on_delete is not None:
            pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> builtins.str:
        """
        The UIDs of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> builtins.str:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ZeroTrustAccessApplicationScimConfigAuthentication']:
        """
        Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> Optional[builtins.bool]:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.ZeroTrustAccessApplicationScimConfigMapping']]:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class ZeroTrustAccessApplicationScimConfigAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationUrl":
            suggest = "authorization_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationScimConfigAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationScimConfigAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationScimConfigAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scheme: builtins.str,
                 authorization_url: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None,
                 token: Optional[builtins.str] = None,
                 token_url: Optional[builtins.str] = None,
                 user: Optional[builtins.str] = None):
        """
        :param builtins.str scheme: The authentication scheme to use when making SCIM requests to this application.
        :param builtins.str authorization_url: URL used to generate the auth code used during token generation.
        :param builtins.str client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        :param builtins.str client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        :param Sequence[builtins.str] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        :param builtins.str token: Token used to authenticate with the remote SCIM service.
        :param builtins.str token_url: URL used to generate the token used to authenticate with the remote SCIM service.
        :param builtins.str user: User name used to authenticate with the remote SCIM service.
        """
        pulumi.set(__self__, "scheme", scheme)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def scheme(self) -> builtins.str:
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[builtins.str]:
        """
        URL used to generate the auth code used during token generation.
        """
        return pulumi.get(self, "authorization_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def token(self) -> Optional[builtins.str]:
        """
        Token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[builtins.str]:
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter
    def user(self) -> Optional[builtins.str]:
        """
        User name used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ZeroTrustAccessApplicationScimConfigMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformJsonata":
            suggest = "transform_jsonata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationScimConfigMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationScimConfigMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationScimConfigMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: builtins.str,
                 enabled: Optional[builtins.bool] = None,
                 filter: Optional[builtins.str] = None,
                 operations: Optional['outputs.ZeroTrustAccessApplicationScimConfigMappingOperations'] = None,
                 strictness: Optional[builtins.str] = None,
                 transform_jsonata: Optional[builtins.str] = None):
        """
        :param builtins.str schema: Which SCIM resource type this mapping applies to.
        :param builtins.bool enabled: Whether or not this mapping is enabled.
        :param builtins.str filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param 'ZeroTrustAccessApplicationScimConfigMappingOperationsArgs' operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param builtins.str strictness: How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        :param builtins.str transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "schema", schema)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if strictness is not None:
            pulumi.set(__self__, "strictness", strictness)
        if transform_jsonata is not None:
            pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @property
    @pulumi.getter
    def schema(self) -> builtins.str:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filter(self) -> Optional[builtins.str]:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def operations(self) -> Optional['outputs.ZeroTrustAccessApplicationScimConfigMappingOperations']:
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def strictness(self) -> Optional[builtins.str]:
        """
        How strictly to adhere to outbound resource schemas when provisioning to this mapping. "strict" will remove unknown values when provisioning, while "passthrough" will pass unknown values to the target.
        """
        return pulumi.get(self, "strictness")

    @property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> Optional[builtins.str]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")


@pulumi.output_type
class ZeroTrustAccessApplicationScimConfigMappingOperations(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.bool] = None,
                 delete: Optional[builtins.bool] = None,
                 update: Optional[builtins.bool] = None):
        """
        :param builtins.bool create: Whether or not this mapping applies to create (POST) operations.
        :param builtins.bool delete: Whether or not this mapping applies to DELETE operations.
        :param builtins.bool update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.bool]:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.bool]:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.bool]:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ZeroTrustAccessApplicationTargetCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetAttributes":
            suggest = "target_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessApplicationTargetCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessApplicationTargetCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessApplicationTargetCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: builtins.int,
                 protocol: builtins.str,
                 target_attributes: Sequence['outputs.ZeroTrustAccessApplicationTargetCriteriaTargetAttribute']):
        """
        :param builtins.int port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param builtins.str protocol: The communication protocol your application secures.
        :param Sequence['ZeroTrustAccessApplicationTargetCriteriaTargetAttributeArgs'] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> builtins.str:
        """
        The communication protocol your application secures.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> Sequence['outputs.ZeroTrustAccessApplicationTargetCriteriaTargetAttribute']:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")


@pulumi.output_type
class ZeroTrustAccessApplicationTargetCriteriaTargetAttribute(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str name: The key of the attribute.
        :param Sequence[builtins.str] values: The values of the attribute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The key of the attribute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        The values of the attribute.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ZeroTrustAccessGroupExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluations":
            suggest = "external_evaluations"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluations: Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeExternalEvaluation']] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeOkta']] = None,
                 samls: Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['ZeroTrustAccessGroupExcludeAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param Sequence['ZeroTrustAccessGroupExcludeExternalEvaluationArgs'] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['ZeroTrustAccessGroupExcludeGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['ZeroTrustAccessGroupExcludeGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['ZeroTrustAccessGroupExcludeOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['ZeroTrustAccessGroupExcludeSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeExternalEvaluation']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupExcludeSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class ZeroTrustAccessGroupExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluations":
            suggest = "external_evaluations"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluations: Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeExternalEvaluation']] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeOkta']] = None,
                 samls: Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['ZeroTrustAccessGroupIncludeAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param Sequence['ZeroTrustAccessGroupIncludeExternalEvaluationArgs'] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['ZeroTrustAccessGroupIncludeGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['ZeroTrustAccessGroupIncludeGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['ZeroTrustAccessGroupIncludeOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['ZeroTrustAccessGroupIncludeSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeExternalEvaluation']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupIncludeSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class ZeroTrustAccessGroupIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluations":
            suggest = "external_evaluations"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.ZeroTrustAccessGroupRequireAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.ZeroTrustAccessGroupRequireAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluations: Optional[Sequence['outputs.ZeroTrustAccessGroupRequireExternalEvaluation']] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.ZeroTrustAccessGroupRequireGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.ZeroTrustAccessGroupRequireGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.ZeroTrustAccessGroupRequireOkta']] = None,
                 samls: Optional[Sequence['outputs.ZeroTrustAccessGroupRequireSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['ZeroTrustAccessGroupRequireAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param Sequence['ZeroTrustAccessGroupRequireExternalEvaluationArgs'] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['ZeroTrustAccessGroupRequireGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['ZeroTrustAccessGroupRequireGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['ZeroTrustAccessGroupRequireOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['ZeroTrustAccessGroupRequireSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupRequireAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupRequireAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupRequireExternalEvaluation']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupRequireGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupRequireGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupRequireOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.ZeroTrustAccessGroupRequireSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class ZeroTrustAccessGroupRequireAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupRequireAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class ZeroTrustAccessGroupRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessGroupRequireGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class ZeroTrustAccessGroupRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessGroupRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class ZeroTrustAccessGroupRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessGroupRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessGroupRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessGroupRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessIdentityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "appsDomain":
            suggest = "apps_domain"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "authorizationServerId":
            suggest = "authorization_server_id"
        elif key == "centrifyAccount":
            suggest = "centrify_account"
        elif key == "centrifyAppId":
            suggest = "centrify_app_id"
        elif key == "certsUrl":
            suggest = "certs_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "conditionalAccessEnabled":
            suggest = "conditional_access_enabled"
        elif key == "directoryId":
            suggest = "directory_id"
        elif key == "emailAttributeName":
            suggest = "email_attribute_name"
        elif key == "emailClaimName":
            suggest = "email_claim_name"
        elif key == "idpPublicCert":
            suggest = "idp_public_cert"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "oktaAccount":
            suggest = "okta_account"
        elif key == "oneloginAccount":
            suggest = "onelogin_account"
        elif key == "pingEnvId":
            suggest = "ping_env_id"
        elif key == "pkceEnabled":
            suggest = "pkce_enabled"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "signRequest":
            suggest = "sign_request"
        elif key == "ssoTargetUrl":
            suggest = "sso_target_url"
        elif key == "supportGroups":
            suggest = "support_groups"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessIdentityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessIdentityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessIdentityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional[builtins.str] = None,
                 apps_domain: Optional[builtins.str] = None,
                 attributes: Optional[Sequence[builtins.str]] = None,
                 auth_url: Optional[builtins.str] = None,
                 authorization_server_id: Optional[builtins.str] = None,
                 centrify_account: Optional[builtins.str] = None,
                 centrify_app_id: Optional[builtins.str] = None,
                 certs_url: Optional[builtins.str] = None,
                 claims: Optional[Sequence[builtins.str]] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 conditional_access_enabled: Optional[builtins.bool] = None,
                 directory_id: Optional[builtins.str] = None,
                 email_attribute_name: Optional[builtins.str] = None,
                 email_claim_name: Optional[builtins.str] = None,
                 idp_public_cert: Optional[builtins.str] = None,
                 issuer_url: Optional[builtins.str] = None,
                 okta_account: Optional[builtins.str] = None,
                 onelogin_account: Optional[builtins.str] = None,
                 ping_env_id: Optional[builtins.str] = None,
                 pkce_enabled: Optional[builtins.bool] = None,
                 redirect_url: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None,
                 sign_request: Optional[builtins.bool] = None,
                 sso_target_url: Optional[builtins.str] = None,
                 support_groups: Optional[builtins.bool] = None,
                 token_url: Optional[builtins.str] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if conditional_access_enabled is not None:
            pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            pulumi.set(__self__, "email_claim_name", email_claim_name)
        if idp_public_cert is not None:
            pulumi.set(__self__, "idp_public_cert", idp_public_cert)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if ping_env_id is not None:
            pulumi.set(__self__, "ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[builtins.str]:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[builtins.str]:
        return pulumi.get(self, "apps_domain")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "authorization_server_id")

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[builtins.str]:
        return pulumi.get(self, "centrify_account")

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "centrify_app_id")

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "certs_url")

    @property
    @pulumi.getter
    def claims(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "claims")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "conditional_access_enabled")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email_attribute_name")

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email_claim_name")

    @property
    @pulumi.getter(name="idpPublicCert")
    def idp_public_cert(self) -> Optional[builtins.str]:
        return pulumi.get(self, "idp_public_cert")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[builtins.str]:
        return pulumi.get(self, "okta_account")

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[builtins.str]:
        return pulumi.get(self, "onelogin_account")

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ping_env_id")

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "pkce_enabled")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "sign_request")

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "sso_target_url")

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "support_groups")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class ZeroTrustAccessIdentityProviderScimConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupMemberDeprovision":
            suggest = "group_member_deprovision"
        elif key == "identityUpdateBehavior":
            suggest = "identity_update_behavior"
        elif key == "seatDeprovision":
            suggest = "seat_deprovision"
        elif key == "userDeprovision":
            suggest = "user_deprovision"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessIdentityProviderScimConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessIdentityProviderScimConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessIdentityProviderScimConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 group_member_deprovision: Optional[builtins.bool] = None,
                 identity_update_behavior: Optional[builtins.str] = None,
                 seat_deprovision: Optional[builtins.bool] = None,
                 secret: Optional[builtins.str] = None,
                 user_deprovision: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: A flag to enable or disable SCIM for the identity provider.
        :param builtins.bool group_member_deprovision: Deprecated. Use `identity_update_behavior`.
        :param builtins.str identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        :param builtins.bool seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param builtins.str secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        :param builtins.bool user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group_member_deprovision is not None:
            pulumi.set(__self__, "group_member_deprovision", group_member_deprovision)
        if identity_update_behavior is not None:
            pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="groupMemberDeprovision")
    def group_member_deprovision(self) -> Optional[builtins.bool]:
        """
        Deprecated. Use `identity_update_behavior`.
        """
        return pulumi.get(self, "group_member_deprovision")

    @property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> Optional[builtins.str]:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        return pulumi.get(self, "identity_update_behavior")

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[builtins.bool]:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @property
    @pulumi.getter
    def secret(self) -> Optional[builtins.str]:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[builtins.bool]:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")


@pulumi.output_type
class ZeroTrustAccessMtlsHostnameSettingsSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chinaNetwork":
            suggest = "china_network"
        elif key == "clientCertificateForwarding":
            suggest = "client_certificate_forwarding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessMtlsHostnameSettingsSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessMtlsHostnameSettingsSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessMtlsHostnameSettingsSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: builtins.str,
                 china_network: Optional[builtins.bool] = None,
                 client_certificate_forwarding: Optional[builtins.bool] = None):
        """
        :param builtins.str hostname: The hostname that these settings apply to.
        :param builtins.bool china_network: Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        :param builtins.bool client_certificate_forwarding: Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        pulumi.set(__self__, "hostname", hostname)
        if china_network is not None:
            pulumi.set(__self__, "china_network", china_network)
        if client_certificate_forwarding is not None:
            pulumi.set(__self__, "client_certificate_forwarding", client_certificate_forwarding)

    @property
    @pulumi.getter
    def hostname(self) -> builtins.str:
        """
        The hostname that these settings apply to.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="chinaNetwork")
    def china_network(self) -> Optional[builtins.bool]:
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        return pulumi.get(self, "china_network")

    @property
    @pulumi.getter(name="clientCertificateForwarding")
    def client_certificate_forwarding(self) -> Optional[builtins.bool]:
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        return pulumi.get(self, "client_certificate_forwarding")


@pulumi.output_type
class ZeroTrustAccessOrganizationCustomPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityDenied":
            suggest = "identity_denied"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessOrganizationCustomPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessOrganizationCustomPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessOrganizationCustomPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forbidden: Optional[builtins.str] = None,
                 identity_denied: Optional[builtins.str] = None):
        """
        :param builtins.str forbidden: The id of the forbidden page.
        :param builtins.str identity_denied: The id of the identity denied page.
        """
        if forbidden is not None:
            pulumi.set(__self__, "forbidden", forbidden)
        if identity_denied is not None:
            pulumi.set(__self__, "identity_denied", identity_denied)

    @property
    @pulumi.getter
    def forbidden(self) -> Optional[builtins.str]:
        """
        The id of the forbidden page.
        """
        return pulumi.get(self, "forbidden")

    @property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[builtins.str]:
        """
        The id of the identity denied page.
        """
        return pulumi.get(self, "identity_denied")


@pulumi.output_type
class ZeroTrustAccessOrganizationLoginDesign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessOrganizationLoginDesign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessOrganizationLoginDesign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessOrganizationLoginDesign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[builtins.str] = None,
                 footer_text: Optional[builtins.str] = None,
                 header_text: Optional[builtins.str] = None,
                 logo_path: Optional[builtins.str] = None,
                 text_color: Optional[builtins.str] = None):
        """
        :param builtins.str background_color: The background color on the login page.
        :param builtins.str footer_text: The text at the bottom of the login page.
        :param builtins.str header_text: The text at the top of the login page.
        :param builtins.str logo_path: The URL of the logo on the login page.
        :param builtins.str text_color: The text color on the login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[builtins.str]:
        """
        The background color on the login page.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[builtins.str]:
        """
        The text at the bottom of the login page.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[builtins.str]:
        """
        The text at the top of the login page.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[builtins.str]:
        """
        The URL of the logo on the login page.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[builtins.str]:
        """
        The text color on the login page.
        """
        return pulumi.get(self, "text_color")


@pulumi.output_type
class ZeroTrustAccessPolicyApprovalGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalsNeeded":
            suggest = "approvals_needed"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailListUuid":
            suggest = "email_list_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyApprovalGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyApprovalGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyApprovalGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approvals_needed: builtins.int,
                 email_addresses: Optional[Sequence[builtins.str]] = None,
                 email_list_uuid: Optional[builtins.str] = None):
        """
        :param builtins.int approvals_needed: Number of approvals needed.
        :param Sequence[builtins.str] email_addresses: List of emails to request approval from.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> builtins.int:
        """
        Number of approvals needed.
        """
        return pulumi.get(self, "approvals_needed")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[builtins.str]]:
        """
        List of emails to request approval from.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email_list_uuid")


@pulumi.output_type
class ZeroTrustAccessPolicyConnectionRules(dict):
    def __init__(__self__, *,
                 ssh: 'outputs.ZeroTrustAccessPolicyConnectionRulesSsh'):
        """
        :param 'ZeroTrustAccessPolicyConnectionRulesSshArgs' ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def ssh(self) -> 'outputs.ZeroTrustAccessPolicyConnectionRulesSsh':
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class ZeroTrustAccessPolicyConnectionRulesSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowEmailAlias":
            suggest = "allow_email_alias"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyConnectionRulesSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyConnectionRulesSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyConnectionRulesSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usernames: Sequence[builtins.str],
                 allow_email_alias: Optional[builtins.bool] = None):
        """
        :param Sequence[builtins.str] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        :param builtins.bool allow_email_alias: Allows connecting to Unix username that matches the authenticating email prefix.
        """
        pulumi.set(__self__, "usernames", usernames)
        if allow_email_alias is not None:
            pulumi.set(__self__, "allow_email_alias", allow_email_alias)

    @property
    @pulumi.getter
    def usernames(self) -> Sequence[builtins.str]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")

    @property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> Optional[builtins.bool]:
        """
        Allows connecting to Unix username that matches the authenticating email prefix.
        """
        return pulumi.get(self, "allow_email_alias")


@pulumi.output_type
class ZeroTrustAccessPolicyExclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluations":
            suggest = "external_evaluations"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluations: Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeExternalEvaluation']] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeOkta']] = None,
                 samls: Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['ZeroTrustAccessPolicyExcludeAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param Sequence['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs'] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['ZeroTrustAccessPolicyExcludeGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['ZeroTrustAccessPolicyExcludeGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['ZeroTrustAccessPolicyExcludeOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['ZeroTrustAccessPolicyExcludeSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeExternalEvaluation']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyExcludeSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class ZeroTrustAccessPolicyExcludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyExcludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyExcludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyExcludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyInclude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluations":
            suggest = "external_evaluations"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyInclude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyInclude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyInclude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluations: Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeExternalEvaluation']] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeOkta']] = None,
                 samls: Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['ZeroTrustAccessPolicyIncludeAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param Sequence['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs'] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['ZeroTrustAccessPolicyIncludeGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['ZeroTrustAccessPolicyIncludeGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['ZeroTrustAccessPolicyIncludeOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['ZeroTrustAccessPolicyIncludeSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeExternalEvaluation']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyIncludeSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class ZeroTrustAccessPolicyIncludeSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyIncludeSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyIncludeSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyIncludeSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyValidServiceToken":
            suggest = "any_valid_service_token"
        elif key == "authContexts":
            suggest = "auth_contexts"
        elif key == "authMethod":
            suggest = "auth_method"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "commonNames":
            suggest = "common_names"
        elif key == "devicePostures":
            suggest = "device_postures"
        elif key == "emailDomains":
            suggest = "email_domains"
        elif key == "emailLists":
            suggest = "email_lists"
        elif key == "externalEvaluations":
            suggest = "external_evaluations"
        elif key == "ipLists":
            suggest = "ip_lists"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "serviceTokens":
            suggest = "service_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_valid_service_token: Optional[builtins.bool] = None,
                 auth_contexts: Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireAuthContext']] = None,
                 auth_method: Optional[builtins.str] = None,
                 azures: Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireAzure']] = None,
                 certificate: Optional[builtins.bool] = None,
                 common_name: Optional[builtins.str] = None,
                 common_names: Optional[Sequence[builtins.str]] = None,
                 device_postures: Optional[Sequence[builtins.str]] = None,
                 email_domains: Optional[Sequence[builtins.str]] = None,
                 email_lists: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 everyone: Optional[builtins.bool] = None,
                 external_evaluations: Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireExternalEvaluation']] = None,
                 geos: Optional[Sequence[builtins.str]] = None,
                 githubs: Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireGithub']] = None,
                 groups: Optional[Sequence[builtins.str]] = None,
                 gsuites: Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireGsuite']] = None,
                 ip_lists: Optional[Sequence[builtins.str]] = None,
                 ips: Optional[Sequence[builtins.str]] = None,
                 login_methods: Optional[Sequence[builtins.str]] = None,
                 oktas: Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireOkta']] = None,
                 samls: Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireSaml']] = None,
                 service_tokens: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool any_valid_service_token: Matches any valid Access service token.
        :param builtins.str auth_method: The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        :param Sequence['ZeroTrustAccessPolicyRequireAzureArgs'] azures: Matches an Azure group. Requires an Azure identity provider.
        :param builtins.bool certificate: Matches any valid client certificate.
        :param builtins.str common_name: Matches a valid client certificate common name.
        :param Sequence[builtins.str] common_names: Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        :param Sequence[builtins.str] device_postures: The ID of a device posture integration.
        :param Sequence[builtins.str] email_domains: The email domain to match.
        :param Sequence[builtins.str] email_lists: The ID of a previously created email list.
        :param Sequence[builtins.str] emails: The email of the user.
        :param builtins.bool everyone: Matches everyone.
        :param Sequence['ZeroTrustAccessPolicyRequireExternalEvaluationArgs'] external_evaluations: Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        :param Sequence[builtins.str] geos: Matches a specific country.
        :param Sequence['ZeroTrustAccessPolicyRequireGithubArgs'] githubs: Matches a Github organization. Requires a Github identity provider.
        :param Sequence[builtins.str] groups: The ID of a previously created Access group.
        :param Sequence['ZeroTrustAccessPolicyRequireGsuiteArgs'] gsuites: Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        :param Sequence[builtins.str] ip_lists: The ID of a previously created IP list.
        :param Sequence[builtins.str] ips: An IPv4 or IPv6 CIDR block.
        :param Sequence[builtins.str] login_methods: The ID of a configured identity provider.
        :param Sequence['ZeroTrustAccessPolicyRequireOktaArgs'] oktas: Matches an Okta group. Requires an Okta identity provider.
        :param Sequence['ZeroTrustAccessPolicyRequireSamlArgs'] samls: Matches a SAML group. Requires a SAML identity provider.
        :param Sequence[builtins.str] service_tokens: The ID of an Access service token.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_contexts is not None:
            pulumi.set(__self__, "auth_contexts", auth_contexts)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azures is not None:
            pulumi.set(__self__, "azures", azures)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if common_names is not None:
            pulumi.set(__self__, "common_names", common_names)
        if device_postures is not None:
            pulumi.set(__self__, "device_postures", device_postures)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluations is not None:
            pulumi.set(__self__, "external_evaluations", external_evaluations)
        if geos is not None:
            pulumi.set(__self__, "geos", geos)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if gsuites is not None:
            pulumi.set(__self__, "gsuites", gsuites)
        if ip_lists is not None:
            pulumi.set(__self__, "ip_lists", ip_lists)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if oktas is not None:
            pulumi.set(__self__, "oktas", oktas)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)
        if service_tokens is not None:
            pulumi.set(__self__, "service_tokens", service_tokens)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[builtins.bool]:
        """
        Matches any valid Access service token.
        """
        return pulumi.get(self, "any_valid_service_token")

    @property
    @pulumi.getter(name="authContexts")
    def auth_contexts(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireAuthContext']]:
        return pulumi.get(self, "auth_contexts")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[builtins.str]:
        """
        The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter
    def azures(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireAzure']]:
        """
        Matches an Azure group. Requires an Azure identity provider.
        """
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.bool]:
        """
        Matches any valid client certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        Matches a valid client certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="commonNames")
    def common_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
        """
        return pulumi.get(self, "common_names")

    @property
    @pulumi.getter(name="devicePostures")
    def device_postures(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "device_postures")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "email_lists")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email of the user.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def everyone(self) -> Optional[builtins.bool]:
        """
        Matches everyone.
        """
        return pulumi.get(self, "everyone")

    @property
    @pulumi.getter(name="externalEvaluations")
    def external_evaluations(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireExternalEvaluation']]:
        """
        Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.
        """
        return pulumi.get(self, "external_evaluations")

    @property
    @pulumi.getter
    def geos(self) -> Optional[Sequence[builtins.str]]:
        """
        Matches a specific country.
        """
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireGithub']]:
        """
        Matches a Github organization. Requires a Github identity provider.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def gsuites(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireGsuite']]:
        """
        Matches a group in Google Workspace. Requires a Google Workspace identity provider.
        """
        return pulumi.get(self, "gsuites")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[builtins.str]]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of a configured identity provider.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter
    def oktas(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireOkta']]:
        """
        Matches an Okta group. Requires an Okta identity provider.
        """
        return pulumi.get(self, "oktas")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.ZeroTrustAccessPolicyRequireSaml']]:
        """
        Matches a SAML group. Requires a SAML identity provider.
        """
        return pulumi.get(self, "samls")

    @property
    @pulumi.getter(name="serviceTokens")
    def service_tokens(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of an Access service token.
        """
        return pulumi.get(self, "service_tokens")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireAuthContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acId":
            suggest = "ac_id"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireAuthContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireAuthContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireAuthContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ac_id: builtins.str,
                 id: builtins.str,
                 identity_provider_id: builtins.str):
        """
        :param builtins.str ac_id: The ACID of the Authentication Context.
        :param builtins.str id: The ID of the Authentication Context.
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> builtins.str:
        """
        The ACID of the Authentication Context.
        """
        return pulumi.get(self, "ac_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the Authentication Context.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of the Azure identity provider.
        :param Sequence[builtins.str] ids: The ID of the Azure group or user.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of the Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The ID of the Azure group or user.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireExternalEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateUrl":
            suggest = "evaluate_url"
        elif key == "keysUrl":
            suggest = "keys_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireExternalEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireExternalEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireExternalEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_url: Optional[builtins.str] = None,
                 keys_url: Optional[builtins.str] = None):
        """
        :param builtins.str evaluate_url: The API endpoint containing your business logic.
        :param builtins.str keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        if evaluate_url is not None:
            pulumi.set(__self__, "evaluate_url", evaluate_url)
        if keys_url is not None:
            pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> Optional[builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 teams: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Github identity provider.
        :param builtins.str name: The name of the organization.
        :param Sequence[builtins.str] teams: The teams that should be matched.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[builtins.str]]:
        """
        The teams that should be matched.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireGsuite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireGsuite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireGsuite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireGsuite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Sequence[builtins.str],
                 identity_provider_id: builtins.str):
        """
        :param Sequence[builtins.str] emails: The email of the Google Workspace group.
        :param builtins.str identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def emails(self) -> Sequence[builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> builtins.str:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireOkta(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireOkta. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireOkta.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireOkta.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider_id: Optional[builtins.str] = None,
                 names: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str identity_provider_id: The ID of your Okta identity provider.
        :param Sequence[builtins.str] names: The name of the Okta Group.
        """
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of the Okta Group.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class ZeroTrustAccessPolicyRequireSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValue":
            suggest = "attribute_value"
        elif key == "identityProviderId":
            suggest = "identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustAccessPolicyRequireSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustAccessPolicyRequireSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustAccessPolicyRequireSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[builtins.str] = None,
                 attribute_value: Optional[builtins.str] = None,
                 identity_provider_id: Optional[builtins.str] = None):
        """
        :param builtins.str attribute_name: The name of the SAML attribute.
        :param builtins.str attribute_value: The SAML attribute value to look for.
        :param builtins.str identity_provider_id: The ID of your SAML identity provider.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if identity_provider_id is not None:
            pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> Optional[builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")


@pulumi.output_type
class ZeroTrustDeviceManagedNetworksConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSockaddr":
            suggest = "tls_sockaddr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDeviceManagedNetworksConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDeviceManagedNetworksConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDeviceManagedNetworksConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sha256: builtins.str,
                 tls_sockaddr: builtins.str):
        """
        :param builtins.str sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        :param builtins.str tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        pulumi.set(__self__, "sha256", sha256)
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)

    @property
    @pulumi.getter
    def sha256(self) -> builtins.str:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> builtins.str:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")


@pulumi.output_type
class ZeroTrustDevicePostureIntegrationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessClientId":
            suggest = "access_client_id"
        elif key == "accessClientSecret":
            suggest = "access_client_secret"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customerId":
            suggest = "customer_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDevicePostureIntegrationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDevicePostureIntegrationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDevicePostureIntegrationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_client_id: Optional[builtins.str] = None,
                 access_client_secret: Optional[builtins.str] = None,
                 api_url: Optional[builtins.str] = None,
                 auth_url: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_key: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 customer_id: Optional[builtins.str] = None):
        """
        :param builtins.str access_client_id: The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        :param builtins.str access_client_secret: The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        :param builtins.str api_url: The third-party API's URL.
        :param builtins.str auth_url: The third-party authorization API URL.
        :param builtins.str client_id: The client identifier for authenticating API calls.
        :param builtins.str client_key: The client key for authenticating API calls.
        :param builtins.str client_secret: The client secret for authenticating API calls.
        :param builtins.str customer_id: The customer identifier for authenticating API calls.
        """
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[builtins.str]:
        """
        The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
        """
        return pulumi.get(self, "access_client_id")

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[builtins.str]:
        """
        The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
        """
        return pulumi.get(self, "access_client_secret")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[builtins.str]:
        """
        The third-party API's URL.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[builtins.str]:
        """
        The third-party authorization API URL.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The client identifier for authenticating API calls.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[builtins.str]:
        """
        The client key for authenticating API calls.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The client secret for authenticating API calls.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[builtins.str]:
        """
        The customer identifier for authenticating API calls.
        """
        return pulumi.get(self, "customer_id")


@pulumi.output_type
class ZeroTrustDevicePostureRuleInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeThreats":
            suggest = "active_threats"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "checkDisks":
            suggest = "check_disks"
        elif key == "checkPrivateKey":
            suggest = "check_private_key"
        elif key == "complianceStatus":
            suggest = "compliance_status"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "countOperator":
            suggest = "count_operator"
        elif key == "eidLastSeen":
            suggest = "eid_last_seen"
        elif key == "extendedKeyUsages":
            suggest = "extended_key_usages"
        elif key == "isActive":
            suggest = "is_active"
        elif key == "issueCount":
            suggest = "issue_count"
        elif key == "lastSeen":
            suggest = "last_seen"
        elif key == "networkStatus":
            suggest = "network_status"
        elif key == "operationalState":
            suggest = "operational_state"
        elif key == "osDistroName":
            suggest = "os_distro_name"
        elif key == "osDistroRevision":
            suggest = "os_distro_revision"
        elif key == "osVersionExtra":
            suggest = "os_version_extra"
        elif key == "requireAll":
            suggest = "require_all"
        elif key == "riskLevel":
            suggest = "risk_level"
        elif key == "sensorConfig":
            suggest = "sensor_config"
        elif key == "totalScore":
            suggest = "total_score"
        elif key == "versionOperator":
            suggest = "version_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDevicePostureRuleInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDevicePostureRuleInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDevicePostureRuleInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_threats: Optional[builtins.int] = None,
                 certificate_id: Optional[builtins.str] = None,
                 check_disks: Optional[Sequence[builtins.str]] = None,
                 check_private_key: Optional[builtins.bool] = None,
                 cn: Optional[builtins.str] = None,
                 compliance_status: Optional[builtins.str] = None,
                 connection_id: Optional[builtins.str] = None,
                 count_operator: Optional[builtins.str] = None,
                 domain: Optional[builtins.str] = None,
                 eid_last_seen: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 exists: Optional[builtins.bool] = None,
                 extended_key_usages: Optional[Sequence[builtins.str]] = None,
                 id: Optional[builtins.str] = None,
                 infected: Optional[builtins.bool] = None,
                 is_active: Optional[builtins.bool] = None,
                 issue_count: Optional[builtins.str] = None,
                 last_seen: Optional[builtins.str] = None,
                 locations: Optional[Sequence['outputs.ZeroTrustDevicePostureRuleInputLocation']] = None,
                 network_status: Optional[builtins.str] = None,
                 operational_state: Optional[builtins.str] = None,
                 operator: Optional[builtins.str] = None,
                 os: Optional[builtins.str] = None,
                 os_distro_name: Optional[builtins.str] = None,
                 os_distro_revision: Optional[builtins.str] = None,
                 os_version_extra: Optional[builtins.str] = None,
                 overall: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None,
                 require_all: Optional[builtins.bool] = None,
                 risk_level: Optional[builtins.str] = None,
                 running: Optional[builtins.bool] = None,
                 score: Optional[builtins.int] = None,
                 sensor_config: Optional[builtins.str] = None,
                 sha256: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None,
                 total_score: Optional[builtins.int] = None,
                 version: Optional[builtins.str] = None,
                 version_operator: Optional[builtins.str] = None):
        """
        :param builtins.int active_threats: The number of active threats from SentinelOne.
        :param builtins.str certificate_id: The UUID of a Cloudflare managed certificate.
        :param Sequence[builtins.str] check_disks: Specific volume(s) to check for encryption.
        :param builtins.bool check_private_key: Confirm the certificate was not imported from another device.
        :param builtins.str cn: The common name for a certificate.
        :param builtins.str compliance_status: The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        :param builtins.str connection_id: The workspace one or intune connection id.
        :param builtins.str count_operator: The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param builtins.str domain: The domain that the client must join.
        :param builtins.str eid_last_seen: The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        :param builtins.bool enabled: True if the firewall must be enabled.
        :param builtins.bool exists: Checks if the file should exist.
        :param Sequence[builtins.str] extended_key_usages: List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        :param builtins.str id: The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        :param builtins.bool infected: True if SentinelOne device is infected.
        :param builtins.bool is_active: True if SentinelOne device is active.
        :param builtins.str issue_count: The number of issues for kolide.
        :param builtins.str last_seen: The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        :param Sequence['ZeroTrustDevicePostureRuleInputLocationArgs'] locations: List of operating system locations to check for a client certificate..
        :param builtins.str network_status: The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        :param builtins.str operational_state: The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        :param builtins.str operator: The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        :param builtins.str os: OS signal score from Crowdstrike. Value must be between 1 and 100.
        :param builtins.str os_distro_name: The operating system excluding version information.
        :param builtins.str os_distro_revision: The operating system version excluding OS name information or release name.
        :param builtins.str os_version_extra: Extra version value following the operating system semantic version.
        :param builtins.str overall: Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        :param builtins.str path: The path to the file.
        :param builtins.bool require_all: True if all drives must be encrypted.
        :param builtins.str risk_level: The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        :param builtins.bool running: Checks if the application should be running.
        :param builtins.int score: A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        :param builtins.str sensor_config: Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        :param builtins.str sha256: The sha256 hash of the file.
        :param builtins.str state: The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        :param builtins.str thumbprint: The thumbprint of the file certificate.
        :param builtins.int total_score: The total score from Tanium.
        :param builtins.str version: The operating system semantic version.
        :param builtins.str version_operator: The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if check_private_key is not None:
            pulumi.set(__self__, "check_private_key", check_private_key)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if eid_last_seen is not None:
            pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)
        if running is not None:
            pulumi.set(__self__, "running", running)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if total_score is not None:
            pulumi.set(__self__, "total_score", total_score)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[builtins.int]:
        """
        The number of active threats from SentinelOne.
        """
        return pulumi.get(self, "active_threats")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[builtins.str]:
        """
        The UUID of a Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[Sequence[builtins.str]]:
        """
        Specific volume(s) to check for encryption.
        """
        return pulumi.get(self, "check_disks")

    @property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> Optional[builtins.bool]:
        """
        Confirm the certificate was not imported from another device.
        """
        return pulumi.get(self, "check_private_key")

    @property
    @pulumi.getter
    def cn(self) -> Optional[builtins.str]:
        """
        The common name for a certificate.
        """
        return pulumi.get(self, "cn")

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[builtins.str]:
        """
        The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
        """
        return pulumi.get(self, "compliance_status")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[builtins.str]:
        """
        The workspace one or intune connection id.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[builtins.str]:
        """
        The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "count_operator")

    @property
    @pulumi.getter
    def domain(self) -> Optional[builtins.str]:
        """
        The domain that the client must join.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[builtins.str]:
        """
        The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        return pulumi.get(self, "eid_last_seen")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        True if the firewall must be enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exists(self) -> Optional[builtins.bool]:
        """
        Checks if the file should exist.
        """
        return pulumi.get(self, "exists")

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[Sequence[builtins.str]]:
        """
        List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
        """
        return pulumi.get(self, "extended_key_usages")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def infected(self) -> Optional[builtins.bool]:
        """
        True if SentinelOne device is infected.
        """
        return pulumi.get(self, "infected")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[builtins.bool]:
        """
        True if SentinelOne device is active.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[builtins.str]:
        """
        The number of issues for kolide.
        """
        return pulumi.get(self, "issue_count")

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[builtins.str]:
        """
        The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
        """
        return pulumi.get(self, "last_seen")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.ZeroTrustDevicePostureRuleInputLocation']]:
        """
        List of operating system locations to check for a client certificate..
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[builtins.str]:
        """
        The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
        """
        return pulumi.get(self, "network_status")

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[builtins.str]:
        """
        The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.
        """
        return pulumi.get(self, "operational_state")

    @property
    @pulumi.getter
    def operator(self) -> Optional[builtins.str]:
        """
        The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def os(self) -> Optional[builtins.str]:
        """
        OS signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "os")

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[builtins.str]:
        """
        The operating system excluding version information.
        """
        return pulumi.get(self, "os_distro_name")

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[builtins.str]:
        """
        The operating system version excluding OS name information or release name.
        """
        return pulumi.get(self, "os_distro_revision")

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[builtins.str]:
        """
        Extra version value following the operating system semantic version.
        """
        return pulumi.get(self, "os_version_extra")

    @property
    @pulumi.getter
    def overall(self) -> Optional[builtins.str]:
        """
        Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "overall")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The path to the file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[builtins.bool]:
        """
        True if all drives must be encrypted.
        """
        return pulumi.get(self, "require_all")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[builtins.str]:
        """
        The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "risk_level")

    @property
    @pulumi.getter
    def running(self) -> Optional[builtins.bool]:
        """
        Checks if the application should be running.
        """
        return pulumi.get(self, "running")

    @property
    @pulumi.getter
    def score(self) -> Optional[builtins.int]:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[builtins.str]:
        """
        Sensor signal score from Crowdstrike. Value must be between 1 and 100.
        """
        return pulumi.get(self, "sensor_config")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[builtins.str]:
        """
        The sha256 hash of the file.
        """
        return pulumi.get(self, "sha256")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of the file certificate.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[builtins.int]:
        """
        The total score from Tanium.
        """
        return pulumi.get(self, "total_score")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        The operating system semantic version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[builtins.str]:
        """
        The version comparison operator for Crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
        """
        return pulumi.get(self, "version_operator")


@pulumi.output_type
class ZeroTrustDevicePostureRuleInputLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustStores":
            suggest = "trust_stores"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDevicePostureRuleInputLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDevicePostureRuleInputLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDevicePostureRuleInputLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paths: Optional[Sequence[builtins.str]] = None,
                 trust_stores: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] paths: List of paths to check for client certificate rule.
        :param Sequence[builtins.str] trust_stores: List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if trust_stores is not None:
            pulumi.set(__self__, "trust_stores", trust_stores)

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[builtins.str]]:
        """
        List of paths to check for client certificate rule.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Optional[Sequence[builtins.str]]:
        """
        List of trust stores to check for client certificate rule. Available values: `system`, `user`.
        """
        return pulumi.get(self, "trust_stores")


@pulumi.output_type
class ZeroTrustDevicePostureRuleMatch(dict):
    def __init__(__self__, *,
                 platform: Optional[builtins.str] = None):
        """
        :param builtins.str platform: The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[builtins.str]:
        """
        The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class ZeroTrustDexTestData(dict):
    def __init__(__self__, *,
                 host: builtins.str,
                 kind: builtins.str,
                 method: Optional[builtins.str] = None):
        """
        :param builtins.str host: The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        :param builtins.str kind: The type of Device Dex Test. Available values: `http`, `traceroute`.
        :param builtins.str method: The http request method. Available values: `GET`.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        The type of Device Dex Test. Available values: `http`, `traceroute`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def method(self) -> Optional[builtins.str]:
        """
        The http request method. Available values: `GET`.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class ZeroTrustDlpProfileContextAwareness(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool,
                 skip: 'outputs.ZeroTrustDlpProfileContextAwarenessSkip'):
        """
        :param builtins.bool enabled: Scan the context of predefined entries to only return matches surrounded by keywords.
        :param 'ZeroTrustDlpProfileContextAwarenessSkipArgs' skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def skip(self) -> 'outputs.ZeroTrustDlpProfileContextAwarenessSkip':
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")


@pulumi.output_type
class ZeroTrustDlpProfileContextAwarenessSkip(dict):
    def __init__(__self__, *,
                 files: builtins.bool):
        """
        :param builtins.bool files: Return all matches, regardless of context analysis result, if the data is a file.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> builtins.bool:
        """
        Return all matches, regardless of context analysis result, if the data is a file.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class ZeroTrustDlpProfileEntry(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 enabled: Optional[builtins.bool] = None,
                 id: Optional[builtins.str] = None,
                 pattern: Optional['outputs.ZeroTrustDlpProfileEntryPattern'] = None):
        """
        :param builtins.str name: Name of the entry to deploy.
        :param builtins.bool enabled: Whether the entry is active. Defaults to `false`.
        :param builtins.str id: Unique entry identifier.
        """
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the entry to deploy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether the entry is active. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Unique entry identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['outputs.ZeroTrustDlpProfileEntryPattern']:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ZeroTrustDlpProfileEntryPattern(dict):
    def __init__(__self__, *,
                 regex: builtins.str,
                 validation: Optional[builtins.str] = None):
        """
        :param builtins.str regex: The regex that defines the pattern.
        :param builtins.str validation: The validation algorithm to apply with this pattern.
        """
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> builtins.str:
        """
        The regex that defines the pattern.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def validation(self) -> Optional[builtins.str]:
        """
        The validation algorithm to apply with this pattern.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class ZeroTrustDnsLocationEndpoints(dict):
    def __init__(__self__, *,
                 doh: Optional['outputs.ZeroTrustDnsLocationEndpointsDoh'] = None,
                 dot: Optional['outputs.ZeroTrustDnsLocationEndpointsDot'] = None,
                 ipv4: Optional['outputs.ZeroTrustDnsLocationEndpointsIpv4'] = None,
                 ipv6: Optional['outputs.ZeroTrustDnsLocationEndpointsIpv6'] = None):
        if doh is not None:
            pulumi.set(__self__, "doh", doh)
        if dot is not None:
            pulumi.set(__self__, "dot", dot)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def doh(self) -> Optional['outputs.ZeroTrustDnsLocationEndpointsDoh']:
        return pulumi.get(self, "doh")

    @property
    @pulumi.getter
    def dot(self) -> Optional['outputs.ZeroTrustDnsLocationEndpointsDot']:
        return pulumi.get(self, "dot")

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.ZeroTrustDnsLocationEndpointsIpv4']:
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.ZeroTrustDnsLocationEndpointsIpv6']:
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsDoh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationEnabled":
            suggest = "authentication_enabled"
        elif key == "requireToken":
            suggest = "require_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDnsLocationEndpointsDoh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDnsLocationEndpointsDoh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDnsLocationEndpointsDoh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 authentication_enabled: Optional[builtins.bool] = None,
                 networks: Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsDohNetwork']] = None,
                 require_token: Optional[builtins.bool] = None):
        pulumi.set(__self__, "enabled", enabled)
        if authentication_enabled is not None:
            pulumi.set(__self__, "authentication_enabled", authentication_enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if require_token is not None:
            pulumi.set(__self__, "require_token", require_token)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authenticationEnabled")
    def authentication_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "authentication_enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsDohNetwork']]:
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "require_token")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsDohNetwork(dict):
    def __init__(__self__, *,
                 network: builtins.str):
        """
        :param builtins.str network: CIDR notation representation of the network IP.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> builtins.str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsDot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationEnabled":
            suggest = "authentication_enabled"
        elif key == "requireToken":
            suggest = "require_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDnsLocationEndpointsDot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDnsLocationEndpointsDot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDnsLocationEndpointsDot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 authentication_enabled: Optional[builtins.bool] = None,
                 networks: Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsDotNetwork']] = None,
                 require_token: Optional[builtins.bool] = None):
        pulumi.set(__self__, "enabled", enabled)
        if authentication_enabled is not None:
            pulumi.set(__self__, "authentication_enabled", authentication_enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if require_token is not None:
            pulumi.set(__self__, "require_token", require_token)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authenticationEnabled")
    def authentication_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "authentication_enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsDotNetwork']]:
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "require_token")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsDotNetwork(dict):
    def __init__(__self__, *,
                 network: builtins.str):
        """
        :param builtins.str network: CIDR notation representation of the network IP.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> builtins.str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsIpv4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationEnabled":
            suggest = "authentication_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDnsLocationEndpointsIpv4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDnsLocationEndpointsIpv4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDnsLocationEndpointsIpv4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 authentication_enabled: Optional[builtins.bool] = None):
        pulumi.set(__self__, "enabled", enabled)
        if authentication_enabled is not None:
            pulumi.set(__self__, "authentication_enabled", authentication_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authenticationEnabled")
    def authentication_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "authentication_enabled")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationEnabled":
            suggest = "authentication_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustDnsLocationEndpointsIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustDnsLocationEndpointsIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustDnsLocationEndpointsIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 authentication_enabled: Optional[builtins.bool] = None,
                 networks: Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsIpv6Network']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if authentication_enabled is not None:
            pulumi.set(__self__, "authentication_enabled", authentication_enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authenticationEnabled")
    def authentication_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "authentication_enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.ZeroTrustDnsLocationEndpointsIpv6Network']]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class ZeroTrustDnsLocationEndpointsIpv6Network(dict):
    def __init__(__self__, *,
                 network: builtins.str):
        """
        :param builtins.str network: CIDR notation representation of the network IP.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> builtins.str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ZeroTrustDnsLocationNetwork(dict):
    def __init__(__self__, *,
                 network: builtins.str):
        """
        :param builtins.str network: CIDR notation representation of the network IP.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> builtins.str:
        """
        CIDR notation representation of the network IP.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addHeaders":
            suggest = "add_headers"
        elif key == "allowChildBypass":
            suggest = "allow_child_bypass"
        elif key == "auditSsh":
            suggest = "audit_ssh"
        elif key == "bisoAdminControls":
            suggest = "biso_admin_controls"
        elif key == "blockPageEnabled":
            suggest = "block_page_enabled"
        elif key == "blockPageReason":
            suggest = "block_page_reason"
        elif key == "bypassParentRule":
            suggest = "bypass_parent_rule"
        elif key == "checkSession":
            suggest = "check_session"
        elif key == "dnsResolvers":
            suggest = "dns_resolvers"
        elif key == "ignoreCnameCategoryMatches":
            suggest = "ignore_cname_category_matches"
        elif key == "insecureDisableDnssecValidation":
            suggest = "insecure_disable_dnssec_validation"
        elif key == "ipCategories":
            suggest = "ip_categories"
        elif key == "notificationSettings":
            suggest = "notification_settings"
        elif key == "overrideHost":
            suggest = "override_host"
        elif key == "overrideIps":
            suggest = "override_ips"
        elif key == "payloadLog":
            suggest = "payload_log"
        elif key == "resolveDnsInternally":
            suggest = "resolve_dns_internally"
        elif key == "resolveDnsThroughCloudflare":
            suggest = "resolve_dns_through_cloudflare"
        elif key == "untrustedCert":
            suggest = "untrusted_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_headers: Optional[Mapping[str, builtins.str]] = None,
                 allow_child_bypass: Optional[builtins.bool] = None,
                 audit_ssh: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsAuditSsh'] = None,
                 biso_admin_controls: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls'] = None,
                 block_page_enabled: Optional[builtins.bool] = None,
                 block_page_reason: Optional[builtins.str] = None,
                 bypass_parent_rule: Optional[builtins.bool] = None,
                 check_session: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsCheckSession'] = None,
                 dns_resolvers: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolvers'] = None,
                 egress: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsEgress'] = None,
                 ignore_cname_category_matches: Optional[builtins.bool] = None,
                 insecure_disable_dnssec_validation: Optional[builtins.bool] = None,
                 ip_categories: Optional[builtins.bool] = None,
                 l4override: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsL4override'] = None,
                 notification_settings: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettings'] = None,
                 override_host: Optional[builtins.str] = None,
                 override_ips: Optional[Sequence[builtins.str]] = None,
                 payload_log: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLog'] = None,
                 resolve_dns_internally: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally'] = None,
                 resolve_dns_through_cloudflare: Optional[builtins.bool] = None,
                 untrusted_cert: Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCert'] = None):
        """
        :param Mapping[str, builtins.str] add_headers: Add custom headers to allowed requests in the form of key-value pairs.
        :param builtins.bool allow_child_bypass: Allow parent MSP accounts to enable bypass their children's rules.
        :param 'ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs' audit_ssh: Settings for auditing SSH usage.
        :param 'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs' biso_admin_controls: Configure how browser isolation behaves.
        :param builtins.bool block_page_enabled: Indicator of block page enablement.
        :param builtins.str block_page_reason: The displayed reason for a user being blocked.
        :param builtins.bool bypass_parent_rule: Allow child MSP accounts to bypass their parent's rule.
        :param 'ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs' check_session: Configure how session check behaves.
        :param 'ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs' dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        :param 'ZeroTrustGatewayPolicyRuleSettingsEgressArgs' egress: Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        :param builtins.bool ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response.
        :param builtins.bool insecure_disable_dnssec_validation: Disable DNSSEC validation (must be Allow rule).
        :param builtins.bool ip_categories: Turns on IP category based filter on dns if the rule contains dns category checks.
        :param 'ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs' l4override: Settings to forward layer 4 traffic.
        :param 'ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs' notification_settings: Notification settings on a block rule.
        :param builtins.str override_host: The host to override matching DNS queries with.
        :param Sequence[builtins.str] override_ips: The IPs to override matching DNS queries with.
        :param 'ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs' payload_log: Configure DLP Payload Logging settings for this rule.
        :param 'ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs' resolve_dns_internally: Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        :param builtins.bool resolve_dns_through_cloudflare: Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        :param 'ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs' untrusted_cert: Configure untrusted certificate settings for this rule.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_page_reason is not None:
            pulumi.set(__self__, "block_page_reason", block_page_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if dns_resolvers is not None:
            pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ignore_cname_category_matches is not None:
            pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if resolve_dns_internally is not None:
            pulumi.set(__self__, "resolve_dns_internally", resolve_dns_internally)
        if resolve_dns_through_cloudflare is not None:
            pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Add custom headers to allowed requests in the form of key-value pairs.
        """
        return pulumi.get(self, "add_headers")

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[builtins.bool]:
        """
        Allow parent MSP accounts to enable bypass their children's rules.
        """
        return pulumi.get(self, "allow_child_bypass")

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsAuditSsh']:
        """
        Settings for auditing SSH usage.
        """
        return pulumi.get(self, "audit_ssh")

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls']:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[builtins.bool]:
        """
        Indicator of block page enablement.
        """
        return pulumi.get(self, "block_page_enabled")

    @property
    @pulumi.getter(name="blockPageReason")
    def block_page_reason(self) -> Optional[builtins.str]:
        """
        The displayed reason for a user being blocked.
        """
        return pulumi.get(self, "block_page_reason")

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[builtins.bool]:
        """
        Allow child MSP accounts to bypass their parent's rule.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsCheckSession']:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolvers']:
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
        """
        return pulumi.get(self, "dns_resolvers")

    @property
    @pulumi.getter
    def egress(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsEgress']:
        """
        Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
        """
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> Optional[builtins.bool]:
        """
        Set to true, to ignore the category matches at CNAME domains in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[builtins.bool]:
        """
        Disable DNSSEC validation (must be Allow rule).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[builtins.bool]:
        """
        Turns on IP category based filter on dns if the rule contains dns category checks.
        """
        return pulumi.get(self, "ip_categories")

    @property
    @pulumi.getter
    def l4override(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsL4override']:
        """
        Settings to forward layer 4 traffic.
        """
        return pulumi.get(self, "l4override")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettings']:
        """
        Notification settings on a block rule.
        """
        return pulumi.get(self, "notification_settings")

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[builtins.str]:
        """
        The host to override matching DNS queries with.
        """
        return pulumi.get(self, "override_host")

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[Sequence[builtins.str]]:
        """
        The IPs to override matching DNS queries with.
        """
        return pulumi.get(self, "override_ips")

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLog']:
        """
        Configure DLP Payload Logging settings for this rule.
        """
        return pulumi.get(self, "payload_log")

    @property
    @pulumi.getter(name="resolveDnsInternally")
    def resolve_dns_internally(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally']:
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_internally")

    @property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> Optional[builtins.bool]:
        """
        Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional['outputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCert']:
        """
        Configure untrusted certificate settings for this rule.
        """
        return pulumi.get(self, "untrusted_cert")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsAuditSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandLogging":
            suggest = "command_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsAuditSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsAuditSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsAuditSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_logging: builtins.bool):
        """
        :param builtins.bool command_logging: Log all SSH commands.
        """
        pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> builtins.bool:
        """
        Log all SSH commands.
        """
        return pulumi.get(self, "command_logging")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableClipboardRedirection":
            suggest = "disable_clipboard_redirection"
        elif key == "disableCopyPaste":
            suggest = "disable_copy_paste"
        elif key == "disableDownload":
            suggest = "disable_download"
        elif key == "disableKeyboard":
            suggest = "disable_keyboard"
        elif key == "disablePrinting":
            suggest = "disable_printing"
        elif key == "disableUpload":
            suggest = "disable_upload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_clipboard_redirection: Optional[builtins.bool] = None,
                 disable_copy_paste: Optional[builtins.bool] = None,
                 disable_download: Optional[builtins.bool] = None,
                 disable_keyboard: Optional[builtins.bool] = None,
                 disable_printing: Optional[builtins.bool] = None,
                 disable_upload: Optional[builtins.bool] = None):
        """
        :param builtins.bool disable_clipboard_redirection: Disable clipboard redirection.
        :param builtins.bool disable_copy_paste: Disable copy-paste.
        :param builtins.bool disable_download: Disable download.
        :param builtins.bool disable_keyboard: Disable keyboard usage.
        :param builtins.bool disable_printing: Disable printing.
        :param builtins.bool disable_upload: Disable upload.
        """
        if disable_clipboard_redirection is not None:
            pulumi.set(__self__, "disable_clipboard_redirection", disable_clipboard_redirection)
        if disable_copy_paste is not None:
            pulumi.set(__self__, "disable_copy_paste", disable_copy_paste)
        if disable_download is not None:
            pulumi.set(__self__, "disable_download", disable_download)
        if disable_keyboard is not None:
            pulumi.set(__self__, "disable_keyboard", disable_keyboard)
        if disable_printing is not None:
            pulumi.set(__self__, "disable_printing", disable_printing)
        if disable_upload is not None:
            pulumi.set(__self__, "disable_upload", disable_upload)

    @property
    @pulumi.getter(name="disableClipboardRedirection")
    def disable_clipboard_redirection(self) -> Optional[builtins.bool]:
        """
        Disable clipboard redirection.
        """
        return pulumi.get(self, "disable_clipboard_redirection")

    @property
    @pulumi.getter(name="disableCopyPaste")
    def disable_copy_paste(self) -> Optional[builtins.bool]:
        """
        Disable copy-paste.
        """
        return pulumi.get(self, "disable_copy_paste")

    @property
    @pulumi.getter(name="disableDownload")
    def disable_download(self) -> Optional[builtins.bool]:
        """
        Disable download.
        """
        return pulumi.get(self, "disable_download")

    @property
    @pulumi.getter(name="disableKeyboard")
    def disable_keyboard(self) -> Optional[builtins.bool]:
        """
        Disable keyboard usage.
        """
        return pulumi.get(self, "disable_keyboard")

    @property
    @pulumi.getter(name="disablePrinting")
    def disable_printing(self) -> Optional[builtins.bool]:
        """
        Disable printing.
        """
        return pulumi.get(self, "disable_printing")

    @property
    @pulumi.getter(name="disableUpload")
    def disable_upload(self) -> Optional[builtins.bool]:
        """
        Disable upload.
        """
        return pulumi.get(self, "disable_upload")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsCheckSession(dict):
    def __init__(__self__, *,
                 duration: builtins.str,
                 enforce: builtins.bool):
        """
        :param builtins.str duration: Configure how fresh the session needs to be to be considered valid.
        :param builtins.bool enforce: Enable session enforcement for this rule.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> builtins.str:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enforce(self) -> builtins.bool:
        """
        Enable session enforcement for this rule.
        """
        return pulumi.get(self, "enforce")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolvers(dict):
    def __init__(__self__, *,
                 ipv4s: Optional[Sequence['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4']] = None,
                 ipv6s: Optional[Sequence['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6']] = None):
        """
        :param Sequence['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args'] ipv4s: IPv4 resolvers.
        :param Sequence['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args'] ipv6s: IPv6 resolvers.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[Sequence['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4']]:
        """
        IPv4 resolvers.
        """
        return pulumi.get(self, "ipv4s")

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[Sequence['outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6']]:
        """
        IPv6 resolvers.
        """
        return pulumi.get(self, "ipv6s")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeThroughPrivateNetwork":
            suggest = "route_through_private_network"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: builtins.str,
                 port: Optional[builtins.int] = None,
                 route_through_private_network: Optional[builtins.bool] = None,
                 vnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str ip: The IPv4 or IPv6 address of the upstream resolver.
        :param builtins.int port: A port number to use for the upstream resolver. Defaults to `53`.
        :param builtins.bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        :param builtins.str vnet_id: specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[builtins.bool]:
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[builtins.str]:
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeThroughPrivateNetwork":
            suggest = "route_through_private_network"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: builtins.str,
                 port: Optional[builtins.int] = None,
                 route_through_private_network: Optional[builtins.bool] = None,
                 vnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str ip: The IPv4 or IPv6 address of the upstream resolver.
        :param builtins.int port: A port number to use for the upstream resolver. Defaults to `53`.
        :param builtins.bool route_through_private_network: Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        :param builtins.str vnet_id: specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        The IPv4 or IPv6 address of the upstream resolver.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        A port number to use for the upstream resolver. Defaults to `53`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[builtins.bool]:
        """
        Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[builtins.str]:
        """
        specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Fallback":
            suggest = "ipv4_fallback"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4: builtins.str,
                 ipv6: builtins.str,
                 ipv4_fallback: Optional[builtins.str] = None):
        """
        :param builtins.str ipv4: The IPv4 address to be used for egress.
        :param builtins.str ipv6: The IPv6 range to be used for egress.
        :param builtins.str ipv4_fallback: The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)

    @property
    @pulumi.getter
    def ipv4(self) -> builtins.str:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> builtins.str:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[builtins.str]:
        """
        The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
        """
        return pulumi.get(self, "ipv4_fallback")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsL4override(dict):
    def __init__(__self__, *,
                 ip: builtins.str,
                 port: builtins.int):
        """
        :param builtins.str ip: Override IP to forward traffic to.
        :param builtins.int port: Override Port to forward traffic to.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        Override IP to forward traffic to.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        Override Port to forward traffic to.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportUrl":
            suggest = "support_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 message: Optional[builtins.str] = None,
                 support_url: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Enable notification settings.
        :param builtins.str message: Notification content.
        :param builtins.str support_url: Support URL to show in the notification.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Enable notification settings.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Notification content.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[builtins.str]:
        """
        Support URL to show in the notification.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsPayloadLog(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Enable or disable DLP Payload Logging for this rule.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Enable or disable DLP Payload Logging for this rule.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewId":
            suggest = "view_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback: Optional[builtins.str] = None,
                 view_id: Optional[builtins.str] = None):
        """
        :param builtins.str fallback: The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        :param builtins.str view_id: The internal DNS view identifier that's passed to the internal DNS service.
        """
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if view_id is not None:
            pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter
    def fallback(self) -> Optional[builtins.str]:
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        """
        return pulumi.get(self, "fallback")

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> Optional[builtins.str]:
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
        return pulumi.get(self, "view_id")


@pulumi.output_type
class ZeroTrustGatewayPolicyRuleSettingsUntrustedCert(dict):
    def __init__(__self__, *,
                 action: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class ZeroTrustGatewaySettingsAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledDownloadPhase":
            suggest = "enabled_download_phase"
        elif key == "enabledUploadPhase":
            suggest = "enabled_upload_phase"
        elif key == "failClosed":
            suggest = "fail_closed"
        elif key == "notificationSettings":
            suggest = "notification_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_download_phase: builtins.bool,
                 enabled_upload_phase: builtins.bool,
                 fail_closed: builtins.bool,
                 notification_settings: Optional['outputs.ZeroTrustGatewaySettingsAntivirusNotificationSettings'] = None):
        """
        :param builtins.bool enabled_download_phase: Scan on file download.
        :param builtins.bool enabled_upload_phase: Scan on file upload.
        :param builtins.bool fail_closed: Block requests for files that cannot be scanned.
        :param 'ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs' notification_settings: Set notifications for antivirus.
        """
        pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        pulumi.set(__self__, "fail_closed", fail_closed)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> builtins.bool:
        """
        Scan on file download.
        """
        return pulumi.get(self, "enabled_download_phase")

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> builtins.bool:
        """
        Scan on file upload.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> builtins.bool:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.ZeroTrustGatewaySettingsAntivirusNotificationSettings']:
        """
        Set notifications for antivirus.
        """
        return pulumi.get(self, "notification_settings")


@pulumi.output_type
class ZeroTrustGatewaySettingsAntivirusNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportUrl":
            suggest = "support_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsAntivirusNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsAntivirusNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsAntivirusNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 message: Optional[builtins.str] = None,
                 support_url: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Enable notification settings.
        :param builtins.str message: Notification content.
        :param builtins.str support_url: Support URL to show in the notification.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Enable notification settings.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Notification content.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[builtins.str]:
        """
        Support URL to show in the notification.
        """
        return pulumi.get(self, "support_url")


@pulumi.output_type
class ZeroTrustGatewaySettingsBlockPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "footerText":
            suggest = "footer_text"
        elif key == "headerText":
            suggest = "header_text"
        elif key == "logoPath":
            suggest = "logo_path"
        elif key == "mailtoAddress":
            suggest = "mailto_address"
        elif key == "mailtoSubject":
            suggest = "mailto_subject"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsBlockPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsBlockPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsBlockPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 footer_text: Optional[builtins.str] = None,
                 header_text: Optional[builtins.str] = None,
                 logo_path: Optional[builtins.str] = None,
                 mailto_address: Optional[builtins.str] = None,
                 mailto_subject: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str background_color: Hex code of block page background color.
        :param builtins.bool enabled: Indicator of enablement.
        :param builtins.str footer_text: Block page footer text.
        :param builtins.str header_text: Block page header text.
        :param builtins.str logo_path: URL of block page logo.
        :param builtins.str mailto_address: Admin email for users to contact.
        :param builtins.str mailto_subject: Subject line for emails created from block page.
        :param builtins.str name: Name of block page configuration.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[builtins.str]:
        """
        Hex code of block page background color.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Indicator of enablement.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[builtins.str]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[builtins.str]:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[builtins.str]:
        """
        URL of block page logo.
        """
        return pulumi.get(self, "logo_path")

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[builtins.str]:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[builtins.str]:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of block page configuration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ZeroTrustGatewaySettingsBodyScanning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectionMode":
            suggest = "inspection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsBodyScanning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsBodyScanning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsBodyScanning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspection_mode: builtins.str):
        """
        :param builtins.str inspection_mode: Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
        pulumi.set(__self__, "inspection_mode", inspection_mode)

    @property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> builtins.str:
        """
        Body scanning inspection mode. Available values: `deep`, `shallow`.
        """
        return pulumi.get(self, "inspection_mode")


@pulumi.output_type
class ZeroTrustGatewaySettingsCertificate(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: ID of certificate for TLS interception.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of certificate for TLS interception.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ZeroTrustGatewaySettingsCustomCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsCustomCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsCustomCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsCustomCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 id: Optional[builtins.str] = None,
                 updated_at: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Whether TLS encryption should use a custom certificate.
        :param builtins.str id: ID of custom certificate.
        """
        pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether TLS encryption should use a custom certificate.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of custom certificate.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[builtins.str]:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ZeroTrustGatewaySettingsExtendedEmailMatching(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZeroTrustGatewaySettingsFips(dict):
    def __init__(__self__, *,
                 tls: Optional[builtins.bool] = None):
        """
        :param builtins.bool tls: Only allow FIPS-compliant TLS configuration.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[builtins.bool]:
        """
        Only allow FIPS-compliant TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class ZeroTrustGatewaySettingsLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redactPii":
            suggest = "redact_pii"
        elif key == "settingsByRuleType":
            suggest = "settings_by_rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redact_pii: builtins.bool,
                 settings_by_rule_type: 'outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleType'):
        """
        :param builtins.bool redact_pii: Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        :param 'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs' settings_by_rule_type: Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        pulumi.set(__self__, "redact_pii", redact_pii)
        pulumi.set(__self__, "settings_by_rule_type", settings_by_rule_type)

    @property
    @pulumi.getter(name="redactPii")
    def redact_pii(self) -> builtins.bool:
        """
        Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
        """
        return pulumi.get(self, "redact_pii")

    @property
    @pulumi.getter(name="settingsByRuleType")
    def settings_by_rule_type(self) -> 'outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleType':
        """
        Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
        """
        return pulumi.get(self, "settings_by_rule_type")


@pulumi.output_type
class ZeroTrustGatewaySettingsLoggingSettingsByRuleType(dict):
    def __init__(__self__, *,
                 dns: 'outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns',
                 http: 'outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp',
                 l4: 'outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4'):
        """
        :param 'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs' dns: Logging configuration for DNS requests.
        :param 'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs' http: Logging configuration for HTTP requests.
        :param 'ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args' l4: Logging configuration for layer 4 requests.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "http", http)
        pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns':
        """
        Logging configuration for DNS requests.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def http(self) -> 'outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp':
        """
        Logging configuration for HTTP requests.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def l4(self) -> 'outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4':
        """
        Logging configuration for layer 4 requests.
        """
        return pulumi.get(self, "l4")


@pulumi.output_type
class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: builtins.bool,
                 log_blocks: builtins.bool):
        """
        :param builtins.bool log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> builtins.bool:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> builtins.bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: builtins.bool,
                 log_blocks: builtins.bool):
        """
        :param builtins.bool log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> builtins.bool:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> builtins.bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAll":
            suggest = "log_all"
        elif key == "logBlocks":
            suggest = "log_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_all: builtins.bool,
                 log_blocks: builtins.bool):
        """
        :param builtins.bool log_all: Whether to log all activity.
        """
        pulumi.set(__self__, "log_all", log_all)
        pulumi.set(__self__, "log_blocks", log_blocks)

    @property
    @pulumi.getter(name="logAll")
    def log_all(self) -> builtins.bool:
        """
        Whether to log all activity.
        """
        return pulumi.get(self, "log_all")

    @property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> builtins.bool:
        return pulumi.get(self, "log_blocks")


@pulumi.output_type
class ZeroTrustGatewaySettingsPayloadLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsPayloadLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsPayloadLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsPayloadLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: builtins.str):
        """
        :param builtins.str public_key: Public key used to encrypt matched payloads.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> builtins.str:
        """
        Public key used to encrypt matched payloads.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class ZeroTrustGatewaySettingsProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableForTime":
            suggest = "disable_for_time"
        elif key == "rootCa":
            suggest = "root_ca"
        elif key == "virtualIp":
            suggest = "virtual_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_for_time: builtins.int,
                 root_ca: builtins.bool,
                 tcp: builtins.bool,
                 udp: builtins.bool,
                 virtual_ip: builtins.bool):
        """
        :param builtins.int disable_for_time: Sets the time limit in seconds that a user can use an override code to bypass WARP.
        :param builtins.bool root_ca: Whether root ca is enabled account wide for ZT clients.
        :param builtins.bool tcp: Whether gateway proxy is enabled on gateway devices for TCP traffic.
        :param builtins.bool udp: Whether gateway proxy is enabled on gateway devices for UDP traffic.
        :param builtins.bool virtual_ip: Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
        pulumi.set(__self__, "disable_for_time", disable_for_time)
        pulumi.set(__self__, "root_ca", root_ca)
        pulumi.set(__self__, "tcp", tcp)
        pulumi.set(__self__, "udp", udp)
        pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="disableForTime")
    def disable_for_time(self) -> builtins.int:
        """
        Sets the time limit in seconds that a user can use an override code to bypass WARP.
        """
        return pulumi.get(self, "disable_for_time")

    @property
    @pulumi.getter(name="rootCa")
    def root_ca(self) -> builtins.bool:
        """
        Whether root ca is enabled account wide for ZT clients.
        """
        return pulumi.get(self, "root_ca")

    @property
    @pulumi.getter
    def tcp(self) -> builtins.bool:
        """
        Whether gateway proxy is enabled on gateway devices for TCP traffic.
        """
        return pulumi.get(self, "tcp")

    @property
    @pulumi.getter
    def udp(self) -> builtins.bool:
        """
        Whether gateway proxy is enabled on gateway devices for UDP traffic.
        """
        return pulumi.get(self, "udp")

    @property
    @pulumi.getter(name="virtualIp")
    def virtual_ip(self) -> builtins.bool:
        """
        Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
        """
        return pulumi.get(self, "virtual_ip")


@pulumi.output_type
class ZeroTrustGatewaySettingsSshSessionLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustGatewaySettingsSshSessionLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustGatewaySettingsSshSessionLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustGatewaySettingsSshSessionLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: builtins.str):
        """
        :param builtins.str public_key: Public key used to encrypt ssh session.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> builtins.str:
        """
        Public key used to encrypt ssh session.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class ZeroTrustInfrastructureAccessTargetIp(dict):
    def __init__(__self__, *,
                 ipv4: Optional['outputs.ZeroTrustInfrastructureAccessTargetIpIpv4'] = None,
                 ipv6: Optional['outputs.ZeroTrustInfrastructureAccessTargetIpIpv6'] = None):
        """
        :param 'ZeroTrustInfrastructureAccessTargetIpIpv4Args' ipv4: The target's IPv4 address.
        :param 'ZeroTrustInfrastructureAccessTargetIpIpv6Args' ipv6: The target's IPv6 address.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.ZeroTrustInfrastructureAccessTargetIpIpv4']:
        """
        The target's IPv4 address.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.ZeroTrustInfrastructureAccessTargetIpIpv6']:
        """
        The target's IPv6 address.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class ZeroTrustInfrastructureAccessTargetIpIpv4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddr":
            suggest = "ip_addr"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustInfrastructureAccessTargetIpIpv4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustInfrastructureAccessTargetIpIpv4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustInfrastructureAccessTargetIpIpv4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addr: builtins.str,
                 virtual_network_id: builtins.str):
        """
        :param builtins.str ip_addr: The IP address of the target.
        :param builtins.str virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> builtins.str:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class ZeroTrustInfrastructureAccessTargetIpIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddr":
            suggest = "ip_addr"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustInfrastructureAccessTargetIpIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustInfrastructureAccessTargetIpIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustInfrastructureAccessTargetIpIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addr: builtins.str,
                 virtual_network_id: builtins.str):
        """
        :param builtins.str ip_addr: The IP address of the target.
        :param builtins.str virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> builtins.str:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class ZeroTrustListItemsWithDescription(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 value: builtins.str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ZeroTrustLocalFallbackDomainDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustLocalFallbackDomainDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustLocalFallbackDomainDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustLocalFallbackDomainDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[builtins.str] = None,
                 dns_servers: Optional[Sequence[builtins.str]] = None,
                 suffix: Optional[builtins.str] = None):
        """
        :param builtins.str description: A description of the fallback domain, displayed in the client UI.
        :param Sequence[builtins.str] dns_servers: A list of IP addresses to handle domain resolution.
        :param builtins.str suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[builtins.str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ZeroTrustRiskBehaviorBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "riskLevel":
            suggest = "risk_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustRiskBehaviorBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustRiskBehaviorBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustRiskBehaviorBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 name: builtins.str,
                 risk_level: builtins.str):
        """
        :param builtins.bool enabled: Whether this risk behavior type is enabled.
        :param builtins.str name: Name of this risk behavior type
        :param builtins.str risk_level: Risk level. Available values: `low`, `medium`, `high`
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether this risk behavior type is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of this risk behavior type
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> builtins.str:
        """
        Risk level. Available values: `low`, `medium`, `high`
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class ZeroTrustSplitTunnelTunnel(dict):
    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 host: Optional[builtins.str] = None):
        """
        :param builtins.str address: The address for the tunnel.
        :param builtins.str description: A description for the tunnel.
        :param builtins.str host: The domain name for the tunnel.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        The address for the tunnel.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A description for the tunnel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> Optional[builtins.str]:
        """
        The domain name for the tunnel.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingressRules":
            suggest = "ingress_rules"
        elif key == "originRequest":
            suggest = "origin_request"
        elif key == "warpRouting":
            suggest = "warp_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingress_rules: Sequence['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRule'],
                 origin_request: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequest'] = None,
                 warp_routing: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRouting'] = None):
        """
        :param Sequence['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs'] ingress_rules: Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        :param 'ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs' warp_routing: If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        pulumi.set(__self__, "ingress_rules", ingress_rules)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @property
    @pulumi.getter(name="ingressRules")
    def ingress_rules(self) -> Sequence['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRule']:
        """
        Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
        """
        return pulumi.get(self, "ingress_rules")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequest']:
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRouting']:
        """
        If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
        """
        return pulumi.get(self, "warp_routing")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originRequest":
            suggest = "origin_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigIngressRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: builtins.str,
                 hostname: Optional[builtins.str] = None,
                 origin_request: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest'] = None,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str service: Name of the service to which the request will be sent.
        :param builtins.str hostname: Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        :param builtins.str path: Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def service(self) -> builtins.str:
        """
        Name of the service to which the request will be sent.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[builtins.str]:
        """
        Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest']:
        return pulumi.get(self, "origin_request")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Path of the incoming request. If the path matches, the request will be sent to the local service.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bastionMode":
            suggest = "bastion_mode"
        elif key == "caPool":
            suggest = "ca_pool"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "disableChunkedEncoding":
            suggest = "disable_chunked_encoding"
        elif key == "http2Origin":
            suggest = "http2_origin"
        elif key == "httpHostHeader":
            suggest = "http_host_header"
        elif key == "ipRules":
            suggest = "ip_rules"
        elif key == "keepAliveConnections":
            suggest = "keep_alive_connections"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "noHappyEyeballs":
            suggest = "no_happy_eyeballs"
        elif key == "noTlsVerify":
            suggest = "no_tls_verify"
        elif key == "originServerName":
            suggest = "origin_server_name"
        elif key == "proxyAddress":
            suggest = "proxy_address"
        elif key == "proxyPort":
            suggest = "proxy_port"
        elif key == "proxyType":
            suggest = "proxy_type"
        elif key == "tcpKeepAlive":
            suggest = "tcp_keep_alive"
        elif key == "tlsTimeout":
            suggest = "tls_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess'] = None,
                 bastion_mode: Optional[builtins.bool] = None,
                 ca_pool: Optional[builtins.str] = None,
                 connect_timeout: Optional[builtins.str] = None,
                 disable_chunked_encoding: Optional[builtins.bool] = None,
                 http2_origin: Optional[builtins.bool] = None,
                 http_host_header: Optional[builtins.str] = None,
                 ip_rules: Optional[Sequence['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule']] = None,
                 keep_alive_connections: Optional[builtins.int] = None,
                 keep_alive_timeout: Optional[builtins.str] = None,
                 no_happy_eyeballs: Optional[builtins.bool] = None,
                 no_tls_verify: Optional[builtins.bool] = None,
                 origin_server_name: Optional[builtins.str] = None,
                 proxy_address: Optional[builtins.str] = None,
                 proxy_port: Optional[builtins.int] = None,
                 proxy_type: Optional[builtins.str] = None,
                 tcp_keep_alive: Optional[builtins.str] = None,
                 tls_timeout: Optional[builtins.str] = None):
        """
        :param 'ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs' access: Access rules for the ingress service.
        :param builtins.bool bastion_mode: Runs as jump host.
        :param builtins.str ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param builtins.str connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param builtins.bool disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param builtins.bool http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param builtins.str http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param Sequence['ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRuleArgs'] ip_rules: IP rules for the proxy service.
        :param builtins.int keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param builtins.str keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param builtins.bool no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param builtins.bool no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param builtins.str origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param builtins.str proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param builtins.int proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param builtins.str proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param builtins.str tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param builtins.str tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess']:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[builtins.bool]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[builtins.str]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[builtins.str]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[builtins.bool]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[builtins.bool]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[builtins.str]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule']]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[builtins.int]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[builtins.str]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[builtins.bool]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[builtins.bool]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[builtins.str]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[builtins.str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[builtins.int]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[builtins.str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[builtins.str]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[builtins.str]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audTags":
            suggest = "aud_tags"
        elif key == "teamName":
            suggest = "team_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aud_tags: Optional[Sequence[builtins.str]] = None,
                 required: Optional[builtins.bool] = None,
                 team_name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] aud_tags: Audience tags of the access rule.
        :param builtins.bool required: Whether the access rule is required.
        :param builtins.str team_name: Name of the team to which the access rule applies.
        """
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[builtins.str]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule(dict):
    def __init__(__self__, *,
                 allow: Optional[builtins.bool] = None,
                 ports: Optional[Sequence[builtins.int]] = None,
                 prefix: Optional[builtins.str] = None):
        """
        :param builtins.bool allow: Whether to allow the IP prefix.
        :param Sequence[builtins.int] ports: Ports to use within the IP rule.
        :param builtins.str prefix: IP rule prefix.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[builtins.bool]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.int]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[builtins.str]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bastionMode":
            suggest = "bastion_mode"
        elif key == "caPool":
            suggest = "ca_pool"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "disableChunkedEncoding":
            suggest = "disable_chunked_encoding"
        elif key == "http2Origin":
            suggest = "http2_origin"
        elif key == "httpHostHeader":
            suggest = "http_host_header"
        elif key == "ipRules":
            suggest = "ip_rules"
        elif key == "keepAliveConnections":
            suggest = "keep_alive_connections"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "noHappyEyeballs":
            suggest = "no_happy_eyeballs"
        elif key == "noTlsVerify":
            suggest = "no_tls_verify"
        elif key == "originServerName":
            suggest = "origin_server_name"
        elif key == "proxyAddress":
            suggest = "proxy_address"
        elif key == "proxyPort":
            suggest = "proxy_port"
        elif key == "proxyType":
            suggest = "proxy_type"
        elif key == "tcpKeepAlive":
            suggest = "tcp_keep_alive"
        elif key == "tlsTimeout":
            suggest = "tls_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigOriginRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigOriginRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigOriginRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess'] = None,
                 bastion_mode: Optional[builtins.bool] = None,
                 ca_pool: Optional[builtins.str] = None,
                 connect_timeout: Optional[builtins.str] = None,
                 disable_chunked_encoding: Optional[builtins.bool] = None,
                 http2_origin: Optional[builtins.bool] = None,
                 http_host_header: Optional[builtins.str] = None,
                 ip_rules: Optional[Sequence['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule']] = None,
                 keep_alive_connections: Optional[builtins.int] = None,
                 keep_alive_timeout: Optional[builtins.str] = None,
                 no_happy_eyeballs: Optional[builtins.bool] = None,
                 no_tls_verify: Optional[builtins.bool] = None,
                 origin_server_name: Optional[builtins.str] = None,
                 proxy_address: Optional[builtins.str] = None,
                 proxy_port: Optional[builtins.int] = None,
                 proxy_type: Optional[builtins.str] = None,
                 tcp_keep_alive: Optional[builtins.str] = None,
                 tls_timeout: Optional[builtins.str] = None):
        """
        :param 'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs' access: Access rules for the ingress service.
        :param builtins.bool bastion_mode: Runs as jump host.
        :param builtins.str ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        :param builtins.str connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        :param builtins.bool disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        :param builtins.bool http2_origin: Enables HTTP/2 support for the origin connection. Defaults to `false`.
        :param builtins.str http_host_header: Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        :param Sequence['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs'] ip_rules: IP rules for the proxy service.
        :param builtins.int keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        :param builtins.str keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        :param builtins.bool no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        :param builtins.bool no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        :param builtins.str origin_server_name: Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        :param builtins.str proxy_address: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        :param builtins.int proxy_port: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        :param builtins.str proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        :param builtins.str tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        :param builtins.str tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if bastion_mode is not None:
            pulumi.set(__self__, "bastion_mode", bastion_mode)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_address is not None:
            pulumi.set(__self__, "proxy_address", proxy_address)
        if proxy_port is not None:
            pulumi.set(__self__, "proxy_port", proxy_port)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess']:
        """
        Access rules for the ingress service.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="bastionMode")
    def bastion_mode(self) -> Optional[builtins.bool]:
        """
        Runs as jump host.
        """
        return pulumi.get(self, "bastion_mode")

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[builtins.str]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
        """
        return pulumi.get(self, "ca_pool")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[builtins.str]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[builtins.bool]:
        """
        Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[builtins.bool]:
        """
        Enables HTTP/2 support for the origin connection. Defaults to `false`.
        """
        return pulumi.get(self, "http2_origin")

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[builtins.str]:
        """
        Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
        """
        return pulumi.get(self, "http_host_header")

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule']]:
        """
        IP rules for the proxy service.
        """
        return pulumi.get(self, "ip_rules")

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[builtins.int]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
        """
        return pulumi.get(self, "keep_alive_connections")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[builtins.str]:
        """
        Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[builtins.bool]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[builtins.bool]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
        """
        return pulumi.get(self, "no_tls_verify")

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[builtins.str]:
        """
        Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
        """
        return pulumi.get(self, "origin_server_name")

    @property
    @pulumi.getter(name="proxyAddress")
    def proxy_address(self) -> Optional[builtins.str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
        """
        return pulumi.get(self, "proxy_address")

    @property
    @pulumi.getter(name="proxyPort")
    def proxy_port(self) -> Optional[builtins.int]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
        """
        return pulumi.get(self, "proxy_port")

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[builtins.str]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
        """
        return pulumi.get(self, "proxy_type")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[builtins.str]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[builtins.str]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
        """
        return pulumi.get(self, "tls_timeout")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audTags":
            suggest = "aud_tags"
        elif key == "teamName":
            suggest = "team_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aud_tags: Optional[Sequence[builtins.str]] = None,
                 required: Optional[builtins.bool] = None,
                 team_name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] aud_tags: Audience tags of the access rule.
        :param builtins.bool required: Whether the access rule is required.
        :param builtins.str team_name: Name of the team to which the access rule applies.
        """
        if aud_tags is not None:
            pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        Audience tags of the access rule.
        """
        return pulumi.get(self, "aud_tags")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        Whether the access rule is required.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[builtins.str]:
        """
        Name of the team to which the access rule applies.
        """
        return pulumi.get(self, "team_name")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule(dict):
    def __init__(__self__, *,
                 allow: Optional[builtins.bool] = None,
                 ports: Optional[Sequence[builtins.int]] = None,
                 prefix: Optional[builtins.str] = None):
        """
        :param builtins.bool allow: Whether to allow the IP prefix.
        :param Sequence[builtins.int] ports: Ports to use within the IP rule.
        :param builtins.str prefix: IP rule prefix.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def allow(self) -> Optional[builtins.bool]:
        """
        Whether to allow the IP prefix.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.int]]:
        """
        Ports to use within the IP rule.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[builtins.str]:
        """
        IP rule prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ZeroTrustTunnelCloudflaredConfigConfigWarpRouting(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: Whether WARP routing is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether WARP routing is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZoneLockdownConfiguration(dict):
    def __init__(__self__, *,
                 target: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str target: The request property to target. Available values: `ip`, `ip_range`.
        :param builtins.str value: The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The request property to target. Available values: `ip`, `ip_range`.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ZoneSettingsOverrideInitialSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOnline":
            suggest = "always_online"
        elif key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "binaryAst":
            suggest = "binary_ast"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "challengeTtl":
            suggest = "challenge_ttl"
        elif key == "cnameFlattening":
            suggest = "cname_flattening"
        elif key == "developmentMode":
            suggest = "development_mode"
        elif key == "earlyHints":
            suggest = "early_hints"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "filterLogsToCloudflare":
            suggest = "filter_logs_to_cloudflare"
        elif key == "h2Prioritization":
            suggest = "h2_prioritization"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "imageResizing":
            suggest = "image_resizing"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "logToCloudflare":
            suggest = "log_to_cloudflare"
        elif key == "maxUpload":
            suggest = "max_upload"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "mobileRedirect":
            suggest = "mobile_redirect"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "opportunisticOnion":
            suggest = "opportunistic_onion"
        elif key == "orangeToOrange":
            suggest = "orange_to_orange"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "originMaxHttpVersion":
            suggest = "origin_max_http_version"
        elif key == "prefetchPreload":
            suggest = "prefetch_preload"
        elif key == "privacyPass":
            suggest = "privacy_pass"
        elif key == "proxyReadTimeout":
            suggest = "proxy_read_timeout"
        elif key == "pseudoIpv4":
            suggest = "pseudo_ipv4"
        elif key == "replaceInsecureJs":
            suggest = "replace_insecure_js"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityHeader":
            suggest = "security_header"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "speedBrain":
            suggest = "speed_brain"
        elif key == "sslAutomaticMode":
            suggest = "ssl_automatic_mode"
        elif key == "tls12Only":
            suggest = "tls12_only"
        elif key == "tlsClientAuth":
            suggest = "tls_client_auth"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"
        elif key == "universalSsl":
            suggest = "universal_ssl"
        elif key == "visitorIp":
            suggest = "visitor_ip"
        elif key == "zeroRtt":
            suggest = "zero_rtt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aegis: Optional['outputs.ZoneSettingsOverrideInitialSettingAegis'] = None,
                 always_online: Optional[builtins.str] = None,
                 always_use_https: Optional[builtins.str] = None,
                 automatic_https_rewrites: Optional[builtins.str] = None,
                 binary_ast: Optional[builtins.str] = None,
                 brotli: Optional[builtins.str] = None,
                 browser_cache_ttl: Optional[builtins.int] = None,
                 browser_check: Optional[builtins.str] = None,
                 cache_level: Optional[builtins.str] = None,
                 challenge_ttl: Optional[builtins.int] = None,
                 ciphers: Optional[Sequence[builtins.str]] = None,
                 cname_flattening: Optional[builtins.str] = None,
                 development_mode: Optional[builtins.str] = None,
                 early_hints: Optional[builtins.str] = None,
                 email_obfuscation: Optional[builtins.str] = None,
                 filter_logs_to_cloudflare: Optional[builtins.str] = None,
                 fonts: Optional[builtins.str] = None,
                 h2_prioritization: Optional[builtins.str] = None,
                 hotlink_protection: Optional[builtins.str] = None,
                 http2: Optional[builtins.str] = None,
                 http3: Optional[builtins.str] = None,
                 image_resizing: Optional[builtins.str] = None,
                 ip_geolocation: Optional[builtins.str] = None,
                 ipv6: Optional[builtins.str] = None,
                 log_to_cloudflare: Optional[builtins.str] = None,
                 max_upload: Optional[builtins.int] = None,
                 min_tls_version: Optional[builtins.str] = None,
                 minify: Optional['outputs.ZoneSettingsOverrideInitialSettingMinify'] = None,
                 mirage: Optional[builtins.str] = None,
                 mobile_redirect: Optional['outputs.ZoneSettingsOverrideInitialSettingMobileRedirect'] = None,
                 nel: Optional['outputs.ZoneSettingsOverrideInitialSettingNel'] = None,
                 opportunistic_encryption: Optional[builtins.str] = None,
                 opportunistic_onion: Optional[builtins.str] = None,
                 orange_to_orange: Optional[builtins.str] = None,
                 origin_error_page_pass_thru: Optional[builtins.str] = None,
                 origin_max_http_version: Optional[builtins.str] = None,
                 polish: Optional[builtins.str] = None,
                 prefetch_preload: Optional[builtins.str] = None,
                 privacy_pass: Optional[builtins.str] = None,
                 proxy_read_timeout: Optional[builtins.str] = None,
                 pseudo_ipv4: Optional[builtins.str] = None,
                 replace_insecure_js: Optional[builtins.str] = None,
                 response_buffering: Optional[builtins.str] = None,
                 rocket_loader: Optional[builtins.str] = None,
                 security_header: Optional['outputs.ZoneSettingsOverrideInitialSettingSecurityHeader'] = None,
                 security_level: Optional[builtins.str] = None,
                 server_side_exclude: Optional[builtins.str] = None,
                 sort_query_string_for_cache: Optional[builtins.str] = None,
                 speed_brain: Optional[builtins.str] = None,
                 ssl: Optional[builtins.str] = None,
                 ssl_automatic_mode: Optional[builtins.str] = None,
                 tls12_only: Optional[builtins.str] = None,
                 tls13: Optional[builtins.str] = None,
                 tls_client_auth: Optional[builtins.str] = None,
                 true_client_ip_header: Optional[builtins.str] = None,
                 universal_ssl: Optional[builtins.str] = None,
                 visitor_ip: Optional[builtins.str] = None,
                 waf: Optional[builtins.str] = None,
                 webp: Optional[builtins.str] = None,
                 websockets: Optional[builtins.str] = None,
                 zero_rtt: Optional[builtins.str] = None):
        if aegis is not None:
            pulumi.set(__self__, "aegis", aegis)
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            pulumi.set(__self__, "binary_ast", binary_ast)
        if brotli is not None:
            pulumi.set(__self__, "brotli", brotli)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if challenge_ttl is not None:
            pulumi.set(__self__, "challenge_ttl", challenge_ttl)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if cname_flattening is not None:
            pulumi.set(__self__, "cname_flattening", cname_flattening)
        if development_mode is not None:
            pulumi.set(__self__, "development_mode", development_mode)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            pulumi.set(__self__, "filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if h2_prioritization is not None:
            pulumi.set(__self__, "h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if http3 is not None:
            pulumi.set(__self__, "http3", http3)
        if image_resizing is not None:
            pulumi.set(__self__, "image_resizing", image_resizing)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if log_to_cloudflare is not None:
            pulumi.set(__self__, "log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            pulumi.set(__self__, "max_upload", max_upload)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minify is not None:
            pulumi.set(__self__, "minify", minify)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if mobile_redirect is not None:
            pulumi.set(__self__, "mobile_redirect", mobile_redirect)
        if nel is not None:
            pulumi.set(__self__, "nel", nel)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            pulumi.set(__self__, "opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            pulumi.set(__self__, "orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if origin_max_http_version is not None:
            pulumi.set(__self__, "origin_max_http_version", origin_max_http_version)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if prefetch_preload is not None:
            pulumi.set(__self__, "prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            pulumi.set(__self__, "privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            pulumi.set(__self__, "proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            pulumi.set(__self__, "pseudo_ipv4", pseudo_ipv4)
        if replace_insecure_js is not None:
            pulumi.set(__self__, "replace_insecure_js", replace_insecure_js)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_header is not None:
            pulumi.set(__self__, "security_header", security_header)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if speed_brain is not None:
            pulumi.set(__self__, "speed_brain", speed_brain)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_automatic_mode is not None:
            pulumi.set(__self__, "ssl_automatic_mode", ssl_automatic_mode)
        if tls12_only is not None:
            pulumi.set(__self__, "tls12_only", tls12_only)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)
        if tls_client_auth is not None:
            pulumi.set(__self__, "tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            pulumi.set(__self__, "universal_ssl", universal_ssl)
        if visitor_ip is not None:
            pulumi.set(__self__, "visitor_ip", visitor_ip)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)
        if zero_rtt is not None:
            pulumi.set(__self__, "zero_rtt", zero_rtt)

    @property
    @pulumi.getter
    def aegis(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingAegis']:
        return pulumi.get(self, "aegis")

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[builtins.str]:
        return pulumi.get(self, "always_online")

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[builtins.str]:
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[builtins.str]:
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[builtins.str]:
        return pulumi.get(self, "binary_ast")

    @property
    @pulumi.getter
    def brotli(self) -> Optional[builtins.str]:
        return pulumi.get(self, "brotli")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[builtins.int]:
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[builtins.str]:
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[builtins.int]:
        return pulumi.get(self, "challenge_ttl")

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cname_flattening")

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "development_mode")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[builtins.str]:
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[builtins.str]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @property
    @pulumi.getter
    def fonts(self) -> Optional[builtins.str]:
        return pulumi.get(self, "fonts")

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[builtins.str]:
        return pulumi.get(self, "h2_prioritization")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[builtins.str]:
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def http2(self) -> Optional[builtins.str]:
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def http3(self) -> Optional[builtins.str]:
        return pulumi.get(self, "http3")

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[builtins.str]:
        return pulumi.get(self, "image_resizing")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[builtins.str]:
        return pulumi.get(self, "log_to_cloudflare")

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max_upload")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def minify(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingMinify']:
        return pulumi.get(self, "minify")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="mobileRedirect")
    @_utilities.deprecated("""Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.""")
    def mobile_redirect(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingMobileRedirect']:
        return pulumi.get(self, "mobile_redirect")

    @property
    @pulumi.getter
    def nel(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingNel']:
        return pulumi.get(self, "nel")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[builtins.str]:
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[builtins.str]:
        return pulumi.get(self, "opportunistic_onion")

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[builtins.str]:
        return pulumi.get(self, "orange_to_orange")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[builtins.str]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter(name="originMaxHttpVersion")
    def origin_max_http_version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "origin_max_http_version")

    @property
    @pulumi.getter
    def polish(self) -> Optional[builtins.str]:
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[builtins.str]:
        return pulumi.get(self, "prefetch_preload")

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[builtins.str]:
        return pulumi.get(self, "privacy_pass")

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[builtins.str]:
        return pulumi.get(self, "proxy_read_timeout")

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[builtins.str]:
        return pulumi.get(self, "pseudo_ipv4")

    @property
    @pulumi.getter(name="replaceInsecureJs")
    def replace_insecure_js(self) -> Optional[builtins.str]:
        return pulumi.get(self, "replace_insecure_js")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[builtins.str]:
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[builtins.str]:
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional['outputs.ZoneSettingsOverrideInitialSettingSecurityHeader']:
        return pulumi.get(self, "security_header")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[builtins.str]:
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[builtins.str]:
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[builtins.str]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter(name="speedBrain")
    def speed_brain(self) -> Optional[builtins.str]:
        return pulumi.get(self, "speed_brain")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslAutomaticMode")
    def ssl_automatic_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ssl_automatic_mode")

    @property
    @pulumi.getter(name="tls12Only")
    @_utilities.deprecated("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")
    def tls12_only(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tls12_only")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tls13")

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tls_client_auth")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[builtins.str]:
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[builtins.str]:
        return pulumi.get(self, "universal_ssl")

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[builtins.str]:
        return pulumi.get(self, "visitor_ip")

    @property
    @pulumi.getter
    def waf(self) -> Optional[builtins.str]:
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter
    def webp(self) -> Optional[builtins.str]:
        return pulumi.get(self, "webp")

    @property
    @pulumi.getter
    def websockets(self) -> Optional[builtins.str]:
        return pulumi.get(self, "websockets")

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[builtins.str]:
        return pulumi.get(self, "zero_rtt")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingAegis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSettingAegis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSettingAegis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSettingAegis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 pool_id: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Whether Aegis zone setting is enabled.
        :param builtins.str pool_id: Egress pool id which refers to a grouping of dedicated egress IPs through which Cloudflare will connect to origin.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether Aegis zone setting is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[builtins.str]:
        """
        Egress pool id which refers to a grouping of dedicated egress IPs through which Cloudflare will connect to origin.
        """
        return pulumi.get(self, "pool_id")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingMinify(dict):
    def __init__(__self__, *,
                 css: builtins.str,
                 html: builtins.str,
                 js: builtins.str):
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> builtins.str:
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> builtins.str:
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> builtins.str:
        return pulumi.get(self, "js")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingMobileRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mobileSubdomain":
            suggest = "mobile_subdomain"
        elif key == "stripUri":
            suggest = "strip_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSettingMobileRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSettingMobileRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSettingMobileRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mobile_subdomain: builtins.str,
                 status: builtins.str,
                 strip_uri: builtins.bool):
        pulumi.set(__self__, "mobile_subdomain", mobile_subdomain)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> builtins.str:
        return pulumi.get(self, "mobile_subdomain")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> builtins.bool:
        return pulumi.get(self, "strip_uri")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingNel(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZoneSettingsOverrideInitialSettingSecurityHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideInitialSettingSecurityHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideInitialSettingSecurityHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideInitialSettingSecurityHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 include_subdomains: Optional[builtins.bool] = None,
                 max_age: Optional[builtins.int] = None,
                 nosniff: Optional[builtins.bool] = None,
                 preload: Optional[builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if nosniff is not None:
            pulumi.set(__self__, "nosniff", nosniff)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "nosniff")

    @property
    @pulumi.getter
    def preload(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "preload")


@pulumi.output_type
class ZoneSettingsOverrideSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOnline":
            suggest = "always_online"
        elif key == "alwaysUseHttps":
            suggest = "always_use_https"
        elif key == "automaticHttpsRewrites":
            suggest = "automatic_https_rewrites"
        elif key == "binaryAst":
            suggest = "binary_ast"
        elif key == "browserCacheTtl":
            suggest = "browser_cache_ttl"
        elif key == "browserCheck":
            suggest = "browser_check"
        elif key == "cacheLevel":
            suggest = "cache_level"
        elif key == "challengeTtl":
            suggest = "challenge_ttl"
        elif key == "cnameFlattening":
            suggest = "cname_flattening"
        elif key == "developmentMode":
            suggest = "development_mode"
        elif key == "earlyHints":
            suggest = "early_hints"
        elif key == "emailObfuscation":
            suggest = "email_obfuscation"
        elif key == "filterLogsToCloudflare":
            suggest = "filter_logs_to_cloudflare"
        elif key == "h2Prioritization":
            suggest = "h2_prioritization"
        elif key == "hotlinkProtection":
            suggest = "hotlink_protection"
        elif key == "imageResizing":
            suggest = "image_resizing"
        elif key == "ipGeolocation":
            suggest = "ip_geolocation"
        elif key == "logToCloudflare":
            suggest = "log_to_cloudflare"
        elif key == "maxUpload":
            suggest = "max_upload"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "mobileRedirect":
            suggest = "mobile_redirect"
        elif key == "opportunisticEncryption":
            suggest = "opportunistic_encryption"
        elif key == "opportunisticOnion":
            suggest = "opportunistic_onion"
        elif key == "orangeToOrange":
            suggest = "orange_to_orange"
        elif key == "originErrorPagePassThru":
            suggest = "origin_error_page_pass_thru"
        elif key == "originMaxHttpVersion":
            suggest = "origin_max_http_version"
        elif key == "prefetchPreload":
            suggest = "prefetch_preload"
        elif key == "privacyPass":
            suggest = "privacy_pass"
        elif key == "proxyReadTimeout":
            suggest = "proxy_read_timeout"
        elif key == "pseudoIpv4":
            suggest = "pseudo_ipv4"
        elif key == "replaceInsecureJs":
            suggest = "replace_insecure_js"
        elif key == "responseBuffering":
            suggest = "response_buffering"
        elif key == "rocketLoader":
            suggest = "rocket_loader"
        elif key == "securityHeader":
            suggest = "security_header"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "serverSideExclude":
            suggest = "server_side_exclude"
        elif key == "sortQueryStringForCache":
            suggest = "sort_query_string_for_cache"
        elif key == "speedBrain":
            suggest = "speed_brain"
        elif key == "sslAutomaticMode":
            suggest = "ssl_automatic_mode"
        elif key == "tls12Only":
            suggest = "tls12_only"
        elif key == "tlsClientAuth":
            suggest = "tls_client_auth"
        elif key == "trueClientIpHeader":
            suggest = "true_client_ip_header"
        elif key == "universalSsl":
            suggest = "universal_ssl"
        elif key == "visitorIp":
            suggest = "visitor_ip"
        elif key == "zeroRtt":
            suggest = "zero_rtt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aegis: Optional['outputs.ZoneSettingsOverrideSettingsAegis'] = None,
                 always_online: Optional[builtins.str] = None,
                 always_use_https: Optional[builtins.str] = None,
                 automatic_https_rewrites: Optional[builtins.str] = None,
                 binary_ast: Optional[builtins.str] = None,
                 brotli: Optional[builtins.str] = None,
                 browser_cache_ttl: Optional[builtins.int] = None,
                 browser_check: Optional[builtins.str] = None,
                 cache_level: Optional[builtins.str] = None,
                 challenge_ttl: Optional[builtins.int] = None,
                 ciphers: Optional[Sequence[builtins.str]] = None,
                 cname_flattening: Optional[builtins.str] = None,
                 development_mode: Optional[builtins.str] = None,
                 early_hints: Optional[builtins.str] = None,
                 email_obfuscation: Optional[builtins.str] = None,
                 filter_logs_to_cloudflare: Optional[builtins.str] = None,
                 fonts: Optional[builtins.str] = None,
                 h2_prioritization: Optional[builtins.str] = None,
                 hotlink_protection: Optional[builtins.str] = None,
                 http2: Optional[builtins.str] = None,
                 http3: Optional[builtins.str] = None,
                 image_resizing: Optional[builtins.str] = None,
                 ip_geolocation: Optional[builtins.str] = None,
                 ipv6: Optional[builtins.str] = None,
                 log_to_cloudflare: Optional[builtins.str] = None,
                 max_upload: Optional[builtins.int] = None,
                 min_tls_version: Optional[builtins.str] = None,
                 minify: Optional['outputs.ZoneSettingsOverrideSettingsMinify'] = None,
                 mirage: Optional[builtins.str] = None,
                 mobile_redirect: Optional['outputs.ZoneSettingsOverrideSettingsMobileRedirect'] = None,
                 nel: Optional['outputs.ZoneSettingsOverrideSettingsNel'] = None,
                 opportunistic_encryption: Optional[builtins.str] = None,
                 opportunistic_onion: Optional[builtins.str] = None,
                 orange_to_orange: Optional[builtins.str] = None,
                 origin_error_page_pass_thru: Optional[builtins.str] = None,
                 origin_max_http_version: Optional[builtins.str] = None,
                 polish: Optional[builtins.str] = None,
                 prefetch_preload: Optional[builtins.str] = None,
                 privacy_pass: Optional[builtins.str] = None,
                 proxy_read_timeout: Optional[builtins.str] = None,
                 pseudo_ipv4: Optional[builtins.str] = None,
                 replace_insecure_js: Optional[builtins.str] = None,
                 response_buffering: Optional[builtins.str] = None,
                 rocket_loader: Optional[builtins.str] = None,
                 security_header: Optional['outputs.ZoneSettingsOverrideSettingsSecurityHeader'] = None,
                 security_level: Optional[builtins.str] = None,
                 server_side_exclude: Optional[builtins.str] = None,
                 sort_query_string_for_cache: Optional[builtins.str] = None,
                 speed_brain: Optional[builtins.str] = None,
                 ssl: Optional[builtins.str] = None,
                 ssl_automatic_mode: Optional[builtins.str] = None,
                 tls12_only: Optional[builtins.str] = None,
                 tls13: Optional[builtins.str] = None,
                 tls_client_auth: Optional[builtins.str] = None,
                 true_client_ip_header: Optional[builtins.str] = None,
                 universal_ssl: Optional[builtins.str] = None,
                 visitor_ip: Optional[builtins.str] = None,
                 waf: Optional[builtins.str] = None,
                 webp: Optional[builtins.str] = None,
                 websockets: Optional[builtins.str] = None,
                 zero_rtt: Optional[builtins.str] = None):
        if aegis is not None:
            pulumi.set(__self__, "aegis", aegis)
        if always_online is not None:
            pulumi.set(__self__, "always_online", always_online)
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if binary_ast is not None:
            pulumi.set(__self__, "binary_ast", binary_ast)
        if brotli is not None:
            pulumi.set(__self__, "brotli", brotli)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if challenge_ttl is not None:
            pulumi.set(__self__, "challenge_ttl", challenge_ttl)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if cname_flattening is not None:
            pulumi.set(__self__, "cname_flattening", cname_flattening)
        if development_mode is not None:
            pulumi.set(__self__, "development_mode", development_mode)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if filter_logs_to_cloudflare is not None:
            pulumi.set(__self__, "filter_logs_to_cloudflare", filter_logs_to_cloudflare)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if h2_prioritization is not None:
            pulumi.set(__self__, "h2_prioritization", h2_prioritization)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if http3 is not None:
            pulumi.set(__self__, "http3", http3)
        if image_resizing is not None:
            pulumi.set(__self__, "image_resizing", image_resizing)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if log_to_cloudflare is not None:
            pulumi.set(__self__, "log_to_cloudflare", log_to_cloudflare)
        if max_upload is not None:
            pulumi.set(__self__, "max_upload", max_upload)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minify is not None:
            pulumi.set(__self__, "minify", minify)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if mobile_redirect is not None:
            pulumi.set(__self__, "mobile_redirect", mobile_redirect)
        if nel is not None:
            pulumi.set(__self__, "nel", nel)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if opportunistic_onion is not None:
            pulumi.set(__self__, "opportunistic_onion", opportunistic_onion)
        if orange_to_orange is not None:
            pulumi.set(__self__, "orange_to_orange", orange_to_orange)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if origin_max_http_version is not None:
            pulumi.set(__self__, "origin_max_http_version", origin_max_http_version)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if prefetch_preload is not None:
            pulumi.set(__self__, "prefetch_preload", prefetch_preload)
        if privacy_pass is not None:
            pulumi.set(__self__, "privacy_pass", privacy_pass)
        if proxy_read_timeout is not None:
            pulumi.set(__self__, "proxy_read_timeout", proxy_read_timeout)
        if pseudo_ipv4 is not None:
            pulumi.set(__self__, "pseudo_ipv4", pseudo_ipv4)
        if replace_insecure_js is not None:
            pulumi.set(__self__, "replace_insecure_js", replace_insecure_js)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_header is not None:
            pulumi.set(__self__, "security_header", security_header)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if server_side_exclude is not None:
            pulumi.set(__self__, "server_side_exclude", server_side_exclude)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if speed_brain is not None:
            pulumi.set(__self__, "speed_brain", speed_brain)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_automatic_mode is not None:
            pulumi.set(__self__, "ssl_automatic_mode", ssl_automatic_mode)
        if tls12_only is not None:
            pulumi.set(__self__, "tls12_only", tls12_only)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)
        if tls_client_auth is not None:
            pulumi.set(__self__, "tls_client_auth", tls_client_auth)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if universal_ssl is not None:
            pulumi.set(__self__, "universal_ssl", universal_ssl)
        if visitor_ip is not None:
            pulumi.set(__self__, "visitor_ip", visitor_ip)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)
        if zero_rtt is not None:
            pulumi.set(__self__, "zero_rtt", zero_rtt)

    @property
    @pulumi.getter
    def aegis(self) -> Optional['outputs.ZoneSettingsOverrideSettingsAegis']:
        return pulumi.get(self, "aegis")

    @property
    @pulumi.getter(name="alwaysOnline")
    def always_online(self) -> Optional[builtins.str]:
        return pulumi.get(self, "always_online")

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[builtins.str]:
        return pulumi.get(self, "always_use_https")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[builtins.str]:
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter(name="binaryAst")
    def binary_ast(self) -> Optional[builtins.str]:
        return pulumi.get(self, "binary_ast")

    @property
    @pulumi.getter
    def brotli(self) -> Optional[builtins.str]:
        return pulumi.get(self, "brotli")

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[builtins.int]:
        return pulumi.get(self, "browser_cache_ttl")

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[builtins.str]:
        return pulumi.get(self, "browser_check")

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cache_level")

    @property
    @pulumi.getter(name="challengeTtl")
    def challenge_ttl(self) -> Optional[builtins.int]:
        return pulumi.get(self, "challenge_ttl")

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="cnameFlattening")
    def cname_flattening(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cname_flattening")

    @property
    @pulumi.getter(name="developmentMode")
    def development_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "development_mode")

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[builtins.str]:
        return pulumi.get(self, "early_hints")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="filterLogsToCloudflare")
    def filter_logs_to_cloudflare(self) -> Optional[builtins.str]:
        return pulumi.get(self, "filter_logs_to_cloudflare")

    @property
    @pulumi.getter
    def fonts(self) -> Optional[builtins.str]:
        return pulumi.get(self, "fonts")

    @property
    @pulumi.getter(name="h2Prioritization")
    def h2_prioritization(self) -> Optional[builtins.str]:
        return pulumi.get(self, "h2_prioritization")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[builtins.str]:
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def http2(self) -> Optional[builtins.str]:
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def http3(self) -> Optional[builtins.str]:
        return pulumi.get(self, "http3")

    @property
    @pulumi.getter(name="imageResizing")
    def image_resizing(self) -> Optional[builtins.str]:
        return pulumi.get(self, "image_resizing")

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ip_geolocation")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="logToCloudflare")
    def log_to_cloudflare(self) -> Optional[builtins.str]:
        return pulumi.get(self, "log_to_cloudflare")

    @property
    @pulumi.getter(name="maxUpload")
    def max_upload(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max_upload")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter
    def minify(self) -> Optional['outputs.ZoneSettingsOverrideSettingsMinify']:
        return pulumi.get(self, "minify")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="mobileRedirect")
    @_utilities.deprecated("""Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.""")
    def mobile_redirect(self) -> Optional['outputs.ZoneSettingsOverrideSettingsMobileRedirect']:
        return pulumi.get(self, "mobile_redirect")

    @property
    @pulumi.getter
    def nel(self) -> Optional['outputs.ZoneSettingsOverrideSettingsNel']:
        return pulumi.get(self, "nel")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[builtins.str]:
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter(name="opportunisticOnion")
    def opportunistic_onion(self) -> Optional[builtins.str]:
        return pulumi.get(self, "opportunistic_onion")

    @property
    @pulumi.getter(name="orangeToOrange")
    def orange_to_orange(self) -> Optional[builtins.str]:
        return pulumi.get(self, "orange_to_orange")

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[builtins.str]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @property
    @pulumi.getter(name="originMaxHttpVersion")
    def origin_max_http_version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "origin_max_http_version")

    @property
    @pulumi.getter
    def polish(self) -> Optional[builtins.str]:
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter(name="prefetchPreload")
    def prefetch_preload(self) -> Optional[builtins.str]:
        return pulumi.get(self, "prefetch_preload")

    @property
    @pulumi.getter(name="privacyPass")
    def privacy_pass(self) -> Optional[builtins.str]:
        return pulumi.get(self, "privacy_pass")

    @property
    @pulumi.getter(name="proxyReadTimeout")
    def proxy_read_timeout(self) -> Optional[builtins.str]:
        return pulumi.get(self, "proxy_read_timeout")

    @property
    @pulumi.getter(name="pseudoIpv4")
    def pseudo_ipv4(self) -> Optional[builtins.str]:
        return pulumi.get(self, "pseudo_ipv4")

    @property
    @pulumi.getter(name="replaceInsecureJs")
    def replace_insecure_js(self) -> Optional[builtins.str]:
        return pulumi.get(self, "replace_insecure_js")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[builtins.str]:
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[builtins.str]:
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter(name="securityHeader")
    def security_header(self) -> Optional['outputs.ZoneSettingsOverrideSettingsSecurityHeader']:
        return pulumi.get(self, "security_header")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[builtins.str]:
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serverSideExclude")
    def server_side_exclude(self) -> Optional[builtins.str]:
        return pulumi.get(self, "server_side_exclude")

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[builtins.str]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @property
    @pulumi.getter(name="speedBrain")
    def speed_brain(self) -> Optional[builtins.str]:
        return pulumi.get(self, "speed_brain")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslAutomaticMode")
    def ssl_automatic_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "ssl_automatic_mode")

    @property
    @pulumi.getter(name="tls12Only")
    @_utilities.deprecated("""tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.""")
    def tls12_only(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tls12_only")

    @property
    @pulumi.getter
    def tls13(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tls13")

    @property
    @pulumi.getter(name="tlsClientAuth")
    def tls_client_auth(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tls_client_auth")

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[builtins.str]:
        return pulumi.get(self, "true_client_ip_header")

    @property
    @pulumi.getter(name="universalSsl")
    def universal_ssl(self) -> Optional[builtins.str]:
        return pulumi.get(self, "universal_ssl")

    @property
    @pulumi.getter(name="visitorIp")
    def visitor_ip(self) -> Optional[builtins.str]:
        return pulumi.get(self, "visitor_ip")

    @property
    @pulumi.getter
    def waf(self) -> Optional[builtins.str]:
        return pulumi.get(self, "waf")

    @property
    @pulumi.getter
    def webp(self) -> Optional[builtins.str]:
        return pulumi.get(self, "webp")

    @property
    @pulumi.getter
    def websockets(self) -> Optional[builtins.str]:
        return pulumi.get(self, "websockets")

    @property
    @pulumi.getter(name="zeroRtt")
    def zero_rtt(self) -> Optional[builtins.str]:
        return pulumi.get(self, "zero_rtt")


@pulumi.output_type
class ZoneSettingsOverrideSettingsAegis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettingsAegis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettingsAegis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettingsAegis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 pool_id: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Whether Aegis zone setting is enabled. Defaults to `true`.
        :param builtins.str pool_id: Egress pool id which refers to a grouping of dedicated egress IPs through which Cloudflare will connect to origin.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether Aegis zone setting is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[builtins.str]:
        """
        Egress pool id which refers to a grouping of dedicated egress IPs through which Cloudflare will connect to origin.
        """
        return pulumi.get(self, "pool_id")


@pulumi.output_type
class ZoneSettingsOverrideSettingsMinify(dict):
    def __init__(__self__, *,
                 css: builtins.str,
                 html: builtins.str,
                 js: builtins.str):
        pulumi.set(__self__, "css", css)
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> builtins.str:
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> builtins.str:
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> builtins.str:
        return pulumi.get(self, "js")


@pulumi.output_type
class ZoneSettingsOverrideSettingsMobileRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mobileSubdomain":
            suggest = "mobile_subdomain"
        elif key == "stripUri":
            suggest = "strip_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettingsMobileRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettingsMobileRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettingsMobileRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mobile_subdomain: builtins.str,
                 status: builtins.str,
                 strip_uri: builtins.bool):
        pulumi.set(__self__, "mobile_subdomain", mobile_subdomain)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "strip_uri", strip_uri)

    @property
    @pulumi.getter(name="mobileSubdomain")
    def mobile_subdomain(self) -> builtins.str:
        return pulumi.get(self, "mobile_subdomain")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stripUri")
    def strip_uri(self) -> builtins.bool:
        return pulumi.get(self, "strip_uri")


@pulumi.output_type
class ZoneSettingsOverrideSettingsNel(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ZoneSettingsOverrideSettingsSecurityHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneSettingsOverrideSettingsSecurityHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneSettingsOverrideSettingsSecurityHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneSettingsOverrideSettingsSecurityHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 include_subdomains: Optional[builtins.bool] = None,
                 max_age: Optional[builtins.int] = None,
                 nosniff: Optional[builtins.bool] = None,
                 preload: Optional[builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if nosniff is not None:
            pulumi.set(__self__, "nosniff", nosniff)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def nosniff(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "nosniff")

    @property
    @pulumi.getter
    def preload(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "preload")


@pulumi.output_type
class GetAccountRolesRoleResult(dict):
    def __init__(__self__, *,
                 description: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str description: Description of role's permissions.
        :param builtins.str id: Role identifier tag.
        :param builtins.str name: Role Name.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of role's permissions.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Role identifier tag.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Role Name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAccountsAccountResult(dict):
    def __init__(__self__, *,
                 enforce_twofactor: Optional[builtins.bool] = None,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.bool enforce_twofactor: Whether 2FA is enforced on the account.
        :param builtins.str id: Account ID.
        :param builtins.str name: Account name.
        :param builtins.str type: Account subscription type.
        """
        if enforce_twofactor is not None:
            pulumi.set(__self__, "enforce_twofactor", enforce_twofactor)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="enforceTwofactor")
    def enforce_twofactor(self) -> Optional[builtins.bool]:
        """
        Whether 2FA is enforced on the account.
        """
        return pulumi.get(self, "enforce_twofactor")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Account ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Account name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Account subscription type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDevicePostureRulesRuleResult(dict):
    def __init__(__self__, *,
                 id: builtins.str,
                 type: builtins.str,
                 description: Optional[builtins.str] = None,
                 expiration: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 schedule: Optional[builtins.str] = None):
        """
        :param builtins.str id: ID of the Device Posture Rule.
        :param builtins.str type: The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`
        :param builtins.str expiration: Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        :param builtins.str name: Name of the device posture rule.
        :param builtins.str schedule: Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of the Device Posture Rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expiration(self) -> Optional[builtins.str]:
        """
        Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the device posture rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[builtins.str]:
        """
        Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class GetDevicesDeviceResult(dict):
    def __init__(__self__, *,
                 created: Optional[builtins.str] = None,
                 deleted: Optional[builtins.bool] = None,
                 device_type: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 ip: Optional[builtins.str] = None,
                 key: Optional[builtins.str] = None,
                 last_seen: Optional[builtins.str] = None,
                 mac_address: Optional[builtins.str] = None,
                 manufacturer: Optional[builtins.str] = None,
                 model: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 os_distro_name: Optional[builtins.str] = None,
                 os_distro_revision: Optional[builtins.str] = None,
                 os_version: Optional[builtins.str] = None,
                 os_version_extra: Optional[builtins.str] = None,
                 revoked_at: Optional[builtins.str] = None,
                 serial_number: Optional[builtins.str] = None,
                 updated: Optional[builtins.str] = None,
                 user_email: Optional[builtins.str] = None,
                 user_id: Optional[builtins.str] = None,
                 user_name: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str created: When the device was created.
        :param builtins.bool deleted: Whether the device has been deleted.
        :param builtins.str device_type: The type of the device.
        :param builtins.str id: Device ID.
        :param builtins.str ip: IPv4 or IPv6 address.
        :param builtins.str key: The device's public key.
        :param builtins.str last_seen: When the device was last seen.
        :param builtins.str mac_address: The device's MAC address.
        :param builtins.str manufacturer: The device manufacturer's name.
        :param builtins.str model: The device model name.
        :param builtins.str name: The device name.
        :param builtins.str os_distro_name: The Linux distribution name.
        :param builtins.str os_distro_revision: The Linux distribution revision.
        :param builtins.str os_version: The operating system version.
        :param builtins.str os_version_extra: Extra version value following the operating system version.
        :param builtins.str revoked_at: When the device was revoked.
        :param builtins.str serial_number: The device's serial number.
        :param builtins.str updated: When the device was updated.
        :param builtins.str user_email: User's email.
        :param builtins.str user_id: User's ID.
        :param builtins.str user_name: User's Name.
        :param builtins.str version: The WARP client version.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if deleted is not None:
            pulumi.set(__self__, "deleted", deleted)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version is not None:
            pulumi.set(__self__, "os_version", os_version)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if revoked_at is not None:
            pulumi.set(__self__, "revoked_at", revoked_at)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if updated is not None:
            pulumi.set(__self__, "updated", updated)
        if user_email is not None:
            pulumi.set(__self__, "user_email", user_email)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def created(self) -> Optional[builtins.str]:
        """
        When the device was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def deleted(self) -> Optional[builtins.bool]:
        """
        Whether the device has been deleted.
        """
        return pulumi.get(self, "deleted")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[builtins.str]:
        """
        The type of the device.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Device ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[builtins.str]:
        """
        IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The device's public key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[builtins.str]:
        """
        When the device was last seen.
        """
        return pulumi.get(self, "last_seen")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[builtins.str]:
        """
        The device's MAC address.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[builtins.str]:
        """
        The device manufacturer's name.
        """
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter
    def model(self) -> Optional[builtins.str]:
        """
        The device model name.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The device name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[builtins.str]:
        """
        The Linux distribution name.
        """
        return pulumi.get(self, "os_distro_name")

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[builtins.str]:
        """
        The Linux distribution revision.
        """
        return pulumi.get(self, "os_distro_revision")

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> Optional[builtins.str]:
        """
        The operating system version.
        """
        return pulumi.get(self, "os_version")

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[builtins.str]:
        """
        Extra version value following the operating system version.
        """
        return pulumi.get(self, "os_version_extra")

    @property
    @pulumi.getter(name="revokedAt")
    def revoked_at(self) -> Optional[builtins.str]:
        """
        When the device was revoked.
        """
        return pulumi.get(self, "revoked_at")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[builtins.str]:
        """
        The device's serial number.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def updated(self) -> Optional[builtins.str]:
        """
        When the device was updated.
        """
        return pulumi.get(self, "updated")

    @property
    @pulumi.getter(name="userEmail")
    def user_email(self) -> Optional[builtins.str]:
        """
        User's email.
        """
        return pulumi.get(self, "user_email")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[builtins.str]:
        """
        User's ID.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[builtins.str]:
        """
        User's Name.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        The WARP client version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDlpDatasetsDatasetResult(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 id: builtins.str,
                 name: builtins.str,
                 secret: builtins.bool,
                 status: builtins.str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def secret(self) -> builtins.bool:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayAppTypesAppTypeResult(dict):
    def __init__(__self__, *,
                 application_type_id: builtins.int,
                 description: builtins.str,
                 id: builtins.int,
                 name: builtins.str):
        """
        :param builtins.int application_type_id: The identifier for the application type of this app.
        :param builtins.str description: A short summary of the app type.
        :param builtins.int id: The identifier for this app type. There is only one app type per ID.
        :param builtins.str name: The name of the app type.
        """
        pulumi.set(__self__, "application_type_id", application_type_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="applicationTypeId")
    def application_type_id(self) -> builtins.int:
        """
        The identifier for the application type of this app.
        """
        return pulumi.get(self, "application_type_id")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        A short summary of the app type.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        """
        The identifier for this app type. There is only one app type per ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the app type.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGatewayCategoriesCategoryResult(dict):
    def __init__(__self__, *,
                 beta: builtins.bool,
                 class_: builtins.str,
                 description: builtins.str,
                 id: builtins.int,
                 name: builtins.str,
                 subcategories: Sequence['outputs.GetGatewayCategoriesCategorySubcategoryResult']):
        """
        :param builtins.bool beta: True if the category is in beta and subject to change.
        :param builtins.str class_: Which account types are allowed to create policies based on this category.
        :param builtins.str description: A short summary of domains in the category.
        :param builtins.int id: The identifier for this category. There is only one category per ID.
        :param builtins.str name: The name of the category.
        :param Sequence['GetGatewayCategoriesCategorySubcategoryArgs'] subcategories: A list of subcategories.
        """
        pulumi.set(__self__, "beta", beta)
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subcategories", subcategories)

    @property
    @pulumi.getter
    def beta(self) -> builtins.bool:
        """
        True if the category is in beta and subject to change.
        """
        return pulumi.get(self, "beta")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> builtins.str:
        """
        Which account types are allowed to create policies based on this category.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        A short summary of domains in the category.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        """
        The identifier for this category. There is only one category per ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the category.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subcategories(self) -> Sequence['outputs.GetGatewayCategoriesCategorySubcategoryResult']:
        """
        A list of subcategories.
        """
        return pulumi.get(self, "subcategories")


@pulumi.output_type
class GetGatewayCategoriesCategorySubcategoryResult(dict):
    def __init__(__self__, *,
                 beta: builtins.bool,
                 class_: builtins.str,
                 description: builtins.str,
                 id: builtins.int,
                 name: builtins.str):
        """
        :param builtins.bool beta: True if the subcategory is in beta and subject to change.
        :param builtins.str class_: Which account types are allowed to create policies based on this subcategory.
        :param builtins.str description: A short summary of domains in the subcategory.
        :param builtins.int id: The identifier for this subcategory. There is only one subcategory per ID.
        :param builtins.str name: The name of the subcategory.
        """
        pulumi.set(__self__, "beta", beta)
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def beta(self) -> builtins.bool:
        """
        True if the subcategory is in beta and subject to change.
        """
        return pulumi.get(self, "beta")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> builtins.str:
        """
        Which account types are allowed to create policies based on this subcategory.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        A short summary of domains in the subcategory.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        """
        The identifier for this subcategory. There is only one subcategory per ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the subcategory.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInfrastructureAccessTargetsTargetResult(dict):
    def __init__(__self__, *,
                 account_id: builtins.str,
                 created_at: builtins.str,
                 hostname: builtins.str,
                 id: builtins.str,
                 ip: 'outputs.GetInfrastructureAccessTargetsTargetIpResult',
                 modified_at: builtins.str):
        """
        :param builtins.str account_id: The account identifier to target for the resource.
        :param builtins.str created_at: The date and time at which the target was created.
        :param builtins.str hostname: A non-unique field that refers to a target.
        :param builtins.str id: The identifier of this resource. This is target's unique identifier.
        :param 'GetInfrastructureAccessTargetsTargetIpArgs' ip: The IPv4/IPv6 address that identifies where to reach a target.
        :param builtins.str modified_at: The date and time at which the target was last modified.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "modified_at", modified_at)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> builtins.str:
        """
        The account identifier to target for the resource.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        The date and time at which the target was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def hostname(self) -> builtins.str:
        """
        A non-unique field that refers to a target.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The identifier of this resource. This is target's unique identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetInfrastructureAccessTargetsTargetIpResult':
        """
        The IPv4/IPv6 address that identifies where to reach a target.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="modifiedAt")
    def modified_at(self) -> builtins.str:
        """
        The date and time at which the target was last modified.
        """
        return pulumi.get(self, "modified_at")


@pulumi.output_type
class GetInfrastructureAccessTargetsTargetIpResult(dict):
    def __init__(__self__, *,
                 ipv4: Optional['outputs.GetInfrastructureAccessTargetsTargetIpIpv4Result'] = None,
                 ipv6: Optional['outputs.GetInfrastructureAccessTargetsTargetIpIpv6Result'] = None):
        """
        :param 'GetInfrastructureAccessTargetsTargetIpIpv4Args' ipv4: The target's IPv4 address.
        :param 'GetInfrastructureAccessTargetsTargetIpIpv6Args' ipv6: The target's IPv6 address.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.GetInfrastructureAccessTargetsTargetIpIpv4Result']:
        """
        The target's IPv4 address.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.GetInfrastructureAccessTargetsTargetIpIpv6Result']:
        """
        The target's IPv6 address.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class GetInfrastructureAccessTargetsTargetIpIpv4Result(dict):
    def __init__(__self__, *,
                 ip_addr: builtins.str,
                 virtual_network_id: builtins.str):
        """
        :param builtins.str ip_addr: The IP address of the target.
        :param builtins.str virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> builtins.str:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetInfrastructureAccessTargetsTargetIpIpv6Result(dict):
    def __init__(__self__, *,
                 ip_addr: builtins.str,
                 virtual_network_id: builtins.str):
        """
        :param builtins.str ip_addr: The IP address of the target.
        :param builtins.str virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> builtins.str:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetListsListResult(dict):
    def __init__(__self__, *,
                 description: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 kind: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 numitems: Optional[builtins.int] = None):
        """
        :param builtins.str description: List description.
        :param builtins.str id: List identifier.
        :param builtins.str kind: List kind.
        :param builtins.str name: The list name to target for the resource.
        :param builtins.int numitems: Number of items in list.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if numitems is not None:
            pulumi.set(__self__, "numitems", numitems)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        List description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        List identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        List kind.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The list name to target for the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def numitems(self) -> Optional[builtins.int]:
        """
        Number of items in list.
        """
        return pulumi.get(self, "numitems")


@pulumi.output_type
class GetLoadBalancerPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str name: A regular expression matching the name of the Load Balancer pool to lookup.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        A regular expression matching the name of the Load Balancer pool to lookup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLoadBalancerPoolsPoolResult(dict):
    def __init__(__self__, *,
                 check_regions: Sequence[builtins.str],
                 created_on: builtins.str,
                 description: builtins.str,
                 enabled: builtins.bool,
                 id: builtins.str,
                 latitude: builtins.float,
                 load_sheddings: Sequence['outputs.GetLoadBalancerPoolsPoolLoadSheddingResult'],
                 longitude: builtins.float,
                 minimum_origins: builtins.int,
                 modified_on: builtins.str,
                 monitor: builtins.str,
                 name: builtins.str,
                 notification_email: builtins.str,
                 origins: Sequence['outputs.GetLoadBalancerPoolsPoolOriginResult']):
        """
        :param Sequence[builtins.str] check_regions: List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        :param builtins.str created_on: The RFC3339 timestamp of when the load balancer was created.
        :param builtins.str description: Brief description of the Load Balancer Pool intention.
        :param builtins.bool enabled: Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        :param builtins.str id: ID for this load balancer pool.
        :param builtins.float latitude: Latitude this pool is physically located at; used for proximity steering.
        :param Sequence['GetLoadBalancerPoolsPoolLoadSheddingArgs'] load_sheddings: Setting for controlling load shedding for this pool.
        :param builtins.float longitude: Longitude this pool is physically located at; used for proximity steering.
        :param builtins.int minimum_origins: Minimum number of origins that must be healthy for this pool to serve traffic.
        :param builtins.str modified_on: The RFC3339 timestamp of when the load balancer was last modified.
        :param builtins.str monitor: ID of the Monitor to use for health checking origins within this pool.
        :param builtins.str name: Short name (tag) for the pool.
        :param builtins.str notification_email: Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        :param Sequence['GetLoadBalancerPoolsPoolOriginArgs'] origins: The list of origins within this pool.
        """
        pulumi.set(__self__, "check_regions", check_regions)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "load_sheddings", load_sheddings)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "minimum_origins", minimum_origins)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "monitor", monitor)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_email", notification_email)
        pulumi.set(__self__, "origins", origins)

    @property
    @pulumi.getter(name="checkRegions")
    def check_regions(self) -> Sequence[builtins.str]:
        """
        List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
        """
        return pulumi.get(self, "check_regions")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The RFC3339 timestamp of when the load balancer was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Brief description of the Load Balancer Pool intention.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID for this load balancer pool.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def latitude(self) -> builtins.float:
        """
        Latitude this pool is physically located at; used for proximity steering.
        """
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter(name="loadSheddings")
    def load_sheddings(self) -> Sequence['outputs.GetLoadBalancerPoolsPoolLoadSheddingResult']:
        """
        Setting for controlling load shedding for this pool.
        """
        return pulumi.get(self, "load_sheddings")

    @property
    @pulumi.getter
    def longitude(self) -> builtins.float:
        """
        Longitude this pool is physically located at; used for proximity steering.
        """
        return pulumi.get(self, "longitude")

    @property
    @pulumi.getter(name="minimumOrigins")
    def minimum_origins(self) -> builtins.int:
        """
        Minimum number of origins that must be healthy for this pool to serve traffic.
        """
        return pulumi.get(self, "minimum_origins")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The RFC3339 timestamp of when the load balancer was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter
    def monitor(self) -> builtins.str:
        """
        ID of the Monitor to use for health checking origins within this pool.
        """
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Short name (tag) for the pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notificationEmail")
    def notification_email(self) -> builtins.str:
        """
        Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
        """
        return pulumi.get(self, "notification_email")

    @property
    @pulumi.getter
    def origins(self) -> Sequence['outputs.GetLoadBalancerPoolsPoolOriginResult']:
        """
        The list of origins within this pool.
        """
        return pulumi.get(self, "origins")


@pulumi.output_type
class GetLoadBalancerPoolsPoolLoadSheddingResult(dict):
    def __init__(__self__, *,
                 default_percent: Optional[builtins.float] = None,
                 default_policy: Optional[builtins.str] = None,
                 session_percent: Optional[builtins.float] = None,
                 session_policy: Optional[builtins.str] = None):
        """
        :param builtins.float default_percent: Percent of traffic to shed 0 - 100.
        :param builtins.str default_policy: Method of shedding traffic. Available values: `""`, `hash`, `random`
        :param builtins.float session_percent: Percent of session traffic to shed 0 - 100.
        :param builtins.str session_policy: Method of shedding traffic. Available values: `""`, `hash`
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[builtins.float]:
        """
        Percent of traffic to shed 0 - 100.
        """
        return pulumi.get(self, "default_percent")

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[builtins.str]:
        """
        Method of shedding traffic. Available values: `""`, `hash`, `random`
        """
        return pulumi.get(self, "default_policy")

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[builtins.float]:
        """
        Percent of session traffic to shed 0 - 100.
        """
        return pulumi.get(self, "session_percent")

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[builtins.str]:
        """
        Method of shedding traffic. Available values: `""`, `hash`
        """
        return pulumi.get(self, "session_policy")


@pulumi.output_type
class GetLoadBalancerPoolsPoolOriginResult(dict):
    def __init__(__self__, *,
                 address: builtins.str,
                 name: builtins.str,
                 enabled: Optional[builtins.bool] = None,
                 headers: Optional[Sequence['outputs.GetLoadBalancerPoolsPoolOriginHeaderResult']] = None,
                 virtual_network_id: Optional[builtins.str] = None,
                 weight: Optional[builtins.float] = None):
        """
        :param builtins.str address: The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        :param builtins.str name: A human-identifiable name for the origin.
        :param builtins.bool enabled: Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks.
        :param Sequence['GetLoadBalancerPoolsPoolOriginHeaderArgs'] headers: HTTP request headers.
        :param builtins.str virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param builtins.float weight: The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.GetLoadBalancerPoolsPoolOriginHeaderResult']]:
        """
        HTTP request headers.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[builtins.str]:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @property
    @pulumi.getter
    def weight(self) -> Optional[builtins.float]:
        """
        The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetLoadBalancerPoolsPoolOriginHeaderResult(dict):
    def __init__(__self__, *,
                 header: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str header: HTTP Header name.
        :param Sequence[builtins.str] values: Values for the HTTP headers.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def header(self) -> builtins.str:
        """
        HTTP Header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        Values for the HTTP headers.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRulesetsFilterResult(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 kind: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 phase: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str id: The ID of the Ruleset to target.
        :param builtins.str kind: Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        :param builtins.str name: Name of the ruleset.
        :param builtins.str phase: Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        :param builtins.str version: Version of the ruleset to filter on.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The ID of the Ruleset to target.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the ruleset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def phase(self) -> Optional[builtins.str]:
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the ruleset to filter on.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetRulesetsRulesetResult(dict):
    def __init__(__self__, *,
                 id: builtins.str,
                 kind: builtins.str,
                 name: builtins.str,
                 phase: builtins.str,
                 version: builtins.str,
                 description: Optional[builtins.str] = None,
                 rules: Optional[Sequence['outputs.GetRulesetsRulesetRuleResult']] = None):
        """
        :param builtins.str id: ID of the ruleset.
        :param builtins.str kind: Type of Ruleset. Available values: `custom`, `managed`, `root`, `zone`
        :param builtins.str name: Name of the ruleset.
        :param builtins.str phase: Point in the request/response lifecycle where the ruleset executes. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`
        :param builtins.str version: Version of the ruleset.
        :param builtins.str description: Brief summary of the ruleset and its intended use.
        :param Sequence['GetRulesetsRulesetRuleArgs'] rules: List of rules to apply to the ruleset.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of the ruleset.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        Type of Ruleset. Available values: `custom`, `managed`, `root`, `zone`
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the ruleset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def phase(self) -> builtins.str:
        """
        Point in the request/response lifecycle where the ruleset executes. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version of the ruleset.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Brief summary of the ruleset and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleResult']]:
        """
        List of rules to apply to the ruleset.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetRulesetsRulesetRuleResult(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 id: builtins.str,
                 ref: builtins.str,
                 version: builtins.str,
                 action: Optional[builtins.str] = None,
                 action_parameters: Optional['outputs.GetRulesetsRulesetRuleActionParametersResult'] = None,
                 description: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 exposed_credential_check: Optional['outputs.GetRulesetsRulesetRuleExposedCredentialCheckResult'] = None,
                 last_updated: Optional[builtins.str] = None,
                 logging: Optional['outputs.GetRulesetsRulesetRuleLoggingResult'] = None,
                 ratelimit: Optional['outputs.GetRulesetsRulesetRuleRatelimitResult'] = None):
        """
        :param builtins.str expression: Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
        :param builtins.str id: Unique rule identifier.
        :param builtins.str ref: Rule reference.
        :param builtins.str version: Version of the ruleset to deploy.
        :param builtins.str action: Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`
        :param 'GetRulesetsRulesetRuleActionParametersArgs' action_parameters: List of parameters that configure the behavior of the ruleset rule action.
        :param builtins.str description: Brief summary of the ruleset rule and its intended use.
        :param builtins.bool enabled: Whether the rule is active.
        :param 'GetRulesetsRulesetRuleExposedCredentialCheckArgs' exposed_credential_check: List of parameters that configure exposed credential checks.
        :param builtins.str last_updated: The most recent update to this rule.
        :param 'GetRulesetsRulesetRuleLoggingArgs' logging: List parameters to configure how the rule generates logs.
        :param 'GetRulesetsRulesetRuleRatelimitArgs' ratelimit: List of parameters that configure HTTP rate limiting behaviour.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "version", version)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Unique rule identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ref(self) -> builtins.str:
        """
        Rule reference.
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version of the ruleset to deploy.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersResult']:
        """
        List of parameters that configure the behavior of the ruleset rule action.
        """
        return pulumi.get(self, "action_parameters")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Brief summary of the ruleset rule and its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether the rule is active.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional['outputs.GetRulesetsRulesetRuleExposedCredentialCheckResult']:
        """
        List of parameters that configure exposed credential checks.
        """
        return pulumi.get(self, "exposed_credential_check")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[builtins.str]:
        """
        The most recent update to this rule.
        """
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.GetRulesetsRulesetRuleLoggingResult']:
        """
        List parameters to configure how the rule generates logs.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional['outputs.GetRulesetsRulesetRuleRatelimitResult']:
        """
        List of parameters that configure HTTP rate limiting behaviour.
        """
        return pulumi.get(self, "ratelimit")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersResult(dict):
    def __init__(__self__, *,
                 version: builtins.str,
                 additional_cacheable_ports: Optional[Sequence[builtins.int]] = None,
                 automatic_https_rewrites: Optional[builtins.bool] = None,
                 autominifies: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersAutominifyResult']] = None,
                 bic: Optional[builtins.bool] = None,
                 browser_ttl: Optional['outputs.GetRulesetsRulesetRuleActionParametersBrowserTtlResult'] = None,
                 cache: Optional[builtins.bool] = None,
                 cache_key: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyResult'] = None,
                 cache_reserve: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheReserveResult'] = None,
                 content: Optional[builtins.str] = None,
                 content_type: Optional[builtins.str] = None,
                 cookie_fields: Optional[Sequence[builtins.str]] = None,
                 disable_apps: Optional[builtins.bool] = None,
                 disable_railgun: Optional[builtins.bool] = None,
                 disable_zaraz: Optional[builtins.bool] = None,
                 edge_ttl: Optional['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlResult'] = None,
                 email_obfuscation: Optional[builtins.bool] = None,
                 from_list: Optional['outputs.GetRulesetsRulesetRuleActionParametersFromListResult'] = None,
                 from_value: Optional['outputs.GetRulesetsRulesetRuleActionParametersFromValueResult'] = None,
                 headers: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersHeaderResult']] = None,
                 host_header: Optional[builtins.str] = None,
                 hotlink_protection: Optional[builtins.bool] = None,
                 id: Optional[builtins.str] = None,
                 increment: Optional[builtins.int] = None,
                 matched_data: Optional['outputs.GetRulesetsRulesetRuleActionParametersMatchedDataResult'] = None,
                 mirage: Optional[builtins.bool] = None,
                 opportunistic_encryption: Optional[builtins.bool] = None,
                 origin: Optional['outputs.GetRulesetsRulesetRuleActionParametersOriginResult'] = None,
                 origin_cache_control: Optional[builtins.bool] = None,
                 origin_error_page_passthru: Optional[builtins.bool] = None,
                 overrides: Optional['outputs.GetRulesetsRulesetRuleActionParametersOverridesResult'] = None,
                 phases: Optional[Sequence[builtins.str]] = None,
                 polish: Optional[builtins.str] = None,
                 products: Optional[Sequence[builtins.str]] = None,
                 read_timeout: Optional[builtins.int] = None,
                 request_fields: Optional[Sequence[builtins.str]] = None,
                 respect_strong_etags: Optional[builtins.bool] = None,
                 response_fields: Optional[Sequence[builtins.str]] = None,
                 responses: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersResponseResult']] = None,
                 rocket_loader: Optional[builtins.bool] = None,
                 rules: Optional[Mapping[str, builtins.str]] = None,
                 ruleset: Optional[builtins.str] = None,
                 rulesets: Optional[Sequence[builtins.str]] = None,
                 security_level: Optional[builtins.str] = None,
                 serve_stale: Optional['outputs.GetRulesetsRulesetRuleActionParametersServeStaleResult'] = None,
                 server_side_excludes: Optional[builtins.bool] = None,
                 sni: Optional['outputs.GetRulesetsRulesetRuleActionParametersSniResult'] = None,
                 ssl: Optional[builtins.str] = None,
                 status_code: Optional[builtins.int] = None,
                 sxg: Optional[builtins.bool] = None,
                 uri: Optional['outputs.GetRulesetsRulesetRuleActionParametersUriResult'] = None):
        """
        :param builtins.str version: Version of the ruleset to deploy.
        :param Sequence[builtins.int] additional_cacheable_ports: Allows for the ability to support caching on non-standard ports.
        :param builtins.bool automatic_https_rewrites: Turn on or off Cloudflare Automatic HTTPS rewrites.
        :param Sequence['GetRulesetsRulesetRuleActionParametersAutominifyArgs'] autominifies: Indicate which file extensions to minify automatically.
        :param builtins.bool bic: Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        :param 'GetRulesetsRulesetRuleActionParametersBrowserTtlArgs' browser_ttl: List of browser TTL parameters to apply to the request.
        :param builtins.bool cache: Whether to cache if expression matches.
        :param 'GetRulesetsRulesetRuleActionParametersCacheKeyArgs' cache_key: List of cache key parameters to apply to the request.
        :param 'GetRulesetsRulesetRuleActionParametersCacheReserveArgs' cache_reserve: List of cache reserve parameters to apply to the request.
        :param builtins.str content: Content of the custom error response
        :param builtins.str content_type: Content-Type of the custom error response
        :param Sequence[builtins.str] cookie_fields: List of cookie values to include as part of custom fields logging.
        :param builtins.bool disable_apps: Turn off all active Cloudflare Apps.
        :param builtins.bool disable_railgun: Turn off railgun feature of the Cloudflare Speed app.
        :param builtins.bool disable_zaraz: Turn off zaraz feature.
        :param 'GetRulesetsRulesetRuleActionParametersEdgeTtlArgs' edge_ttl: List of edge TTL parameters to apply to the request.
        :param builtins.bool email_obfuscation: Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        :param 'GetRulesetsRulesetRuleActionParametersFromListArgs' from_list: Use a list to lookup information for the action.
        :param 'GetRulesetsRulesetRuleActionParametersFromValueArgs' from_value: Use a value to lookup information for the action.
        :param Sequence['GetRulesetsRulesetRuleActionParametersHeaderArgs'] headers: List of HTTP header modifications to perform in the ruleset rule.
        :param builtins.str host_header: Host Header that request origin receives.
        :param builtins.bool hotlink_protection: Turn on or off the hotlink protection feature.
        :param builtins.str id: Identifier of the action parameter to modify.
        :param 'GetRulesetsRulesetRuleActionParametersMatchedDataArgs' matched_data: List of properties to configure WAF payload logging.
        :param builtins.bool mirage: Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        :param builtins.bool opportunistic_encryption: Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        :param 'GetRulesetsRulesetRuleActionParametersOriginArgs' origin: List of properties to change request origin.
        :param builtins.bool origin_cache_control: Sets a more compliant mode for parsing Cache Control headers
        :param builtins.bool origin_error_page_passthru: Pass-through error page for origin.
        :param 'GetRulesetsRulesetRuleActionParametersOverridesArgs' overrides: List of override configurations to apply to the ruleset.
        :param Sequence[builtins.str] phases: Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`
        :param builtins.str polish: Apply options from the Polish feature of the Cloudflare Speed app.
        :param Sequence[builtins.str] products: Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`
        :param builtins.int read_timeout: Sets the timeout value for reading content from an origin server.
        :param Sequence[builtins.str] request_fields: List of request headers to include as part of custom fields logging, in lowercase.
        :param builtins.bool respect_strong_etags: Respect strong ETags.
        :param Sequence[builtins.str] response_fields: List of response headers to include as part of custom fields logging, in lowercase.
        :param Sequence['GetRulesetsRulesetRuleActionParametersResponseArgs'] responses: List of parameters that configure the response given to end users
        :param builtins.bool rocket_loader: Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        :param Mapping[str, builtins.str] rules: Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`
        :param builtins.str ruleset: Which ruleset ID to target.
        :param Sequence[builtins.str] rulesets: List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip
        :param builtins.str security_level: Control options for the Security Level feature from the Security app.
        :param 'GetRulesetsRulesetRuleActionParametersServeStaleArgs' serve_stale: List of serve stale parameters to apply to the request.
        :param builtins.bool server_side_excludes: Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        :param 'GetRulesetsRulesetRuleActionParametersSniArgs' sni: List of properties to manange Server Name Indication.
        :param builtins.str ssl: Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        :param builtins.int status_code: HTTP status code of the custom error response
        :param builtins.bool sxg: Turn on or off the SXG feature.
        :param 'GetRulesetsRulesetRuleActionParametersUriArgs' uri: List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        """
        pulumi.set(__self__, "version", version)
        if additional_cacheable_ports is not None:
            pulumi.set(__self__, "additional_cacheable_ports", additional_cacheable_ports)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if autominifies is not None:
            pulumi.set(__self__, "autominifies", autominifies)
        if bic is not None:
            pulumi.set(__self__, "bic", bic)
        if browser_ttl is not None:
            pulumi.set(__self__, "browser_ttl", browser_ttl)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if cache_key is not None:
            pulumi.set(__self__, "cache_key", cache_key)
        if cache_reserve is not None:
            pulumi.set(__self__, "cache_reserve", cache_reserve)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if cookie_fields is not None:
            pulumi.set(__self__, "cookie_fields", cookie_fields)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_railgun is not None:
            pulumi.set(__self__, "disable_railgun", disable_railgun)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            pulumi.set(__self__, "edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if from_list is not None:
            pulumi.set(__self__, "from_list", from_list)
        if from_value is not None:
            pulumi.set(__self__, "from_value", from_value)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_cache_control is not None:
            pulumi.set(__self__, "origin_cache_control", origin_cache_control)
        if origin_error_page_passthru is not None:
            pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if request_fields is not None:
            pulumi.set(__self__, "request_fields", request_fields)
        if respect_strong_etags is not None:
            pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        if response_fields is not None:
            pulumi.set(__self__, "response_fields", response_fields)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if serve_stale is not None:
            pulumi.set(__self__, "serve_stale", serve_stale)
        if server_side_excludes is not None:
            pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if sxg is not None:
            pulumi.set(__self__, "sxg", sxg)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version of the ruleset to deploy.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="additionalCacheablePorts")
    def additional_cacheable_ports(self) -> Optional[Sequence[builtins.int]]:
        """
        Allows for the ability to support caching on non-standard ports.
        """
        return pulumi.get(self, "additional_cacheable_ports")

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[builtins.bool]:
        """
        Turn on or off Cloudflare Automatic HTTPS rewrites.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @property
    @pulumi.getter
    def autominifies(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersAutominifyResult']]:
        """
        Indicate which file extensions to minify automatically.
        """
        return pulumi.get(self, "autominifies")

    @property
    @pulumi.getter
    def bic(self) -> Optional[builtins.bool]:
        """
        Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
        """
        return pulumi.get(self, "bic")

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersBrowserTtlResult']:
        """
        List of browser TTL parameters to apply to the request.
        """
        return pulumi.get(self, "browser_ttl")

    @property
    @pulumi.getter
    def cache(self) -> Optional[builtins.bool]:
        """
        Whether to cache if expression matches.
        """
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyResult']:
        """
        List of cache key parameters to apply to the request.
        """
        return pulumi.get(self, "cache_key")

    @property
    @pulumi.getter(name="cacheReserve")
    def cache_reserve(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheReserveResult']:
        """
        List of cache reserve parameters to apply to the request.
        """
        return pulumi.get(self, "cache_reserve")

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        """
        Content of the custom error response
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[builtins.str]:
        """
        Content-Type of the custom error response
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[Sequence[builtins.str]]:
        """
        List of cookie values to include as part of custom fields logging.
        """
        return pulumi.get(self, "cookie_fields")

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[builtins.bool]:
        """
        Turn off all active Cloudflare Apps.
        """
        return pulumi.get(self, "disable_apps")

    @property
    @pulumi.getter(name="disableRailgun")
    def disable_railgun(self) -> Optional[builtins.bool]:
        """
        Turn off railgun feature of the Cloudflare Speed app.
        """
        return pulumi.get(self, "disable_railgun")

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[builtins.bool]:
        """
        Turn off zaraz feature.
        """
        return pulumi.get(self, "disable_zaraz")

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlResult']:
        """
        List of edge TTL parameters to apply to the request.
        """
        return pulumi.get(self, "edge_ttl")

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[builtins.bool]:
        """
        Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
        """
        return pulumi.get(self, "email_obfuscation")

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersFromListResult']:
        """
        Use a list to lookup information for the action.
        """
        return pulumi.get(self, "from_list")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersFromValueResult']:
        """
        Use a value to lookup information for the action.
        """
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersHeaderResult']]:
        """
        List of HTTP header modifications to perform in the ruleset rule.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[builtins.str]:
        """
        Host Header that request origin receives.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[builtins.bool]:
        """
        Turn on or off the hotlink protection feature.
        """
        return pulumi.get(self, "hotlink_protection")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Identifier of the action parameter to modify.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def increment(self) -> Optional[builtins.int]:
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersMatchedDataResult']:
        """
        List of properties to configure WAF payload logging.
        """
        return pulumi.get(self, "matched_data")

    @property
    @pulumi.getter
    def mirage(self) -> Optional[builtins.bool]:
        """
        Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
        """
        return pulumi.get(self, "mirage")

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[builtins.bool]:
        """
        Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @property
    @pulumi.getter
    def origin(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersOriginResult']:
        """
        List of properties to change request origin.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="originCacheControl")
    def origin_cache_control(self) -> Optional[builtins.bool]:
        """
        Sets a more compliant mode for parsing Cache Control headers
        """
        return pulumi.get(self, "origin_cache_control")

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[builtins.bool]:
        """
        Pass-through error page for origin.
        """
        return pulumi.get(self, "origin_error_page_passthru")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersOverridesResult']:
        """
        List of override configurations to apply to the ruleset.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def phases(self) -> Optional[Sequence[builtins.str]]:
        """
        Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`
        """
        return pulumi.get(self, "phases")

    @property
    @pulumi.getter
    def polish(self) -> Optional[builtins.str]:
        """
        Apply options from the Polish feature of the Cloudflare Speed app.
        """
        return pulumi.get(self, "polish")

    @property
    @pulumi.getter
    def products(self) -> Optional[Sequence[builtins.str]]:
        """
        Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[builtins.int]:
        """
        Sets the timeout value for reading content from an origin server.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[Sequence[builtins.str]]:
        """
        List of request headers to include as part of custom fields logging, in lowercase.
        """
        return pulumi.get(self, "request_fields")

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[builtins.bool]:
        """
        Respect strong ETags.
        """
        return pulumi.get(self, "respect_strong_etags")

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[Sequence[builtins.str]]:
        """
        List of response headers to include as part of custom fields logging, in lowercase.
        """
        return pulumi.get(self, "response_fields")

    @property
    @pulumi.getter
    def responses(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersResponseResult']]:
        """
        List of parameters that configure the response given to end users
        """
        return pulumi.get(self, "responses")

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[builtins.bool]:
        """
        Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
        """
        return pulumi.get(self, "rocket_loader")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[builtins.str]:
        """
        Which ruleset ID to target.
        """
        return pulumi.get(self, "ruleset")

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[Sequence[builtins.str]]:
        """
        List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip
        """
        return pulumi.get(self, "rulesets")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[builtins.str]:
        """
        Control options for the Security Level feature from the Security app.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersServeStaleResult']:
        """
        List of serve stale parameters to apply to the request.
        """
        return pulumi.get(self, "serve_stale")

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[builtins.bool]:
        """
        Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
        """
        return pulumi.get(self, "server_side_excludes")

    @property
    @pulumi.getter
    def sni(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersSniResult']:
        """
        List of properties to manange Server Name Indication.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[builtins.str]:
        """
        Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        HTTP status code of the custom error response
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def sxg(self) -> Optional[builtins.bool]:
        """
        Turn on or off the SXG feature.
        """
        return pulumi.get(self, "sxg")

    @property
    @pulumi.getter
    def uri(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersUriResult']:
        """
        List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersAutominifyResult(dict):
    def __init__(__self__, *,
                 css: Optional[builtins.bool] = None,
                 html: Optional[builtins.bool] = None,
                 js: Optional[builtins.bool] = None):
        """
        :param builtins.bool css: SSL minification.
        :param builtins.bool html: HTML minification.
        :param builtins.bool js: JS minification.
        """
        if css is not None:
            pulumi.set(__self__, "css", css)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if js is not None:
            pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> Optional[builtins.bool]:
        """
        SSL minification.
        """
        return pulumi.get(self, "css")

    @property
    @pulumi.getter
    def html(self) -> Optional[builtins.bool]:
        """
        HTML minification.
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter
    def js(self) -> Optional[builtins.bool]:
        """
        JS minification.
        """
        return pulumi.get(self, "js")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersBrowserTtlResult(dict):
    def __init__(__self__, *,
                 mode: builtins.str,
                 default: Optional[builtins.int] = None):
        """
        :param builtins.str mode: Mode of the browser TTL.
        :param builtins.int default: Default browser TTL.
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Mode of the browser TTL.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[builtins.int]:
        """
        Default browser TTL.
        """
        return pulumi.get(self, "default")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyResult(dict):
    def __init__(__self__, *,
                 cache_by_device_type: Optional[builtins.bool] = None,
                 cache_deception_armor: Optional[builtins.bool] = None,
                 custom_key: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyResult'] = None,
                 ignore_query_strings_order: Optional[builtins.bool] = None):
        """
        :param builtins.bool cache_by_device_type: Cache by device type. Conflicts with "custom_key.user.device_type".
        :param builtins.bool cache_deception_armor: Cache deception armor.
        :param 'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyArgs' custom_key: Custom key parameters for the request.
        :param builtins.bool ignore_query_strings_order: Ignore query strings order.
        """
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if ignore_query_strings_order is not None:
            pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[builtins.bool]:
        """
        Cache by device type. Conflicts with "custom_key.user.device_type".
        """
        return pulumi.get(self, "cache_by_device_type")

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[builtins.bool]:
        """
        Cache deception armor.
        """
        return pulumi.get(self, "cache_deception_armor")

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyResult']:
        """
        Custom key parameters for the request.
        """
        return pulumi.get(self, "custom_key")

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[builtins.bool]:
        """
        Ignore query strings order.
        """
        return pulumi.get(self, "ignore_query_strings_order")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyResult(dict):
    def __init__(__self__, *,
                 cookie: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieResult'] = None,
                 header: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult'] = None,
                 host: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostResult'] = None,
                 query_string: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult'] = None,
                 user: Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserResult'] = None):
        """
        :param 'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieArgs' cookie: Cookie parameters for the custom key.
        :param 'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs' header: Header parameters for the custom key.
        :param 'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostArgs' host: Host parameters for the custom key.
        :param 'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs' query_string: Query string parameters for the custom key.
        :param 'GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserArgs' user: User parameters for the custom key.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieResult']:
        """
        Cookie parameters for the custom key.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult']:
        """
        Header parameters for the custom key.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def host(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostResult']:
        """
        Host parameters for the custom key.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult']:
        """
        Query string parameters for the custom key.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def user(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserResult']:
        """
        User parameters for the custom key.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookieResult(dict):
    def __init__(__self__, *,
                 check_presences: Optional[Sequence[builtins.str]] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] check_presences: List of cookies to check for presence in the custom key.
        :param Sequence[builtins.str] includes: List of cookies to include in the custom key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[builtins.str]]:
        """
        List of cookies to check for presence in the custom key.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of cookies to include in the custom key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeaderResult(dict):
    def __init__(__self__, *,
                 check_presences: Optional[Sequence[builtins.str]] = None,
                 contains: Optional[Mapping[str, Sequence[builtins.str]]] = None,
                 exclude_origin: Optional[builtins.bool] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] check_presences: List of headers to check for presence in the custom key.
        :param Mapping[str, Sequence[builtins.str]] contains: Dictionary of headers mapping to lists of values to check for presence in the custom key.
        :param builtins.bool exclude_origin: Exclude the origin header from the custom key.
        :param Sequence[builtins.str] includes: List of headers to include in the custom key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exclude_origin is not None:
            pulumi.set(__self__, "exclude_origin", exclude_origin)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[Sequence[builtins.str]]:
        """
        List of headers to check for presence in the custom key.
        """
        return pulumi.get(self, "check_presences")

    @property
    @pulumi.getter
    def contains(self) -> Optional[Mapping[str, Sequence[builtins.str]]]:
        """
        Dictionary of headers mapping to lists of values to check for presence in the custom key.
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[builtins.bool]:
        """
        Exclude the origin header from the custom key.
        """
        return pulumi.get(self, "exclude_origin")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of headers to include in the custom key.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHostResult(dict):
    def __init__(__self__, *,
                 resolved: Optional[builtins.bool] = None):
        """
        :param builtins.bool resolved: Resolve hostname to IP address.
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[builtins.bool]:
        """
        Resolve hostname to IP address.
        """
        return pulumi.get(self, "resolved")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryStringResult(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[builtins.str]] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] excludes: List of query string parameters to exclude from the custom key. Conflicts with "include".
        :param Sequence[builtins.str] includes: List of query string parameters to include in the custom key. Conflicts with "exclude".
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of query string parameters to exclude from the custom key. Conflicts with "include".
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of query string parameters to include in the custom key. Conflicts with "exclude".
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUserResult(dict):
    def __init__(__self__, *,
                 device_type: Optional[builtins.bool] = None,
                 geo: Optional[builtins.bool] = None,
                 lang: Optional[builtins.bool] = None):
        """
        :param builtins.bool device_type: Add device type to the custom key. Conflicts with "cache_key.cache_by_device_type".
        :param builtins.bool geo: Add geo data to the custom key.
        :param builtins.bool lang: Add language data to the custom key.
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[builtins.bool]:
        """
        Add device type to the custom key. Conflicts with "cache_key.cache_by_device_type".
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter
    def geo(self) -> Optional[builtins.bool]:
        """
        Add geo data to the custom key.
        """
        return pulumi.get(self, "geo")

    @property
    @pulumi.getter
    def lang(self) -> Optional[builtins.bool]:
        """
        Add language data to the custom key.
        """
        return pulumi.get(self, "lang")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersCacheReserveResult(dict):
    def __init__(__self__, *,
                 eligible: builtins.bool,
                 minimum_file_size: Optional[builtins.int] = None):
        """
        :param builtins.bool eligible: Determines whether Cloudflare will write the eligible resource to cache reserve.
        :param builtins.int minimum_file_size: The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and "eligible" is true, Cloudflare will use 0 bytes by default.
        """
        pulumi.set(__self__, "eligible", eligible)
        if minimum_file_size is not None:
            pulumi.set(__self__, "minimum_file_size", minimum_file_size)

    @property
    @pulumi.getter
    def eligible(self) -> builtins.bool:
        """
        Determines whether Cloudflare will write the eligible resource to cache reserve.
        """
        return pulumi.get(self, "eligible")

    @property
    @pulumi.getter(name="minimumFileSize")
    def minimum_file_size(self) -> Optional[builtins.int]:
        """
        The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and "eligible" is true, Cloudflare will use 0 bytes by default.
        """
        return pulumi.get(self, "minimum_file_size")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersEdgeTtlResult(dict):
    def __init__(__self__, *,
                 mode: builtins.str,
                 default: Optional[builtins.int] = None,
                 status_code_ttls: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult']] = None):
        """
        :param builtins.str mode: Mode of the edge TTL.
        :param builtins.int default: Default edge TTL
        :param Sequence['GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs'] status_code_ttls: Edge TTL for the status codes.
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if status_code_ttls is not None:
            pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Mode of the edge TTL.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def default(self) -> Optional[builtins.int]:
        """
        Default edge TTL
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult']]:
        """
        Edge TTL for the status codes.
        """
        return pulumi.get(self, "status_code_ttls")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlResult(dict):
    def __init__(__self__, *,
                 value: builtins.int,
                 status_code: Optional[builtins.int] = None,
                 status_code_ranges: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult']] = None):
        """
        :param builtins.int value: Status code edge TTL value.
        :param builtins.int status_code: Status code for which the edge TTL is applied. Conflicts with "status_code_range".
        :param Sequence['GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs'] status_code_ranges: Status code range for which the edge TTL is applied. Conflicts with "status_code".
        """
        pulumi.set(__self__, "value", value)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if status_code_ranges is not None:
            pulumi.set(__self__, "status_code_ranges", status_code_ranges)

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        """
        Status code edge TTL value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        Status code for which the edge TTL is applied. Conflicts with "status_code_range".
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult']]:
        """
        Status code range for which the edge TTL is applied. Conflicts with "status_code".
        """
        return pulumi.get(self, "status_code_ranges")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeResult(dict):
    def __init__(__self__, *,
                 from_: Optional[builtins.int] = None,
                 to: Optional[builtins.int] = None):
        """
        :param builtins.int from_: From status code.
        :param builtins.int to: To status code.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[builtins.int]:
        """
        From status code.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[builtins.int]:
        """
        To status code.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersFromListResult(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str key: Expression to use for the list lookup.
        :param builtins.str name: Name of the list.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Expression to use for the list lookup.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the list.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersFromValueResult(dict):
    def __init__(__self__, *,
                 preserve_query_string: Optional[builtins.bool] = None,
                 status_code: Optional[builtins.int] = None,
                 target_url: Optional['outputs.GetRulesetsRulesetRuleActionParametersFromValueTargetUrlResult'] = None):
        """
        :param builtins.bool preserve_query_string: Preserve query string for redirect URL.
        :param builtins.int status_code: Status code for redirect.
        :param 'GetRulesetsRulesetRuleActionParametersFromValueTargetUrlArgs' target_url: Target URL for redirect.
        """
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[builtins.bool]:
        """
        Preserve query string for redirect URL.
        """
        return pulumi.get(self, "preserve_query_string")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        Status code for redirect.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersFromValueTargetUrlResult']:
        """
        Target URL for redirect.
        """
        return pulumi.get(self, "target_url")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersFromValueTargetUrlResult(dict):
    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions. Conflicts with `"value"`.
        :param builtins.str value: Static value to provide as the HTTP request header value. Conflicts with `"expression"`.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions. Conflicts with `"value"`.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Static value to provide as the HTTP request header value. Conflicts with `"expression"`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersHeaderResult(dict):
    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 operation: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions. Conflicts with `"value"`.
        :param builtins.str name: Name of the HTTP request header to target.
        :param builtins.str operation: Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`
        :param builtins.str value: Static value to provide as the HTTP request header value. Conflicts with `"expression"`.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions. Conflicts with `"value"`.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the HTTP request header to target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operation(self) -> Optional[builtins.str]:
        """
        Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Static value to provide as the HTTP request header value. Conflicts with `"expression"`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersMatchedDataResult(dict):
    def __init__(__self__, *,
                 public_key: Optional[builtins.str] = None):
        """
        :param builtins.str public_key: Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure)
        """
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[builtins.str]:
        """
        Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure)
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersOriginResult(dict):
    def __init__(__self__, *,
                 host: Optional[builtins.str] = None,
                 port: Optional[builtins.int] = None):
        """
        :param builtins.str host: Origin Hostname where request is sent.
        :param builtins.int port: Origin Port where request is sent.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[builtins.str]:
        """
        Origin Hostname where request is sent.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        Origin Port where request is sent.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersOverridesResult(dict):
    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 categories: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersOverridesCategoryResult']] = None,
                 enabled: Optional[builtins.bool] = None,
                 rules: Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersOverridesRuleResult']] = None,
                 sensitivity_level: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`
        :param Sequence['GetRulesetsRulesetRuleActionParametersOverridesCategoryArgs'] categories: List of tag-based overrides.
        :param builtins.bool enabled: Defines if the current ruleset-level override enables or disables the ruleset.
        :param Sequence['GetRulesetsRulesetRuleActionParametersOverridesRuleArgs'] rules: List of rule-based overrides.
        :param builtins.str sensitivity_level: Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`
        :param builtins.str status: Defines if the current ruleset-level override enables or disables the ruleset. Available values: `enabled`, `disabled`
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersOverridesCategoryResult']]:
        """
        List of tag-based overrides.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""")
    def enabled(self) -> Optional[builtins.bool]:
        """
        Defines if the current ruleset-level override enables or disables the ruleset.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GetRulesetsRulesetRuleActionParametersOverridesRuleResult']]:
        """
        List of rule-based overrides.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[builtins.str]:
        """
        Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`
        """
        return pulumi.get(self, "sensitivity_level")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Defines if the current ruleset-level override enables or disables the ruleset. Available values: `enabled`, `disabled`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersOverridesCategoryResult(dict):
    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 category: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 status: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`
        :param builtins.str category: Tag name to apply the ruleset rule override to.
        :param builtins.bool enabled: Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        :param builtins.str status: Defines if the current tag-level override enables or disables the ruleset rules with the specified tag. Available values: `enabled`, `disabled`
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Tag name to apply the ruleset rule override to.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""")
    def enabled(self) -> Optional[builtins.bool]:
        """
        Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Defines if the current tag-level override enables or disables the ruleset rules with the specified tag. Available values: `enabled`, `disabled`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersOverridesRuleResult(dict):
    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 id: Optional[builtins.str] = None,
                 score_threshold: Optional[builtins.int] = None,
                 sensitivity_level: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`
        :param builtins.bool enabled: Defines if the current rule-level override enables or disables the rule.
        :param builtins.str id: The ID of this resource.
        :param builtins.int score_threshold: Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        :param builtins.str sensitivity_level: Sensitivity level for a ruleset rule override.
        :param builtins.str status: Defines if the current rule-level override enables or disables the rule. Available values: `enabled`, `disabled`
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""")
    def enabled(self) -> Optional[builtins.bool]:
        """
        Defines if the current rule-level override enables or disables the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[builtins.int]:
        """
        Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
        """
        return pulumi.get(self, "score_threshold")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[builtins.str]:
        """
        Sensitivity level for a ruleset rule override.
        """
        return pulumi.get(self, "sensitivity_level")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Defines if the current rule-level override enables or disables the rule. Available values: `enabled`, `disabled`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersResponseResult(dict):
    def __init__(__self__, *,
                 content: Optional[builtins.str] = None,
                 content_type: Optional[builtins.str] = None,
                 status_code: Optional[builtins.int] = None):
        """
        :param builtins.str content: Body content to include in the response.
        :param builtins.str content_type: HTTP content type to send in the response.
        :param builtins.int status_code: HTTP status code to send in the response.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        """
        Body content to include in the response.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[builtins.str]:
        """
        HTTP content type to send in the response.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        """
        HTTP status code to send in the response.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersServeStaleResult(dict):
    def __init__(__self__, *,
                 disable_stale_while_updating: Optional[builtins.bool] = None):
        """
        :param builtins.bool disable_stale_while_updating: Disable stale while updating.
        """
        if disable_stale_while_updating is not None:
            pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> Optional[builtins.bool]:
        """
        Disable stale while updating.
        """
        return pulumi.get(self, "disable_stale_while_updating")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersSniResult(dict):
    def __init__(__self__, *,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str value: Value to define for SNI.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value to define for SNI.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersUriResult(dict):
    def __init__(__self__, *,
                 origin: Optional[builtins.bool] = None,
                 path: Optional['outputs.GetRulesetsRulesetRuleActionParametersUriPathResult'] = None,
                 query: Optional['outputs.GetRulesetsRulesetRuleActionParametersUriQueryResult'] = None):
        """
        :param 'GetRulesetsRulesetRuleActionParametersUriPathArgs' path: URI path configuration when performing a URL rewrite.
        :param 'GetRulesetsRulesetRuleActionParametersUriQueryArgs' query: Query string configuration when performing a URL rewrite.
        """
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def origin(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersUriPathResult']:
        """
        URI path configuration when performing a URL rewrite.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> Optional['outputs.GetRulesetsRulesetRuleActionParametersUriQueryResult']:
        """
        Query string configuration when performing a URL rewrite.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersUriPathResult(dict):
    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
        :param builtins.str value: Static string value of the updated URI path or query string component.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Static string value of the updated URI path or query string component.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleActionParametersUriQueryResult(dict):
    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str expression: Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
        :param builtins.str value: Static string value of the updated URI path or query string component.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Static string value of the updated URI path or query string component.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesetsRulesetRuleExposedCredentialCheckResult(dict):
    def __init__(__self__, *,
                 password_expression: Optional[builtins.str] = None,
                 username_expression: Optional[builtins.str] = None):
        """
        :param builtins.str password_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        :param builtins.str username_expression: Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        if password_expression is not None:
            pulumi.set(__self__, "password_expression", password_expression)
        if username_expression is not None:
            pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> Optional[builtins.str]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "password_expression")

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> Optional[builtins.str]:
        """
        Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
        """
        return pulumi.get(self, "username_expression")


@pulumi.output_type
class GetRulesetsRulesetRuleLoggingResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 status: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Override the default logging behavior when a rule is matched.
        :param builtins.str status: Override the default logging behavior when a rule is matched. Available values: `enabled`, `disabled`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.""")
    def enabled(self) -> Optional[builtins.bool]:
        """
        Override the default logging behavior when a rule is matched.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Override the default logging behavior when a rule is matched. Available values: `enabled`, `disabled`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesetsRulesetRuleRatelimitResult(dict):
    def __init__(__self__, *,
                 characteristics: Optional[Sequence[builtins.str]] = None,
                 counting_expression: Optional[builtins.str] = None,
                 mitigation_timeout: Optional[builtins.int] = None,
                 period: Optional[builtins.int] = None,
                 requests_per_period: Optional[builtins.int] = None,
                 requests_to_origin: Optional[builtins.bool] = None,
                 score_per_period: Optional[builtins.int] = None,
                 score_response_header_name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] characteristics: List of parameters that define how Cloudflare tracks the request rate for this rule.
        :param builtins.str counting_expression: Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        :param builtins.int mitigation_timeout: Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        :param builtins.int period: The period of time to consider (in seconds) when evaluating the request rate.
        :param builtins.int requests_per_period: The number of requests over the period of time that will trigger the Rate Limiting rule.
        :param builtins.bool requests_to_origin: Whether to include requests to origin within the Rate Limiting count.
        :param builtins.int score_per_period: The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        :param builtins.str score_response_header_name: Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if counting_expression is not None:
            pulumi.set(__self__, "counting_expression", counting_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)
        if requests_to_origin is not None:
            pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        if score_per_period is not None:
            pulumi.set(__self__, "score_per_period", score_per_period)
        if score_response_header_name is not None:
            pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter
    def characteristics(self) -> Optional[Sequence[builtins.str]]:
        """
        List of parameters that define how Cloudflare tracks the request rate for this rule.
        """
        return pulumi.get(self, "characteristics")

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[builtins.str]:
        """
        Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
        """
        return pulumi.get(self, "counting_expression")

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[builtins.int]:
        """
        Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
        """
        return pulumi.get(self, "mitigation_timeout")

    @property
    @pulumi.getter
    def period(self) -> Optional[builtins.int]:
        """
        The period of time to consider (in seconds) when evaluating the request rate.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[builtins.int]:
        """
        The number of requests over the period of time that will trigger the Rate Limiting rule.
        """
        return pulumi.get(self, "requests_per_period")

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> Optional[builtins.bool]:
        """
        Whether to include requests to origin within the Rate Limiting count.
        """
        return pulumi.get(self, "requests_to_origin")

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[builtins.int]:
        """
        The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
        """
        return pulumi.get(self, "score_per_period")

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[builtins.str]:
        """
        Name of HTTP header in the response, set by the origin server, with the score for the current request.
        """
        return pulumi.get(self, "score_response_header_name")


@pulumi.output_type
class GetZeroTrustInfrastructureAccessTargetsTargetResult(dict):
    def __init__(__self__, *,
                 account_id: builtins.str,
                 created_at: builtins.str,
                 hostname: builtins.str,
                 id: builtins.str,
                 ip: 'outputs.GetZeroTrustInfrastructureAccessTargetsTargetIpResult',
                 modified_at: builtins.str):
        """
        :param builtins.str account_id: The account identifier to target for the resource.
        :param builtins.str created_at: The date and time at which the target was created.
        :param builtins.str hostname: A non-unique field that refers to a target.
        :param builtins.str id: The identifier of this resource. This is target's unique identifier.
        :param 'GetZeroTrustInfrastructureAccessTargetsTargetIpArgs' ip: The IPv4/IPv6 address that identifies where to reach a target.
        :param builtins.str modified_at: The date and time at which the target was last modified.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "modified_at", modified_at)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> builtins.str:
        """
        The account identifier to target for the resource.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        The date and time at which the target was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def hostname(self) -> builtins.str:
        """
        A non-unique field that refers to a target.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The identifier of this resource. This is target's unique identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> 'outputs.GetZeroTrustInfrastructureAccessTargetsTargetIpResult':
        """
        The IPv4/IPv6 address that identifies where to reach a target.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="modifiedAt")
    def modified_at(self) -> builtins.str:
        """
        The date and time at which the target was last modified.
        """
        return pulumi.get(self, "modified_at")


@pulumi.output_type
class GetZeroTrustInfrastructureAccessTargetsTargetIpResult(dict):
    def __init__(__self__, *,
                 ipv4: Optional['outputs.GetZeroTrustInfrastructureAccessTargetsTargetIpIpv4Result'] = None,
                 ipv6: Optional['outputs.GetZeroTrustInfrastructureAccessTargetsTargetIpIpv6Result'] = None):
        """
        :param 'GetZeroTrustInfrastructureAccessTargetsTargetIpIpv4Args' ipv4: The target's IPv4 address.
        :param 'GetZeroTrustInfrastructureAccessTargetsTargetIpIpv6Args' ipv6: The target's IPv6 address.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.GetZeroTrustInfrastructureAccessTargetsTargetIpIpv4Result']:
        """
        The target's IPv4 address.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.GetZeroTrustInfrastructureAccessTargetsTargetIpIpv6Result']:
        """
        The target's IPv6 address.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class GetZeroTrustInfrastructureAccessTargetsTargetIpIpv4Result(dict):
    def __init__(__self__, *,
                 ip_addr: builtins.str,
                 virtual_network_id: builtins.str):
        """
        :param builtins.str ip_addr: The IP address of the target.
        :param builtins.str virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> builtins.str:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetZeroTrustInfrastructureAccessTargetsTargetIpIpv6Result(dict):
    def __init__(__self__, *,
                 ip_addr: builtins.str,
                 virtual_network_id: builtins.str):
        """
        :param builtins.str ip_addr: The IP address of the target.
        :param builtins.str virtual_network_id: The private virtual network identifier for the target.
        """
        pulumi.set(__self__, "ip_addr", ip_addr)
        pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> builtins.str:
        """
        The IP address of the target.
        """
        return pulumi.get(self, "ip_addr")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        """
        The private virtual network identifier for the target.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class GetZonesFilterResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[builtins.str] = None,
                 lookup_type: Optional[builtins.str] = None,
                 match: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 paused: Optional[builtins.bool] = None,
                 status: Optional[builtins.str] = None):
        """
        :param builtins.str account_id: The account identifier to target for the resource.
        :param builtins.str lookup_type: The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        :param builtins.str match: A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        :param builtins.str name: A string value to search for.
        :param builtins.bool paused: Paused status of the zone to lookup. Defaults to `false`.
        :param builtins.str status: Status of the zone to lookup.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if lookup_type is not None:
            pulumi.set(__self__, "lookup_type", lookup_type)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[builtins.str]:
        """
        The account identifier to target for the resource.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="lookupType")
    def lookup_type(self) -> Optional[builtins.str]:
        """
        The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
        """
        return pulumi.get(self, "lookup_type")

    @property
    @pulumi.getter
    def match(self) -> Optional[builtins.str]:
        """
        A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        A string value to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def paused(self) -> Optional[builtins.bool]:
        """
        Paused status of the zone to lookup. Defaults to `false`.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status of the zone to lookup.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str id: The zone ID.
        :param builtins.str name: Zone name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The zone ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Zone name.
        """
        return pulumi.get(self, "name")


