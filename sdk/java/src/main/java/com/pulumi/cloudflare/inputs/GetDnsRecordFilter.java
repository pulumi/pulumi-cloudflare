// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.cloudflare.inputs.GetDnsRecordFilterComment;
import com.pulumi.cloudflare.inputs.GetDnsRecordFilterContent;
import com.pulumi.cloudflare.inputs.GetDnsRecordFilterName;
import com.pulumi.cloudflare.inputs.GetDnsRecordFilterTag;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetDnsRecordFilter extends com.pulumi.resources.InvokeArgs {

    public static final GetDnsRecordFilter Empty = new GetDnsRecordFilter();

    @Import(name="comment")
    private @Nullable GetDnsRecordFilterComment comment;

    public Optional<GetDnsRecordFilterComment> comment() {
        return Optional.ofNullable(this.comment);
    }

    @Import(name="content")
    private @Nullable GetDnsRecordFilterContent content;

    public Optional<GetDnsRecordFilterContent> content() {
        return Optional.ofNullable(this.content);
    }

    /**
     * Direction to order DNS records in.
     * Available values: &#34;asc&#34;, &#34;desc&#34;.
     * 
     */
    @Import(name="direction", required=true)
    private String direction;

    /**
     * @return Direction to order DNS records in.
     * Available values: &#34;asc&#34;, &#34;desc&#34;.
     * 
     */
    public String direction() {
        return this.direction;
    }

    /**
     * Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    @Import(name="match", required=true)
    private String match;

    /**
     * @return Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    public String match() {
        return this.match;
    }

    @Import(name="name")
    private @Nullable GetDnsRecordFilterName name;

    public Optional<GetDnsRecordFilterName> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Field to order DNS records by.
     * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
     * 
     */
    @Import(name="order", required=true)
    private String order;

    /**
     * @return Field to order DNS records by.
     * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
     * 
     */
    public String order() {
        return this.order;
    }

    /**
     * Whether the record is receiving the performance and security benefits of Cloudflare.
     * 
     */
    @Import(name="proxied", required=true)
    private Boolean proxied;

    /**
     * @return Whether the record is receiving the performance and security benefits of Cloudflare.
     * 
     */
    public Boolean proxied() {
        return this.proxied;
    }

    /**
     * Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
     * 
     */
    @Import(name="search")
    private @Nullable String search;

    /**
     * @return Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
     * 
     */
    public Optional<String> search() {
        return Optional.ofNullable(this.search);
    }

    @Import(name="tag")
    private @Nullable GetDnsRecordFilterTag tag;

    public Optional<GetDnsRecordFilterTag> tag() {
        return Optional.ofNullable(this.tag);
    }

    /**
     * Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    @Import(name="tagMatch", required=true)
    private String tagMatch;

    /**
     * @return Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    public String tagMatch() {
        return this.tagMatch;
    }

    /**
     * Record type.
     * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
     * 
     */
    @Import(name="type")
    private @Nullable String type;

    /**
     * @return Record type.
     * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
     * 
     */
    public Optional<String> type() {
        return Optional.ofNullable(this.type);
    }

    private GetDnsRecordFilter() {}

    private GetDnsRecordFilter(GetDnsRecordFilter $) {
        this.comment = $.comment;
        this.content = $.content;
        this.direction = $.direction;
        this.match = $.match;
        this.name = $.name;
        this.order = $.order;
        this.proxied = $.proxied;
        this.search = $.search;
        this.tag = $.tag;
        this.tagMatch = $.tagMatch;
        this.type = $.type;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetDnsRecordFilter defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetDnsRecordFilter $;

        public Builder() {
            $ = new GetDnsRecordFilter();
        }

        public Builder(GetDnsRecordFilter defaults) {
            $ = new GetDnsRecordFilter(Objects.requireNonNull(defaults));
        }

        public Builder comment(@Nullable GetDnsRecordFilterComment comment) {
            $.comment = comment;
            return this;
        }

        public Builder content(@Nullable GetDnsRecordFilterContent content) {
            $.content = content;
            return this;
        }

        /**
         * @param direction Direction to order DNS records in.
         * Available values: &#34;asc&#34;, &#34;desc&#34;.
         * 
         * @return builder
         * 
         */
        public Builder direction(String direction) {
            $.direction = direction;
            return this;
        }

        /**
         * @param match Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
         * Available values: &#34;any&#34;, &#34;all&#34;.
         * 
         * @return builder
         * 
         */
        public Builder match(String match) {
            $.match = match;
            return this;
        }

        public Builder name(@Nullable GetDnsRecordFilterName name) {
            $.name = name;
            return this;
        }

        /**
         * @param order Field to order DNS records by.
         * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
         * 
         * @return builder
         * 
         */
        public Builder order(String order) {
            $.order = order;
            return this;
        }

        /**
         * @param proxied Whether the record is receiving the performance and security benefits of Cloudflare.
         * 
         * @return builder
         * 
         */
        public Builder proxied(Boolean proxied) {
            $.proxied = proxied;
            return this;
        }

        /**
         * @param search Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
         * 
         * @return builder
         * 
         */
        public Builder search(@Nullable String search) {
            $.search = search;
            return this;
        }

        public Builder tag(@Nullable GetDnsRecordFilterTag tag) {
            $.tag = tag;
            return this;
        }

        /**
         * @param tagMatch Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
         * Available values: &#34;any&#34;, &#34;all&#34;.
         * 
         * @return builder
         * 
         */
        public Builder tagMatch(String tagMatch) {
            $.tagMatch = tagMatch;
            return this;
        }

        /**
         * @param type Record type.
         * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
         * 
         * @return builder
         * 
         */
        public Builder type(@Nullable String type) {
            $.type = type;
            return this;
        }

        public GetDnsRecordFilter build() {
            if ($.direction == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilter", "direction");
            }
            if ($.match == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilter", "match");
            }
            if ($.order == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilter", "order");
            }
            if ($.proxied == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilter", "proxied");
            }
            if ($.tagMatch == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilter", "tagMatch");
            }
            return $;
        }
    }

}
