// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare;

import com.pulumi.cloudflare.LoadBalancerMonitorArgs;
import com.pulumi.cloudflare.Utilities;
import com.pulumi.cloudflare.inputs.LoadBalancerMonitorState;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.cloudflare.LoadBalancerMonitor;
 * import com.pulumi.cloudflare.LoadBalancerMonitorArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var exampleLoadBalancerMonitor = new LoadBalancerMonitor("exampleLoadBalancerMonitor", LoadBalancerMonitorArgs.builder()
 *             .accountId("023e105f4ecef8ad9ca31a8372d0c353")
 *             .allowInsecure(true)
 *             .consecutiveDown(0)
 *             .consecutiveUp(0)
 *             .description("Login page monitor")
 *             .expectedBody("alive")
 *             .expectedCodes("2xx")
 *             .followRedirects(true)
 *             .header(Map.ofEntries(
 *                 Map.entry("Host", "example.com"),
 *                 Map.entry("X-App-ID", "abc123")
 *             ))
 *             .interval(0)
 *             .method("GET")
 *             .path("/health")
 *             .port(0)
 *             .probeZone("example.com")
 *             .retries(0)
 *             .timeout(0)
 *             .type("http")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * ```sh
 * $ pulumi import cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor example &#39;&lt;account_id&gt;/&lt;monitor_id&gt;&#39;
 * ```
 * 
 */
@ResourceType(type="cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor")
public class LoadBalancerMonitor extends com.pulumi.resources.CustomResource {
    /**
     * Identifier
     * 
     */
    @Export(name="accountId", refs={String.class}, tree="[0]")
    private Output<String> accountId;

    /**
     * @return Identifier
     * 
     */
    public Output<String> accountId() {
        return this.accountId;
    }
    /**
     * Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     * 
     */
    @Export(name="allowInsecure", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowInsecure;

    /**
     * @return Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     * 
     */
    public Output<Boolean> allowInsecure() {
        return this.allowInsecure;
    }
    /**
     * To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     * 
     */
    @Export(name="consecutiveDown", refs={Integer.class}, tree="[0]")
    private Output<Integer> consecutiveDown;

    /**
     * @return To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     * 
     */
    public Output<Integer> consecutiveDown() {
        return this.consecutiveDown;
    }
    /**
     * To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     * 
     */
    @Export(name="consecutiveUp", refs={Integer.class}, tree="[0]")
    private Output<Integer> consecutiveUp;

    /**
     * @return To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     * 
     */
    public Output<Integer> consecutiveUp() {
        return this.consecutiveUp;
    }
    @Export(name="createdOn", refs={String.class}, tree="[0]")
    private Output<String> createdOn;

    public Output<String> createdOn() {
        return this.createdOn;
    }
    /**
     * Object description.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return Object description.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    @Export(name="expectedBody", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> expectedBody;

    /**
     * @return A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public Output<Optional<String>> expectedBody() {
        return Codegen.optional(this.expectedBody);
    }
    /**
     * The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    @Export(name="expectedCodes", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> expectedCodes;

    /**
     * @return The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public Output<Optional<String>> expectedCodes() {
        return Codegen.optional(this.expectedCodes);
    }
    /**
     * Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    @Export(name="followRedirects", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> followRedirects;

    /**
     * @return Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public Output<Boolean> followRedirects() {
        return this.followRedirects;
    }
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    @Export(name="header", refs={Map.class,String.class,List.class}, tree="[0,1,[2,1]]")
    private Output</* @Nullable */ Map<String,List<String>>> header;

    /**
     * @return The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public Output<Optional<Map<String,List<String>>>> header() {
        return Codegen.optional(this.header);
    }
    /**
     * The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     * 
     */
    @Export(name="interval", refs={Integer.class}, tree="[0]")
    private Output<Integer> interval;

    /**
     * @return The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     * 
     */
    public Output<Integer> interval() {
        return this.interval;
    }
    /**
     * The method to use for the health check. This defaults to &#39;GET&#39; for HTTP/HTTPS based checks and &#39;connection_established&#39; for TCP based health checks.
     * 
     */
    @Export(name="method", refs={String.class}, tree="[0]")
    private Output<String> method;

    /**
     * @return The method to use for the health check. This defaults to &#39;GET&#39; for HTTP/HTTPS based checks and &#39;connection_established&#39; for TCP based health checks.
     * 
     */
    public Output<String> method() {
        return this.method;
    }
    @Export(name="modifiedOn", refs={String.class}, tree="[0]")
    private Output<String> modifiedOn;

    public Output<String> modifiedOn() {
        return this.modifiedOn;
    }
    /**
     * The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    @Export(name="path", refs={String.class}, tree="[0]")
    private Output<String> path;

    /**
     * @return The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public Output<String> path() {
        return this.path;
    }
    /**
     * The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     * 
     */
    @Export(name="port", refs={Integer.class}, tree="[0]")
    private Output<Integer> port;

    /**
     * @return The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     * 
     */
    public Output<Integer> port() {
        return this.port;
    }
    /**
     * Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    @Export(name="probeZone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> probeZone;

    /**
     * @return Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public Output<Optional<String>> probeZone() {
        return Codegen.optional(this.probeZone);
    }
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     * 
     */
    @Export(name="retries", refs={Integer.class}, tree="[0]")
    private Output<Integer> retries;

    /**
     * @return The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     * 
     */
    public Output<Integer> retries() {
        return this.retries;
    }
    /**
     * The timeout (in seconds) before marking the health check as failed.
     * 
     */
    @Export(name="timeout", refs={Integer.class}, tree="[0]")
    private Output<Integer> timeout;

    /**
     * @return The timeout (in seconds) before marking the health check as failed.
     * 
     */
    public Output<Integer> timeout() {
        return this.timeout;
    }
    /**
     * The protocol to use for the health check. Currently supported protocols are &#39;HTTP&#39;,&#39;HTTPS&#39;, &#39;TCP&#39;, &#39;ICMP-PING&#39;, &#39;UDP-ICMP&#39;, and &#39;SMTP&#39;.
     * Available values: &#34;http&#34;, &#34;https&#34;, &#34;tcp&#34;, &#34;udp*icmp&#34;, &#34;icmp*ping&#34;, &#34;smtp&#34;.
     * 
     */
    @Export(name="type", refs={String.class}, tree="[0]")
    private Output<String> type;

    /**
     * @return The protocol to use for the health check. Currently supported protocols are &#39;HTTP&#39;,&#39;HTTPS&#39;, &#39;TCP&#39;, &#39;ICMP-PING&#39;, &#39;UDP-ICMP&#39;, and &#39;SMTP&#39;.
     * Available values: &#34;http&#34;, &#34;https&#34;, &#34;tcp&#34;, &#34;udp*icmp&#34;, &#34;icmp*ping&#34;, &#34;smtp&#34;.
     * 
     */
    public Output<String> type() {
        return this.type;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public LoadBalancerMonitor(java.lang.String name) {
        this(name, LoadBalancerMonitorArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public LoadBalancerMonitor(java.lang.String name, LoadBalancerMonitorArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public LoadBalancerMonitor(java.lang.String name, LoadBalancerMonitorArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private LoadBalancerMonitor(java.lang.String name, Output<java.lang.String> id, @Nullable LoadBalancerMonitorState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor", name, state, makeResourceOptions(options, id), false);
    }

    private static LoadBalancerMonitorArgs makeArgs(LoadBalancerMonitorArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? LoadBalancerMonitorArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static LoadBalancerMonitor get(java.lang.String name, Output<java.lang.String> id, @Nullable LoadBalancerMonitorState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new LoadBalancerMonitor(name, id, state, options);
    }
}
