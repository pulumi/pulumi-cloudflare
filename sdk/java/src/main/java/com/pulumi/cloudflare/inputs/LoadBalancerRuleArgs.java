// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.cloudflare.inputs.LoadBalancerRuleFixedResponseArgs;
import com.pulumi.cloudflare.inputs.LoadBalancerRuleOverridesArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class LoadBalancerRuleArgs extends com.pulumi.resources.ResourceArgs {

    public static final LoadBalancerRuleArgs Empty = new LoadBalancerRuleArgs();

    /**
     * The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
     * 
     */
    @Import(name="condition")
    private @Nullable Output<String> condition;

    /**
     * @return The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
     * 
     */
    public Optional<Output<String>> condition() {
        return Optional.ofNullable(this.condition);
    }

    /**
     * Disable this specific rule. It will no longer be evaluated by this load balancer.
     * 
     */
    @Import(name="disabled")
    private @Nullable Output<Boolean> disabled;

    /**
     * @return Disable this specific rule. It will no longer be evaluated by this load balancer.
     * 
     */
    public Optional<Output<Boolean>> disabled() {
        return Optional.ofNullable(this.disabled);
    }

    /**
     * A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
     * 
     */
    @Import(name="fixedResponse")
    private @Nullable Output<LoadBalancerRuleFixedResponseArgs> fixedResponse;

    /**
     * @return A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
     * 
     */
    public Optional<Output<LoadBalancerRuleFixedResponseArgs>> fixedResponse() {
        return Optional.ofNullable(this.fixedResponse);
    }

    /**
     * Name of this rule. Only used for human readability.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of this rule. Only used for human readability.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * A collection of overrides to apply to the load balancer when this rule&#39;s condition is true. All fields are optional.
     * 
     */
    @Import(name="overrides")
    private @Nullable Output<LoadBalancerRuleOverridesArgs> overrides;

    /**
     * @return A collection of overrides to apply to the load balancer when this rule&#39;s condition is true. All fields are optional.
     * 
     */
    public Optional<Output<LoadBalancerRuleOverridesArgs>> overrides() {
        return Optional.ofNullable(this.overrides);
    }

    /**
     * The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
     * 
     */
    @Import(name="priority")
    private @Nullable Output<Integer> priority;

    /**
     * @return The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
     * 
     */
    public Optional<Output<Integer>> priority() {
        return Optional.ofNullable(this.priority);
    }

    /**
     * If this rule&#39;s condition is true, this causes rule evaluation to stop after processing this rule.
     * 
     */
    @Import(name="terminates")
    private @Nullable Output<Boolean> terminates;

    /**
     * @return If this rule&#39;s condition is true, this causes rule evaluation to stop after processing this rule.
     * 
     */
    public Optional<Output<Boolean>> terminates() {
        return Optional.ofNullable(this.terminates);
    }

    private LoadBalancerRuleArgs() {}

    private LoadBalancerRuleArgs(LoadBalancerRuleArgs $) {
        this.condition = $.condition;
        this.disabled = $.disabled;
        this.fixedResponse = $.fixedResponse;
        this.name = $.name;
        this.overrides = $.overrides;
        this.priority = $.priority;
        this.terminates = $.terminates;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(LoadBalancerRuleArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private LoadBalancerRuleArgs $;

        public Builder() {
            $ = new LoadBalancerRuleArgs();
        }

        public Builder(LoadBalancerRuleArgs defaults) {
            $ = new LoadBalancerRuleArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param condition The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
         * 
         * @return builder
         * 
         */
        public Builder condition(@Nullable Output<String> condition) {
            $.condition = condition;
            return this;
        }

        /**
         * @param condition The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
         * 
         * @return builder
         * 
         */
        public Builder condition(String condition) {
            return condition(Output.of(condition));
        }

        /**
         * @param disabled Disable this specific rule. It will no longer be evaluated by this load balancer.
         * 
         * @return builder
         * 
         */
        public Builder disabled(@Nullable Output<Boolean> disabled) {
            $.disabled = disabled;
            return this;
        }

        /**
         * @param disabled Disable this specific rule. It will no longer be evaluated by this load balancer.
         * 
         * @return builder
         * 
         */
        public Builder disabled(Boolean disabled) {
            return disabled(Output.of(disabled));
        }

        /**
         * @param fixedResponse A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
         * 
         * @return builder
         * 
         */
        public Builder fixedResponse(@Nullable Output<LoadBalancerRuleFixedResponseArgs> fixedResponse) {
            $.fixedResponse = fixedResponse;
            return this;
        }

        /**
         * @param fixedResponse A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
         * 
         * @return builder
         * 
         */
        public Builder fixedResponse(LoadBalancerRuleFixedResponseArgs fixedResponse) {
            return fixedResponse(Output.of(fixedResponse));
        }

        /**
         * @param name Name of this rule. Only used for human readability.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of this rule. Only used for human readability.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param overrides A collection of overrides to apply to the load balancer when this rule&#39;s condition is true. All fields are optional.
         * 
         * @return builder
         * 
         */
        public Builder overrides(@Nullable Output<LoadBalancerRuleOverridesArgs> overrides) {
            $.overrides = overrides;
            return this;
        }

        /**
         * @param overrides A collection of overrides to apply to the load balancer when this rule&#39;s condition is true. All fields are optional.
         * 
         * @return builder
         * 
         */
        public Builder overrides(LoadBalancerRuleOverridesArgs overrides) {
            return overrides(Output.of(overrides));
        }

        /**
         * @param priority The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
         * 
         * @return builder
         * 
         */
        public Builder priority(@Nullable Output<Integer> priority) {
            $.priority = priority;
            return this;
        }

        /**
         * @param priority The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
         * 
         * @return builder
         * 
         */
        public Builder priority(Integer priority) {
            return priority(Output.of(priority));
        }

        /**
         * @param terminates If this rule&#39;s condition is true, this causes rule evaluation to stop after processing this rule.
         * 
         * @return builder
         * 
         */
        public Builder terminates(@Nullable Output<Boolean> terminates) {
            $.terminates = terminates;
            return this;
        }

        /**
         * @param terminates If this rule&#39;s condition is true, this causes rule evaluation to stop after processing this rule.
         * 
         * @return builder
         * 
         */
        public Builder terminates(Boolean terminates) {
            return terminates(Output.of(terminates));
        }

        public LoadBalancerRuleArgs build() {
            return $;
        }
    }

}
