// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare;

import com.pulumi.cloudflare.inputs.DnsFirewallAttackMitigationArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DnsFirewallArgs extends com.pulumi.resources.ResourceArgs {

    public static final DnsFirewallArgs Empty = new DnsFirewallArgs();

    /**
     * Identifier.
     * 
     */
    @Import(name="accountId", required=true)
    private Output<String> accountId;

    /**
     * @return Identifier.
     * 
     */
    public Output<String> accountId() {
        return this.accountId;
    }

    /**
     * Attack mitigation settings
     * 
     */
    @Import(name="attackMitigation")
    private @Nullable Output<DnsFirewallAttackMitigationArgs> attackMitigation;

    /**
     * @return Attack mitigation settings
     * 
     */
    public Optional<Output<DnsFirewallAttackMitigationArgs>> attackMitigation() {
        return Optional.ofNullable(this.attackMitigation);
    }

    /**
     * Whether to refuse to answer queries for the ANY type
     * 
     */
    @Import(name="deprecateAnyRequests")
    private @Nullable Output<Boolean> deprecateAnyRequests;

    /**
     * @return Whether to refuse to answer queries for the ANY type
     * 
     */
    public Optional<Output<Boolean>> deprecateAnyRequests() {
        return Optional.ofNullable(this.deprecateAnyRequests);
    }

    /**
     * Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     * 
     */
    @Import(name="ecsFallback")
    private @Nullable Output<Boolean> ecsFallback;

    /**
     * @return Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     * 
     */
    public Optional<Output<Boolean>> ecsFallback() {
        return Optional.ofNullable(this.ecsFallback);
    }

    /**
     * Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
     * 
     */
    @Import(name="maximumCacheTtl")
    private @Nullable Output<Double> maximumCacheTtl;

    /**
     * @return Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
     * 
     */
    public Optional<Output<Double>> maximumCacheTtl() {
        return Optional.ofNullable(this.maximumCacheTtl);
    }

    /**
     * Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
     * 
     */
    @Import(name="minimumCacheTtl")
    private @Nullable Output<Double> minimumCacheTtl;

    /**
     * @return Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
     * 
     */
    public Optional<Output<Double>> minimumCacheTtl() {
        return Optional.ofNullable(this.minimumCacheTtl);
    }

    /**
     * DNS Firewall cluster name
     * 
     */
    @Import(name="name", required=true)
    private Output<String> name;

    /**
     * @return DNS Firewall cluster name
     * 
     */
    public Output<String> name() {
        return this.name;
    }

    /**
     * Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
     * 
     */
    @Import(name="negativeCacheTtl")
    private @Nullable Output<Double> negativeCacheTtl;

    /**
     * @return Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
     * 
     */
    public Optional<Output<Double>> negativeCacheTtl() {
        return Optional.ofNullable(this.negativeCacheTtl);
    }

    /**
     * Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
     * 
     */
    @Import(name="ratelimit")
    private @Nullable Output<Double> ratelimit;

    /**
     * @return Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
     * 
     */
    public Optional<Output<Double>> ratelimit() {
        return Optional.ofNullable(this.ratelimit);
    }

    /**
     * Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
     * 
     */
    @Import(name="retries")
    private @Nullable Output<Double> retries;

    /**
     * @return Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
     * 
     */
    public Optional<Output<Double>> retries() {
        return Optional.ofNullable(this.retries);
    }

    @Import(name="upstreamIps", required=true)
    private Output<List<String>> upstreamIps;

    public Output<List<String>> upstreamIps() {
        return this.upstreamIps;
    }

    private DnsFirewallArgs() {}

    private DnsFirewallArgs(DnsFirewallArgs $) {
        this.accountId = $.accountId;
        this.attackMitigation = $.attackMitigation;
        this.deprecateAnyRequests = $.deprecateAnyRequests;
        this.ecsFallback = $.ecsFallback;
        this.maximumCacheTtl = $.maximumCacheTtl;
        this.minimumCacheTtl = $.minimumCacheTtl;
        this.name = $.name;
        this.negativeCacheTtl = $.negativeCacheTtl;
        this.ratelimit = $.ratelimit;
        this.retries = $.retries;
        this.upstreamIps = $.upstreamIps;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DnsFirewallArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DnsFirewallArgs $;

        public Builder() {
            $ = new DnsFirewallArgs();
        }

        public Builder(DnsFirewallArgs defaults) {
            $ = new DnsFirewallArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param accountId Identifier.
         * 
         * @return builder
         * 
         */
        public Builder accountId(Output<String> accountId) {
            $.accountId = accountId;
            return this;
        }

        /**
         * @param accountId Identifier.
         * 
         * @return builder
         * 
         */
        public Builder accountId(String accountId) {
            return accountId(Output.of(accountId));
        }

        /**
         * @param attackMitigation Attack mitigation settings
         * 
         * @return builder
         * 
         */
        public Builder attackMitigation(@Nullable Output<DnsFirewallAttackMitigationArgs> attackMitigation) {
            $.attackMitigation = attackMitigation;
            return this;
        }

        /**
         * @param attackMitigation Attack mitigation settings
         * 
         * @return builder
         * 
         */
        public Builder attackMitigation(DnsFirewallAttackMitigationArgs attackMitigation) {
            return attackMitigation(Output.of(attackMitigation));
        }

        /**
         * @param deprecateAnyRequests Whether to refuse to answer queries for the ANY type
         * 
         * @return builder
         * 
         */
        public Builder deprecateAnyRequests(@Nullable Output<Boolean> deprecateAnyRequests) {
            $.deprecateAnyRequests = deprecateAnyRequests;
            return this;
        }

        /**
         * @param deprecateAnyRequests Whether to refuse to answer queries for the ANY type
         * 
         * @return builder
         * 
         */
        public Builder deprecateAnyRequests(Boolean deprecateAnyRequests) {
            return deprecateAnyRequests(Output.of(deprecateAnyRequests));
        }

        /**
         * @param ecsFallback Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
         * 
         * @return builder
         * 
         */
        public Builder ecsFallback(@Nullable Output<Boolean> ecsFallback) {
            $.ecsFallback = ecsFallback;
            return this;
        }

        /**
         * @param ecsFallback Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
         * 
         * @return builder
         * 
         */
        public Builder ecsFallback(Boolean ecsFallback) {
            return ecsFallback(Output.of(ecsFallback));
        }

        /**
         * @param maximumCacheTtl Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
         * 
         * @return builder
         * 
         */
        public Builder maximumCacheTtl(@Nullable Output<Double> maximumCacheTtl) {
            $.maximumCacheTtl = maximumCacheTtl;
            return this;
        }

        /**
         * @param maximumCacheTtl Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
         * 
         * @return builder
         * 
         */
        public Builder maximumCacheTtl(Double maximumCacheTtl) {
            return maximumCacheTtl(Output.of(maximumCacheTtl));
        }

        /**
         * @param minimumCacheTtl Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
         * 
         * @return builder
         * 
         */
        public Builder minimumCacheTtl(@Nullable Output<Double> minimumCacheTtl) {
            $.minimumCacheTtl = minimumCacheTtl;
            return this;
        }

        /**
         * @param minimumCacheTtl Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
         * 
         * @return builder
         * 
         */
        public Builder minimumCacheTtl(Double minimumCacheTtl) {
            return minimumCacheTtl(Output.of(minimumCacheTtl));
        }

        /**
         * @param name DNS Firewall cluster name
         * 
         * @return builder
         * 
         */
        public Builder name(Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name DNS Firewall cluster name
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param negativeCacheTtl Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
         * 
         * @return builder
         * 
         */
        public Builder negativeCacheTtl(@Nullable Output<Double> negativeCacheTtl) {
            $.negativeCacheTtl = negativeCacheTtl;
            return this;
        }

        /**
         * @param negativeCacheTtl Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
         * 
         * @return builder
         * 
         */
        public Builder negativeCacheTtl(Double negativeCacheTtl) {
            return negativeCacheTtl(Output.of(negativeCacheTtl));
        }

        /**
         * @param ratelimit Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
         * 
         * @return builder
         * 
         */
        public Builder ratelimit(@Nullable Output<Double> ratelimit) {
            $.ratelimit = ratelimit;
            return this;
        }

        /**
         * @param ratelimit Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
         * 
         * @return builder
         * 
         */
        public Builder ratelimit(Double ratelimit) {
            return ratelimit(Output.of(ratelimit));
        }

        /**
         * @param retries Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
         * 
         * @return builder
         * 
         */
        public Builder retries(@Nullable Output<Double> retries) {
            $.retries = retries;
            return this;
        }

        /**
         * @param retries Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
         * 
         * @return builder
         * 
         */
        public Builder retries(Double retries) {
            return retries(Output.of(retries));
        }

        public Builder upstreamIps(Output<List<String>> upstreamIps) {
            $.upstreamIps = upstreamIps;
            return this;
        }

        public Builder upstreamIps(List<String> upstreamIps) {
            return upstreamIps(Output.of(upstreamIps));
        }

        public Builder upstreamIps(String... upstreamIps) {
            return upstreamIps(List.of(upstreamIps));
        }

        public DnsFirewallArgs build() {
            if ($.accountId == null) {
                throw new MissingRequiredPropertyException("DnsFirewallArgs", "accountId");
            }
            if ($.name == null) {
                throw new MissingRequiredPropertyException("DnsFirewallArgs", "name");
            }
            if ($.upstreamIps == null) {
                throw new MissingRequiredPropertyException("DnsFirewallArgs", "upstreamIps");
            }
            return $;
        }
    }

}
