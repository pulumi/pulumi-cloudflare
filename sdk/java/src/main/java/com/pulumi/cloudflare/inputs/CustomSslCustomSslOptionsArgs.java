// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class CustomSslCustomSslOptionsArgs extends com.pulumi.resources.ResourceArgs {

    public static final CustomSslCustomSslOptionsArgs Empty = new CustomSslCustomSslOptionsArgs();

    /**
     * Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
     * 
     */
    @Import(name="bundleMethod")
    private @Nullable Output<String> bundleMethod;

    /**
     * @return Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
     * 
     */
    public Optional<Output<String>> bundleMethod() {
        return Optional.ofNullable(this.bundleMethod);
    }

    /**
     * Certificate certificate and the intermediate(s)
     * 
     */
    @Import(name="certificate")
    private @Nullable Output<String> certificate;

    /**
     * @return Certificate certificate and the intermediate(s)
     * 
     */
    public Optional<Output<String>> certificate() {
        return Optional.ofNullable(this.certificate);
    }

    /**
     * Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
     * 
     */
    @Import(name="geoRestrictions")
    private @Nullable Output<String> geoRestrictions;

    /**
     * @return Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
     * 
     */
    public Optional<Output<String>> geoRestrictions() {
        return Optional.ofNullable(this.geoRestrictions);
    }

    /**
     * Certificate&#39;s private key
     * 
     */
    @Import(name="privateKey")
    private @Nullable Output<String> privateKey;

    /**
     * @return Certificate&#39;s private key
     * 
     */
    public Optional<Output<String>> privateKey() {
        return Optional.ofNullable(this.privateKey);
    }

    /**
     * Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
     * 
     */
    @Import(name="type")
    private @Nullable Output<String> type;

    /**
     * @return Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
     * 
     */
    public Optional<Output<String>> type() {
        return Optional.ofNullable(this.type);
    }

    private CustomSslCustomSslOptionsArgs() {}

    private CustomSslCustomSslOptionsArgs(CustomSslCustomSslOptionsArgs $) {
        this.bundleMethod = $.bundleMethod;
        this.certificate = $.certificate;
        this.geoRestrictions = $.geoRestrictions;
        this.privateKey = $.privateKey;
        this.type = $.type;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(CustomSslCustomSslOptionsArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private CustomSslCustomSslOptionsArgs $;

        public Builder() {
            $ = new CustomSslCustomSslOptionsArgs();
        }

        public Builder(CustomSslCustomSslOptionsArgs defaults) {
            $ = new CustomSslCustomSslOptionsArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param bundleMethod Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
         * 
         * @return builder
         * 
         */
        public Builder bundleMethod(@Nullable Output<String> bundleMethod) {
            $.bundleMethod = bundleMethod;
            return this;
        }

        /**
         * @param bundleMethod Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
         * 
         * @return builder
         * 
         */
        public Builder bundleMethod(String bundleMethod) {
            return bundleMethod(Output.of(bundleMethod));
        }

        /**
         * @param certificate Certificate certificate and the intermediate(s)
         * 
         * @return builder
         * 
         */
        public Builder certificate(@Nullable Output<String> certificate) {
            $.certificate = certificate;
            return this;
        }

        /**
         * @param certificate Certificate certificate and the intermediate(s)
         * 
         * @return builder
         * 
         */
        public Builder certificate(String certificate) {
            return certificate(Output.of(certificate));
        }

        /**
         * @param geoRestrictions Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
         * 
         * @return builder
         * 
         */
        public Builder geoRestrictions(@Nullable Output<String> geoRestrictions) {
            $.geoRestrictions = geoRestrictions;
            return this;
        }

        /**
         * @param geoRestrictions Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
         * 
         * @return builder
         * 
         */
        public Builder geoRestrictions(String geoRestrictions) {
            return geoRestrictions(Output.of(geoRestrictions));
        }

        /**
         * @param privateKey Certificate&#39;s private key
         * 
         * @return builder
         * 
         */
        public Builder privateKey(@Nullable Output<String> privateKey) {
            $.privateKey = privateKey;
            return this;
        }

        /**
         * @param privateKey Certificate&#39;s private key
         * 
         * @return builder
         * 
         */
        public Builder privateKey(String privateKey) {
            return privateKey(Output.of(privateKey));
        }

        /**
         * @param type Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
         * 
         * @return builder
         * 
         */
        public Builder type(@Nullable Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        public CustomSslCustomSslOptionsArgs build() {
            return $;
        }
    }

}
