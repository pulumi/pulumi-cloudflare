// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetWaitingRoomEventResult {
    private String createdOn;
    /**
     * @return If set, the event will override the waiting room&#39;s `custom_page_html` property while it is active. If null, the event will inherit it.
     * 
     */
    private String customPageHtml;
    /**
     * @return A note that you can use to add more details about the event.
     * 
     */
    private String description;
    /**
     * @return If set, the event will override the waiting room&#39;s `disable_session_renewal` property while it is active. If null, the event will inherit it.
     * 
     */
    private Boolean disableSessionRenewal;
    /**
     * @return An ISO 8601 timestamp that marks the end of the event.
     * 
     */
    private String eventEndTime;
    private @Nullable String eventId;
    /**
     * @return An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event&#39;s configuration. The start time must be at least one minute before `event_end_time`.
     * 
     */
    private String eventStartTime;
    /**
     * @return The ID of this resource.
     * 
     */
    private String id;
    private String modifiedOn;
    /**
     * @return A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     * 
     */
    private String name;
    /**
     * @return If set, the event will override the waiting room&#39;s `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `total_active_users` property is also set.
     * 
     */
    private Integer newUsersPerMinute;
    /**
     * @return An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
     * 
     */
    private String prequeueStartTime;
    /**
     * @return If set, the event will override the waiting room&#39;s `queueing_method` property while it is active. If null, the event will inherit it.
     * 
     */
    private String queueingMethod;
    /**
     * @return If set, the event will override the waiting room&#39;s `session_duration` property while it is active. If null, the event will inherit it.
     * 
     */
    private Integer sessionDuration;
    /**
     * @return If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     * 
     */
    private Boolean shuffleAtEventStart;
    /**
     * @return Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     * 
     */
    private Boolean suspended;
    /**
     * @return If set, the event will override the waiting room&#39;s `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `new_users_per_minute` property is also set.
     * 
     */
    private Integer totalActiveUsers;
    /**
     * @return If set, the event will override the waiting room&#39;s `turnstile_action` property while it is active. If null, the event will inherit it.
     * Available values: &#34;log&#34;, &#34;infinite_queue&#34;.
     * 
     */
    private String turnstileAction;
    /**
     * @return If set, the event will override the waiting room&#39;s `turnstile_mode` property while it is active. If null, the event will inherit it.
     * Available values: &#34;off&#34;, &#34;invisible&#34;, &#34;visible*non*interactive&#34;, &#34;visible_managed&#34;.
     * 
     */
    private String turnstileMode;
    private String waitingRoomId;
    /**
     * @return Identifier.
     * 
     */
    private String zoneId;

    private GetWaitingRoomEventResult() {}
    public String createdOn() {
        return this.createdOn;
    }
    /**
     * @return If set, the event will override the waiting room&#39;s `custom_page_html` property while it is active. If null, the event will inherit it.
     * 
     */
    public String customPageHtml() {
        return this.customPageHtml;
    }
    /**
     * @return A note that you can use to add more details about the event.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return If set, the event will override the waiting room&#39;s `disable_session_renewal` property while it is active. If null, the event will inherit it.
     * 
     */
    public Boolean disableSessionRenewal() {
        return this.disableSessionRenewal;
    }
    /**
     * @return An ISO 8601 timestamp that marks the end of the event.
     * 
     */
    public String eventEndTime() {
        return this.eventEndTime;
    }
    public Optional<String> eventId() {
        return Optional.ofNullable(this.eventId);
    }
    /**
     * @return An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event&#39;s configuration. The start time must be at least one minute before `event_end_time`.
     * 
     */
    public String eventStartTime() {
        return this.eventStartTime;
    }
    /**
     * @return The ID of this resource.
     * 
     */
    public String id() {
        return this.id;
    }
    public String modifiedOn() {
        return this.modifiedOn;
    }
    /**
     * @return A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return If set, the event will override the waiting room&#39;s `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `total_active_users` property is also set.
     * 
     */
    public Integer newUsersPerMinute() {
        return this.newUsersPerMinute;
    }
    /**
     * @return An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
     * 
     */
    public String prequeueStartTime() {
        return this.prequeueStartTime;
    }
    /**
     * @return If set, the event will override the waiting room&#39;s `queueing_method` property while it is active. If null, the event will inherit it.
     * 
     */
    public String queueingMethod() {
        return this.queueingMethod;
    }
    /**
     * @return If set, the event will override the waiting room&#39;s `session_duration` property while it is active. If null, the event will inherit it.
     * 
     */
    public Integer sessionDuration() {
        return this.sessionDuration;
    }
    /**
     * @return If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     * 
     */
    public Boolean shuffleAtEventStart() {
        return this.shuffleAtEventStart;
    }
    /**
     * @return Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     * 
     */
    public Boolean suspended() {
        return this.suspended;
    }
    /**
     * @return If set, the event will override the waiting room&#39;s `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `new_users_per_minute` property is also set.
     * 
     */
    public Integer totalActiveUsers() {
        return this.totalActiveUsers;
    }
    /**
     * @return If set, the event will override the waiting room&#39;s `turnstile_action` property while it is active. If null, the event will inherit it.
     * Available values: &#34;log&#34;, &#34;infinite_queue&#34;.
     * 
     */
    public String turnstileAction() {
        return this.turnstileAction;
    }
    /**
     * @return If set, the event will override the waiting room&#39;s `turnstile_mode` property while it is active. If null, the event will inherit it.
     * Available values: &#34;off&#34;, &#34;invisible&#34;, &#34;visible*non*interactive&#34;, &#34;visible_managed&#34;.
     * 
     */
    public String turnstileMode() {
        return this.turnstileMode;
    }
    public String waitingRoomId() {
        return this.waitingRoomId;
    }
    /**
     * @return Identifier.
     * 
     */
    public String zoneId() {
        return this.zoneId;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetWaitingRoomEventResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String createdOn;
        private String customPageHtml;
        private String description;
        private Boolean disableSessionRenewal;
        private String eventEndTime;
        private @Nullable String eventId;
        private String eventStartTime;
        private String id;
        private String modifiedOn;
        private String name;
        private Integer newUsersPerMinute;
        private String prequeueStartTime;
        private String queueingMethod;
        private Integer sessionDuration;
        private Boolean shuffleAtEventStart;
        private Boolean suspended;
        private Integer totalActiveUsers;
        private String turnstileAction;
        private String turnstileMode;
        private String waitingRoomId;
        private String zoneId;
        public Builder() {}
        public Builder(GetWaitingRoomEventResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.createdOn = defaults.createdOn;
    	      this.customPageHtml = defaults.customPageHtml;
    	      this.description = defaults.description;
    	      this.disableSessionRenewal = defaults.disableSessionRenewal;
    	      this.eventEndTime = defaults.eventEndTime;
    	      this.eventId = defaults.eventId;
    	      this.eventStartTime = defaults.eventStartTime;
    	      this.id = defaults.id;
    	      this.modifiedOn = defaults.modifiedOn;
    	      this.name = defaults.name;
    	      this.newUsersPerMinute = defaults.newUsersPerMinute;
    	      this.prequeueStartTime = defaults.prequeueStartTime;
    	      this.queueingMethod = defaults.queueingMethod;
    	      this.sessionDuration = defaults.sessionDuration;
    	      this.shuffleAtEventStart = defaults.shuffleAtEventStart;
    	      this.suspended = defaults.suspended;
    	      this.totalActiveUsers = defaults.totalActiveUsers;
    	      this.turnstileAction = defaults.turnstileAction;
    	      this.turnstileMode = defaults.turnstileMode;
    	      this.waitingRoomId = defaults.waitingRoomId;
    	      this.zoneId = defaults.zoneId;
        }

        @CustomType.Setter
        public Builder createdOn(String createdOn) {
            if (createdOn == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "createdOn");
            }
            this.createdOn = createdOn;
            return this;
        }
        @CustomType.Setter
        public Builder customPageHtml(String customPageHtml) {
            if (customPageHtml == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "customPageHtml");
            }
            this.customPageHtml = customPageHtml;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder disableSessionRenewal(Boolean disableSessionRenewal) {
            if (disableSessionRenewal == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "disableSessionRenewal");
            }
            this.disableSessionRenewal = disableSessionRenewal;
            return this;
        }
        @CustomType.Setter
        public Builder eventEndTime(String eventEndTime) {
            if (eventEndTime == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "eventEndTime");
            }
            this.eventEndTime = eventEndTime;
            return this;
        }
        @CustomType.Setter
        public Builder eventId(@Nullable String eventId) {

            this.eventId = eventId;
            return this;
        }
        @CustomType.Setter
        public Builder eventStartTime(String eventStartTime) {
            if (eventStartTime == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "eventStartTime");
            }
            this.eventStartTime = eventStartTime;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder modifiedOn(String modifiedOn) {
            if (modifiedOn == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "modifiedOn");
            }
            this.modifiedOn = modifiedOn;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder newUsersPerMinute(Integer newUsersPerMinute) {
            if (newUsersPerMinute == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "newUsersPerMinute");
            }
            this.newUsersPerMinute = newUsersPerMinute;
            return this;
        }
        @CustomType.Setter
        public Builder prequeueStartTime(String prequeueStartTime) {
            if (prequeueStartTime == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "prequeueStartTime");
            }
            this.prequeueStartTime = prequeueStartTime;
            return this;
        }
        @CustomType.Setter
        public Builder queueingMethod(String queueingMethod) {
            if (queueingMethod == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "queueingMethod");
            }
            this.queueingMethod = queueingMethod;
            return this;
        }
        @CustomType.Setter
        public Builder sessionDuration(Integer sessionDuration) {
            if (sessionDuration == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "sessionDuration");
            }
            this.sessionDuration = sessionDuration;
            return this;
        }
        @CustomType.Setter
        public Builder shuffleAtEventStart(Boolean shuffleAtEventStart) {
            if (shuffleAtEventStart == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "shuffleAtEventStart");
            }
            this.shuffleAtEventStart = shuffleAtEventStart;
            return this;
        }
        @CustomType.Setter
        public Builder suspended(Boolean suspended) {
            if (suspended == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "suspended");
            }
            this.suspended = suspended;
            return this;
        }
        @CustomType.Setter
        public Builder totalActiveUsers(Integer totalActiveUsers) {
            if (totalActiveUsers == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "totalActiveUsers");
            }
            this.totalActiveUsers = totalActiveUsers;
            return this;
        }
        @CustomType.Setter
        public Builder turnstileAction(String turnstileAction) {
            if (turnstileAction == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "turnstileAction");
            }
            this.turnstileAction = turnstileAction;
            return this;
        }
        @CustomType.Setter
        public Builder turnstileMode(String turnstileMode) {
            if (turnstileMode == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "turnstileMode");
            }
            this.turnstileMode = turnstileMode;
            return this;
        }
        @CustomType.Setter
        public Builder waitingRoomId(String waitingRoomId) {
            if (waitingRoomId == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "waitingRoomId");
            }
            this.waitingRoomId = waitingRoomId;
            return this;
        }
        @CustomType.Setter
        public Builder zoneId(String zoneId) {
            if (zoneId == null) {
              throw new MissingRequiredPropertyException("GetWaitingRoomEventResult", "zoneId");
            }
            this.zoneId = zoneId;
            return this;
        }
        public GetWaitingRoomEventResult build() {
            final var _resultValue = new GetWaitingRoomEventResult();
            _resultValue.createdOn = createdOn;
            _resultValue.customPageHtml = customPageHtml;
            _resultValue.description = description;
            _resultValue.disableSessionRenewal = disableSessionRenewal;
            _resultValue.eventEndTime = eventEndTime;
            _resultValue.eventId = eventId;
            _resultValue.eventStartTime = eventStartTime;
            _resultValue.id = id;
            _resultValue.modifiedOn = modifiedOn;
            _resultValue.name = name;
            _resultValue.newUsersPerMinute = newUsersPerMinute;
            _resultValue.prequeueStartTime = prequeueStartTime;
            _resultValue.queueingMethod = queueingMethod;
            _resultValue.sessionDuration = sessionDuration;
            _resultValue.shuffleAtEventStart = shuffleAtEventStart;
            _resultValue.suspended = suspended;
            _resultValue.totalActiveUsers = totalActiveUsers;
            _resultValue.turnstileAction = turnstileAction;
            _resultValue.turnstileMode = turnstileMode;
            _resultValue.waitingRoomId = waitingRoomId;
            _resultValue.zoneId = zoneId;
            return _resultValue;
        }
    }
}
