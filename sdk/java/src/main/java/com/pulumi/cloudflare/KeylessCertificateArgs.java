// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class KeylessCertificateArgs extends com.pulumi.resources.ResourceArgs {

    public static final KeylessCertificateArgs Empty = new KeylessCertificateArgs();

    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**
     * 
     */
    @Import(name="bundleMethod")
    private @Nullable Output<String> bundleMethod;

    /**
     * @return A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**
     * 
     */
    public Optional<Output<String>> bundleMethod() {
        return Optional.ofNullable(this.bundleMethod);
    }

    /**
     * The zone&#39;s SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**
     * 
     */
    @Import(name="certificate", required=true)
    private Output<String> certificate;

    /**
     * @return The zone&#39;s SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**
     * 
     */
    public Output<String> certificate() {
        return this.certificate;
    }

    /**
     * Whether the KeyLess SSL is on.
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return Whether the KeyLess SSL is on.
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * The KeyLess SSL host.
     * 
     */
    @Import(name="host", required=true)
    private Output<String> host;

    /**
     * @return The KeyLess SSL host.
     * 
     */
    public Output<String> host() {
        return this.host;
    }

    /**
     * The KeyLess SSL name.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The KeyLess SSL name.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The KeyLess SSL port used to communicate between Cloudflare and the client&#39;s KeyLess SSL server. Defaults to `24008`.
     * 
     */
    @Import(name="port")
    private @Nullable Output<Integer> port;

    /**
     * @return The KeyLess SSL port used to communicate between Cloudflare and the client&#39;s KeyLess SSL server. Defaults to `24008`.
     * 
     */
    public Optional<Output<Integer>> port() {
        return Optional.ofNullable(this.port);
    }

    /**
     * The zone identifier to target for the resource.
     * 
     */
    @Import(name="zoneId", required=true)
    private Output<String> zoneId;

    /**
     * @return The zone identifier to target for the resource.
     * 
     */
    public Output<String> zoneId() {
        return this.zoneId;
    }

    private KeylessCertificateArgs() {}

    private KeylessCertificateArgs(KeylessCertificateArgs $) {
        this.bundleMethod = $.bundleMethod;
        this.certificate = $.certificate;
        this.enabled = $.enabled;
        this.host = $.host;
        this.name = $.name;
        this.port = $.port;
        this.zoneId = $.zoneId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(KeylessCertificateArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private KeylessCertificateArgs $;

        public Builder() {
            $ = new KeylessCertificateArgs();
        }

        public Builder(KeylessCertificateArgs defaults) {
            $ = new KeylessCertificateArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param bundleMethod A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**
         * 
         * @return builder
         * 
         */
        public Builder bundleMethod(@Nullable Output<String> bundleMethod) {
            $.bundleMethod = bundleMethod;
            return this;
        }

        /**
         * @param bundleMethod A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**
         * 
         * @return builder
         * 
         */
        public Builder bundleMethod(String bundleMethod) {
            return bundleMethod(Output.of(bundleMethod));
        }

        /**
         * @param certificate The zone&#39;s SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**
         * 
         * @return builder
         * 
         */
        public Builder certificate(Output<String> certificate) {
            $.certificate = certificate;
            return this;
        }

        /**
         * @param certificate The zone&#39;s SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**
         * 
         * @return builder
         * 
         */
        public Builder certificate(String certificate) {
            return certificate(Output.of(certificate));
        }

        /**
         * @param enabled Whether the KeyLess SSL is on.
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Whether the KeyLess SSL is on.
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param host The KeyLess SSL host.
         * 
         * @return builder
         * 
         */
        public Builder host(Output<String> host) {
            $.host = host;
            return this;
        }

        /**
         * @param host The KeyLess SSL host.
         * 
         * @return builder
         * 
         */
        public Builder host(String host) {
            return host(Output.of(host));
        }

        /**
         * @param name The KeyLess SSL name.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The KeyLess SSL name.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param port The KeyLess SSL port used to communicate between Cloudflare and the client&#39;s KeyLess SSL server. Defaults to `24008`.
         * 
         * @return builder
         * 
         */
        public Builder port(@Nullable Output<Integer> port) {
            $.port = port;
            return this;
        }

        /**
         * @param port The KeyLess SSL port used to communicate between Cloudflare and the client&#39;s KeyLess SSL server. Defaults to `24008`.
         * 
         * @return builder
         * 
         */
        public Builder port(Integer port) {
            return port(Output.of(port));
        }

        /**
         * @param zoneId The zone identifier to target for the resource.
         * 
         * @return builder
         * 
         */
        public Builder zoneId(Output<String> zoneId) {
            $.zoneId = zoneId;
            return this;
        }

        /**
         * @param zoneId The zone identifier to target for the resource.
         * 
         * @return builder
         * 
         */
        public Builder zoneId(String zoneId) {
            return zoneId(Output.of(zoneId));
        }

        public KeylessCertificateArgs build() {
            if ($.certificate == null) {
                throw new MissingRequiredPropertyException("KeylessCertificateArgs", "certificate");
            }
            if ($.host == null) {
                throw new MissingRequiredPropertyException("KeylessCertificateArgs", "host");
            }
            if ($.zoneId == null) {
                throw new MissingRequiredPropertyException("KeylessCertificateArgs", "zoneId");
            }
            return $;
        }
    }

}
