// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.cloudflare.inputs.CustomSslGeoRestrictionsArgs;
import com.pulumi.cloudflare.inputs.CustomSslKeylessServerArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Double;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class CustomSslState extends com.pulumi.resources.ResourceArgs {

    public static final CustomSslState Empty = new CustomSslState();

    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * 
     */
    @Import(name="bundleMethod")
    private @Nullable Output<String> bundleMethod;

    /**
     * @return A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * 
     */
    public Optional<Output<String>> bundleMethod() {
        return Optional.ofNullable(this.bundleMethod);
    }

    /**
     * The zone&#39;s SSL certificate or certificate and the intermediate(s).
     * 
     */
    @Import(name="certificate")
    private @Nullable Output<String> certificate;

    /**
     * @return The zone&#39;s SSL certificate or certificate and the intermediate(s).
     * 
     */
    public Optional<Output<String>> certificate() {
        return Optional.ofNullable(this.certificate);
    }

    /**
     * When the certificate from the authority expires.
     * 
     */
    @Import(name="expiresOn")
    private @Nullable Output<String> expiresOn;

    /**
     * @return When the certificate from the authority expires.
     * 
     */
    public Optional<Output<String>> expiresOn() {
        return Optional.ofNullable(this.expiresOn);
    }

    /**
     * Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
     * 
     */
    @Import(name="geoRestrictions")
    private @Nullable Output<CustomSslGeoRestrictionsArgs> geoRestrictions;

    /**
     * @return Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
     * 
     */
    public Optional<Output<CustomSslGeoRestrictionsArgs>> geoRestrictions() {
        return Optional.ofNullable(this.geoRestrictions);
    }

    @Import(name="hosts")
    private @Nullable Output<List<String>> hosts;

    public Optional<Output<List<String>>> hosts() {
        return Optional.ofNullable(this.hosts);
    }

    /**
     * The certificate authority that issued the certificate.
     * 
     */
    @Import(name="issuer")
    private @Nullable Output<String> issuer;

    /**
     * @return The certificate authority that issued the certificate.
     * 
     */
    public Optional<Output<String>> issuer() {
        return Optional.ofNullable(this.issuer);
    }

    @Import(name="keylessServer")
    private @Nullable Output<CustomSslKeylessServerArgs> keylessServer;

    public Optional<Output<CustomSslKeylessServerArgs>> keylessServer() {
        return Optional.ofNullable(this.keylessServer);
    }

    /**
     * When the certificate was last modified.
     * 
     */
    @Import(name="modifiedOn")
    private @Nullable Output<String> modifiedOn;

    /**
     * @return When the certificate was last modified.
     * 
     */
    public Optional<Output<String>> modifiedOn() {
        return Optional.ofNullable(this.modifiedOn);
    }

    /**
     * Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as &#39;country: IN&#39;, as well as &#39;region: EU&#39; which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
     * 
     */
    @Import(name="policy")
    private @Nullable Output<String> policy;

    /**
     * @return Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as &#39;country: IN&#39;, as well as &#39;region: EU&#39; which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
     * 
     */
    public Optional<Output<String>> policy() {
        return Optional.ofNullable(this.policy);
    }

    /**
     * The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping &#39;legacy*custom&#39; certificates, but &#39;legacy*custom&#39; certificates will always supercede &#39;sni_custom&#39; certificates.
     * 
     */
    @Import(name="priority")
    private @Nullable Output<Double> priority;

    /**
     * @return The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping &#39;legacy*custom&#39; certificates, but &#39;legacy*custom&#39; certificates will always supercede &#39;sni_custom&#39; certificates.
     * 
     */
    public Optional<Output<Double>> priority() {
        return Optional.ofNullable(this.priority);
    }

    /**
     * The zone&#39;s private key.
     * 
     */
    @Import(name="privateKey")
    private @Nullable Output<String> privateKey;

    /**
     * @return The zone&#39;s private key.
     * 
     */
    public Optional<Output<String>> privateKey() {
        return Optional.ofNullable(this.privateKey);
    }

    /**
     * The type of hash used for the certificate.
     * 
     */
    @Import(name="signature")
    private @Nullable Output<String> signature;

    /**
     * @return The type of hash used for the certificate.
     * 
     */
    public Optional<Output<String>> signature() {
        return Optional.ofNullable(this.signature);
    }

    /**
     * Status of the zone&#39;s custom SSL.
     * 
     */
    @Import(name="status")
    private @Nullable Output<String> status;

    /**
     * @return Status of the zone&#39;s custom SSL.
     * 
     */
    public Optional<Output<String>> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * The type &#39;legacy_custom&#39; enables support for legacy clients which do not include SNI in the TLS handshake.
     * 
     */
    @Import(name="type")
    private @Nullable Output<String> type;

    /**
     * @return The type &#39;legacy_custom&#39; enables support for legacy clients which do not include SNI in the TLS handshake.
     * 
     */
    public Optional<Output<String>> type() {
        return Optional.ofNullable(this.type);
    }

    /**
     * When the certificate was uploaded to Cloudflare.
     * 
     */
    @Import(name="uploadedOn")
    private @Nullable Output<String> uploadedOn;

    /**
     * @return When the certificate was uploaded to Cloudflare.
     * 
     */
    public Optional<Output<String>> uploadedOn() {
        return Optional.ofNullable(this.uploadedOn);
    }

    /**
     * Identifier
     * 
     */
    @Import(name="zoneId")
    private @Nullable Output<String> zoneId;

    /**
     * @return Identifier
     * 
     */
    public Optional<Output<String>> zoneId() {
        return Optional.ofNullable(this.zoneId);
    }

    private CustomSslState() {}

    private CustomSslState(CustomSslState $) {
        this.bundleMethod = $.bundleMethod;
        this.certificate = $.certificate;
        this.expiresOn = $.expiresOn;
        this.geoRestrictions = $.geoRestrictions;
        this.hosts = $.hosts;
        this.issuer = $.issuer;
        this.keylessServer = $.keylessServer;
        this.modifiedOn = $.modifiedOn;
        this.policy = $.policy;
        this.priority = $.priority;
        this.privateKey = $.privateKey;
        this.signature = $.signature;
        this.status = $.status;
        this.type = $.type;
        this.uploadedOn = $.uploadedOn;
        this.zoneId = $.zoneId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(CustomSslState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private CustomSslState $;

        public Builder() {
            $ = new CustomSslState();
        }

        public Builder(CustomSslState defaults) {
            $ = new CustomSslState(Objects.requireNonNull(defaults));
        }

        /**
         * @param bundleMethod A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
         * 
         * @return builder
         * 
         */
        public Builder bundleMethod(@Nullable Output<String> bundleMethod) {
            $.bundleMethod = bundleMethod;
            return this;
        }

        /**
         * @param bundleMethod A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
         * 
         * @return builder
         * 
         */
        public Builder bundleMethod(String bundleMethod) {
            return bundleMethod(Output.of(bundleMethod));
        }

        /**
         * @param certificate The zone&#39;s SSL certificate or certificate and the intermediate(s).
         * 
         * @return builder
         * 
         */
        public Builder certificate(@Nullable Output<String> certificate) {
            $.certificate = certificate;
            return this;
        }

        /**
         * @param certificate The zone&#39;s SSL certificate or certificate and the intermediate(s).
         * 
         * @return builder
         * 
         */
        public Builder certificate(String certificate) {
            return certificate(Output.of(certificate));
        }

        /**
         * @param expiresOn When the certificate from the authority expires.
         * 
         * @return builder
         * 
         */
        public Builder expiresOn(@Nullable Output<String> expiresOn) {
            $.expiresOn = expiresOn;
            return this;
        }

        /**
         * @param expiresOn When the certificate from the authority expires.
         * 
         * @return builder
         * 
         */
        public Builder expiresOn(String expiresOn) {
            return expiresOn(Output.of(expiresOn));
        }

        /**
         * @param geoRestrictions Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
         * 
         * @return builder
         * 
         */
        public Builder geoRestrictions(@Nullable Output<CustomSslGeoRestrictionsArgs> geoRestrictions) {
            $.geoRestrictions = geoRestrictions;
            return this;
        }

        /**
         * @param geoRestrictions Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
         * 
         * @return builder
         * 
         */
        public Builder geoRestrictions(CustomSslGeoRestrictionsArgs geoRestrictions) {
            return geoRestrictions(Output.of(geoRestrictions));
        }

        public Builder hosts(@Nullable Output<List<String>> hosts) {
            $.hosts = hosts;
            return this;
        }

        public Builder hosts(List<String> hosts) {
            return hosts(Output.of(hosts));
        }

        public Builder hosts(String... hosts) {
            return hosts(List.of(hosts));
        }

        /**
         * @param issuer The certificate authority that issued the certificate.
         * 
         * @return builder
         * 
         */
        public Builder issuer(@Nullable Output<String> issuer) {
            $.issuer = issuer;
            return this;
        }

        /**
         * @param issuer The certificate authority that issued the certificate.
         * 
         * @return builder
         * 
         */
        public Builder issuer(String issuer) {
            return issuer(Output.of(issuer));
        }

        public Builder keylessServer(@Nullable Output<CustomSslKeylessServerArgs> keylessServer) {
            $.keylessServer = keylessServer;
            return this;
        }

        public Builder keylessServer(CustomSslKeylessServerArgs keylessServer) {
            return keylessServer(Output.of(keylessServer));
        }

        /**
         * @param modifiedOn When the certificate was last modified.
         * 
         * @return builder
         * 
         */
        public Builder modifiedOn(@Nullable Output<String> modifiedOn) {
            $.modifiedOn = modifiedOn;
            return this;
        }

        /**
         * @param modifiedOn When the certificate was last modified.
         * 
         * @return builder
         * 
         */
        public Builder modifiedOn(String modifiedOn) {
            return modifiedOn(Output.of(modifiedOn));
        }

        /**
         * @param policy Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as &#39;country: IN&#39;, as well as &#39;region: EU&#39; which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
         * 
         * @return builder
         * 
         */
        public Builder policy(@Nullable Output<String> policy) {
            $.policy = policy;
            return this;
        }

        /**
         * @param policy Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as &#39;country: IN&#39;, as well as &#39;region: EU&#39; which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
         * 
         * @return builder
         * 
         */
        public Builder policy(String policy) {
            return policy(Output.of(policy));
        }

        /**
         * @param priority The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping &#39;legacy*custom&#39; certificates, but &#39;legacy*custom&#39; certificates will always supercede &#39;sni_custom&#39; certificates.
         * 
         * @return builder
         * 
         */
        public Builder priority(@Nullable Output<Double> priority) {
            $.priority = priority;
            return this;
        }

        /**
         * @param priority The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping &#39;legacy*custom&#39; certificates, but &#39;legacy*custom&#39; certificates will always supercede &#39;sni_custom&#39; certificates.
         * 
         * @return builder
         * 
         */
        public Builder priority(Double priority) {
            return priority(Output.of(priority));
        }

        /**
         * @param privateKey The zone&#39;s private key.
         * 
         * @return builder
         * 
         */
        public Builder privateKey(@Nullable Output<String> privateKey) {
            $.privateKey = privateKey;
            return this;
        }

        /**
         * @param privateKey The zone&#39;s private key.
         * 
         * @return builder
         * 
         */
        public Builder privateKey(String privateKey) {
            return privateKey(Output.of(privateKey));
        }

        /**
         * @param signature The type of hash used for the certificate.
         * 
         * @return builder
         * 
         */
        public Builder signature(@Nullable Output<String> signature) {
            $.signature = signature;
            return this;
        }

        /**
         * @param signature The type of hash used for the certificate.
         * 
         * @return builder
         * 
         */
        public Builder signature(String signature) {
            return signature(Output.of(signature));
        }

        /**
         * @param status Status of the zone&#39;s custom SSL.
         * 
         * @return builder
         * 
         */
        public Builder status(@Nullable Output<String> status) {
            $.status = status;
            return this;
        }

        /**
         * @param status Status of the zone&#39;s custom SSL.
         * 
         * @return builder
         * 
         */
        public Builder status(String status) {
            return status(Output.of(status));
        }

        /**
         * @param type The type &#39;legacy_custom&#39; enables support for legacy clients which do not include SNI in the TLS handshake.
         * 
         * @return builder
         * 
         */
        public Builder type(@Nullable Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type The type &#39;legacy_custom&#39; enables support for legacy clients which do not include SNI in the TLS handshake.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        /**
         * @param uploadedOn When the certificate was uploaded to Cloudflare.
         * 
         * @return builder
         * 
         */
        public Builder uploadedOn(@Nullable Output<String> uploadedOn) {
            $.uploadedOn = uploadedOn;
            return this;
        }

        /**
         * @param uploadedOn When the certificate was uploaded to Cloudflare.
         * 
         * @return builder
         * 
         */
        public Builder uploadedOn(String uploadedOn) {
            return uploadedOn(Output.of(uploadedOn));
        }

        /**
         * @param zoneId Identifier
         * 
         * @return builder
         * 
         */
        public Builder zoneId(@Nullable Output<String> zoneId) {
            $.zoneId = zoneId;
            return this;
        }

        /**
         * @param zoneId Identifier
         * 
         * @return builder
         * 
         */
        public Builder zoneId(String zoneId) {
            return zoneId(Output.of(zoneId));
        }

        public CustomSslState build() {
            return $;
        }
    }

}
