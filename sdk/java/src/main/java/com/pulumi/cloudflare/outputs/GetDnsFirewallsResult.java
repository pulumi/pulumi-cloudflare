// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.outputs;

import com.pulumi.cloudflare.outputs.GetDnsFirewallsResultAttackMitigation;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetDnsFirewallsResult {
    /**
     * @return Attack mitigation settings
     * 
     */
    private GetDnsFirewallsResultAttackMitigation attackMitigation;
    /**
     * @return Whether to refuse to answer queries for the ANY type
     * 
     */
    private Boolean deprecateAnyRequests;
    private List<String> dnsFirewallIps;
    /**
     * @return Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     * 
     */
    private Boolean ecsFallback;
    /**
     * @return Identifier.
     * 
     */
    private String id;
    /**
     * @return Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
     * 
     */
    private Double maximumCacheTtl;
    /**
     * @return Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
     * 
     */
    private Double minimumCacheTtl;
    /**
     * @return Last modification of DNS Firewall cluster
     * 
     */
    private String modifiedOn;
    /**
     * @return DNS Firewall cluster name
     * 
     */
    private String name;
    /**
     * @return Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
     * 
     */
    private Double negativeCacheTtl;
    /**
     * @return Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
     * 
     */
    private Double ratelimit;
    /**
     * @return Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
     * 
     */
    private Double retries;
    private List<String> upstreamIps;

    private GetDnsFirewallsResult() {}
    /**
     * @return Attack mitigation settings
     * 
     */
    public GetDnsFirewallsResultAttackMitigation attackMitigation() {
        return this.attackMitigation;
    }
    /**
     * @return Whether to refuse to answer queries for the ANY type
     * 
     */
    public Boolean deprecateAnyRequests() {
        return this.deprecateAnyRequests;
    }
    public List<String> dnsFirewallIps() {
        return this.dnsFirewallIps;
    }
    /**
     * @return Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     * 
     */
    public Boolean ecsFallback() {
        return this.ecsFallback;
    }
    /**
     * @return Identifier.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
     * 
     */
    public Double maximumCacheTtl() {
        return this.maximumCacheTtl;
    }
    /**
     * @return Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
     * 
     */
    public Double minimumCacheTtl() {
        return this.minimumCacheTtl;
    }
    /**
     * @return Last modification of DNS Firewall cluster
     * 
     */
    public String modifiedOn() {
        return this.modifiedOn;
    }
    /**
     * @return DNS Firewall cluster name
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
     * 
     */
    public Double negativeCacheTtl() {
        return this.negativeCacheTtl;
    }
    /**
     * @return Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
     * 
     */
    public Double ratelimit() {
        return this.ratelimit;
    }
    /**
     * @return Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
     * 
     */
    public Double retries() {
        return this.retries;
    }
    public List<String> upstreamIps() {
        return this.upstreamIps;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDnsFirewallsResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private GetDnsFirewallsResultAttackMitigation attackMitigation;
        private Boolean deprecateAnyRequests;
        private List<String> dnsFirewallIps;
        private Boolean ecsFallback;
        private String id;
        private Double maximumCacheTtl;
        private Double minimumCacheTtl;
        private String modifiedOn;
        private String name;
        private Double negativeCacheTtl;
        private Double ratelimit;
        private Double retries;
        private List<String> upstreamIps;
        public Builder() {}
        public Builder(GetDnsFirewallsResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.attackMitigation = defaults.attackMitigation;
    	      this.deprecateAnyRequests = defaults.deprecateAnyRequests;
    	      this.dnsFirewallIps = defaults.dnsFirewallIps;
    	      this.ecsFallback = defaults.ecsFallback;
    	      this.id = defaults.id;
    	      this.maximumCacheTtl = defaults.maximumCacheTtl;
    	      this.minimumCacheTtl = defaults.minimumCacheTtl;
    	      this.modifiedOn = defaults.modifiedOn;
    	      this.name = defaults.name;
    	      this.negativeCacheTtl = defaults.negativeCacheTtl;
    	      this.ratelimit = defaults.ratelimit;
    	      this.retries = defaults.retries;
    	      this.upstreamIps = defaults.upstreamIps;
        }

        @CustomType.Setter
        public Builder attackMitigation(GetDnsFirewallsResultAttackMitigation attackMitigation) {
            if (attackMitigation == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "attackMitigation");
            }
            this.attackMitigation = attackMitigation;
            return this;
        }
        @CustomType.Setter
        public Builder deprecateAnyRequests(Boolean deprecateAnyRequests) {
            if (deprecateAnyRequests == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "deprecateAnyRequests");
            }
            this.deprecateAnyRequests = deprecateAnyRequests;
            return this;
        }
        @CustomType.Setter
        public Builder dnsFirewallIps(List<String> dnsFirewallIps) {
            if (dnsFirewallIps == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "dnsFirewallIps");
            }
            this.dnsFirewallIps = dnsFirewallIps;
            return this;
        }
        public Builder dnsFirewallIps(String... dnsFirewallIps) {
            return dnsFirewallIps(List.of(dnsFirewallIps));
        }
        @CustomType.Setter
        public Builder ecsFallback(Boolean ecsFallback) {
            if (ecsFallback == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "ecsFallback");
            }
            this.ecsFallback = ecsFallback;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder maximumCacheTtl(Double maximumCacheTtl) {
            if (maximumCacheTtl == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "maximumCacheTtl");
            }
            this.maximumCacheTtl = maximumCacheTtl;
            return this;
        }
        @CustomType.Setter
        public Builder minimumCacheTtl(Double minimumCacheTtl) {
            if (minimumCacheTtl == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "minimumCacheTtl");
            }
            this.minimumCacheTtl = minimumCacheTtl;
            return this;
        }
        @CustomType.Setter
        public Builder modifiedOn(String modifiedOn) {
            if (modifiedOn == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "modifiedOn");
            }
            this.modifiedOn = modifiedOn;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder negativeCacheTtl(Double negativeCacheTtl) {
            if (negativeCacheTtl == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "negativeCacheTtl");
            }
            this.negativeCacheTtl = negativeCacheTtl;
            return this;
        }
        @CustomType.Setter
        public Builder ratelimit(Double ratelimit) {
            if (ratelimit == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "ratelimit");
            }
            this.ratelimit = ratelimit;
            return this;
        }
        @CustomType.Setter
        public Builder retries(Double retries) {
            if (retries == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "retries");
            }
            this.retries = retries;
            return this;
        }
        @CustomType.Setter
        public Builder upstreamIps(List<String> upstreamIps) {
            if (upstreamIps == null) {
              throw new MissingRequiredPropertyException("GetDnsFirewallsResult", "upstreamIps");
            }
            this.upstreamIps = upstreamIps;
            return this;
        }
        public Builder upstreamIps(String... upstreamIps) {
            return upstreamIps(List.of(upstreamIps));
        }
        public GetDnsFirewallsResult build() {
            final var _resultValue = new GetDnsFirewallsResult();
            _resultValue.attackMitigation = attackMitigation;
            _resultValue.deprecateAnyRequests = deprecateAnyRequests;
            _resultValue.dnsFirewallIps = dnsFirewallIps;
            _resultValue.ecsFallback = ecsFallback;
            _resultValue.id = id;
            _resultValue.maximumCacheTtl = maximumCacheTtl;
            _resultValue.minimumCacheTtl = minimumCacheTtl;
            _resultValue.modifiedOn = modifiedOn;
            _resultValue.name = name;
            _resultValue.negativeCacheTtl = negativeCacheTtl;
            _resultValue.ratelimit = ratelimit;
            _resultValue.retries = retries;
            _resultValue.upstreamIps = upstreamIps;
            return _resultValue;
        }
    }
}
