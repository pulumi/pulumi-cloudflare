// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.outputs;

import com.pulumi.cloudflare.outputs.GetDnsRecordFilterComment;
import com.pulumi.cloudflare.outputs.GetDnsRecordFilterContent;
import com.pulumi.cloudflare.outputs.GetDnsRecordFilterName;
import com.pulumi.cloudflare.outputs.GetDnsRecordFilterTag;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetDnsRecordFilter {
    private @Nullable GetDnsRecordFilterComment comment;
    private @Nullable GetDnsRecordFilterContent content;
    /**
     * @return Direction to order DNS records in.
     * Available values: &#34;asc&#34;, &#34;desc&#34;.
     * 
     */
    private String direction;
    /**
     * @return Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    private String match;
    private @Nullable GetDnsRecordFilterName name;
    /**
     * @return Field to order DNS records by.
     * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
     * 
     */
    private String order;
    /**
     * @return Whether the record is receiving the performance and security benefits of Cloudflare.
     * 
     */
    private Boolean proxied;
    /**
     * @return Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
     * 
     */
    private @Nullable String search;
    private @Nullable GetDnsRecordFilterTag tag;
    /**
     * @return Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    private String tagMatch;
    /**
     * @return Record type.
     * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
     * 
     */
    private @Nullable String type;

    private GetDnsRecordFilter() {}
    public Optional<GetDnsRecordFilterComment> comment() {
        return Optional.ofNullable(this.comment);
    }
    public Optional<GetDnsRecordFilterContent> content() {
        return Optional.ofNullable(this.content);
    }
    /**
     * @return Direction to order DNS records in.
     * Available values: &#34;asc&#34;, &#34;desc&#34;.
     * 
     */
    public String direction() {
        return this.direction;
    }
    /**
     * @return Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    public String match() {
        return this.match;
    }
    public Optional<GetDnsRecordFilterName> name() {
        return Optional.ofNullable(this.name);
    }
    /**
     * @return Field to order DNS records by.
     * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
     * 
     */
    public String order() {
        return this.order;
    }
    /**
     * @return Whether the record is receiving the performance and security benefits of Cloudflare.
     * 
     */
    public Boolean proxied() {
        return this.proxied;
    }
    /**
     * @return Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
     * 
     */
    public Optional<String> search() {
        return Optional.ofNullable(this.search);
    }
    public Optional<GetDnsRecordFilterTag> tag() {
        return Optional.ofNullable(this.tag);
    }
    /**
     * @return Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    public String tagMatch() {
        return this.tagMatch;
    }
    /**
     * @return Record type.
     * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
     * 
     */
    public Optional<String> type() {
        return Optional.ofNullable(this.type);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDnsRecordFilter defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable GetDnsRecordFilterComment comment;
        private @Nullable GetDnsRecordFilterContent content;
        private String direction;
        private String match;
        private @Nullable GetDnsRecordFilterName name;
        private String order;
        private Boolean proxied;
        private @Nullable String search;
        private @Nullable GetDnsRecordFilterTag tag;
        private String tagMatch;
        private @Nullable String type;
        public Builder() {}
        public Builder(GetDnsRecordFilter defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.comment = defaults.comment;
    	      this.content = defaults.content;
    	      this.direction = defaults.direction;
    	      this.match = defaults.match;
    	      this.name = defaults.name;
    	      this.order = defaults.order;
    	      this.proxied = defaults.proxied;
    	      this.search = defaults.search;
    	      this.tag = defaults.tag;
    	      this.tagMatch = defaults.tagMatch;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder comment(@Nullable GetDnsRecordFilterComment comment) {

            this.comment = comment;
            return this;
        }
        @CustomType.Setter
        public Builder content(@Nullable GetDnsRecordFilterContent content) {

            this.content = content;
            return this;
        }
        @CustomType.Setter
        public Builder direction(String direction) {
            if (direction == null) {
              throw new MissingRequiredPropertyException("GetDnsRecordFilter", "direction");
            }
            this.direction = direction;
            return this;
        }
        @CustomType.Setter
        public Builder match(String match) {
            if (match == null) {
              throw new MissingRequiredPropertyException("GetDnsRecordFilter", "match");
            }
            this.match = match;
            return this;
        }
        @CustomType.Setter
        public Builder name(@Nullable GetDnsRecordFilterName name) {

            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder order(String order) {
            if (order == null) {
              throw new MissingRequiredPropertyException("GetDnsRecordFilter", "order");
            }
            this.order = order;
            return this;
        }
        @CustomType.Setter
        public Builder proxied(Boolean proxied) {
            if (proxied == null) {
              throw new MissingRequiredPropertyException("GetDnsRecordFilter", "proxied");
            }
            this.proxied = proxied;
            return this;
        }
        @CustomType.Setter
        public Builder search(@Nullable String search) {

            this.search = search;
            return this;
        }
        @CustomType.Setter
        public Builder tag(@Nullable GetDnsRecordFilterTag tag) {

            this.tag = tag;
            return this;
        }
        @CustomType.Setter
        public Builder tagMatch(String tagMatch) {
            if (tagMatch == null) {
              throw new MissingRequiredPropertyException("GetDnsRecordFilter", "tagMatch");
            }
            this.tagMatch = tagMatch;
            return this;
        }
        @CustomType.Setter
        public Builder type(@Nullable String type) {

            this.type = type;
            return this;
        }
        public GetDnsRecordFilter build() {
            final var _resultValue = new GetDnsRecordFilter();
            _resultValue.comment = comment;
            _resultValue.content = content;
            _resultValue.direction = direction;
            _resultValue.match = match;
            _resultValue.name = name;
            _resultValue.order = order;
            _resultValue.proxied = proxied;
            _resultValue.search = search;
            _resultValue.tag = tag;
            _resultValue.tagMatch = tagMatch;
            _resultValue.type = type;
            return _resultValue;
        }
    }
}
