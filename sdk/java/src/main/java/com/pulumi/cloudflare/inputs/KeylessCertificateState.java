// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.cloudflare.inputs.KeylessCertificateTunnelArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class KeylessCertificateState extends com.pulumi.resources.ResourceArgs {

    public static final KeylessCertificateState Empty = new KeylessCertificateState();

    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * Available values: &#34;ubiquitous&#34;, &#34;optimal&#34;, &#34;force&#34;.
     * 
     */
    @Import(name="bundleMethod")
    private @Nullable Output<String> bundleMethod;

    /**
     * @return A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * Available values: &#34;ubiquitous&#34;, &#34;optimal&#34;, &#34;force&#34;.
     * 
     */
    public Optional<Output<String>> bundleMethod() {
        return Optional.ofNullable(this.bundleMethod);
    }

    /**
     * The zone&#39;s SSL certificate or SSL certificate and intermediate(s).
     * 
     */
    @Import(name="certificate")
    private @Nullable Output<String> certificate;

    /**
     * @return The zone&#39;s SSL certificate or SSL certificate and intermediate(s).
     * 
     */
    public Optional<Output<String>> certificate() {
        return Optional.ofNullable(this.certificate);
    }

    /**
     * When the Keyless SSL was created.
     * 
     */
    @Import(name="createdOn")
    private @Nullable Output<String> createdOn;

    /**
     * @return When the Keyless SSL was created.
     * 
     */
    public Optional<Output<String>> createdOn() {
        return Optional.ofNullable(this.createdOn);
    }

    /**
     * Whether or not the Keyless SSL is on or off.
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return Whether or not the Keyless SSL is on or off.
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * The keyless SSL name.
     * 
     */
    @Import(name="host")
    private @Nullable Output<String> host;

    /**
     * @return The keyless SSL name.
     * 
     */
    public Optional<Output<String>> host() {
        return Optional.ofNullable(this.host);
    }

    /**
     * When the Keyless SSL was last modified.
     * 
     */
    @Import(name="modifiedOn")
    private @Nullable Output<String> modifiedOn;

    /**
     * @return When the Keyless SSL was last modified.
     * 
     */
    public Optional<Output<String>> modifiedOn() {
        return Optional.ofNullable(this.modifiedOn);
    }

    /**
     * The keyless SSL name.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The keyless SSL name.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     * 
     */
    @Import(name="permissions")
    private @Nullable Output<List<String>> permissions;

    /**
     * @return Available permissions for the Keyless SSL for the current user requesting the item.
     * 
     */
    public Optional<Output<List<String>>> permissions() {
        return Optional.ofNullable(this.permissions);
    }

    /**
     * The keyless SSL port used to communicate between Cloudflare and the client&#39;s Keyless SSL server.
     * 
     */
    @Import(name="port")
    private @Nullable Output<Double> port;

    /**
     * @return The keyless SSL port used to communicate between Cloudflare and the client&#39;s Keyless SSL server.
     * 
     */
    public Optional<Output<Double>> port() {
        return Optional.ofNullable(this.port);
    }

    /**
     * Status of the Keyless SSL.
     * Available values: &#34;active&#34;, &#34;deleted&#34;.
     * 
     */
    @Import(name="status")
    private @Nullable Output<String> status;

    /**
     * @return Status of the Keyless SSL.
     * Available values: &#34;active&#34;, &#34;deleted&#34;.
     * 
     */
    public Optional<Output<String>> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     * 
     */
    @Import(name="tunnel")
    private @Nullable Output<KeylessCertificateTunnelArgs> tunnel;

    /**
     * @return Configuration for using Keyless SSL through a Cloudflare Tunnel
     * 
     */
    public Optional<Output<KeylessCertificateTunnelArgs>> tunnel() {
        return Optional.ofNullable(this.tunnel);
    }

    /**
     * Identifier
     * 
     */
    @Import(name="zoneId")
    private @Nullable Output<String> zoneId;

    /**
     * @return Identifier
     * 
     */
    public Optional<Output<String>> zoneId() {
        return Optional.ofNullable(this.zoneId);
    }

    private KeylessCertificateState() {}

    private KeylessCertificateState(KeylessCertificateState $) {
        this.bundleMethod = $.bundleMethod;
        this.certificate = $.certificate;
        this.createdOn = $.createdOn;
        this.enabled = $.enabled;
        this.host = $.host;
        this.modifiedOn = $.modifiedOn;
        this.name = $.name;
        this.permissions = $.permissions;
        this.port = $.port;
        this.status = $.status;
        this.tunnel = $.tunnel;
        this.zoneId = $.zoneId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(KeylessCertificateState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private KeylessCertificateState $;

        public Builder() {
            $ = new KeylessCertificateState();
        }

        public Builder(KeylessCertificateState defaults) {
            $ = new KeylessCertificateState(Objects.requireNonNull(defaults));
        }

        /**
         * @param bundleMethod A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
         * Available values: &#34;ubiquitous&#34;, &#34;optimal&#34;, &#34;force&#34;.
         * 
         * @return builder
         * 
         */
        public Builder bundleMethod(@Nullable Output<String> bundleMethod) {
            $.bundleMethod = bundleMethod;
            return this;
        }

        /**
         * @param bundleMethod A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
         * Available values: &#34;ubiquitous&#34;, &#34;optimal&#34;, &#34;force&#34;.
         * 
         * @return builder
         * 
         */
        public Builder bundleMethod(String bundleMethod) {
            return bundleMethod(Output.of(bundleMethod));
        }

        /**
         * @param certificate The zone&#39;s SSL certificate or SSL certificate and intermediate(s).
         * 
         * @return builder
         * 
         */
        public Builder certificate(@Nullable Output<String> certificate) {
            $.certificate = certificate;
            return this;
        }

        /**
         * @param certificate The zone&#39;s SSL certificate or SSL certificate and intermediate(s).
         * 
         * @return builder
         * 
         */
        public Builder certificate(String certificate) {
            return certificate(Output.of(certificate));
        }

        /**
         * @param createdOn When the Keyless SSL was created.
         * 
         * @return builder
         * 
         */
        public Builder createdOn(@Nullable Output<String> createdOn) {
            $.createdOn = createdOn;
            return this;
        }

        /**
         * @param createdOn When the Keyless SSL was created.
         * 
         * @return builder
         * 
         */
        public Builder createdOn(String createdOn) {
            return createdOn(Output.of(createdOn));
        }

        /**
         * @param enabled Whether or not the Keyless SSL is on or off.
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Whether or not the Keyless SSL is on or off.
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param host The keyless SSL name.
         * 
         * @return builder
         * 
         */
        public Builder host(@Nullable Output<String> host) {
            $.host = host;
            return this;
        }

        /**
         * @param host The keyless SSL name.
         * 
         * @return builder
         * 
         */
        public Builder host(String host) {
            return host(Output.of(host));
        }

        /**
         * @param modifiedOn When the Keyless SSL was last modified.
         * 
         * @return builder
         * 
         */
        public Builder modifiedOn(@Nullable Output<String> modifiedOn) {
            $.modifiedOn = modifiedOn;
            return this;
        }

        /**
         * @param modifiedOn When the Keyless SSL was last modified.
         * 
         * @return builder
         * 
         */
        public Builder modifiedOn(String modifiedOn) {
            return modifiedOn(Output.of(modifiedOn));
        }

        /**
         * @param name The keyless SSL name.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The keyless SSL name.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param permissions Available permissions for the Keyless SSL for the current user requesting the item.
         * 
         * @return builder
         * 
         */
        public Builder permissions(@Nullable Output<List<String>> permissions) {
            $.permissions = permissions;
            return this;
        }

        /**
         * @param permissions Available permissions for the Keyless SSL for the current user requesting the item.
         * 
         * @return builder
         * 
         */
        public Builder permissions(List<String> permissions) {
            return permissions(Output.of(permissions));
        }

        /**
         * @param permissions Available permissions for the Keyless SSL for the current user requesting the item.
         * 
         * @return builder
         * 
         */
        public Builder permissions(String... permissions) {
            return permissions(List.of(permissions));
        }

        /**
         * @param port The keyless SSL port used to communicate between Cloudflare and the client&#39;s Keyless SSL server.
         * 
         * @return builder
         * 
         */
        public Builder port(@Nullable Output<Double> port) {
            $.port = port;
            return this;
        }

        /**
         * @param port The keyless SSL port used to communicate between Cloudflare and the client&#39;s Keyless SSL server.
         * 
         * @return builder
         * 
         */
        public Builder port(Double port) {
            return port(Output.of(port));
        }

        /**
         * @param status Status of the Keyless SSL.
         * Available values: &#34;active&#34;, &#34;deleted&#34;.
         * 
         * @return builder
         * 
         */
        public Builder status(@Nullable Output<String> status) {
            $.status = status;
            return this;
        }

        /**
         * @param status Status of the Keyless SSL.
         * Available values: &#34;active&#34;, &#34;deleted&#34;.
         * 
         * @return builder
         * 
         */
        public Builder status(String status) {
            return status(Output.of(status));
        }

        /**
         * @param tunnel Configuration for using Keyless SSL through a Cloudflare Tunnel
         * 
         * @return builder
         * 
         */
        public Builder tunnel(@Nullable Output<KeylessCertificateTunnelArgs> tunnel) {
            $.tunnel = tunnel;
            return this;
        }

        /**
         * @param tunnel Configuration for using Keyless SSL through a Cloudflare Tunnel
         * 
         * @return builder
         * 
         */
        public Builder tunnel(KeylessCertificateTunnelArgs tunnel) {
            return tunnel(Output.of(tunnel));
        }

        /**
         * @param zoneId Identifier
         * 
         * @return builder
         * 
         */
        public Builder zoneId(@Nullable Output<String> zoneId) {
            $.zoneId = zoneId;
            return this;
        }

        /**
         * @param zoneId Identifier
         * 
         * @return builder
         * 
         */
        public Builder zoneId(String zoneId) {
            return zoneId(Output.of(zoneId));
        }

        public KeylessCertificateState build() {
            return $;
        }
    }

}
