// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.cloudflare.inputs.LoadBalancerRuleOverrideAdaptiveRoutingArgs;
import com.pulumi.cloudflare.inputs.LoadBalancerRuleOverrideCountryPoolArgs;
import com.pulumi.cloudflare.inputs.LoadBalancerRuleOverrideLocationStrategyArgs;
import com.pulumi.cloudflare.inputs.LoadBalancerRuleOverridePopPoolArgs;
import com.pulumi.cloudflare.inputs.LoadBalancerRuleOverrideRandomSteeringArgs;
import com.pulumi.cloudflare.inputs.LoadBalancerRuleOverrideRegionPoolArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class LoadBalancerRuleOverrideArgs extends com.pulumi.resources.ResourceArgs {

    public static final LoadBalancerRuleOverrideArgs Empty = new LoadBalancerRuleOverrideArgs();

    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
     * 
     */
    @Import(name="adaptiveRoutings")
    private @Nullable Output<List<LoadBalancerRuleOverrideAdaptiveRoutingArgs>> adaptiveRoutings;

    /**
     * @return Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
     * 
     */
    public Optional<Output<List<LoadBalancerRuleOverrideAdaptiveRoutingArgs>>> adaptiveRoutings() {
        return Optional.ofNullable(this.adaptiveRoutings);
    }

    /**
     * A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
     * 
     */
    @Import(name="countryPools")
    private @Nullable Output<List<LoadBalancerRuleOverrideCountryPoolArgs>> countryPools;

    /**
     * @return A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
     * 
     */
    public Optional<Output<List<LoadBalancerRuleOverrideCountryPoolArgs>>> countryPools() {
        return Optional.ofNullable(this.countryPools);
    }

    @Import(name="defaultPools")
    private @Nullable Output<List<String>> defaultPools;

    public Optional<Output<List<String>>> defaultPools() {
        return Optional.ofNullable(this.defaultPools);
    }

    @Import(name="fallbackPool")
    private @Nullable Output<String> fallbackPool;

    public Optional<Output<String>> fallbackPool() {
        return Optional.ofNullable(this.fallbackPool);
    }

    /**
     * Controls location-based steering for non-proxied requests.
     * 
     */
    @Import(name="locationStrategies")
    private @Nullable Output<List<LoadBalancerRuleOverrideLocationStrategyArgs>> locationStrategies;

    /**
     * @return Controls location-based steering for non-proxied requests.
     * 
     */
    public Optional<Output<List<LoadBalancerRuleOverrideLocationStrategyArgs>>> locationStrategies() {
        return Optional.ofNullable(this.locationStrategies);
    }

    /**
     * A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
     * 
     */
    @Import(name="popPools")
    private @Nullable Output<List<LoadBalancerRuleOverridePopPoolArgs>> popPools;

    /**
     * @return A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
     * 
     */
    public Optional<Output<List<LoadBalancerRuleOverridePopPoolArgs>>> popPools() {
        return Optional.ofNullable(this.popPools);
    }

    /**
     * Configures pool weights for random steering. When the `steering_policy=&#34;random&#34;`, a random pool is selected with probability proportional to these pool weights.
     * 
     */
    @Import(name="randomSteerings")
    private @Nullable Output<List<LoadBalancerRuleOverrideRandomSteeringArgs>> randomSteerings;

    /**
     * @return Configures pool weights for random steering. When the `steering_policy=&#34;random&#34;`, a random pool is selected with probability proportional to these pool weights.
     * 
     */
    public Optional<Output<List<LoadBalancerRuleOverrideRandomSteeringArgs>>> randomSteerings() {
        return Optional.ofNullable(this.randomSteerings);
    }

    /**
     * A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
     * 
     */
    @Import(name="regionPools")
    private @Nullable Output<List<LoadBalancerRuleOverrideRegionPoolArgs>> regionPools;

    /**
     * @return A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
     * 
     */
    public Optional<Output<List<LoadBalancerRuleOverrideRegionPoolArgs>>> regionPools() {
        return Optional.ofNullable(this.regionPools);
    }

    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `none` or `&#34;&#34;` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client&#39;s IP address. Available values: `&#34;&#34;`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.
     * 
     */
    @Import(name="sessionAffinity")
    private @Nullable Output<String> sessionAffinity;

    /**
     * @return Specifies the type of session affinity the load balancer should use unless specified as `none` or `&#34;&#34;` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client&#39;s IP address. Available values: `&#34;&#34;`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.
     * 
     */
    public Optional<Output<String>> sessionAffinity() {
        return Optional.ofNullable(this.sessionAffinity);
    }

    /**
     * See `session_affinity_attributes`.
     * 
     */
    @Import(name="sessionAffinityAttributes")
    private @Nullable Output<Map<String,String>> sessionAffinityAttributes;

    /**
     * @return See `session_affinity_attributes`.
     * 
     */
    public Optional<Output<Map<String,String>>> sessionAffinityAttributes() {
        return Optional.ofNullable(this.sessionAffinityAttributes);
    }

    /**
     * Time, in seconds, until this load balancer&#39;s session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
     * 
     */
    @Import(name="sessionAffinityTtl")
    private @Nullable Output<Integer> sessionAffinityTtl;

    /**
     * @return Time, in seconds, until this load balancer&#39;s session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
     * 
     */
    public Optional<Output<Integer>> sessionAffinityTtl() {
        return Optional.ofNullable(this.sessionAffinityTtl);
    }

    /**
     * The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools&#39; latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `&#34;&#34;` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `&#34;&#34;` Defaults to `&#34;&#34;`.
     * 
     */
    @Import(name="steeringPolicy")
    private @Nullable Output<String> steeringPolicy;

    /**
     * @return The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools&#39; latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `&#34;&#34;` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `&#34;&#34;` Defaults to `&#34;&#34;`.
     * 
     */
    public Optional<Output<String>> steeringPolicy() {
        return Optional.ofNullable(this.steeringPolicy);
    }

    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.
     * 
     */
    @Import(name="ttl")
    private @Nullable Output<Integer> ttl;

    /**
     * @return Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.
     * 
     */
    public Optional<Output<Integer>> ttl() {
        return Optional.ofNullable(this.ttl);
    }

    private LoadBalancerRuleOverrideArgs() {}

    private LoadBalancerRuleOverrideArgs(LoadBalancerRuleOverrideArgs $) {
        this.adaptiveRoutings = $.adaptiveRoutings;
        this.countryPools = $.countryPools;
        this.defaultPools = $.defaultPools;
        this.fallbackPool = $.fallbackPool;
        this.locationStrategies = $.locationStrategies;
        this.popPools = $.popPools;
        this.randomSteerings = $.randomSteerings;
        this.regionPools = $.regionPools;
        this.sessionAffinity = $.sessionAffinity;
        this.sessionAffinityAttributes = $.sessionAffinityAttributes;
        this.sessionAffinityTtl = $.sessionAffinityTtl;
        this.steeringPolicy = $.steeringPolicy;
        this.ttl = $.ttl;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(LoadBalancerRuleOverrideArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private LoadBalancerRuleOverrideArgs $;

        public Builder() {
            $ = new LoadBalancerRuleOverrideArgs();
        }

        public Builder(LoadBalancerRuleOverrideArgs defaults) {
            $ = new LoadBalancerRuleOverrideArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param adaptiveRoutings Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
         * 
         * @return builder
         * 
         */
        public Builder adaptiveRoutings(@Nullable Output<List<LoadBalancerRuleOverrideAdaptiveRoutingArgs>> adaptiveRoutings) {
            $.adaptiveRoutings = adaptiveRoutings;
            return this;
        }

        /**
         * @param adaptiveRoutings Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
         * 
         * @return builder
         * 
         */
        public Builder adaptiveRoutings(List<LoadBalancerRuleOverrideAdaptiveRoutingArgs> adaptiveRoutings) {
            return adaptiveRoutings(Output.of(adaptiveRoutings));
        }

        /**
         * @param adaptiveRoutings Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
         * 
         * @return builder
         * 
         */
        public Builder adaptiveRoutings(LoadBalancerRuleOverrideAdaptiveRoutingArgs... adaptiveRoutings) {
            return adaptiveRoutings(List.of(adaptiveRoutings));
        }

        /**
         * @param countryPools A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
         * 
         * @return builder
         * 
         */
        public Builder countryPools(@Nullable Output<List<LoadBalancerRuleOverrideCountryPoolArgs>> countryPools) {
            $.countryPools = countryPools;
            return this;
        }

        /**
         * @param countryPools A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
         * 
         * @return builder
         * 
         */
        public Builder countryPools(List<LoadBalancerRuleOverrideCountryPoolArgs> countryPools) {
            return countryPools(Output.of(countryPools));
        }

        /**
         * @param countryPools A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
         * 
         * @return builder
         * 
         */
        public Builder countryPools(LoadBalancerRuleOverrideCountryPoolArgs... countryPools) {
            return countryPools(List.of(countryPools));
        }

        public Builder defaultPools(@Nullable Output<List<String>> defaultPools) {
            $.defaultPools = defaultPools;
            return this;
        }

        public Builder defaultPools(List<String> defaultPools) {
            return defaultPools(Output.of(defaultPools));
        }

        public Builder defaultPools(String... defaultPools) {
            return defaultPools(List.of(defaultPools));
        }

        public Builder fallbackPool(@Nullable Output<String> fallbackPool) {
            $.fallbackPool = fallbackPool;
            return this;
        }

        public Builder fallbackPool(String fallbackPool) {
            return fallbackPool(Output.of(fallbackPool));
        }

        /**
         * @param locationStrategies Controls location-based steering for non-proxied requests.
         * 
         * @return builder
         * 
         */
        public Builder locationStrategies(@Nullable Output<List<LoadBalancerRuleOverrideLocationStrategyArgs>> locationStrategies) {
            $.locationStrategies = locationStrategies;
            return this;
        }

        /**
         * @param locationStrategies Controls location-based steering for non-proxied requests.
         * 
         * @return builder
         * 
         */
        public Builder locationStrategies(List<LoadBalancerRuleOverrideLocationStrategyArgs> locationStrategies) {
            return locationStrategies(Output.of(locationStrategies));
        }

        /**
         * @param locationStrategies Controls location-based steering for non-proxied requests.
         * 
         * @return builder
         * 
         */
        public Builder locationStrategies(LoadBalancerRuleOverrideLocationStrategyArgs... locationStrategies) {
            return locationStrategies(List.of(locationStrategies));
        }

        /**
         * @param popPools A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
         * 
         * @return builder
         * 
         */
        public Builder popPools(@Nullable Output<List<LoadBalancerRuleOverridePopPoolArgs>> popPools) {
            $.popPools = popPools;
            return this;
        }

        /**
         * @param popPools A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
         * 
         * @return builder
         * 
         */
        public Builder popPools(List<LoadBalancerRuleOverridePopPoolArgs> popPools) {
            return popPools(Output.of(popPools));
        }

        /**
         * @param popPools A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
         * 
         * @return builder
         * 
         */
        public Builder popPools(LoadBalancerRuleOverridePopPoolArgs... popPools) {
            return popPools(List.of(popPools));
        }

        /**
         * @param randomSteerings Configures pool weights for random steering. When the `steering_policy=&#34;random&#34;`, a random pool is selected with probability proportional to these pool weights.
         * 
         * @return builder
         * 
         */
        public Builder randomSteerings(@Nullable Output<List<LoadBalancerRuleOverrideRandomSteeringArgs>> randomSteerings) {
            $.randomSteerings = randomSteerings;
            return this;
        }

        /**
         * @param randomSteerings Configures pool weights for random steering. When the `steering_policy=&#34;random&#34;`, a random pool is selected with probability proportional to these pool weights.
         * 
         * @return builder
         * 
         */
        public Builder randomSteerings(List<LoadBalancerRuleOverrideRandomSteeringArgs> randomSteerings) {
            return randomSteerings(Output.of(randomSteerings));
        }

        /**
         * @param randomSteerings Configures pool weights for random steering. When the `steering_policy=&#34;random&#34;`, a random pool is selected with probability proportional to these pool weights.
         * 
         * @return builder
         * 
         */
        public Builder randomSteerings(LoadBalancerRuleOverrideRandomSteeringArgs... randomSteerings) {
            return randomSteerings(List.of(randomSteerings));
        }

        /**
         * @param regionPools A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
         * 
         * @return builder
         * 
         */
        public Builder regionPools(@Nullable Output<List<LoadBalancerRuleOverrideRegionPoolArgs>> regionPools) {
            $.regionPools = regionPools;
            return this;
        }

        /**
         * @param regionPools A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
         * 
         * @return builder
         * 
         */
        public Builder regionPools(List<LoadBalancerRuleOverrideRegionPoolArgs> regionPools) {
            return regionPools(Output.of(regionPools));
        }

        /**
         * @param regionPools A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
         * 
         * @return builder
         * 
         */
        public Builder regionPools(LoadBalancerRuleOverrideRegionPoolArgs... regionPools) {
            return regionPools(List.of(regionPools));
        }

        /**
         * @param sessionAffinity Specifies the type of session affinity the load balancer should use unless specified as `none` or `&#34;&#34;` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client&#39;s IP address. Available values: `&#34;&#34;`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.
         * 
         * @return builder
         * 
         */
        public Builder sessionAffinity(@Nullable Output<String> sessionAffinity) {
            $.sessionAffinity = sessionAffinity;
            return this;
        }

        /**
         * @param sessionAffinity Specifies the type of session affinity the load balancer should use unless specified as `none` or `&#34;&#34;` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client&#39;s IP address. Available values: `&#34;&#34;`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.
         * 
         * @return builder
         * 
         */
        public Builder sessionAffinity(String sessionAffinity) {
            return sessionAffinity(Output.of(sessionAffinity));
        }

        /**
         * @param sessionAffinityAttributes See `session_affinity_attributes`.
         * 
         * @return builder
         * 
         */
        public Builder sessionAffinityAttributes(@Nullable Output<Map<String,String>> sessionAffinityAttributes) {
            $.sessionAffinityAttributes = sessionAffinityAttributes;
            return this;
        }

        /**
         * @param sessionAffinityAttributes See `session_affinity_attributes`.
         * 
         * @return builder
         * 
         */
        public Builder sessionAffinityAttributes(Map<String,String> sessionAffinityAttributes) {
            return sessionAffinityAttributes(Output.of(sessionAffinityAttributes));
        }

        /**
         * @param sessionAffinityTtl Time, in seconds, until this load balancer&#39;s session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
         * 
         * @return builder
         * 
         */
        public Builder sessionAffinityTtl(@Nullable Output<Integer> sessionAffinityTtl) {
            $.sessionAffinityTtl = sessionAffinityTtl;
            return this;
        }

        /**
         * @param sessionAffinityTtl Time, in seconds, until this load balancer&#39;s session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
         * 
         * @return builder
         * 
         */
        public Builder sessionAffinityTtl(Integer sessionAffinityTtl) {
            return sessionAffinityTtl(Output.of(sessionAffinityTtl));
        }

        /**
         * @param steeringPolicy The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools&#39; latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `&#34;&#34;` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `&#34;&#34;` Defaults to `&#34;&#34;`.
         * 
         * @return builder
         * 
         */
        public Builder steeringPolicy(@Nullable Output<String> steeringPolicy) {
            $.steeringPolicy = steeringPolicy;
            return this;
        }

        /**
         * @param steeringPolicy The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools&#39; latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `&#34;&#34;` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `&#34;&#34;` Defaults to `&#34;&#34;`.
         * 
         * @return builder
         * 
         */
        public Builder steeringPolicy(String steeringPolicy) {
            return steeringPolicy(Output.of(steeringPolicy));
        }

        /**
         * @param ttl Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.
         * 
         * @return builder
         * 
         */
        public Builder ttl(@Nullable Output<Integer> ttl) {
            $.ttl = ttl;
            return this;
        }

        /**
         * @param ttl Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.
         * 
         * @return builder
         * 
         */
        public Builder ttl(Integer ttl) {
            return ttl(Output.of(ttl));
        }

        public LoadBalancerRuleOverrideArgs build() {
            return $;
        }
    }

}
