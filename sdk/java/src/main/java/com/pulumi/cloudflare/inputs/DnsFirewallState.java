// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.cloudflare.inputs.DnsFirewallAttackMitigationArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DnsFirewallState extends com.pulumi.resources.ResourceArgs {

    public static final DnsFirewallState Empty = new DnsFirewallState();

    /**
     * Identifier.
     * 
     */
    @Import(name="accountId")
    private @Nullable Output<String> accountId;

    /**
     * @return Identifier.
     * 
     */
    public Optional<Output<String>> accountId() {
        return Optional.ofNullable(this.accountId);
    }

    /**
     * Attack mitigation settings
     * 
     */
    @Import(name="attackMitigation")
    private @Nullable Output<DnsFirewallAttackMitigationArgs> attackMitigation;

    /**
     * @return Attack mitigation settings
     * 
     */
    public Optional<Output<DnsFirewallAttackMitigationArgs>> attackMitigation() {
        return Optional.ofNullable(this.attackMitigation);
    }

    /**
     * Whether to refuse to answer queries for the ANY type
     * 
     */
    @Import(name="deprecateAnyRequests")
    private @Nullable Output<Boolean> deprecateAnyRequests;

    /**
     * @return Whether to refuse to answer queries for the ANY type
     * 
     */
    public Optional<Output<Boolean>> deprecateAnyRequests() {
        return Optional.ofNullable(this.deprecateAnyRequests);
    }

    @Import(name="dnsFirewallIps")
    private @Nullable Output<List<String>> dnsFirewallIps;

    public Optional<Output<List<String>>> dnsFirewallIps() {
        return Optional.ofNullable(this.dnsFirewallIps);
    }

    /**
     * Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     * 
     */
    @Import(name="ecsFallback")
    private @Nullable Output<Boolean> ecsFallback;

    /**
     * @return Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     * 
     */
    public Optional<Output<Boolean>> ecsFallback() {
        return Optional.ofNullable(this.ecsFallback);
    }

    /**
     * By default, Cloudflare attempts to cache responses for as long as
     * indicated by the TTL received from upstream nameservers. This setting
     * sets an upper bound on this duration. For caching purposes, higher TTLs
     * will be decreased to the maximum value defined by this setting.
     * 
     */
    @Import(name="maximumCacheTtl")
    private @Nullable Output<Double> maximumCacheTtl;

    /**
     * @return By default, Cloudflare attempts to cache responses for as long as
     * indicated by the TTL received from upstream nameservers. This setting
     * sets an upper bound on this duration. For caching purposes, higher TTLs
     * will be decreased to the maximum value defined by this setting.
     * 
     */
    public Optional<Output<Double>> maximumCacheTtl() {
        return Optional.ofNullable(this.maximumCacheTtl);
    }

    /**
     * By default, Cloudflare attempts to cache responses for as long as
     * indicated by the TTL received from upstream nameservers. This setting
     * sets a lower bound on this duration. For caching purposes, lower TTLs
     * will be increased to the minimum value defined by this setting.
     * 
     * This setting does not affect the TTL value in the DNS response
     * Cloudflare returns to clients. Cloudflare will always forward the TTL
     * value received from upstream nameservers.
     * 
     * Note that, even with this setting, there is no guarantee that a
     * response will be cached for at least the specified duration. Cached
     * responses may be removed earlier for capacity or other operational
     * reasons.
     * 
     */
    @Import(name="minimumCacheTtl")
    private @Nullable Output<Double> minimumCacheTtl;

    /**
     * @return By default, Cloudflare attempts to cache responses for as long as
     * indicated by the TTL received from upstream nameservers. This setting
     * sets a lower bound on this duration. For caching purposes, lower TTLs
     * will be increased to the minimum value defined by this setting.
     * 
     * This setting does not affect the TTL value in the DNS response
     * Cloudflare returns to clients. Cloudflare will always forward the TTL
     * value received from upstream nameservers.
     * 
     * Note that, even with this setting, there is no guarantee that a
     * response will be cached for at least the specified duration. Cached
     * responses may be removed earlier for capacity or other operational
     * reasons.
     * 
     */
    public Optional<Output<Double>> minimumCacheTtl() {
        return Optional.ofNullable(this.minimumCacheTtl);
    }

    /**
     * Last modification of DNS Firewall cluster
     * 
     */
    @Import(name="modifiedOn")
    private @Nullable Output<String> modifiedOn;

    /**
     * @return Last modification of DNS Firewall cluster
     * 
     */
    public Optional<Output<String>> modifiedOn() {
        return Optional.ofNullable(this.modifiedOn);
    }

    /**
     * DNS Firewall cluster name
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return DNS Firewall cluster name
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * This setting controls how long DNS Firewall should cache negative
     * responses (e.g., NXDOMAIN) from the upstream servers.
     * 
     * This setting does not affect the TTL value in the DNS response
     * Cloudflare returns to clients. Cloudflare will always forward the TTL
     * value received from upstream nameservers.
     * 
     */
    @Import(name="negativeCacheTtl")
    private @Nullable Output<Double> negativeCacheTtl;

    /**
     * @return This setting controls how long DNS Firewall should cache negative
     * responses (e.g., NXDOMAIN) from the upstream servers.
     * 
     * This setting does not affect the TTL value in the DNS response
     * Cloudflare returns to clients. Cloudflare will always forward the TTL
     * value received from upstream nameservers.
     * 
     */
    public Optional<Output<Double>> negativeCacheTtl() {
        return Optional.ofNullable(this.negativeCacheTtl);
    }

    /**
     * Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
     * 
     */
    @Import(name="ratelimit")
    private @Nullable Output<Double> ratelimit;

    /**
     * @return Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
     * 
     */
    public Optional<Output<Double>> ratelimit() {
        return Optional.ofNullable(this.ratelimit);
    }

    /**
     * Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
     * 
     */
    @Import(name="retries")
    private @Nullable Output<Double> retries;

    /**
     * @return Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
     * 
     */
    public Optional<Output<Double>> retries() {
        return Optional.ofNullable(this.retries);
    }

    @Import(name="upstreamIps")
    private @Nullable Output<List<String>> upstreamIps;

    public Optional<Output<List<String>>> upstreamIps() {
        return Optional.ofNullable(this.upstreamIps);
    }

    private DnsFirewallState() {}

    private DnsFirewallState(DnsFirewallState $) {
        this.accountId = $.accountId;
        this.attackMitigation = $.attackMitigation;
        this.deprecateAnyRequests = $.deprecateAnyRequests;
        this.dnsFirewallIps = $.dnsFirewallIps;
        this.ecsFallback = $.ecsFallback;
        this.maximumCacheTtl = $.maximumCacheTtl;
        this.minimumCacheTtl = $.minimumCacheTtl;
        this.modifiedOn = $.modifiedOn;
        this.name = $.name;
        this.negativeCacheTtl = $.negativeCacheTtl;
        this.ratelimit = $.ratelimit;
        this.retries = $.retries;
        this.upstreamIps = $.upstreamIps;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DnsFirewallState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DnsFirewallState $;

        public Builder() {
            $ = new DnsFirewallState();
        }

        public Builder(DnsFirewallState defaults) {
            $ = new DnsFirewallState(Objects.requireNonNull(defaults));
        }

        /**
         * @param accountId Identifier.
         * 
         * @return builder
         * 
         */
        public Builder accountId(@Nullable Output<String> accountId) {
            $.accountId = accountId;
            return this;
        }

        /**
         * @param accountId Identifier.
         * 
         * @return builder
         * 
         */
        public Builder accountId(String accountId) {
            return accountId(Output.of(accountId));
        }

        /**
         * @param attackMitigation Attack mitigation settings
         * 
         * @return builder
         * 
         */
        public Builder attackMitigation(@Nullable Output<DnsFirewallAttackMitigationArgs> attackMitigation) {
            $.attackMitigation = attackMitigation;
            return this;
        }

        /**
         * @param attackMitigation Attack mitigation settings
         * 
         * @return builder
         * 
         */
        public Builder attackMitigation(DnsFirewallAttackMitigationArgs attackMitigation) {
            return attackMitigation(Output.of(attackMitigation));
        }

        /**
         * @param deprecateAnyRequests Whether to refuse to answer queries for the ANY type
         * 
         * @return builder
         * 
         */
        public Builder deprecateAnyRequests(@Nullable Output<Boolean> deprecateAnyRequests) {
            $.deprecateAnyRequests = deprecateAnyRequests;
            return this;
        }

        /**
         * @param deprecateAnyRequests Whether to refuse to answer queries for the ANY type
         * 
         * @return builder
         * 
         */
        public Builder deprecateAnyRequests(Boolean deprecateAnyRequests) {
            return deprecateAnyRequests(Output.of(deprecateAnyRequests));
        }

        public Builder dnsFirewallIps(@Nullable Output<List<String>> dnsFirewallIps) {
            $.dnsFirewallIps = dnsFirewallIps;
            return this;
        }

        public Builder dnsFirewallIps(List<String> dnsFirewallIps) {
            return dnsFirewallIps(Output.of(dnsFirewallIps));
        }

        public Builder dnsFirewallIps(String... dnsFirewallIps) {
            return dnsFirewallIps(List.of(dnsFirewallIps));
        }

        /**
         * @param ecsFallback Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
         * 
         * @return builder
         * 
         */
        public Builder ecsFallback(@Nullable Output<Boolean> ecsFallback) {
            $.ecsFallback = ecsFallback;
            return this;
        }

        /**
         * @param ecsFallback Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
         * 
         * @return builder
         * 
         */
        public Builder ecsFallback(Boolean ecsFallback) {
            return ecsFallback(Output.of(ecsFallback));
        }

        /**
         * @param maximumCacheTtl By default, Cloudflare attempts to cache responses for as long as
         * indicated by the TTL received from upstream nameservers. This setting
         * sets an upper bound on this duration. For caching purposes, higher TTLs
         * will be decreased to the maximum value defined by this setting.
         * 
         * @return builder
         * 
         */
        public Builder maximumCacheTtl(@Nullable Output<Double> maximumCacheTtl) {
            $.maximumCacheTtl = maximumCacheTtl;
            return this;
        }

        /**
         * @param maximumCacheTtl By default, Cloudflare attempts to cache responses for as long as
         * indicated by the TTL received from upstream nameservers. This setting
         * sets an upper bound on this duration. For caching purposes, higher TTLs
         * will be decreased to the maximum value defined by this setting.
         * 
         * @return builder
         * 
         */
        public Builder maximumCacheTtl(Double maximumCacheTtl) {
            return maximumCacheTtl(Output.of(maximumCacheTtl));
        }

        /**
         * @param minimumCacheTtl By default, Cloudflare attempts to cache responses for as long as
         * indicated by the TTL received from upstream nameservers. This setting
         * sets a lower bound on this duration. For caching purposes, lower TTLs
         * will be increased to the minimum value defined by this setting.
         * 
         * This setting does not affect the TTL value in the DNS response
         * Cloudflare returns to clients. Cloudflare will always forward the TTL
         * value received from upstream nameservers.
         * 
         * Note that, even with this setting, there is no guarantee that a
         * response will be cached for at least the specified duration. Cached
         * responses may be removed earlier for capacity or other operational
         * reasons.
         * 
         * @return builder
         * 
         */
        public Builder minimumCacheTtl(@Nullable Output<Double> minimumCacheTtl) {
            $.minimumCacheTtl = minimumCacheTtl;
            return this;
        }

        /**
         * @param minimumCacheTtl By default, Cloudflare attempts to cache responses for as long as
         * indicated by the TTL received from upstream nameservers. This setting
         * sets a lower bound on this duration. For caching purposes, lower TTLs
         * will be increased to the minimum value defined by this setting.
         * 
         * This setting does not affect the TTL value in the DNS response
         * Cloudflare returns to clients. Cloudflare will always forward the TTL
         * value received from upstream nameservers.
         * 
         * Note that, even with this setting, there is no guarantee that a
         * response will be cached for at least the specified duration. Cached
         * responses may be removed earlier for capacity or other operational
         * reasons.
         * 
         * @return builder
         * 
         */
        public Builder minimumCacheTtl(Double minimumCacheTtl) {
            return minimumCacheTtl(Output.of(minimumCacheTtl));
        }

        /**
         * @param modifiedOn Last modification of DNS Firewall cluster
         * 
         * @return builder
         * 
         */
        public Builder modifiedOn(@Nullable Output<String> modifiedOn) {
            $.modifiedOn = modifiedOn;
            return this;
        }

        /**
         * @param modifiedOn Last modification of DNS Firewall cluster
         * 
         * @return builder
         * 
         */
        public Builder modifiedOn(String modifiedOn) {
            return modifiedOn(Output.of(modifiedOn));
        }

        /**
         * @param name DNS Firewall cluster name
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name DNS Firewall cluster name
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param negativeCacheTtl This setting controls how long DNS Firewall should cache negative
         * responses (e.g., NXDOMAIN) from the upstream servers.
         * 
         * This setting does not affect the TTL value in the DNS response
         * Cloudflare returns to clients. Cloudflare will always forward the TTL
         * value received from upstream nameservers.
         * 
         * @return builder
         * 
         */
        public Builder negativeCacheTtl(@Nullable Output<Double> negativeCacheTtl) {
            $.negativeCacheTtl = negativeCacheTtl;
            return this;
        }

        /**
         * @param negativeCacheTtl This setting controls how long DNS Firewall should cache negative
         * responses (e.g., NXDOMAIN) from the upstream servers.
         * 
         * This setting does not affect the TTL value in the DNS response
         * Cloudflare returns to clients. Cloudflare will always forward the TTL
         * value received from upstream nameservers.
         * 
         * @return builder
         * 
         */
        public Builder negativeCacheTtl(Double negativeCacheTtl) {
            return negativeCacheTtl(Output.of(negativeCacheTtl));
        }

        /**
         * @param ratelimit Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
         * 
         * @return builder
         * 
         */
        public Builder ratelimit(@Nullable Output<Double> ratelimit) {
            $.ratelimit = ratelimit;
            return this;
        }

        /**
         * @param ratelimit Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
         * 
         * @return builder
         * 
         */
        public Builder ratelimit(Double ratelimit) {
            return ratelimit(Output.of(ratelimit));
        }

        /**
         * @param retries Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
         * 
         * @return builder
         * 
         */
        public Builder retries(@Nullable Output<Double> retries) {
            $.retries = retries;
            return this;
        }

        /**
         * @param retries Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
         * 
         * @return builder
         * 
         */
        public Builder retries(Double retries) {
            return retries(Output.of(retries));
        }

        public Builder upstreamIps(@Nullable Output<List<String>> upstreamIps) {
            $.upstreamIps = upstreamIps;
            return this;
        }

        public Builder upstreamIps(List<String> upstreamIps) {
            return upstreamIps(Output.of(upstreamIps));
        }

        public Builder upstreamIps(String... upstreamIps) {
            return upstreamIps(List.of(upstreamIps));
        }

        public DnsFirewallState build() {
            return $;
        }
    }

}
