// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetLogpushJobOutputOptions {
    /**
     * @return String to be prepended before each batch.
     * 
     */
    private String batchPrefix;
    /**
     * @return String to be appended after each batch.
     * 
     */
    private String batchSuffix;
    /**
     * @return If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     * 
     */
    private Boolean cve20214428;
    /**
     * @return String to join fields. This field be ignored when `record_template` is set.
     * 
     */
    private String fieldDelimiter;
    /**
     * @return List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     * 
     */
    private List<String> fieldNames;
    /**
     * @return Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     * 
     */
    private String outputType;
    /**
     * @return String to be inserted in-between the records as separator.
     * 
     */
    private String recordDelimiter;
    /**
     * @return String to be prepended before each record.
     * 
     */
    private String recordPrefix;
    /**
     * @return String to be appended after each record.
     * 
     */
    private String recordSuffix;
    /**
     * @return String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     * 
     */
    private String recordTemplate;
    /**
     * @return Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
     * 
     */
    private Double sampleRate;
    /**
     * @return String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     * 
     */
    private String timestampFormat;

    private GetLogpushJobOutputOptions() {}
    /**
     * @return String to be prepended before each batch.
     * 
     */
    public String batchPrefix() {
        return this.batchPrefix;
    }
    /**
     * @return String to be appended after each batch.
     * 
     */
    public String batchSuffix() {
        return this.batchSuffix;
    }
    /**
     * @return If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     * 
     */
    public Boolean cve20214428() {
        return this.cve20214428;
    }
    /**
     * @return String to join fields. This field be ignored when `record_template` is set.
     * 
     */
    public String fieldDelimiter() {
        return this.fieldDelimiter;
    }
    /**
     * @return List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     * 
     */
    public List<String> fieldNames() {
        return this.fieldNames;
    }
    /**
     * @return Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     * 
     */
    public String outputType() {
        return this.outputType;
    }
    /**
     * @return String to be inserted in-between the records as separator.
     * 
     */
    public String recordDelimiter() {
        return this.recordDelimiter;
    }
    /**
     * @return String to be prepended before each record.
     * 
     */
    public String recordPrefix() {
        return this.recordPrefix;
    }
    /**
     * @return String to be appended after each record.
     * 
     */
    public String recordSuffix() {
        return this.recordSuffix;
    }
    /**
     * @return String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     * 
     */
    public String recordTemplate() {
        return this.recordTemplate;
    }
    /**
     * @return Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
     * 
     */
    public Double sampleRate() {
        return this.sampleRate;
    }
    /**
     * @return String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     * 
     */
    public String timestampFormat() {
        return this.timestampFormat;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetLogpushJobOutputOptions defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String batchPrefix;
        private String batchSuffix;
        private Boolean cve20214428;
        private String fieldDelimiter;
        private List<String> fieldNames;
        private String outputType;
        private String recordDelimiter;
        private String recordPrefix;
        private String recordSuffix;
        private String recordTemplate;
        private Double sampleRate;
        private String timestampFormat;
        public Builder() {}
        public Builder(GetLogpushJobOutputOptions defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.batchPrefix = defaults.batchPrefix;
    	      this.batchSuffix = defaults.batchSuffix;
    	      this.cve20214428 = defaults.cve20214428;
    	      this.fieldDelimiter = defaults.fieldDelimiter;
    	      this.fieldNames = defaults.fieldNames;
    	      this.outputType = defaults.outputType;
    	      this.recordDelimiter = defaults.recordDelimiter;
    	      this.recordPrefix = defaults.recordPrefix;
    	      this.recordSuffix = defaults.recordSuffix;
    	      this.recordTemplate = defaults.recordTemplate;
    	      this.sampleRate = defaults.sampleRate;
    	      this.timestampFormat = defaults.timestampFormat;
        }

        @CustomType.Setter
        public Builder batchPrefix(String batchPrefix) {
            if (batchPrefix == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "batchPrefix");
            }
            this.batchPrefix = batchPrefix;
            return this;
        }
        @CustomType.Setter
        public Builder batchSuffix(String batchSuffix) {
            if (batchSuffix == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "batchSuffix");
            }
            this.batchSuffix = batchSuffix;
            return this;
        }
        @CustomType.Setter
        public Builder cve20214428(Boolean cve20214428) {
            if (cve20214428 == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "cve20214428");
            }
            this.cve20214428 = cve20214428;
            return this;
        }
        @CustomType.Setter
        public Builder fieldDelimiter(String fieldDelimiter) {
            if (fieldDelimiter == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "fieldDelimiter");
            }
            this.fieldDelimiter = fieldDelimiter;
            return this;
        }
        @CustomType.Setter
        public Builder fieldNames(List<String> fieldNames) {
            if (fieldNames == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "fieldNames");
            }
            this.fieldNames = fieldNames;
            return this;
        }
        public Builder fieldNames(String... fieldNames) {
            return fieldNames(List.of(fieldNames));
        }
        @CustomType.Setter
        public Builder outputType(String outputType) {
            if (outputType == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "outputType");
            }
            this.outputType = outputType;
            return this;
        }
        @CustomType.Setter
        public Builder recordDelimiter(String recordDelimiter) {
            if (recordDelimiter == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "recordDelimiter");
            }
            this.recordDelimiter = recordDelimiter;
            return this;
        }
        @CustomType.Setter
        public Builder recordPrefix(String recordPrefix) {
            if (recordPrefix == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "recordPrefix");
            }
            this.recordPrefix = recordPrefix;
            return this;
        }
        @CustomType.Setter
        public Builder recordSuffix(String recordSuffix) {
            if (recordSuffix == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "recordSuffix");
            }
            this.recordSuffix = recordSuffix;
            return this;
        }
        @CustomType.Setter
        public Builder recordTemplate(String recordTemplate) {
            if (recordTemplate == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "recordTemplate");
            }
            this.recordTemplate = recordTemplate;
            return this;
        }
        @CustomType.Setter
        public Builder sampleRate(Double sampleRate) {
            if (sampleRate == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "sampleRate");
            }
            this.sampleRate = sampleRate;
            return this;
        }
        @CustomType.Setter
        public Builder timestampFormat(String timestampFormat) {
            if (timestampFormat == null) {
              throw new MissingRequiredPropertyException("GetLogpushJobOutputOptions", "timestampFormat");
            }
            this.timestampFormat = timestampFormat;
            return this;
        }
        public GetLogpushJobOutputOptions build() {
            final var _resultValue = new GetLogpushJobOutputOptions();
            _resultValue.batchPrefix = batchPrefix;
            _resultValue.batchSuffix = batchSuffix;
            _resultValue.cve20214428 = cve20214428;
            _resultValue.fieldDelimiter = fieldDelimiter;
            _resultValue.fieldNames = fieldNames;
            _resultValue.outputType = outputType;
            _resultValue.recordDelimiter = recordDelimiter;
            _resultValue.recordPrefix = recordPrefix;
            _resultValue.recordSuffix = recordSuffix;
            _resultValue.recordTemplate = recordTemplate;
            _resultValue.sampleRate = sampleRate;
            _resultValue.timestampFormat = timestampFormat;
            return _resultValue;
        }
    }
}
