// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetLoadBalancerMonitorsResult {
    /**
     * @return Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     * 
     */
    private Boolean allowInsecure;
    /**
     * @return To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     * 
     */
    private Integer consecutiveDown;
    /**
     * @return To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     * 
     */
    private Integer consecutiveUp;
    private String createdOn;
    /**
     * @return Object description.
     * 
     */
    private String description;
    /**
     * @return A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    private String expectedBody;
    /**
     * @return The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    private String expectedCodes;
    /**
     * @return Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    private Boolean followRedirects;
    /**
     * @return The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    private Map<String,List<String>> header;
    private String id;
    /**
     * @return The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     * 
     */
    private Integer interval;
    /**
     * @return The method to use for the health check. This defaults to &#39;GET&#39; for HTTP/HTTPS based checks and &#39;connection_established&#39; for TCP based health checks.
     * 
     */
    private String method;
    private String modifiedOn;
    /**
     * @return The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    private String path;
    /**
     * @return The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     * 
     */
    private Integer port;
    /**
     * @return Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    private String probeZone;
    /**
     * @return The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     * 
     */
    private Integer retries;
    /**
     * @return The timeout (in seconds) before marking the health check as failed.
     * 
     */
    private Integer timeout;
    /**
     * @return The protocol to use for the health check. Currently supported protocols are &#39;HTTP&#39;,&#39;HTTPS&#39;, &#39;TCP&#39;, &#39;ICMP-PING&#39;, &#39;UDP-ICMP&#39;, and &#39;SMTP&#39;.
     * Available values: &#34;http&#34;, &#34;https&#34;, &#34;tcp&#34;, &#34;udp*icmp&#34;, &#34;icmp*ping&#34;, &#34;smtp&#34;.
     * 
     */
    private String type;

    private GetLoadBalancerMonitorsResult() {}
    /**
     * @return Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     * 
     */
    public Boolean allowInsecure() {
        return this.allowInsecure;
    }
    /**
     * @return To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     * 
     */
    public Integer consecutiveDown() {
        return this.consecutiveDown;
    }
    /**
     * @return To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     * 
     */
    public Integer consecutiveUp() {
        return this.consecutiveUp;
    }
    public String createdOn() {
        return this.createdOn;
    }
    /**
     * @return Object description.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public String expectedBody() {
        return this.expectedBody;
    }
    /**
     * @return The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public String expectedCodes() {
        return this.expectedCodes;
    }
    /**
     * @return Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public Boolean followRedirects() {
        return this.followRedirects;
    }
    /**
     * @return The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public Map<String,List<String>> header() {
        return this.header;
    }
    public String id() {
        return this.id;
    }
    /**
     * @return The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     * 
     */
    public Integer interval() {
        return this.interval;
    }
    /**
     * @return The method to use for the health check. This defaults to &#39;GET&#39; for HTTP/HTTPS based checks and &#39;connection_established&#39; for TCP based health checks.
     * 
     */
    public String method() {
        return this.method;
    }
    public String modifiedOn() {
        return this.modifiedOn;
    }
    /**
     * @return The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public String path() {
        return this.path;
    }
    /**
     * @return The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     * 
     */
    public Integer port() {
        return this.port;
    }
    /**
     * @return Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     * 
     */
    public String probeZone() {
        return this.probeZone;
    }
    /**
     * @return The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     * 
     */
    public Integer retries() {
        return this.retries;
    }
    /**
     * @return The timeout (in seconds) before marking the health check as failed.
     * 
     */
    public Integer timeout() {
        return this.timeout;
    }
    /**
     * @return The protocol to use for the health check. Currently supported protocols are &#39;HTTP&#39;,&#39;HTTPS&#39;, &#39;TCP&#39;, &#39;ICMP-PING&#39;, &#39;UDP-ICMP&#39;, and &#39;SMTP&#39;.
     * Available values: &#34;http&#34;, &#34;https&#34;, &#34;tcp&#34;, &#34;udp*icmp&#34;, &#34;icmp*ping&#34;, &#34;smtp&#34;.
     * 
     */
    public String type() {
        return this.type;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetLoadBalancerMonitorsResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean allowInsecure;
        private Integer consecutiveDown;
        private Integer consecutiveUp;
        private String createdOn;
        private String description;
        private String expectedBody;
        private String expectedCodes;
        private Boolean followRedirects;
        private Map<String,List<String>> header;
        private String id;
        private Integer interval;
        private String method;
        private String modifiedOn;
        private String path;
        private Integer port;
        private String probeZone;
        private Integer retries;
        private Integer timeout;
        private String type;
        public Builder() {}
        public Builder(GetLoadBalancerMonitorsResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allowInsecure = defaults.allowInsecure;
    	      this.consecutiveDown = defaults.consecutiveDown;
    	      this.consecutiveUp = defaults.consecutiveUp;
    	      this.createdOn = defaults.createdOn;
    	      this.description = defaults.description;
    	      this.expectedBody = defaults.expectedBody;
    	      this.expectedCodes = defaults.expectedCodes;
    	      this.followRedirects = defaults.followRedirects;
    	      this.header = defaults.header;
    	      this.id = defaults.id;
    	      this.interval = defaults.interval;
    	      this.method = defaults.method;
    	      this.modifiedOn = defaults.modifiedOn;
    	      this.path = defaults.path;
    	      this.port = defaults.port;
    	      this.probeZone = defaults.probeZone;
    	      this.retries = defaults.retries;
    	      this.timeout = defaults.timeout;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder allowInsecure(Boolean allowInsecure) {
            if (allowInsecure == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "allowInsecure");
            }
            this.allowInsecure = allowInsecure;
            return this;
        }
        @CustomType.Setter
        public Builder consecutiveDown(Integer consecutiveDown) {
            if (consecutiveDown == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "consecutiveDown");
            }
            this.consecutiveDown = consecutiveDown;
            return this;
        }
        @CustomType.Setter
        public Builder consecutiveUp(Integer consecutiveUp) {
            if (consecutiveUp == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "consecutiveUp");
            }
            this.consecutiveUp = consecutiveUp;
            return this;
        }
        @CustomType.Setter
        public Builder createdOn(String createdOn) {
            if (createdOn == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "createdOn");
            }
            this.createdOn = createdOn;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder expectedBody(String expectedBody) {
            if (expectedBody == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "expectedBody");
            }
            this.expectedBody = expectedBody;
            return this;
        }
        @CustomType.Setter
        public Builder expectedCodes(String expectedCodes) {
            if (expectedCodes == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "expectedCodes");
            }
            this.expectedCodes = expectedCodes;
            return this;
        }
        @CustomType.Setter
        public Builder followRedirects(Boolean followRedirects) {
            if (followRedirects == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "followRedirects");
            }
            this.followRedirects = followRedirects;
            return this;
        }
        @CustomType.Setter
        public Builder header(Map<String,List<String>> header) {
            if (header == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "header");
            }
            this.header = header;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder interval(Integer interval) {
            if (interval == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "interval");
            }
            this.interval = interval;
            return this;
        }
        @CustomType.Setter
        public Builder method(String method) {
            if (method == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "method");
            }
            this.method = method;
            return this;
        }
        @CustomType.Setter
        public Builder modifiedOn(String modifiedOn) {
            if (modifiedOn == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "modifiedOn");
            }
            this.modifiedOn = modifiedOn;
            return this;
        }
        @CustomType.Setter
        public Builder path(String path) {
            if (path == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "path");
            }
            this.path = path;
            return this;
        }
        @CustomType.Setter
        public Builder port(Integer port) {
            if (port == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "port");
            }
            this.port = port;
            return this;
        }
        @CustomType.Setter
        public Builder probeZone(String probeZone) {
            if (probeZone == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "probeZone");
            }
            this.probeZone = probeZone;
            return this;
        }
        @CustomType.Setter
        public Builder retries(Integer retries) {
            if (retries == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "retries");
            }
            this.retries = retries;
            return this;
        }
        @CustomType.Setter
        public Builder timeout(Integer timeout) {
            if (timeout == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "timeout");
            }
            this.timeout = timeout;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetLoadBalancerMonitorsResult", "type");
            }
            this.type = type;
            return this;
        }
        public GetLoadBalancerMonitorsResult build() {
            final var _resultValue = new GetLoadBalancerMonitorsResult();
            _resultValue.allowInsecure = allowInsecure;
            _resultValue.consecutiveDown = consecutiveDown;
            _resultValue.consecutiveUp = consecutiveUp;
            _resultValue.createdOn = createdOn;
            _resultValue.description = description;
            _resultValue.expectedBody = expectedBody;
            _resultValue.expectedCodes = expectedCodes;
            _resultValue.followRedirects = followRedirects;
            _resultValue.header = header;
            _resultValue.id = id;
            _resultValue.interval = interval;
            _resultValue.method = method;
            _resultValue.modifiedOn = modifiedOn;
            _resultValue.path = path;
            _resultValue.port = port;
            _resultValue.probeZone = probeZone;
            _resultValue.retries = retries;
            _resultValue.timeout = timeout;
            _resultValue.type = type;
            return _resultValue;
        }
    }
}
