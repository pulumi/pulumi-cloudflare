// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.outputs;

import com.pulumi.cloudflare.outputs.CustomHostnameSslSetting;
import com.pulumi.cloudflare.outputs.CustomHostnameSslValidationError;
import com.pulumi.cloudflare.outputs.CustomHostnameSslValidationRecord;
import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class CustomHostnameSsl {
    /**
     * @return A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     * 
     */
    private @Nullable String bundleMethod;
    private @Nullable String certificateAuthority;
    /**
     * @return If a custom uploaded certificate is used.
     * 
     */
    private @Nullable String customCertificate;
    /**
     * @return The key for a custom uploaded certificate.
     * 
     */
    private @Nullable String customKey;
    /**
     * @return Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
     * 
     */
    private @Nullable String method;
    /**
     * @return SSL/TLS settings for the certificate.
     * 
     */
    private @Nullable List<CustomHostnameSslSetting> settings;
    private @Nullable String status;
    /**
     * @return Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
     * 
     */
    private @Nullable String type;
    private @Nullable List<CustomHostnameSslValidationError> validationErrors;
    private @Nullable List<CustomHostnameSslValidationRecord> validationRecords;
    /**
     * @return Indicates whether the certificate covers a wildcard.
     * 
     */
    private @Nullable Boolean wildcard;

    private CustomHostnameSsl() {}
    /**
     * @return A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     * 
     */
    public Optional<String> bundleMethod() {
        return Optional.ofNullable(this.bundleMethod);
    }
    public Optional<String> certificateAuthority() {
        return Optional.ofNullable(this.certificateAuthority);
    }
    /**
     * @return If a custom uploaded certificate is used.
     * 
     */
    public Optional<String> customCertificate() {
        return Optional.ofNullable(this.customCertificate);
    }
    /**
     * @return The key for a custom uploaded certificate.
     * 
     */
    public Optional<String> customKey() {
        return Optional.ofNullable(this.customKey);
    }
    /**
     * @return Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
     * 
     */
    public Optional<String> method() {
        return Optional.ofNullable(this.method);
    }
    /**
     * @return SSL/TLS settings for the certificate.
     * 
     */
    public List<CustomHostnameSslSetting> settings() {
        return this.settings == null ? List.of() : this.settings;
    }
    public Optional<String> status() {
        return Optional.ofNullable(this.status);
    }
    /**
     * @return Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
     * 
     */
    public Optional<String> type() {
        return Optional.ofNullable(this.type);
    }
    public List<CustomHostnameSslValidationError> validationErrors() {
        return this.validationErrors == null ? List.of() : this.validationErrors;
    }
    public List<CustomHostnameSslValidationRecord> validationRecords() {
        return this.validationRecords == null ? List.of() : this.validationRecords;
    }
    /**
     * @return Indicates whether the certificate covers a wildcard.
     * 
     */
    public Optional<Boolean> wildcard() {
        return Optional.ofNullable(this.wildcard);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(CustomHostnameSsl defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String bundleMethod;
        private @Nullable String certificateAuthority;
        private @Nullable String customCertificate;
        private @Nullable String customKey;
        private @Nullable String method;
        private @Nullable List<CustomHostnameSslSetting> settings;
        private @Nullable String status;
        private @Nullable String type;
        private @Nullable List<CustomHostnameSslValidationError> validationErrors;
        private @Nullable List<CustomHostnameSslValidationRecord> validationRecords;
        private @Nullable Boolean wildcard;
        public Builder() {}
        public Builder(CustomHostnameSsl defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.bundleMethod = defaults.bundleMethod;
    	      this.certificateAuthority = defaults.certificateAuthority;
    	      this.customCertificate = defaults.customCertificate;
    	      this.customKey = defaults.customKey;
    	      this.method = defaults.method;
    	      this.settings = defaults.settings;
    	      this.status = defaults.status;
    	      this.type = defaults.type;
    	      this.validationErrors = defaults.validationErrors;
    	      this.validationRecords = defaults.validationRecords;
    	      this.wildcard = defaults.wildcard;
        }

        @CustomType.Setter
        public Builder bundleMethod(@Nullable String bundleMethod) {

            this.bundleMethod = bundleMethod;
            return this;
        }
        @CustomType.Setter
        public Builder certificateAuthority(@Nullable String certificateAuthority) {

            this.certificateAuthority = certificateAuthority;
            return this;
        }
        @CustomType.Setter
        public Builder customCertificate(@Nullable String customCertificate) {

            this.customCertificate = customCertificate;
            return this;
        }
        @CustomType.Setter
        public Builder customKey(@Nullable String customKey) {

            this.customKey = customKey;
            return this;
        }
        @CustomType.Setter
        public Builder method(@Nullable String method) {

            this.method = method;
            return this;
        }
        @CustomType.Setter
        public Builder settings(@Nullable List<CustomHostnameSslSetting> settings) {

            this.settings = settings;
            return this;
        }
        public Builder settings(CustomHostnameSslSetting... settings) {
            return settings(List.of(settings));
        }
        @CustomType.Setter
        public Builder status(@Nullable String status) {

            this.status = status;
            return this;
        }
        @CustomType.Setter
        public Builder type(@Nullable String type) {

            this.type = type;
            return this;
        }
        @CustomType.Setter
        public Builder validationErrors(@Nullable List<CustomHostnameSslValidationError> validationErrors) {

            this.validationErrors = validationErrors;
            return this;
        }
        public Builder validationErrors(CustomHostnameSslValidationError... validationErrors) {
            return validationErrors(List.of(validationErrors));
        }
        @CustomType.Setter
        public Builder validationRecords(@Nullable List<CustomHostnameSslValidationRecord> validationRecords) {

            this.validationRecords = validationRecords;
            return this;
        }
        public Builder validationRecords(CustomHostnameSslValidationRecord... validationRecords) {
            return validationRecords(List.of(validationRecords));
        }
        @CustomType.Setter
        public Builder wildcard(@Nullable Boolean wildcard) {

            this.wildcard = wildcard;
            return this;
        }
        public CustomHostnameSsl build() {
            final var _resultValue = new CustomHostnameSsl();
            _resultValue.bundleMethod = bundleMethod;
            _resultValue.certificateAuthority = certificateAuthority;
            _resultValue.customCertificate = customCertificate;
            _resultValue.customKey = customKey;
            _resultValue.method = method;
            _resultValue.settings = settings;
            _resultValue.status = status;
            _resultValue.type = type;
            _resultValue.validationErrors = validationErrors;
            _resultValue.validationRecords = validationRecords;
            _resultValue.wildcard = wildcard;
            return _resultValue;
        }
    }
}
