// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.outputs;

import com.pulumi.cloudflare.outputs.LoadBalancerRuleOverrideAdaptiveRouting;
import com.pulumi.cloudflare.outputs.LoadBalancerRuleOverrideCountryPool;
import com.pulumi.cloudflare.outputs.LoadBalancerRuleOverrideLocationStrategy;
import com.pulumi.cloudflare.outputs.LoadBalancerRuleOverridePopPool;
import com.pulumi.cloudflare.outputs.LoadBalancerRuleOverrideRandomSteering;
import com.pulumi.cloudflare.outputs.LoadBalancerRuleOverrideRegionPool;
import com.pulumi.cloudflare.outputs.LoadBalancerRuleOverrideSessionAffinityAttribute;
import com.pulumi.core.annotations.CustomType;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class LoadBalancerRuleOverride {
    /**
     * @return Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
     * 
     */
    private @Nullable List<LoadBalancerRuleOverrideAdaptiveRouting> adaptiveRoutings;
    /**
     * @return A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
     * 
     */
    private @Nullable List<LoadBalancerRuleOverrideCountryPool> countryPools;
    /**
     * @return A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
     * 
     */
    private @Nullable List<String> defaultPools;
    /**
     * @return The pool ID to use when all other pools are detected as unhealthy.
     * 
     */
    private @Nullable String fallbackPool;
    /**
     * @return Controls location-based steering for non-proxied requests.
     * 
     */
    private @Nullable List<LoadBalancerRuleOverrideLocationStrategy> locationStrategies;
    /**
     * @return A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
     * 
     */
    private @Nullable List<LoadBalancerRuleOverridePopPool> popPools;
    /**
     * @return Configures pool weights. When `steering_policy=&#34;random&#34;`, a random pool is selected with probability proportional to pool weights. When `steering_policy=&#34;least_outstanding_requests&#34;`, pool weights are used to scale each pool&#39;s outstanding requests.
     * 
     */
    private @Nullable List<LoadBalancerRuleOverrideRandomSteering> randomSteerings;
    /**
     * @return A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
     * 
     */
    private @Nullable List<LoadBalancerRuleOverrideRegionPool> regionPools;
    /**
     * @return Configure attributes for session affinity.
     * 
     */
    private @Nullable String sessionAffinity;
    /**
     * @return Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
     * 
     */
    private @Nullable List<LoadBalancerRuleOverrideSessionAffinityAttribute> sessionAffinityAttributes;
    /**
     * @return Time, in seconds, until this load balancer&#39;s session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
     * 
     */
    private @Nullable Integer sessionAffinityTtl;
    /**
     * @return The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools&#39; latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool&#39;s number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `&#34;&#34;` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `&#34;&#34;` Defaults to `&#34;&#34;`.
     * 
     */
    private @Nullable String steeringPolicy;
    /**
     * @return Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
     * 
     */
    private @Nullable Integer ttl;

    private LoadBalancerRuleOverride() {}
    /**
     * @return Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
     * 
     */
    public List<LoadBalancerRuleOverrideAdaptiveRouting> adaptiveRoutings() {
        return this.adaptiveRoutings == null ? List.of() : this.adaptiveRoutings;
    }
    /**
     * @return A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
     * 
     */
    public List<LoadBalancerRuleOverrideCountryPool> countryPools() {
        return this.countryPools == null ? List.of() : this.countryPools;
    }
    /**
     * @return A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
     * 
     */
    public List<String> defaultPools() {
        return this.defaultPools == null ? List.of() : this.defaultPools;
    }
    /**
     * @return The pool ID to use when all other pools are detected as unhealthy.
     * 
     */
    public Optional<String> fallbackPool() {
        return Optional.ofNullable(this.fallbackPool);
    }
    /**
     * @return Controls location-based steering for non-proxied requests.
     * 
     */
    public List<LoadBalancerRuleOverrideLocationStrategy> locationStrategies() {
        return this.locationStrategies == null ? List.of() : this.locationStrategies;
    }
    /**
     * @return A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
     * 
     */
    public List<LoadBalancerRuleOverridePopPool> popPools() {
        return this.popPools == null ? List.of() : this.popPools;
    }
    /**
     * @return Configures pool weights. When `steering_policy=&#34;random&#34;`, a random pool is selected with probability proportional to pool weights. When `steering_policy=&#34;least_outstanding_requests&#34;`, pool weights are used to scale each pool&#39;s outstanding requests.
     * 
     */
    public List<LoadBalancerRuleOverrideRandomSteering> randomSteerings() {
        return this.randomSteerings == null ? List.of() : this.randomSteerings;
    }
    /**
     * @return A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
     * 
     */
    public List<LoadBalancerRuleOverrideRegionPool> regionPools() {
        return this.regionPools == null ? List.of() : this.regionPools;
    }
    /**
     * @return Configure attributes for session affinity.
     * 
     */
    public Optional<String> sessionAffinity() {
        return Optional.ofNullable(this.sessionAffinity);
    }
    /**
     * @return Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
     * 
     */
    public List<LoadBalancerRuleOverrideSessionAffinityAttribute> sessionAffinityAttributes() {
        return this.sessionAffinityAttributes == null ? List.of() : this.sessionAffinityAttributes;
    }
    /**
     * @return Time, in seconds, until this load balancer&#39;s session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
     * 
     */
    public Optional<Integer> sessionAffinityTtl() {
        return Optional.ofNullable(this.sessionAffinityTtl);
    }
    /**
     * @return The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools&#39; latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool&#39;s number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `&#34;&#34;` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `&#34;&#34;` Defaults to `&#34;&#34;`.
     * 
     */
    public Optional<String> steeringPolicy() {
        return Optional.ofNullable(this.steeringPolicy);
    }
    /**
     * @return Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
     * 
     */
    public Optional<Integer> ttl() {
        return Optional.ofNullable(this.ttl);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(LoadBalancerRuleOverride defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable List<LoadBalancerRuleOverrideAdaptiveRouting> adaptiveRoutings;
        private @Nullable List<LoadBalancerRuleOverrideCountryPool> countryPools;
        private @Nullable List<String> defaultPools;
        private @Nullable String fallbackPool;
        private @Nullable List<LoadBalancerRuleOverrideLocationStrategy> locationStrategies;
        private @Nullable List<LoadBalancerRuleOverridePopPool> popPools;
        private @Nullable List<LoadBalancerRuleOverrideRandomSteering> randomSteerings;
        private @Nullable List<LoadBalancerRuleOverrideRegionPool> regionPools;
        private @Nullable String sessionAffinity;
        private @Nullable List<LoadBalancerRuleOverrideSessionAffinityAttribute> sessionAffinityAttributes;
        private @Nullable Integer sessionAffinityTtl;
        private @Nullable String steeringPolicy;
        private @Nullable Integer ttl;
        public Builder() {}
        public Builder(LoadBalancerRuleOverride defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.adaptiveRoutings = defaults.adaptiveRoutings;
    	      this.countryPools = defaults.countryPools;
    	      this.defaultPools = defaults.defaultPools;
    	      this.fallbackPool = defaults.fallbackPool;
    	      this.locationStrategies = defaults.locationStrategies;
    	      this.popPools = defaults.popPools;
    	      this.randomSteerings = defaults.randomSteerings;
    	      this.regionPools = defaults.regionPools;
    	      this.sessionAffinity = defaults.sessionAffinity;
    	      this.sessionAffinityAttributes = defaults.sessionAffinityAttributes;
    	      this.sessionAffinityTtl = defaults.sessionAffinityTtl;
    	      this.steeringPolicy = defaults.steeringPolicy;
    	      this.ttl = defaults.ttl;
        }

        @CustomType.Setter
        public Builder adaptiveRoutings(@Nullable List<LoadBalancerRuleOverrideAdaptiveRouting> adaptiveRoutings) {
            this.adaptiveRoutings = adaptiveRoutings;
            return this;
        }
        public Builder adaptiveRoutings(LoadBalancerRuleOverrideAdaptiveRouting... adaptiveRoutings) {
            return adaptiveRoutings(List.of(adaptiveRoutings));
        }
        @CustomType.Setter
        public Builder countryPools(@Nullable List<LoadBalancerRuleOverrideCountryPool> countryPools) {
            this.countryPools = countryPools;
            return this;
        }
        public Builder countryPools(LoadBalancerRuleOverrideCountryPool... countryPools) {
            return countryPools(List.of(countryPools));
        }
        @CustomType.Setter
        public Builder defaultPools(@Nullable List<String> defaultPools) {
            this.defaultPools = defaultPools;
            return this;
        }
        public Builder defaultPools(String... defaultPools) {
            return defaultPools(List.of(defaultPools));
        }
        @CustomType.Setter
        public Builder fallbackPool(@Nullable String fallbackPool) {
            this.fallbackPool = fallbackPool;
            return this;
        }
        @CustomType.Setter
        public Builder locationStrategies(@Nullable List<LoadBalancerRuleOverrideLocationStrategy> locationStrategies) {
            this.locationStrategies = locationStrategies;
            return this;
        }
        public Builder locationStrategies(LoadBalancerRuleOverrideLocationStrategy... locationStrategies) {
            return locationStrategies(List.of(locationStrategies));
        }
        @CustomType.Setter
        public Builder popPools(@Nullable List<LoadBalancerRuleOverridePopPool> popPools) {
            this.popPools = popPools;
            return this;
        }
        public Builder popPools(LoadBalancerRuleOverridePopPool... popPools) {
            return popPools(List.of(popPools));
        }
        @CustomType.Setter
        public Builder randomSteerings(@Nullable List<LoadBalancerRuleOverrideRandomSteering> randomSteerings) {
            this.randomSteerings = randomSteerings;
            return this;
        }
        public Builder randomSteerings(LoadBalancerRuleOverrideRandomSteering... randomSteerings) {
            return randomSteerings(List.of(randomSteerings));
        }
        @CustomType.Setter
        public Builder regionPools(@Nullable List<LoadBalancerRuleOverrideRegionPool> regionPools) {
            this.regionPools = regionPools;
            return this;
        }
        public Builder regionPools(LoadBalancerRuleOverrideRegionPool... regionPools) {
            return regionPools(List.of(regionPools));
        }
        @CustomType.Setter
        public Builder sessionAffinity(@Nullable String sessionAffinity) {
            this.sessionAffinity = sessionAffinity;
            return this;
        }
        @CustomType.Setter
        public Builder sessionAffinityAttributes(@Nullable List<LoadBalancerRuleOverrideSessionAffinityAttribute> sessionAffinityAttributes) {
            this.sessionAffinityAttributes = sessionAffinityAttributes;
            return this;
        }
        public Builder sessionAffinityAttributes(LoadBalancerRuleOverrideSessionAffinityAttribute... sessionAffinityAttributes) {
            return sessionAffinityAttributes(List.of(sessionAffinityAttributes));
        }
        @CustomType.Setter
        public Builder sessionAffinityTtl(@Nullable Integer sessionAffinityTtl) {
            this.sessionAffinityTtl = sessionAffinityTtl;
            return this;
        }
        @CustomType.Setter
        public Builder steeringPolicy(@Nullable String steeringPolicy) {
            this.steeringPolicy = steeringPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder ttl(@Nullable Integer ttl) {
            this.ttl = ttl;
            return this;
        }
        public LoadBalancerRuleOverride build() {
            final var o = new LoadBalancerRuleOverride();
            o.adaptiveRoutings = adaptiveRoutings;
            o.countryPools = countryPools;
            o.defaultPools = defaultPools;
            o.fallbackPool = fallbackPool;
            o.locationStrategies = locationStrategies;
            o.popPools = popPools;
            o.randomSteerings = randomSteerings;
            o.regionPools = regionPools;
            o.sessionAffinity = sessionAffinity;
            o.sessionAffinityAttributes = sessionAffinityAttributes;
            o.sessionAffinityTtl = sessionAffinityTtl;
            o.steeringPolicy = steeringPolicy;
            o.ttl = ttl;
            return o;
        }
    }
}
