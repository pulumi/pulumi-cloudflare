// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.cloudflare.inputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs extends com.pulumi.resources.ResourceArgs {

    public static final ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs Empty = new ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs();

    /**
     * For all L7 requests to this hostname, cloudflared will validate each request&#39;s Cf-Access-Jwt-Assertion request header.
     * 
     */
    @Import(name="access")
    private @Nullable Output<ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs> access;

    /**
     * @return For all L7 requests to this hostname, cloudflared will validate each request&#39;s Cf-Access-Jwt-Assertion request header.
     * 
     */
    public Optional<Output<ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs>> access() {
        return Optional.ofNullable(this.access);
    }

    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     * 
     */
    @Import(name="caPool")
    private @Nullable Output<String> caPool;

    /**
     * @return Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     * 
     */
    public Optional<Output<String>> caPool() {
        return Optional.ofNullable(this.caPool);
    }

    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     * 
     */
    @Import(name="connectTimeout")
    private @Nullable Output<Integer> connectTimeout;

    /**
     * @return Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     * 
     */
    public Optional<Output<Integer>> connectTimeout() {
        return Optional.ofNullable(this.connectTimeout);
    }

    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     * 
     */
    @Import(name="disableChunkedEncoding")
    private @Nullable Output<Boolean> disableChunkedEncoding;

    /**
     * @return Disables chunked transfer encoding. Useful if you are running a WSGI server.
     * 
     */
    public Optional<Output<Boolean>> disableChunkedEncoding() {
        return Optional.ofNullable(this.disableChunkedEncoding);
    }

    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     * 
     */
    @Import(name="http2Origin")
    private @Nullable Output<Boolean> http2Origin;

    /**
     * @return Attempt to connect to origin using HTTP2. Origin must be configured as https.
     * 
     */
    public Optional<Output<Boolean>> http2Origin() {
        return Optional.ofNullable(this.http2Origin);
    }

    /**
     * Sets the HTTP Host header on requests sent to the local service.
     * 
     */
    @Import(name="httpHostHeader")
    private @Nullable Output<String> httpHostHeader;

    /**
     * @return Sets the HTTP Host header on requests sent to the local service.
     * 
     */
    public Optional<Output<String>> httpHostHeader() {
        return Optional.ofNullable(this.httpHostHeader);
    }

    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     * 
     */
    @Import(name="keepAliveConnections")
    private @Nullable Output<Integer> keepAliveConnections;

    /**
     * @return Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     * 
     */
    public Optional<Output<Integer>> keepAliveConnections() {
        return Optional.ofNullable(this.keepAliveConnections);
    }

    /**
     * Timeout after which an idle keepalive connection can be discarded.
     * 
     */
    @Import(name="keepAliveTimeout")
    private @Nullable Output<Integer> keepAliveTimeout;

    /**
     * @return Timeout after which an idle keepalive connection can be discarded.
     * 
     */
    public Optional<Output<Integer>> keepAliveTimeout() {
        return Optional.ofNullable(this.keepAliveTimeout);
    }

    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     * 
     */
    @Import(name="noHappyEyeballs")
    private @Nullable Output<Boolean> noHappyEyeballs;

    /**
     * @return Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     * 
     */
    public Optional<Output<Boolean>> noHappyEyeballs() {
        return Optional.ofNullable(this.noHappyEyeballs);
    }

    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     * 
     */
    @Import(name="noTlsVerify")
    private @Nullable Output<Boolean> noTlsVerify;

    /**
     * @return Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     * 
     */
    public Optional<Output<Boolean>> noTlsVerify() {
        return Optional.ofNullable(this.noTlsVerify);
    }

    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     * 
     */
    @Import(name="originServerName")
    private @Nullable Output<String> originServerName;

    /**
     * @return Hostname that cloudflared should expect from your origin server certificate.
     * 
     */
    public Optional<Output<String>> originServerName() {
        return Optional.ofNullable(this.originServerName);
    }

    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: &#34;&#34; for the regular proxy and &#34;socks&#34; for a SOCKS5 proxy.
     * 
     */
    @Import(name="proxyType")
    private @Nullable Output<String> proxyType;

    /**
     * @return cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: &#34;&#34; for the regular proxy and &#34;socks&#34; for a SOCKS5 proxy.
     * 
     */
    public Optional<Output<String>> proxyType() {
        return Optional.ofNullable(this.proxyType);
    }

    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     * 
     */
    @Import(name="tcpKeepAlive")
    private @Nullable Output<Integer> tcpKeepAlive;

    /**
     * @return The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     * 
     */
    public Optional<Output<Integer>> tcpKeepAlive() {
        return Optional.ofNullable(this.tcpKeepAlive);
    }

    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     * 
     */
    @Import(name="tlsTimeout")
    private @Nullable Output<Integer> tlsTimeout;

    /**
     * @return Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     * 
     */
    public Optional<Output<Integer>> tlsTimeout() {
        return Optional.ofNullable(this.tlsTimeout);
    }

    private ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs() {}

    private ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs(ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs $) {
        this.access = $.access;
        this.caPool = $.caPool;
        this.connectTimeout = $.connectTimeout;
        this.disableChunkedEncoding = $.disableChunkedEncoding;
        this.http2Origin = $.http2Origin;
        this.httpHostHeader = $.httpHostHeader;
        this.keepAliveConnections = $.keepAliveConnections;
        this.keepAliveTimeout = $.keepAliveTimeout;
        this.noHappyEyeballs = $.noHappyEyeballs;
        this.noTlsVerify = $.noTlsVerify;
        this.originServerName = $.originServerName;
        this.proxyType = $.proxyType;
        this.tcpKeepAlive = $.tcpKeepAlive;
        this.tlsTimeout = $.tlsTimeout;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs $;

        public Builder() {
            $ = new ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs();
        }

        public Builder(ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs defaults) {
            $ = new ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param access For all L7 requests to this hostname, cloudflared will validate each request&#39;s Cf-Access-Jwt-Assertion request header.
         * 
         * @return builder
         * 
         */
        public Builder access(@Nullable Output<ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs> access) {
            $.access = access;
            return this;
        }

        /**
         * @param access For all L7 requests to this hostname, cloudflared will validate each request&#39;s Cf-Access-Jwt-Assertion request header.
         * 
         * @return builder
         * 
         */
        public Builder access(ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs access) {
            return access(Output.of(access));
        }

        /**
         * @param caPool Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
         * 
         * @return builder
         * 
         */
        public Builder caPool(@Nullable Output<String> caPool) {
            $.caPool = caPool;
            return this;
        }

        /**
         * @param caPool Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
         * 
         * @return builder
         * 
         */
        public Builder caPool(String caPool) {
            return caPool(Output.of(caPool));
        }

        /**
         * @param connectTimeout Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
         * 
         * @return builder
         * 
         */
        public Builder connectTimeout(@Nullable Output<Integer> connectTimeout) {
            $.connectTimeout = connectTimeout;
            return this;
        }

        /**
         * @param connectTimeout Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
         * 
         * @return builder
         * 
         */
        public Builder connectTimeout(Integer connectTimeout) {
            return connectTimeout(Output.of(connectTimeout));
        }

        /**
         * @param disableChunkedEncoding Disables chunked transfer encoding. Useful if you are running a WSGI server.
         * 
         * @return builder
         * 
         */
        public Builder disableChunkedEncoding(@Nullable Output<Boolean> disableChunkedEncoding) {
            $.disableChunkedEncoding = disableChunkedEncoding;
            return this;
        }

        /**
         * @param disableChunkedEncoding Disables chunked transfer encoding. Useful if you are running a WSGI server.
         * 
         * @return builder
         * 
         */
        public Builder disableChunkedEncoding(Boolean disableChunkedEncoding) {
            return disableChunkedEncoding(Output.of(disableChunkedEncoding));
        }

        /**
         * @param http2Origin Attempt to connect to origin using HTTP2. Origin must be configured as https.
         * 
         * @return builder
         * 
         */
        public Builder http2Origin(@Nullable Output<Boolean> http2Origin) {
            $.http2Origin = http2Origin;
            return this;
        }

        /**
         * @param http2Origin Attempt to connect to origin using HTTP2. Origin must be configured as https.
         * 
         * @return builder
         * 
         */
        public Builder http2Origin(Boolean http2Origin) {
            return http2Origin(Output.of(http2Origin));
        }

        /**
         * @param httpHostHeader Sets the HTTP Host header on requests sent to the local service.
         * 
         * @return builder
         * 
         */
        public Builder httpHostHeader(@Nullable Output<String> httpHostHeader) {
            $.httpHostHeader = httpHostHeader;
            return this;
        }

        /**
         * @param httpHostHeader Sets the HTTP Host header on requests sent to the local service.
         * 
         * @return builder
         * 
         */
        public Builder httpHostHeader(String httpHostHeader) {
            return httpHostHeader(Output.of(httpHostHeader));
        }

        /**
         * @param keepAliveConnections Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
         * 
         * @return builder
         * 
         */
        public Builder keepAliveConnections(@Nullable Output<Integer> keepAliveConnections) {
            $.keepAliveConnections = keepAliveConnections;
            return this;
        }

        /**
         * @param keepAliveConnections Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
         * 
         * @return builder
         * 
         */
        public Builder keepAliveConnections(Integer keepAliveConnections) {
            return keepAliveConnections(Output.of(keepAliveConnections));
        }

        /**
         * @param keepAliveTimeout Timeout after which an idle keepalive connection can be discarded.
         * 
         * @return builder
         * 
         */
        public Builder keepAliveTimeout(@Nullable Output<Integer> keepAliveTimeout) {
            $.keepAliveTimeout = keepAliveTimeout;
            return this;
        }

        /**
         * @param keepAliveTimeout Timeout after which an idle keepalive connection can be discarded.
         * 
         * @return builder
         * 
         */
        public Builder keepAliveTimeout(Integer keepAliveTimeout) {
            return keepAliveTimeout(Output.of(keepAliveTimeout));
        }

        /**
         * @param noHappyEyeballs Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
         * 
         * @return builder
         * 
         */
        public Builder noHappyEyeballs(@Nullable Output<Boolean> noHappyEyeballs) {
            $.noHappyEyeballs = noHappyEyeballs;
            return this;
        }

        /**
         * @param noHappyEyeballs Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
         * 
         * @return builder
         * 
         */
        public Builder noHappyEyeballs(Boolean noHappyEyeballs) {
            return noHappyEyeballs(Output.of(noHappyEyeballs));
        }

        /**
         * @param noTlsVerify Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
         * 
         * @return builder
         * 
         */
        public Builder noTlsVerify(@Nullable Output<Boolean> noTlsVerify) {
            $.noTlsVerify = noTlsVerify;
            return this;
        }

        /**
         * @param noTlsVerify Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
         * 
         * @return builder
         * 
         */
        public Builder noTlsVerify(Boolean noTlsVerify) {
            return noTlsVerify(Output.of(noTlsVerify));
        }

        /**
         * @param originServerName Hostname that cloudflared should expect from your origin server certificate.
         * 
         * @return builder
         * 
         */
        public Builder originServerName(@Nullable Output<String> originServerName) {
            $.originServerName = originServerName;
            return this;
        }

        /**
         * @param originServerName Hostname that cloudflared should expect from your origin server certificate.
         * 
         * @return builder
         * 
         */
        public Builder originServerName(String originServerName) {
            return originServerName(Output.of(originServerName));
        }

        /**
         * @param proxyType cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: &#34;&#34; for the regular proxy and &#34;socks&#34; for a SOCKS5 proxy.
         * 
         * @return builder
         * 
         */
        public Builder proxyType(@Nullable Output<String> proxyType) {
            $.proxyType = proxyType;
            return this;
        }

        /**
         * @param proxyType cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: &#34;&#34; for the regular proxy and &#34;socks&#34; for a SOCKS5 proxy.
         * 
         * @return builder
         * 
         */
        public Builder proxyType(String proxyType) {
            return proxyType(Output.of(proxyType));
        }

        /**
         * @param tcpKeepAlive The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
         * 
         * @return builder
         * 
         */
        public Builder tcpKeepAlive(@Nullable Output<Integer> tcpKeepAlive) {
            $.tcpKeepAlive = tcpKeepAlive;
            return this;
        }

        /**
         * @param tcpKeepAlive The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
         * 
         * @return builder
         * 
         */
        public Builder tcpKeepAlive(Integer tcpKeepAlive) {
            return tcpKeepAlive(Output.of(tcpKeepAlive));
        }

        /**
         * @param tlsTimeout Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
         * 
         * @return builder
         * 
         */
        public Builder tlsTimeout(@Nullable Output<Integer> tlsTimeout) {
            $.tlsTimeout = tlsTimeout;
            return this;
        }

        /**
         * @param tlsTimeout Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
         * 
         * @return builder
         * 
         */
        public Builder tlsTimeout(Integer tlsTimeout) {
            return tlsTimeout(Output.of(tlsTimeout));
        }

        public ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs build() {
            return $;
        }
    }

}
