// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare.inputs;

import com.pulumi.cloudflare.inputs.GetDnsRecordFilterCommentArgs;
import com.pulumi.cloudflare.inputs.GetDnsRecordFilterContentArgs;
import com.pulumi.cloudflare.inputs.GetDnsRecordFilterNameArgs;
import com.pulumi.cloudflare.inputs.GetDnsRecordFilterTagArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetDnsRecordFilterArgs extends com.pulumi.resources.ResourceArgs {

    public static final GetDnsRecordFilterArgs Empty = new GetDnsRecordFilterArgs();

    @Import(name="comment")
    private @Nullable Output<GetDnsRecordFilterCommentArgs> comment;

    public Optional<Output<GetDnsRecordFilterCommentArgs>> comment() {
        return Optional.ofNullable(this.comment);
    }

    @Import(name="content")
    private @Nullable Output<GetDnsRecordFilterContentArgs> content;

    public Optional<Output<GetDnsRecordFilterContentArgs>> content() {
        return Optional.ofNullable(this.content);
    }

    /**
     * Direction to order DNS records in.
     * Available values: &#34;asc&#34;, &#34;desc&#34;.
     * 
     */
    @Import(name="direction", required=true)
    private Output<String> direction;

    /**
     * @return Direction to order DNS records in.
     * Available values: &#34;asc&#34;, &#34;desc&#34;.
     * 
     */
    public Output<String> direction() {
        return this.direction;
    }

    /**
     * Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    @Import(name="match", required=true)
    private Output<String> match;

    /**
     * @return Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    public Output<String> match() {
        return this.match;
    }

    @Import(name="name")
    private @Nullable Output<GetDnsRecordFilterNameArgs> name;

    public Optional<Output<GetDnsRecordFilterNameArgs>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Field to order DNS records by.
     * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
     * 
     */
    @Import(name="order", required=true)
    private Output<String> order;

    /**
     * @return Field to order DNS records by.
     * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
     * 
     */
    public Output<String> order() {
        return this.order;
    }

    /**
     * Whether the record is receiving the performance and security benefits of Cloudflare.
     * 
     */
    @Import(name="proxied", required=true)
    private Output<Boolean> proxied;

    /**
     * @return Whether the record is receiving the performance and security benefits of Cloudflare.
     * 
     */
    public Output<Boolean> proxied() {
        return this.proxied;
    }

    /**
     * Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
     * 
     */
    @Import(name="search")
    private @Nullable Output<String> search;

    /**
     * @return Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
     * 
     */
    public Optional<Output<String>> search() {
        return Optional.ofNullable(this.search);
    }

    @Import(name="tag")
    private @Nullable Output<GetDnsRecordFilterTagArgs> tag;

    public Optional<Output<GetDnsRecordFilterTagArgs>> tag() {
        return Optional.ofNullable(this.tag);
    }

    /**
     * Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    @Import(name="tagMatch", required=true)
    private Output<String> tagMatch;

    /**
     * @return Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
     * Available values: &#34;any&#34;, &#34;all&#34;.
     * 
     */
    public Output<String> tagMatch() {
        return this.tagMatch;
    }

    /**
     * Record type.
     * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
     * 
     */
    @Import(name="type")
    private @Nullable Output<String> type;

    /**
     * @return Record type.
     * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
     * 
     */
    public Optional<Output<String>> type() {
        return Optional.ofNullable(this.type);
    }

    private GetDnsRecordFilterArgs() {}

    private GetDnsRecordFilterArgs(GetDnsRecordFilterArgs $) {
        this.comment = $.comment;
        this.content = $.content;
        this.direction = $.direction;
        this.match = $.match;
        this.name = $.name;
        this.order = $.order;
        this.proxied = $.proxied;
        this.search = $.search;
        this.tag = $.tag;
        this.tagMatch = $.tagMatch;
        this.type = $.type;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetDnsRecordFilterArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetDnsRecordFilterArgs $;

        public Builder() {
            $ = new GetDnsRecordFilterArgs();
        }

        public Builder(GetDnsRecordFilterArgs defaults) {
            $ = new GetDnsRecordFilterArgs(Objects.requireNonNull(defaults));
        }

        public Builder comment(@Nullable Output<GetDnsRecordFilterCommentArgs> comment) {
            $.comment = comment;
            return this;
        }

        public Builder comment(GetDnsRecordFilterCommentArgs comment) {
            return comment(Output.of(comment));
        }

        public Builder content(@Nullable Output<GetDnsRecordFilterContentArgs> content) {
            $.content = content;
            return this;
        }

        public Builder content(GetDnsRecordFilterContentArgs content) {
            return content(Output.of(content));
        }

        /**
         * @param direction Direction to order DNS records in.
         * Available values: &#34;asc&#34;, &#34;desc&#34;.
         * 
         * @return builder
         * 
         */
        public Builder direction(Output<String> direction) {
            $.direction = direction;
            return this;
        }

        /**
         * @param direction Direction to order DNS records in.
         * Available values: &#34;asc&#34;, &#34;desc&#34;.
         * 
         * @return builder
         * 
         */
        public Builder direction(String direction) {
            return direction(Output.of(direction));
        }

        /**
         * @param match Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
         * Available values: &#34;any&#34;, &#34;all&#34;.
         * 
         * @return builder
         * 
         */
        public Builder match(Output<String> match) {
            $.match = match;
            return this;
        }

        /**
         * @param match Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
         * Available values: &#34;any&#34;, &#34;all&#34;.
         * 
         * @return builder
         * 
         */
        public Builder match(String match) {
            return match(Output.of(match));
        }

        public Builder name(@Nullable Output<GetDnsRecordFilterNameArgs> name) {
            $.name = name;
            return this;
        }

        public Builder name(GetDnsRecordFilterNameArgs name) {
            return name(Output.of(name));
        }

        /**
         * @param order Field to order DNS records by.
         * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
         * 
         * @return builder
         * 
         */
        public Builder order(Output<String> order) {
            $.order = order;
            return this;
        }

        /**
         * @param order Field to order DNS records by.
         * Available values: &#34;type&#34;, &#34;name&#34;, &#34;content&#34;, &#34;ttl&#34;, &#34;proxied&#34;.
         * 
         * @return builder
         * 
         */
        public Builder order(String order) {
            return order(Output.of(order));
        }

        /**
         * @param proxied Whether the record is receiving the performance and security benefits of Cloudflare.
         * 
         * @return builder
         * 
         */
        public Builder proxied(Output<Boolean> proxied) {
            $.proxied = proxied;
            return this;
        }

        /**
         * @param proxied Whether the record is receiving the performance and security benefits of Cloudflare.
         * 
         * @return builder
         * 
         */
        public Builder proxied(Boolean proxied) {
            return proxied(Output.of(proxied));
        }

        /**
         * @param search Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
         * 
         * @return builder
         * 
         */
        public Builder search(@Nullable Output<String> search) {
            $.search = search;
            return this;
        }

        /**
         * @param search Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
         * 
         * @return builder
         * 
         */
        public Builder search(String search) {
            return search(Output.of(search));
        }

        public Builder tag(@Nullable Output<GetDnsRecordFilterTagArgs> tag) {
            $.tag = tag;
            return this;
        }

        public Builder tag(GetDnsRecordFilterTagArgs tag) {
            return tag(Output.of(tag));
        }

        /**
         * @param tagMatch Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
         * Available values: &#34;any&#34;, &#34;all&#34;.
         * 
         * @return builder
         * 
         */
        public Builder tagMatch(Output<String> tagMatch) {
            $.tagMatch = tagMatch;
            return this;
        }

        /**
         * @param tagMatch Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren&#39;t related to tags.
         * Available values: &#34;any&#34;, &#34;all&#34;.
         * 
         * @return builder
         * 
         */
        public Builder tagMatch(String tagMatch) {
            return tagMatch(Output.of(tagMatch));
        }

        /**
         * @param type Record type.
         * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
         * 
         * @return builder
         * 
         */
        public Builder type(@Nullable Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type Record type.
         * Available values: &#34;A&#34;, &#34;AAAA&#34;, &#34;CAA&#34;, &#34;CERT&#34;, &#34;CNAME&#34;, &#34;DNSKEY&#34;, &#34;DS&#34;, &#34;HTTPS&#34;, &#34;LOC&#34;, &#34;MX&#34;, &#34;NAPTR&#34;, &#34;NS&#34;, &#34;OPENPGPKEY&#34;, &#34;PTR&#34;, &#34;SMIMEA&#34;, &#34;SRV&#34;, &#34;SSHFP&#34;, &#34;SVCB&#34;, &#34;TLSA&#34;, &#34;TXT&#34;, &#34;URI&#34;.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        public GetDnsRecordFilterArgs build() {
            if ($.direction == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilterArgs", "direction");
            }
            if ($.match == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilterArgs", "match");
            }
            if ($.order == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilterArgs", "order");
            }
            if ($.proxied == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilterArgs", "proxied");
            }
            if ($.tagMatch == null) {
                throw new MissingRequiredPropertyException("GetDnsRecordFilterArgs", "tagMatch");
            }
            return $;
        }
    }

}
