// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cloudflare;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class WaitingRoomEventArgs extends com.pulumi.resources.ResourceArgs {

    public static final WaitingRoomEventArgs Empty = new WaitingRoomEventArgs();

    /**
     * If set, the event will override the waiting room&#39;s `custom_page_html` property while it is active. If null, the event will inherit it.
     * 
     */
    @Import(name="customPageHtml")
    private @Nullable Output<String> customPageHtml;

    /**
     * @return If set, the event will override the waiting room&#39;s `custom_page_html` property while it is active. If null, the event will inherit it.
     * 
     */
    public Optional<Output<String>> customPageHtml() {
        return Optional.ofNullable(this.customPageHtml);
    }

    /**
     * A note that you can use to add more details about the event.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return A note that you can use to add more details about the event.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * If set, the event will override the waiting room&#39;s `disable_session_renewal` property while it is active. If null, the event will inherit it.
     * 
     */
    @Import(name="disableSessionRenewal")
    private @Nullable Output<Boolean> disableSessionRenewal;

    /**
     * @return If set, the event will override the waiting room&#39;s `disable_session_renewal` property while it is active. If null, the event will inherit it.
     * 
     */
    public Optional<Output<Boolean>> disableSessionRenewal() {
        return Optional.ofNullable(this.disableSessionRenewal);
    }

    /**
     * An ISO 8601 timestamp that marks the end of the event.
     * 
     */
    @Import(name="eventEndTime", required=true)
    private Output<String> eventEndTime;

    /**
     * @return An ISO 8601 timestamp that marks the end of the event.
     * 
     */
    public Output<String> eventEndTime() {
        return this.eventEndTime;
    }

    /**
     * An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event&#39;s configuration. The start time must be at least one minute before `event_end_time`.
     * 
     */
    @Import(name="eventStartTime", required=true)
    private Output<String> eventStartTime;

    /**
     * @return An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event&#39;s configuration. The start time must be at least one minute before `event_end_time`.
     * 
     */
    public Output<String> eventStartTime() {
        return this.eventStartTime;
    }

    /**
     * A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     * 
     */
    @Import(name="name", required=true)
    private Output<String> name;

    /**
     * @return A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     * 
     */
    public Output<String> name() {
        return this.name;
    }

    /**
     * If set, the event will override the waiting room&#39;s `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `total_active_users` property is also set.
     * 
     */
    @Import(name="newUsersPerMinute")
    private @Nullable Output<Integer> newUsersPerMinute;

    /**
     * @return If set, the event will override the waiting room&#39;s `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `total_active_users` property is also set.
     * 
     */
    public Optional<Output<Integer>> newUsersPerMinute() {
        return Optional.ofNullable(this.newUsersPerMinute);
    }

    /**
     * An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
     * 
     */
    @Import(name="prequeueStartTime")
    private @Nullable Output<String> prequeueStartTime;

    /**
     * @return An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
     * 
     */
    public Optional<Output<String>> prequeueStartTime() {
        return Optional.ofNullable(this.prequeueStartTime);
    }

    /**
     * If set, the event will override the waiting room&#39;s `queueing_method` property while it is active. If null, the event will inherit it.
     * 
     */
    @Import(name="queueingMethod")
    private @Nullable Output<String> queueingMethod;

    /**
     * @return If set, the event will override the waiting room&#39;s `queueing_method` property while it is active. If null, the event will inherit it.
     * 
     */
    public Optional<Output<String>> queueingMethod() {
        return Optional.ofNullable(this.queueingMethod);
    }

    /**
     * If set, the event will override the waiting room&#39;s `session_duration` property while it is active. If null, the event will inherit it.
     * 
     */
    @Import(name="sessionDuration")
    private @Nullable Output<Integer> sessionDuration;

    /**
     * @return If set, the event will override the waiting room&#39;s `session_duration` property while it is active. If null, the event will inherit it.
     * 
     */
    public Optional<Output<Integer>> sessionDuration() {
        return Optional.ofNullable(this.sessionDuration);
    }

    /**
     * If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     * 
     */
    @Import(name="shuffleAtEventStart")
    private @Nullable Output<Boolean> shuffleAtEventStart;

    /**
     * @return If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     * 
     */
    public Optional<Output<Boolean>> shuffleAtEventStart() {
        return Optional.ofNullable(this.shuffleAtEventStart);
    }

    /**
     * Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     * 
     */
    @Import(name="suspended")
    private @Nullable Output<Boolean> suspended;

    /**
     * @return Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     * 
     */
    public Optional<Output<Boolean>> suspended() {
        return Optional.ofNullable(this.suspended);
    }

    /**
     * If set, the event will override the waiting room&#39;s `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `new_users_per_minute` property is also set.
     * 
     */
    @Import(name="totalActiveUsers")
    private @Nullable Output<Integer> totalActiveUsers;

    /**
     * @return If set, the event will override the waiting room&#39;s `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `new_users_per_minute` property is also set.
     * 
     */
    public Optional<Output<Integer>> totalActiveUsers() {
        return Optional.ofNullable(this.totalActiveUsers);
    }

    /**
     * If set, the event will override the waiting room&#39;s `turnstile_action` property while it is active. If null, the event will inherit it.
     * Available values: &#34;log&#34;, &#34;infinite_queue&#34;.
     * 
     */
    @Import(name="turnstileAction")
    private @Nullable Output<String> turnstileAction;

    /**
     * @return If set, the event will override the waiting room&#39;s `turnstile_action` property while it is active. If null, the event will inherit it.
     * Available values: &#34;log&#34;, &#34;infinite_queue&#34;.
     * 
     */
    public Optional<Output<String>> turnstileAction() {
        return Optional.ofNullable(this.turnstileAction);
    }

    /**
     * If set, the event will override the waiting room&#39;s `turnstile_mode` property while it is active. If null, the event will inherit it.
     * Available values: &#34;off&#34;, &#34;invisible&#34;, &#34;visible*non*interactive&#34;, &#34;visible_managed&#34;.
     * 
     */
    @Import(name="turnstileMode")
    private @Nullable Output<String> turnstileMode;

    /**
     * @return If set, the event will override the waiting room&#39;s `turnstile_mode` property while it is active. If null, the event will inherit it.
     * Available values: &#34;off&#34;, &#34;invisible&#34;, &#34;visible*non*interactive&#34;, &#34;visible_managed&#34;.
     * 
     */
    public Optional<Output<String>> turnstileMode() {
        return Optional.ofNullable(this.turnstileMode);
    }

    @Import(name="waitingRoomId", required=true)
    private Output<String> waitingRoomId;

    public Output<String> waitingRoomId() {
        return this.waitingRoomId;
    }

    /**
     * Identifier
     * 
     */
    @Import(name="zoneId", required=true)
    private Output<String> zoneId;

    /**
     * @return Identifier
     * 
     */
    public Output<String> zoneId() {
        return this.zoneId;
    }

    private WaitingRoomEventArgs() {}

    private WaitingRoomEventArgs(WaitingRoomEventArgs $) {
        this.customPageHtml = $.customPageHtml;
        this.description = $.description;
        this.disableSessionRenewal = $.disableSessionRenewal;
        this.eventEndTime = $.eventEndTime;
        this.eventStartTime = $.eventStartTime;
        this.name = $.name;
        this.newUsersPerMinute = $.newUsersPerMinute;
        this.prequeueStartTime = $.prequeueStartTime;
        this.queueingMethod = $.queueingMethod;
        this.sessionDuration = $.sessionDuration;
        this.shuffleAtEventStart = $.shuffleAtEventStart;
        this.suspended = $.suspended;
        this.totalActiveUsers = $.totalActiveUsers;
        this.turnstileAction = $.turnstileAction;
        this.turnstileMode = $.turnstileMode;
        this.waitingRoomId = $.waitingRoomId;
        this.zoneId = $.zoneId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(WaitingRoomEventArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private WaitingRoomEventArgs $;

        public Builder() {
            $ = new WaitingRoomEventArgs();
        }

        public Builder(WaitingRoomEventArgs defaults) {
            $ = new WaitingRoomEventArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param customPageHtml If set, the event will override the waiting room&#39;s `custom_page_html` property while it is active. If null, the event will inherit it.
         * 
         * @return builder
         * 
         */
        public Builder customPageHtml(@Nullable Output<String> customPageHtml) {
            $.customPageHtml = customPageHtml;
            return this;
        }

        /**
         * @param customPageHtml If set, the event will override the waiting room&#39;s `custom_page_html` property while it is active. If null, the event will inherit it.
         * 
         * @return builder
         * 
         */
        public Builder customPageHtml(String customPageHtml) {
            return customPageHtml(Output.of(customPageHtml));
        }

        /**
         * @param description A note that you can use to add more details about the event.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description A note that you can use to add more details about the event.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param disableSessionRenewal If set, the event will override the waiting room&#39;s `disable_session_renewal` property while it is active. If null, the event will inherit it.
         * 
         * @return builder
         * 
         */
        public Builder disableSessionRenewal(@Nullable Output<Boolean> disableSessionRenewal) {
            $.disableSessionRenewal = disableSessionRenewal;
            return this;
        }

        /**
         * @param disableSessionRenewal If set, the event will override the waiting room&#39;s `disable_session_renewal` property while it is active. If null, the event will inherit it.
         * 
         * @return builder
         * 
         */
        public Builder disableSessionRenewal(Boolean disableSessionRenewal) {
            return disableSessionRenewal(Output.of(disableSessionRenewal));
        }

        /**
         * @param eventEndTime An ISO 8601 timestamp that marks the end of the event.
         * 
         * @return builder
         * 
         */
        public Builder eventEndTime(Output<String> eventEndTime) {
            $.eventEndTime = eventEndTime;
            return this;
        }

        /**
         * @param eventEndTime An ISO 8601 timestamp that marks the end of the event.
         * 
         * @return builder
         * 
         */
        public Builder eventEndTime(String eventEndTime) {
            return eventEndTime(Output.of(eventEndTime));
        }

        /**
         * @param eventStartTime An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event&#39;s configuration. The start time must be at least one minute before `event_end_time`.
         * 
         * @return builder
         * 
         */
        public Builder eventStartTime(Output<String> eventStartTime) {
            $.eventStartTime = eventStartTime;
            return this;
        }

        /**
         * @param eventStartTime An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event&#39;s configuration. The start time must be at least one minute before `event_end_time`.
         * 
         * @return builder
         * 
         */
        public Builder eventStartTime(String eventStartTime) {
            return eventStartTime(Output.of(eventStartTime));
        }

        /**
         * @param name A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
         * 
         * @return builder
         * 
         */
        public Builder name(Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param newUsersPerMinute If set, the event will override the waiting room&#39;s `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `total_active_users` property is also set.
         * 
         * @return builder
         * 
         */
        public Builder newUsersPerMinute(@Nullable Output<Integer> newUsersPerMinute) {
            $.newUsersPerMinute = newUsersPerMinute;
            return this;
        }

        /**
         * @param newUsersPerMinute If set, the event will override the waiting room&#39;s `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `total_active_users` property is also set.
         * 
         * @return builder
         * 
         */
        public Builder newUsersPerMinute(Integer newUsersPerMinute) {
            return newUsersPerMinute(Output.of(newUsersPerMinute));
        }

        /**
         * @param prequeueStartTime An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
         * 
         * @return builder
         * 
         */
        public Builder prequeueStartTime(@Nullable Output<String> prequeueStartTime) {
            $.prequeueStartTime = prequeueStartTime;
            return this;
        }

        /**
         * @param prequeueStartTime An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
         * 
         * @return builder
         * 
         */
        public Builder prequeueStartTime(String prequeueStartTime) {
            return prequeueStartTime(Output.of(prequeueStartTime));
        }

        /**
         * @param queueingMethod If set, the event will override the waiting room&#39;s `queueing_method` property while it is active. If null, the event will inherit it.
         * 
         * @return builder
         * 
         */
        public Builder queueingMethod(@Nullable Output<String> queueingMethod) {
            $.queueingMethod = queueingMethod;
            return this;
        }

        /**
         * @param queueingMethod If set, the event will override the waiting room&#39;s `queueing_method` property while it is active. If null, the event will inherit it.
         * 
         * @return builder
         * 
         */
        public Builder queueingMethod(String queueingMethod) {
            return queueingMethod(Output.of(queueingMethod));
        }

        /**
         * @param sessionDuration If set, the event will override the waiting room&#39;s `session_duration` property while it is active. If null, the event will inherit it.
         * 
         * @return builder
         * 
         */
        public Builder sessionDuration(@Nullable Output<Integer> sessionDuration) {
            $.sessionDuration = sessionDuration;
            return this;
        }

        /**
         * @param sessionDuration If set, the event will override the waiting room&#39;s `session_duration` property while it is active. If null, the event will inherit it.
         * 
         * @return builder
         * 
         */
        public Builder sessionDuration(Integer sessionDuration) {
            return sessionDuration(Output.of(sessionDuration));
        }

        /**
         * @param shuffleAtEventStart If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
         * 
         * @return builder
         * 
         */
        public Builder shuffleAtEventStart(@Nullable Output<Boolean> shuffleAtEventStart) {
            $.shuffleAtEventStart = shuffleAtEventStart;
            return this;
        }

        /**
         * @param shuffleAtEventStart If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
         * 
         * @return builder
         * 
         */
        public Builder shuffleAtEventStart(Boolean shuffleAtEventStart) {
            return shuffleAtEventStart(Output.of(shuffleAtEventStart));
        }

        /**
         * @param suspended Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
         * 
         * @return builder
         * 
         */
        public Builder suspended(@Nullable Output<Boolean> suspended) {
            $.suspended = suspended;
            return this;
        }

        /**
         * @param suspended Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
         * 
         * @return builder
         * 
         */
        public Builder suspended(Boolean suspended) {
            return suspended(Output.of(suspended));
        }

        /**
         * @param totalActiveUsers If set, the event will override the waiting room&#39;s `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `new_users_per_minute` property is also set.
         * 
         * @return builder
         * 
         */
        public Builder totalActiveUsers(@Nullable Output<Integer> totalActiveUsers) {
            $.totalActiveUsers = totalActiveUsers;
            return this;
        }

        /**
         * @param totalActiveUsers If set, the event will override the waiting room&#39;s `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event&#39;s `new_users_per_minute` property is also set.
         * 
         * @return builder
         * 
         */
        public Builder totalActiveUsers(Integer totalActiveUsers) {
            return totalActiveUsers(Output.of(totalActiveUsers));
        }

        /**
         * @param turnstileAction If set, the event will override the waiting room&#39;s `turnstile_action` property while it is active. If null, the event will inherit it.
         * Available values: &#34;log&#34;, &#34;infinite_queue&#34;.
         * 
         * @return builder
         * 
         */
        public Builder turnstileAction(@Nullable Output<String> turnstileAction) {
            $.turnstileAction = turnstileAction;
            return this;
        }

        /**
         * @param turnstileAction If set, the event will override the waiting room&#39;s `turnstile_action` property while it is active. If null, the event will inherit it.
         * Available values: &#34;log&#34;, &#34;infinite_queue&#34;.
         * 
         * @return builder
         * 
         */
        public Builder turnstileAction(String turnstileAction) {
            return turnstileAction(Output.of(turnstileAction));
        }

        /**
         * @param turnstileMode If set, the event will override the waiting room&#39;s `turnstile_mode` property while it is active. If null, the event will inherit it.
         * Available values: &#34;off&#34;, &#34;invisible&#34;, &#34;visible*non*interactive&#34;, &#34;visible_managed&#34;.
         * 
         * @return builder
         * 
         */
        public Builder turnstileMode(@Nullable Output<String> turnstileMode) {
            $.turnstileMode = turnstileMode;
            return this;
        }

        /**
         * @param turnstileMode If set, the event will override the waiting room&#39;s `turnstile_mode` property while it is active. If null, the event will inherit it.
         * Available values: &#34;off&#34;, &#34;invisible&#34;, &#34;visible*non*interactive&#34;, &#34;visible_managed&#34;.
         * 
         * @return builder
         * 
         */
        public Builder turnstileMode(String turnstileMode) {
            return turnstileMode(Output.of(turnstileMode));
        }

        public Builder waitingRoomId(Output<String> waitingRoomId) {
            $.waitingRoomId = waitingRoomId;
            return this;
        }

        public Builder waitingRoomId(String waitingRoomId) {
            return waitingRoomId(Output.of(waitingRoomId));
        }

        /**
         * @param zoneId Identifier
         * 
         * @return builder
         * 
         */
        public Builder zoneId(Output<String> zoneId) {
            $.zoneId = zoneId;
            return this;
        }

        /**
         * @param zoneId Identifier
         * 
         * @return builder
         * 
         */
        public Builder zoneId(String zoneId) {
            return zoneId(Output.of(zoneId));
        }

        public WaitingRoomEventArgs build() {
            if ($.eventEndTime == null) {
                throw new MissingRequiredPropertyException("WaitingRoomEventArgs", "eventEndTime");
            }
            if ($.eventStartTime == null) {
                throw new MissingRequiredPropertyException("WaitingRoomEventArgs", "eventStartTime");
            }
            if ($.name == null) {
                throw new MissingRequiredPropertyException("WaitingRoomEventArgs", "name");
            }
            if ($.waitingRoomId == null) {
                throw new MissingRequiredPropertyException("WaitingRoomEventArgs", "waitingRoomId");
            }
            if ($.zoneId == null) {
                throw new MissingRequiredPropertyException("WaitingRoomEventArgs", "zoneId");
            }
            return $;
        }
    }

}
